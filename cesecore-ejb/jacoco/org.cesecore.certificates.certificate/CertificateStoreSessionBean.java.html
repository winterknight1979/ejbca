<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CertificateStoreSessionBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security EJB Implementation</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.certificate</a> &gt; <span class="el_source">CertificateStoreSessionBean.java</span></div><h1>CertificateStoreSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.certificate;

import java.math.BigInteger;
import java.security.PublicKey;
import java.security.cert.CertPathValidatorException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.security.spec.ECParameterSpec;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.EJBException;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.ejb.Timeout;
import javax.ejb.Timer;
import javax.ejb.TimerConfig;
import javax.ejb.TimerService;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.audit.enums.EventStatus;
import org.cesecore.audit.enums.EventTypes;
import org.cesecore.audit.enums.ModuleTypes;
import org.cesecore.audit.enums.ServiceTypes;
import org.cesecore.audit.log.SecurityEventsLoggerSessionLocal;
import org.cesecore.authentication.tokens.AlwaysAllowLocalAuthenticationToken;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authentication.tokens.UsernamePrincipal;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.authorization.AuthorizationSessionLocal;
import org.cesecore.authorization.control.StandardRules;
import org.cesecore.certificates.ca.internal.CaCertificateCache;
import org.cesecore.certificates.certificate.request.RequestMessage;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificateprofile.CertificateProfileConstants;
import org.cesecore.certificates.certificateprofile.CertificateProfileSessionLocal;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.certificates.endentity.EndEntityConstants;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.config.GlobalCesecoreConfiguration;
import org.cesecore.config.OcspConfiguration;
import org.cesecore.configuration.GlobalConfigurationSessionLocal;
import org.cesecore.internal.InternalResources;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.util.Base64;
import org.cesecore.util.CertTools;
import org.cesecore.util.EJBTools;
import org.cesecore.util.StringTools;
import org.cesecore.util.ValueExtractor;
import org.ejbca.cvc.PublicKeyEC;

/**
 * @version $Id: CertificateStoreSessionBean.java 29454 2018-07-04 09:22:00Z
 *     mikekushner $
 */
@Stateless(
    mappedName =
        JndiConstants.APP_JNDI_PREFIX + &quot;CertificateStoreSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.SUPPORTS)
<span class="nc" id="L90">public class CertificateStoreSessionBean</span>
    implements CertificateStoreSessionRemote, CertificateStoreSessionLocal {

    /**Log. */
<span class="nc" id="L94">  private static final Logger LOG =</span>
<span class="nc" id="L95">      Logger.getLogger(CertificateStoreSessionBean.class);</span>
  /** Internal localization of logs and errors. */
<span class="nc" id="L97">  private static final InternalResources INTRES =</span>
<span class="nc" id="L98">      InternalResources.getInstance();</span>

  /** ID. */
  private static final int TIMERID_CACERTIFICATECACHE = 1;

  /** EM. */
  @PersistenceContext(unitName = CesecoreConfiguration.PERSISTENCE_UNIT)
  private EntityManager entityManager;
  /** Auth. */
  @EJB private AuthorizationSessionLocal authorizationSession;
  /** Profile. */
  @EJB private CertificateProfileSessionLocal certificateProfileSession;
  /** Data. */
  @EJB private CertificateDataSessionLocal certificateDataSession;
  /** Config. */
  @EJB private GlobalConfigurationSessionLocal globalConfigurationSession;
  /** Log. */
  @EJB private SecurityEventsLoggerSessionLocal logSession;
  /** Myself needs to be looked up in postConstruct. */
  @Resource private SessionContext sessionContext;
  /** Local session.*/
  private CertificateStoreSessionLocal certificateStoreSession;
  /** When the sessionContext is injected, the timerService should be looked up.
   * This is due to the Glassfish EJB verifier complaining.
   */
  private TimerService timerService;

  /** Default create for SessionBean without any creation Arguments. */
  @PostConstruct
  public void postConstruct() {
    // We lookup the reference to our-self in PostConstruct, since we cannot
    // inject this.
    // We can not inject ourself, JBoss will not start then therefore we use
    // this to get a reference to this session bean
    // to call isUniqueCertificateSerialNumberIndex we want to do it on the real
    // bean in order to get
    // the transaction setting (NOT_SUPPORTED) which suspends the active
    // transaction and makes the check outside the transaction
<span class="nc" id="L136">    certificateStoreSession =</span>
<span class="nc" id="L137">        sessionContext.getBusinessObject(CertificateStoreSessionLocal.class);</span>
<span class="nc" id="L138">    timerService = sessionContext.getTimerService();</span>
<span class="nc" id="L139">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void initTimers() {
    // Reload CA certificate cache cache, and cancel/create timers if there are
    // no timers or if the cache is empty (probably a fresh startup)
<span class="nc bnc" id="L146" title="All 2 branches missed.">    if (getTimerCount(TIMERID_CACERTIFICATECACHE) == 0</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        || CaCertificateCache.INSTANCE.isCacheExpired()) {</span>
<span class="nc" id="L148">      reloadCaCertificateCacheAndSetTimeout();</span>
    } else {
<span class="nc" id="L150">      LOG.info(</span>
          &quot;Not initing CaCertificateCache reload timers, there are already&quot;
              + &quot; some.&quot;);
    }
<span class="nc" id="L154">  }</span>

  private GlobalCesecoreConfiguration getGlobalCesecoreConfiguration() {
<span class="nc" id="L157">    return (GlobalCesecoreConfiguration)</span>
<span class="nc" id="L158">        globalConfigurationSession.getCachedConfiguration(</span>
            GlobalCesecoreConfiguration.CESECORE_CONFIGURATION_ID);
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public CertificateDataWrapper storeCertificate(
      final AuthenticationToken admin,
      final Certificate incert,
      final String username,
      final String cafp,
      final int status,
      final int type,
      final int certificateProfileId,
      final int endEntityProfileId,
      final String tag,
      final long updateTime)
      throws AuthorizationDeniedException {
    // Check that user is authorized to the CA that issued this certificate
<span class="nc" id="L177">    int caid = CertTools.getIssuerDN(incert).hashCode();</span>
<span class="nc" id="L178">    authorizedToCA(admin, caid);</span>
<span class="nc" id="L179">    return storeCertificateNoAuth(</span>
        admin,
        incert,
        username,
        cafp,
        status,
        type,
        certificateProfileId,
        endEntityProfileId,
        tag,
        updateTime);
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public void storeCertificateRemote(
      final AuthenticationToken admin,
      final CertificateWrapper wrappedCert,
      final String username,
      final String cafp,
      final int status,
      final int type,
      final int certificateProfileId,
      final int endEntityProfileId,
      final String tag,
      final long updateTime)
      throws AuthorizationDeniedException {
<span class="nc" id="L206">    Certificate incert = EJBTools.unwrap(wrappedCert);</span>
    // Check that user is authorized to the CA that issued this certificate
<span class="nc" id="L208">    int caid = CertTools.getIssuerDN(incert).hashCode();</span>
<span class="nc" id="L209">    authorizedToCA(admin, caid);</span>
<span class="nc" id="L210">    storeCertificateNoAuth(</span>
        admin,
        incert,
        username,
        cafp,
        status,
        type,
        certificateProfileId,
        endEntityProfileId,
        tag,
        updateTime);
<span class="nc" id="L221">  }</span>

  /** Local interface only. */
  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public CertificateDataWrapper storeCertificateNoAuth(
      final AuthenticationToken adminForLogging,
      final Certificate incert,
      final String username,
      final String cafp,
      final int status,
      final int type,
      final int certificateProfileId,
      final int endEntityProfileId,
      final String tag,
      final long updateTime) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L238">      LOG.trace(</span>
          &quot;&gt;storeCertificateNoAuth(&quot;
              + username
              + &quot;, &quot;
              + cafp
              + &quot;, &quot;
              + status
              + &quot;, &quot;
              + type
              + &quot;)&quot;);
    }
<span class="nc" id="L249">    final CertificateDataWrapper ret =</span>
<span class="nc" id="L250">        storeCertificateNoAuthInternal(</span>
            adminForLogging,
            incert,
            username,
            cafp,
            status,
            type,
            certificateProfileId,
            endEntityProfileId,
            tag,
            updateTime,
            true);
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L263">      LOG.trace(&quot;&lt;storeCertificateNoAuth()&quot;);</span>
    }
<span class="nc" id="L265">    return ret;</span>
  }
  /**
   * same as storeCertificateNoAuth but with a flag to not audit log certificate
   * storage. The only reason to not audit log is when called from
   * checkForUniqueCertificateSerialNumberIndexInTransaction
   *
   * @param adminForLogging the AuthenticationToken that will be used for audit
   *     logging of the event
   * @param incert The certificate to be stored.
   * @param username username of end entity owning the certificate.
   * @param cafp Fingerprint (hex) of the CAs certificate.
   * @param status the status from the CertificateConstants.CERT_ constants
   * @param type Type of certificate (CERTTYPE_ENDENTITY etc from
   *     CertificateConstants).
   * @param certificateProfileId the certificate profile id this cert was issued
   *     under
   * @param endEntityProfileId the end entity profile id this cert was issued
   *     under
   * @param tag a custom string tagging this certificate for some purpose
   * @param updateTime epoch millis to use as last update time of the stored
   *     object
   * @param doAuditLog determines if a security audit log event shall be written
   *     or not with, EventTypes.CERT_STORED, ModuleTypes.CERTIFICATE, must only
   *     be used when storing special internal certificates, such as the test
   *     certificates for checking unique database index.
   * @return data
   */
  private CertificateDataWrapper storeCertificateNoAuthInternal(
      final AuthenticationToken adminForLogging,
      final Certificate incert,
      final String username,
      final String cafp,
      final int status,
      final int type,
      final int certificateProfileId,
      final int endEntityProfileId,
      final String tag,
      final long updateTime,
      final boolean doAuditLog) {
<span class="nc" id="L305">    final PublicKey pubk = enrichEcPublicKey(incert.getPublicKey(), cafp);</span>
    // Create the certificate in one go with all parameters at once. This used
    // to be important in EJB2.1 so the persistence layer only creates
    // *one* single
    // insert statement. If we do a home.create and the some setXX, it will
    // create one insert and one update statement to the database.
    // Probably not important in EJB3 anymore
    final boolean useBase64CertTable =
<span class="nc" id="L313">        CesecoreConfiguration.useBase64CertTable();</span>
<span class="nc" id="L314">    Base64CertData base64CertData = null;</span>
<span class="nc" id="L315">    final CertificateProfile certificateProfile =</span>
<span class="nc" id="L316">        certificateProfileSession.getCertificateProfile(certificateProfileId);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    final boolean storeCertificateData =</span>
        certificateProfile == null
<span class="nc bnc" id="L319" title="All 2 branches missed.">            || certificateProfile.getStoreCertificateData();</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">    if (useBase64CertTable &amp;&amp; storeCertificateData) {</span>
      // use special table for encoded data if told so.
<span class="nc" id="L322">      base64CertData = new Base64CertData(incert);</span>
<span class="nc" id="L323">      entityManager.persist(new Base64CertData(incert));</span>
    }
<span class="nc bnc" id="L325" title="All 2 branches missed.">    final boolean storeSubjectAlternativeName =</span>
        certificateProfile == null
<span class="nc bnc" id="L327" title="All 2 branches missed.">            || certificateProfile.getStoreSubjectAlternativeName();</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">    final CertificateData certificateData =</span>
        new CertificateData(
            incert,
            pubk,
            username,
            cafp,
            status,
            type,
            certificateProfileId,
            endEntityProfileId,
            tag,
            updateTime,
            !useBase64CertTable &amp;&amp; storeCertificateData,
            storeSubjectAlternativeName);
<span class="nc" id="L342">    entityManager.persist(certificateData);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    if (doAuditLog) {</span>
<span class="nc" id="L344">      final String serialNo = CertTools.getSerialNumberAsString(incert);</span>
<span class="nc" id="L345">      final String msg =</span>
<span class="nc" id="L346">          INTRES.getLocalizedMessage(</span>
              &quot;store.storecert&quot;,
              username,
<span class="nc" id="L349">              certificateData.getFingerprint(),</span>
<span class="nc" id="L350">              certificateData.getSubjectDnNeverNull(),</span>
<span class="nc" id="L351">              certificateData.getIssuerDN(),</span>
              serialNo);
<span class="nc" id="L353">      final String caId =</span>
<span class="nc" id="L354">          String.valueOf(CertTools.getIssuerDN(incert).hashCode());</span>
<span class="nc" id="L355">      logSession.log(</span>
          EventTypes.CERT_STORED,
          EventStatus.SUCCESS,
          ModuleTypes.CERTIFICATE,
          ServiceTypes.CORE,
<span class="nc" id="L360">          adminForLogging.toString(),</span>
          caId,
          serialNo,
          username,
          msg);
    }
<span class="nc" id="L366">    return new CertificateDataWrapper(incert, certificateData, base64CertData);</span>
  }

  /** Local interface only. */
  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public CertificateDataWrapper getCertificateData(final String fingerprint) {
<span class="nc" id="L373">    final CertificateData certificateData =</span>
<span class="nc" id="L374">        certificateDataSession.findByFingerprint(fingerprint);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">    if (certificateData == null) {</span>
<span class="nc" id="L376">      return null;</span>
    }
    final Base64CertData base64CertData;
<span class="nc bnc" id="L379" title="All 2 branches missed.">    if (CesecoreConfiguration.useBase64CertTable()) {</span>
<span class="nc" id="L380">      base64CertData =</span>
<span class="nc" id="L381">          Base64CertData.findByFingerprint(entityManager, fingerprint);</span>
    } else {
<span class="nc" id="L383">      base64CertData = null;</span>
    }
<span class="nc" id="L385">    return new CertificateDataWrapper(certificateData, base64CertData);</span>
  }

  /**
   * We need special handling here of CVC certificate with EC keys, because they
   * lack EC parameters in all certs except the Root certificate (CVCA).
   *
   * @param pubk key
   * @param cafp FP
   * @return enriched key
   */
  private PublicKey enrichEcPublicKey(final PublicKey pubk, final String cafp) {
<span class="nc" id="L397">    final int max = 5;</span>
<span class="nc" id="L398">      PublicKey ret = pubk;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">    if ((pubk instanceof PublicKeyEC)) {</span>
<span class="nc" id="L400">      PublicKeyEC pkec = (PublicKeyEC) pubk;</span>
      // The public key of IS and DV certificate (CVC) do not have any
      // parameters so we have to do some magic to get a complete EC public key
<span class="nc" id="L403">      ECParameterSpec spec = pkec.getParams();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">      if (spec == null) {</span>
        // We need to enrich this public key with parameters
        try {
<span class="nc bnc" id="L407" title="All 2 branches missed.">          if (cafp != null) {</span>
<span class="nc" id="L408">            String cafingerp = cafp;</span>
<span class="nc" id="L409">            CertificateData cacert =</span>
<span class="nc" id="L410">                certificateDataSession.findByFingerprint(cafp);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (cacert != null) {</span>
<span class="nc" id="L412">              String nextcafp = cacert.getCaFingerprint();</span>
<span class="nc" id="L413">              int bar =</span>
                  0; // never go more than 5 rounds, who knows what strange
                     // things can exist in the CAFingerprint column, make sure
                     // we
              // never get stuck here
<span class="nc bnc" id="L418" title="All 4 branches missed.">              while ((!StringUtils.equals(cafingerp, nextcafp))</span>
                  &amp;&amp; (bar++ &lt; max)) {
<span class="nc" id="L420">                cacert = certificateDataSession.findByFingerprint(cafp);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                if (cacert == null) {</span>
<span class="nc" id="L422">                  break;</span>
                }
<span class="nc" id="L424">                cafingerp = nextcafp;</span>
<span class="nc" id="L425">                nextcafp = cacert.getCaFingerprint();</span>
              }
<span class="nc bnc" id="L427" title="All 2 branches missed.">              if (cacert != null) {</span>
                // We found a root CA certificate, hopefully ?
<span class="nc" id="L429">                PublicKey pkwithparams =</span>
<span class="nc" id="L430">                    cacert.getCertificate(this.entityManager).getPublicKey();</span>
<span class="nc" id="L431">                ret = KeyTools.getECPublicKeyWithParams(pubk, pkwithparams);</span>
              }
            }
          }
<span class="nc" id="L435">        } catch (InvalidKeySpecException e) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L437">            LOG.debug(</span>
                &quot;Can not enrich EC public key with missing parameters: &quot;, e);
          }
<span class="nc" id="L440">        }</span>
      }
    } // finished with ECC key special handling
<span class="nc" id="L443">    return ret;</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public boolean updateCertificateOnly(
      final AuthenticationToken authenticationToken,
      final Certificate certificate) {
<span class="nc" id="L451">    final String fingerprint = CertTools.getFingerprintAsString(certificate);</span>
<span class="nc" id="L452">    final CertificateData certificateData =</span>
<span class="nc" id="L453">        certificateDataSession.findByFingerprint(fingerprint);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">    if (certificateData == null</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        || certificateData.getCertificate(entityManager) != null) {</span>
<span class="nc" id="L456">      return false;</span>
    }
    final boolean useBase64CertTable =
<span class="nc" id="L459">        CesecoreConfiguration.useBase64CertTable();</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">    if (useBase64CertTable) {</span>
      // use special table for encoded data if told so.
<span class="nc" id="L462">      entityManager.persist(new Base64CertData(certificate));</span>
    } else {
      try {
<span class="nc" id="L465">        certificateData.setBase64Cert(</span>
<span class="nc" id="L466">            new String(Base64.encode(certificate.getEncoded())));</span>
<span class="nc" id="L467">      } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L468">        LOG.error(</span>
            &quot;Failed to encode certificate for fingerprint &quot; + fingerprint, e);
<span class="nc" id="L470">        return false;</span>
<span class="nc" id="L471">      }</span>
    }
<span class="nc" id="L473">    final String username = certificateData.getUsername();</span>
<span class="nc" id="L474">    final String serialNo = CertTools.getSerialNumberAsString(certificate);</span>
<span class="nc" id="L475">    final String msg =</span>
<span class="nc" id="L476">        INTRES.getLocalizedMessage(</span>
            &quot;store.storecert&quot;,
            username,
            fingerprint,
<span class="nc" id="L480">            certificateData.getSubjectDnNeverNull(),</span>
<span class="nc" id="L481">            certificateData.getIssuerDN(),</span>
            serialNo);
<span class="nc" id="L483">    Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L484">    details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L485">    final String caId =</span>
<span class="nc" id="L486">        String.valueOf(CertTools.getIssuerDN(certificate).hashCode());</span>
<span class="nc" id="L487">    logSession.log(</span>
        EventTypes.CERT_STORED,
        EventStatus.SUCCESS,
        ModuleTypes.CERTIFICATE,
        ServiceTypes.CORE,
<span class="nc" id="L492">        authenticationToken.toString(),</span>
        caId,
        serialNo,
        username,
        details);
<span class="nc" id="L497">    return true;</span>
  }

  @Override
  public Collection&lt;String&gt; listAllCertificates(final String issuerdn) {
<span class="nc bnc" id="L502" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L503">      LOG.trace(&quot;&gt;listAllCertificates()&quot;);</span>
    }
    // This method was only used from CertificateDataTest and it didn't care
    // about the expireDate, so it will only select fingerprints now.
<span class="nc" id="L507">    return certificateDataSession.findFingerprintsByIssuerDN(</span>
<span class="nc" id="L508">        CertTools.stringToBCDNString(StringTools.strip(issuerdn)));</span>
  }

  @Override
  public Collection&lt;RevokedCertInfo&gt; listRevokedCertInfo(
      final String issuerdn, final long lastbasecrldate) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L515">      LOG.trace(&quot;&gt;listRevokedCertInfo()&quot;);</span>
    }
<span class="nc" id="L517">    return certificateDataSession.getRevokedCertInfos(</span>
<span class="nc" id="L518">        CertTools.stringToBCDNString(StringTools.strip(issuerdn)),</span>
        lastbasecrldate);
  }

  @Override
  public List&lt;Certificate&gt; findCertificatesBySubjectAndIssuer(
      final String subjectDN, final String issuerDN) {
<span class="nc" id="L525">    return findCertificatesBySubjectAndIssuer(subjectDN, issuerDN, false);</span>
  }

  @Override
  public List&lt;Certificate&gt; findCertificatesBySubjectAndIssuer(
      final String subjectDN, final String issuerDN, final boolean onlyActive) {
<span class="nc bnc" id="L531" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L532">      LOG.trace(</span>
          &quot;&gt;findCertificatesBySubjectAndIssuer(), dn='&quot;
              + subjectDN
              + &quot;' and issuer='&quot;
              + issuerDN
              + &quot;'&quot;);
    }
<span class="nc" id="L539">    final List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
    for (final CertificateDataWrapper cdw
<span class="nc bnc" id="L541" title="All 2 branches missed.">        : getCertificateDatasBySubjectAndIssuer(</span>
            subjectDN, issuerDN, onlyActive)) {
<span class="nc" id="L543">      ret.add(cdw.getCertificate());</span>
<span class="nc" id="L544">    }</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L546">      LOG.trace(</span>
          &quot;&lt;findCertificatesBySubjectAndIssuer(), dn='&quot;
              + subjectDN
              + &quot;' and issuer='&quot;
              + issuerDN
              + &quot;'&quot;);
    }
<span class="nc" id="L553">    return ret;</span>
  }

  @Override
  public List&lt;CertificateDataWrapper&gt; getCertificateDatasBySubjectAndIssuer(
      final String subjectDN, final String issuerDN, final boolean onlyActive) {
    // First make a DN in our well-known format
<span class="nc" id="L560">    final String dn =</span>
<span class="nc" id="L561">        CertTools.stringToBCDNString(StringTools.strip(subjectDN));</span>
<span class="nc" id="L562">    final String issuerdn =</span>
<span class="nc" id="L563">        CertTools.stringToBCDNString(StringTools.strip(issuerDN));</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L565">      LOG.debug(&quot;Looking for cert with (transformed)DN: &quot; + dn);</span>
    }
<span class="nc" id="L567">    final List&lt;CertificateDataWrapper&gt; ret = new ArrayList&lt;&gt;();</span>
    final Query query;
<span class="nc bnc" id="L569" title="All 2 branches missed.">    if (onlyActive) {</span>
<span class="nc" id="L570">      query =</span>
<span class="nc" id="L571">          entityManager.createQuery(</span>
              &quot;SELECT a FROM CertificateData a WHERE a.subjectDN=:subjectDN&quot;
                  + &quot; AND a.issuerDN=:issuerDN AND (a.status=:active OR&quot;
                  + &quot; a.status=:notifiedexpired OR (a.status=:revoked AND&quot;
                  + &quot; a.revocationReason=:onhold))AND&quot;
                  + &quot; a.expireDate&gt;:expireDate&quot;);
<span class="nc" id="L577">      query.setParameter(&quot;active&quot;, CertificateConstants.CERT_ACTIVE);</span>
<span class="nc" id="L578">      query.setParameter(</span>
<span class="nc" id="L579">          &quot;notifiedexpired&quot;, CertificateConstants.CERT_NOTIFIEDABOUTEXPIRATION);</span>
<span class="nc" id="L580">      query.setParameter(&quot;revoked&quot;, CertificateConstants.CERT_REVOKED);</span>
<span class="nc" id="L581">      query.setParameter(</span>
<span class="nc" id="L582">          &quot;onhold&quot;, RevokedCertInfo.REVOCATION_REASON_CERTIFICATEHOLD);</span>
<span class="nc" id="L583">      query.setParameter(&quot;expireDate&quot;, System.currentTimeMillis());</span>
    } else {
<span class="nc" id="L585">      query =</span>
<span class="nc" id="L586">          entityManager.createQuery(</span>
              &quot;SELECT a FROM CertificateData a WHERE a.subjectDN=:subjectDN&quot;
                  + &quot; AND a.issuerDN=:issuerDN&quot;);
    }
<span class="nc" id="L590">    query.setParameter(&quot;subjectDN&quot;, dn);</span>
<span class="nc" id="L591">    query.setParameter(&quot;issuerDN&quot;, issuerdn);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">    for (final Object certificateDataObject : query.getResultList()) {</span>
<span class="nc" id="L593">      final CertificateData certificateData =</span>
          (CertificateData) certificateDataObject;
<span class="nc" id="L595">      ret.add(</span>
          new CertificateDataWrapper(
              certificateData,
<span class="nc" id="L598">              Base64CertData.findByFingerprint(</span>
<span class="nc" id="L599">                  entityManager, certificateData.getFingerprint())));</span>
<span class="nc" id="L600">    }</span>
<span class="nc" id="L601">    return ret;</span>
  }

  @Override
  public Set&lt;String&gt; findUsernamesByIssuerDNAndSubjectDN(
      final String issuerDN, final String subjectDN) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L608">      LOG.trace(</span>
          &quot;&gt;findUsernamesByIssuerDNAndSubjectDN(), issuer='&quot; + issuerDN + &quot;'&quot;);
    }
    // First make a DN in our well-known format
<span class="nc" id="L612">    final String transformedIssuerDN =</span>
<span class="nc" id="L613">        CertTools.stringToBCDNString(StringTools.strip(issuerDN));</span>
<span class="nc" id="L614">    final String transformedSubjectDN =</span>
<span class="nc" id="L615">        CertTools.stringToBCDNString(StringTools.strip(subjectDN));</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L617">      LOG.debug(</span>
          &quot;Looking for user with a certificate with issuer DN(transformed) '&quot;
              + transformedIssuerDN
              + &quot;' and subject DN(transformed) '&quot;
              + transformedSubjectDN
              + &quot;'.&quot;);
    }
    try {
<span class="nc" id="L625">      return certificateDataSession.findUsernamesBySubjectDNAndIssuerDN(</span>
          transformedSubjectDN, transformedIssuerDN);
    } finally {
<span class="nc bnc" id="L628" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L629">        LOG.trace(</span>
            &quot;&lt;findUsernamesByIssuerDNAndSubjectDN(), issuer='&quot;
                + issuerDN
                + &quot;'&quot;);
      }
    }
  }

  @Override
  public Set&lt;String&gt; findUsernamesByIssuerDNAndSubjectKeyId(
      final String issuerDN, final byte[] subjectKeyId) {
<span class="nc bnc" id="L640" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L641">      LOG.trace(</span>
          &quot;&gt;findUsernamesByIssuerDNAndSubjectKeyId(), issuer='&quot;
              + issuerDN
              + &quot;'&quot;);
    }
    // First make a DN in our well-known format
<span class="nc" id="L647">    final String transformedIssuerDN =</span>
<span class="nc" id="L648">        CertTools.stringToBCDNString(StringTools.strip(issuerDN));</span>
<span class="nc" id="L649">    final String sSubjectKeyId = new String(Base64.encode(subjectKeyId, false));</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L651">      LOG.debug(</span>
          &quot;Looking for user with a certificate with issuer DN(transformed) '&quot;
              + transformedIssuerDN
              + &quot;' and SubjectKeyId '&quot;
              + sSubjectKeyId
              + &quot;'.&quot;);
    }
    try {
<span class="nc" id="L659">      return certificateDataSession.findUsernamesByIssuerDNAndSubjectKeyId(</span>
          transformedIssuerDN, sSubjectKeyId);
    } finally {
<span class="nc bnc" id="L662" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L663">        LOG.trace(</span>
            &quot;&lt;findUsernamesByIssuerDNAndSubjectKeyId(), issuer='&quot;
                + issuerDN
                + &quot;'&quot;);
      }
    }
  }

  @Override
  public String findUsernameByIssuerDnAndSerialNumber(
      final String issuerDn, final BigInteger serialNumber) {
<span class="nc" id="L674">    return certificateDataSession.findUsernameByIssuerDnAndSerialNumber(</span>
<span class="nc" id="L675">        issuerDn, serialNumber.toString());</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public String findUsernameByFingerprint(final String fingerprint) {
<span class="nc" id="L681">    final Query query =</span>
<span class="nc" id="L682">        entityManager.createQuery(</span>
            &quot;SELECT a.username FROM CertificateData a WHERE&quot;
                + &quot; a.fingerprint=:fingerprint&quot;);
<span class="nc" id="L685">    query.setParameter(&quot;fingerprint&quot;, fingerprint);</span>
<span class="nc" id="L686">    final List&lt;String&gt; usernames = query.getResultList();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">    if (usernames.isEmpty()) {</span>
<span class="nc" id="L688">      return null;</span>
    } else {
<span class="nc" id="L690">      return usernames.get(0);</span>
    }
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  public boolean isOnlyUsernameForSubjectKeyIdOrDnAndIssuerDN(
      final String issuerDN,
      final byte[] subjectKeyId,
      final String subjectDN,
      final String username) {
<span class="nc bnc" id="L701" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L702">      LOG.trace(</span>
          &quot;&gt;isOnlyUsernameForSubjectKeyIdOrDnAndIssuerDN(), issuer='&quot;
              + issuerDN
              + &quot;'&quot;);
    }
    // First make a DN in our well-known format
<span class="nc" id="L708">    final String transformedIssuerDN =</span>
<span class="nc" id="L709">        CertTools.stringToBCDNString(StringTools.strip(issuerDN));</span>
<span class="nc" id="L710">    final String sSubjectKeyId = new String(Base64.encode(subjectKeyId, false));</span>
<span class="nc" id="L711">    final String transformedSubjectDN =</span>
<span class="nc" id="L712">        CertTools.stringToBCDNString(StringTools.strip(subjectDN));</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L714">      LOG.debug(</span>
          &quot;Looking for user with a certificate with issuer DN(transformed) '&quot;
              + transformedIssuerDN
              + &quot;' and SubjectKeyId '&quot;
              + sSubjectKeyId
              + &quot;' OR subject DN(transformed) '&quot;
              + transformedSubjectDN
              + &quot;'.&quot;);
    }
    try {
<span class="nc" id="L724">      final Set&lt;String&gt; usernames =</span>
<span class="nc" id="L725">          certificateDataSession.findUsernamesBySubjectKeyIdOrDnAndIssuer(</span>
              transformedIssuerDN, sSubjectKeyId, transformedSubjectDN);
<span class="nc bnc" id="L727" title="All 2 branches missed.">      return usernames.size() == 0</span>
<span class="nc bnc" id="L728" title="All 4 branches missed.">          || (usernames.size() == 1 &amp;&amp; usernames.contains(username));</span>
    } finally {
<span class="nc bnc" id="L730" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L731">        LOG.trace(</span>
            &quot;&lt;isOnlyUsernameForSubjectKeyIdOrDnAndIssuerDN(), issuer='&quot;
                + issuerDN
                + &quot;'&quot;);
      }
    }
  }

  @Override
  public List&lt;Certificate&gt; findCertificatesBySubject(final String subjectDN) {
<span class="nc bnc" id="L741" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L742">      LOG.trace(&quot;&gt;findCertificatesBySubject(), dn='&quot; + subjectDN + &quot;'&quot;);</span>
    }
    // First make a DN in our well-known format
<span class="nc" id="L745">    final List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
    for (final CertificateDataWrapper cdw
<span class="nc bnc" id="L747" title="All 2 branches missed.">        : getCertificateDatasBySubject(subjectDN)) {</span>
<span class="nc" id="L748">      ret.add(cdw.getCertificate());</span>
<span class="nc" id="L749">    }</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L751">      LOG.trace(</span>
          &quot;&lt;findCertificatesBySubject(), dn='&quot;
              + subjectDN
              + &quot;': &quot;
<span class="nc" id="L755">              + ret.size());</span>
    }
<span class="nc" id="L757">    return ret;</span>
  }

  @Override
  public List&lt;CertificateDataWrapper&gt; getCertificateDatasBySubject(
      final String subjectDN) {
    // First make a DN in our well-known format
<span class="nc" id="L764">    final String dn =</span>
<span class="nc" id="L765">        CertTools.stringToBCDNString(StringTools.strip(subjectDN));</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L767">      LOG.debug(&quot;Looking for cert with (transformed) DN: &quot; + dn);</span>
    }
<span class="nc" id="L769">    final List&lt;CertificateDataWrapper&gt; ret = new ArrayList&lt;&gt;();</span>
    for (final CertificateData certificateData
<span class="nc bnc" id="L771" title="All 2 branches missed.">       : certificateDataSession.findBySubjectDN(dn)) {</span>
<span class="nc" id="L772">      ret.add(</span>
          new CertificateDataWrapper(
              certificateData,
<span class="nc" id="L775">              Base64CertData.findByFingerprint(</span>
<span class="nc" id="L776">                  entityManager, certificateData.getFingerprint())));</span>
<span class="nc" id="L777">    }</span>
<span class="nc" id="L778">    return ret;</span>
  }

  @Override
  public X509Certificate findLatestX509CertificateBySubject(
      final String subjectDN) {
<span class="nc" id="L784">    return findLatestX509CertificateBySubject(subjectDN, null, false);</span>
  }

  @Override
  public X509Certificate findLatestX509CertificateBySubject(
      final String subjectDN,
      final X509Certificate rolloverCA,
      final boolean findRollover) {
<span class="nc" id="L792">    final Collection&lt;CertificateDataWrapper&gt; certificateDatas =</span>
<span class="nc" id="L793">        getCertificateDatasBySubject(subjectDN);</span>
<span class="nc" id="L794">    X509Certificate result = null;</span>
<span class="nc" id="L795">    Collection&lt;X509Certificate&gt; trustedChain = null;</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">    if (rolloverCA != null) {</span>
<span class="nc" id="L797">      trustedChain = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L798">      trustedChain.add(rolloverCA);</span>
    }

    // Find the newest certificate
<span class="nc bnc" id="L802" title="All 2 branches missed.">    for (CertificateDataWrapper certDataWrapper : certificateDatas) {</span>
<span class="nc" id="L803">      final int status = certDataWrapper.getCertificateData().getStatus();</span>
      // Ignore rollover CA certificates unless explicitly requested
<span class="nc bnc" id="L805" title="All 4 branches missed.">      if (status == CertificateConstants.CERT_ROLLOVERPENDING</span>
          &amp;&amp; !findRollover) {
<span class="nc" id="L807">        continue;</span>
      }
<span class="nc bnc" id="L809" title="All 2 branches missed.">      if (certDataWrapper.getCertificate() instanceof X509Certificate) {</span>
<span class="nc" id="L810">        final X509Certificate x509Certificate =</span>
<span class="nc" id="L811">            (X509Certificate) certDataWrapper.getCertificate();</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (rolloverCA != null) {</span>
          // The old and new CA certificate will generally have different keys,
          // but we also handle the case where they don't by checking the date
<span class="nc" id="L815">          boolean signedByRolloverCAKey = false;</span>
          try {
<span class="nc" id="L817">            CertTools.verify(</span>
                x509Certificate,
                trustedChain,
<span class="nc" id="L820">                CertTools.getNotBefore(x509Certificate));</span>
<span class="nc" id="L821">            signedByRolloverCAKey = true;</span>
<span class="nc" id="L822">          } catch (CertPathValidatorException e) {</span>
            // NOPMD
<span class="nc" id="L824">          }</span>
          // Check that the EE roll-over certificate validity starts equal to or
          // after the roll-over CA certificates validity
<span class="nc" id="L827">          final Date notBeforeX509Certificate =</span>
<span class="nc" id="L828">              CertTools.getNotBefore(x509Certificate);</span>
<span class="nc" id="L829">          final Date notBeforeRolloverCA = CertTools.getNotBefore(rolloverCA);</span>
<span class="nc" id="L830">          final boolean eeCertValidUnderCaValidity =</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">              !notBeforeX509Certificate.before(notBeforeRolloverCA);</span>
<span class="nc bnc" id="L832" title="All 4 branches missed.">          final boolean isRollover =</span>
              signedByRolloverCAKey &amp;&amp; eeCertValidUnderCaValidity;
<span class="nc bnc" id="L834" title="All 2 branches missed.">          if (isRollover != findRollover) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L836">              final String fingerprint =</span>
<span class="nc" id="L837">                  CertTools.getFingerprintAsString(x509Certificate);</span>
<span class="nc" id="L838">              LOG.trace(</span>
                  &quot;Certificate with fingerprint '&quot;
                      + fingerprint
                      + &quot;' is not considered a rollover certificate.&quot;
                      + &quot; signedByRolloverCAKey: &quot;
                      + signedByRolloverCAKey
                      + &quot; leaf not before: &quot;
                      + notBeforeX509Certificate
                      + &quot; CA not before: &quot;
                      + notBeforeRolloverCA);
<span class="nc" id="L848">            }</span>
            continue;
          }
        }
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (result == null</span>
<span class="nc" id="L853">            || CertTools.getNotBefore(x509Certificate)</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                .after(CertTools.getNotBefore(result))) {</span>
<span class="nc" id="L855">          result = x509Certificate;</span>
        }
      }
<span class="nc" id="L858">    }</span>

<span class="nc" id="L860">    return result;</span>
  }

  @Override
  public Collection&lt;CertificateWrapper&gt; findCertificatesByExpireTimeWithLimit(
      final Date expireTime) {
<span class="nc bnc" id="L866" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L867">      LOG.trace(&quot;&gt;findCertificatesByExpireTimeWithLimit(), time=&quot; + expireTime);</span>
    }
    // First make expire time in well know format
<span class="nc bnc" id="L870" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L871">      LOG.debug(&quot;Looking for certs that expire before: &quot; + expireTime);</span>
    }
<span class="nc" id="L873">    final List&lt;CertificateData&gt; certificateDatas =</span>
<span class="nc" id="L874">        certificateDataSession.findByExpireDateWithLimit(</span>
<span class="nc" id="L875">            expireTime.getTime(),</span>
<span class="nc" id="L876">            getGlobalCesecoreConfiguration().getMaximumQueryCount());</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L878">      LOG.debug(</span>
          &quot;Found &quot;
<span class="nc" id="L880">              + certificateDatas.size()</span>
              + &quot; certificates that expire before &quot;
              + expireTime);
    }
<span class="nc" id="L884">    final List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">    for (final CertificateData certificateData : certificateDatas) {</span>
<span class="nc" id="L886">      final Certificate certificate =</span>
<span class="nc" id="L887">          certificateData.getCertificate(entityManager);</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">      if (certificate == null) {</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L890">          LOG.debug(</span>
              &quot;Skipping CertificateData with fingerprint '&quot;
<span class="nc" id="L892">                  + certificateData.getFingerprint()</span>
                  + &quot;' since it has no stored certificate.&quot;);
        }
      } else {
<span class="nc" id="L896">        ret.add(certificate);</span>
      }
<span class="nc" id="L898">    }</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L900">      LOG.trace(&quot;&lt;findCertificatesByExpireTimeWithLimit(), time=&quot; + expireTime);</span>
    }
<span class="nc" id="L902">    return EJBTools.wrapCertCollection(ret);</span>
  }

  @Override
  public List&lt;Certificate&gt; findCertificatesByExpireTimeWithLimit(
      final Date expireTime, final int maxNumberOfResults) {
<span class="nc bnc" id="L908" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L909">      LOG.trace(</span>
          &quot;&gt;findCertificatesByExpireTimeWithLimit(), time=&quot;
              + expireTime
              + &quot; - maxNumberOfResults=&quot;
              + maxNumberOfResults);
    }
<span class="nc bnc" id="L915" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L916">      LOG.debug(&quot;Looking for certs that expire before: &quot; + expireTime);</span>
    }
<span class="nc" id="L918">    List&lt;CertificateData&gt; certificateDatas =</span>
<span class="nc" id="L919">        certificateDataSession.findByExpireDateWithLimit(</span>
<span class="nc" id="L920">            expireTime.getTime(), maxNumberOfResults);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L922">      LOG.debug(</span>
          &quot;Found &quot;
<span class="nc" id="L924">              + certificateDatas.size()</span>
              + &quot; certificates that expire before &quot;
              + expireTime);
    }
<span class="nc" id="L928">    final List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">    for (final CertificateData certificateData : certificateDatas) {</span>
<span class="nc" id="L930">      final Certificate certificate =</span>
<span class="nc" id="L931">          certificateData.getCertificate(entityManager);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">      if (certificate == null) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L934">          LOG.debug(</span>
              &quot;Skipping CertificateData with fingerprint '&quot;
<span class="nc" id="L936">                  + certificateData.getFingerprint()</span>
                  + &quot;' since it has no stored certificate.&quot;);
        }
      } else {
<span class="nc" id="L940">        ret.add(certificate);</span>
      }
<span class="nc" id="L942">    }</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L944">      LOG.trace(</span>
          &quot;&lt;findCertificatesByExpireTimeWithLimit(), time=&quot;
              + expireTime
              + &quot; - maxNumberOfResults=&quot;
              + maxNumberOfResults);
    }
<span class="nc" id="L950">    return ret;</span>
  }

  @Override
  public int findNumberOfExpiringCertificates(final Date expirationDate) {
<span class="nc" id="L955">    return certificateDataSession.countByExpireDate(expirationDate.getTime());</span>
  }

  @Override
  public List&lt;Certificate&gt; findExpiringCertificates(
      final Date expirationDate,
      final int maxNumberOfResults,
      final int offset) {
<span class="nc" id="L963">    LOG.trace(</span>
        &quot;&gt;findExpiringCertificates(), time=&quot;
            + expirationDate
            + &quot; - maxNumberOfResults=&quot;
            + maxNumberOfResults
            + &quot; - offset=&quot;
            + offset);
<span class="nc" id="L970">    LOG.debug(&quot;Looking for certs that expire before: &quot; + expirationDate);</span>
<span class="nc" id="L971">    List&lt;CertificateData&gt; certificateDatas =</span>
<span class="nc" id="L972">        certificateDataSession.findByExpireDateWithLimitAndOffset(</span>
<span class="nc" id="L973">            expirationDate.getTime(), maxNumberOfResults, offset);</span>
<span class="nc" id="L974">    LOG.debug(</span>
        &quot;Found &quot;
<span class="nc" id="L976">            + certificateDatas.size()</span>
            + &quot; certificates that expire before &quot;
            + expirationDate);
<span class="nc" id="L979">    final List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">    for (final CertificateData certificateData : certificateDatas) {</span>
<span class="nc" id="L981">      final Certificate certificate =</span>
<span class="nc" id="L982">          certificateData.getCertificate(entityManager);</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">      if (certificate == null) {</span>
<span class="nc" id="L984">        LOG.debug(</span>
            &quot;Skipping CertificateData with fingerprint '&quot;
<span class="nc" id="L986">                + certificateData.getFingerprint()</span>
                + &quot;' since it has no stored certificate.&quot;);
      } else {
<span class="nc" id="L989">        ret.add(certificate);</span>
      }
<span class="nc" id="L991">    }</span>
<span class="nc" id="L992">    LOG.trace(</span>
        &quot;&lt;findExpiringCertificates(), time=&quot;
            + expirationDate
            + &quot; - maxNumberOfResults=&quot;
            + maxNumberOfResults
            + &quot; - offset=&quot;
            + offset);
<span class="nc" id="L999">    return ret;</span>
  }

  @Override
  public List&lt;Certificate&gt; findCertificatesByExpireTimeAndIssuerWithLimit(
      final Date expireTime,
      final String issuerDN,
      final int maxNumberOfResults) {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1008">      LOG.trace(</span>
          &quot;&gt;findCertificatesByExpireTimeWithLimit(), time=&quot;
              + expireTime
              + &quot;  - issuerDN=&quot;
              + issuerDN
              + &quot;  - maxNumberOfResults=&quot;
              + maxNumberOfResults);
    }
<span class="nc bnc" id="L1016" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1017">      LOG.debug(&quot;Looking for certs that expire before: &quot; + expireTime);</span>
    }
<span class="nc" id="L1019">    List&lt;CertificateData&gt; coll =</span>
<span class="nc" id="L1020">        certificateDataSession.findByExpireDateAndIssuerWithLimit(</span>
<span class="nc" id="L1021">            expireTime.getTime(), issuerDN, maxNumberOfResults);</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1023">      LOG.debug(</span>
          &quot;Found &quot;
<span class="nc" id="L1025">              + coll.size()</span>
              + &quot; certificates that expire before &quot;
              + expireTime
              + &quot; and issuerDN &quot;
              + issuerDN);
    }
<span class="nc" id="L1031">    List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">    for (CertificateData certData : coll) {</span>
<span class="nc" id="L1033">      ret.add(certData.getCertificate(entityManager));</span>
<span class="nc" id="L1034">    }</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1036">      LOG.trace(</span>
          &quot;&lt;findCertificatesByExpireTimeWithLimit(), time=&quot;
              + expireTime
              + &quot;  issuerDN=&quot;
              + issuerDN
              + &quot;  - maxNumberOfResults=&quot;
              + maxNumberOfResults);
    }
<span class="nc" id="L1044">    return ret;</span>
  }

  @Override
  public List&lt;Certificate&gt; findCertificatesByExpireTimeAndTypeWithLimit(
      final Date expireTime,
      final int certificateType,
      final int maxNumberOfResults) {
<span class="nc bnc" id="L1052" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1053">      LOG.trace(</span>
          &quot;&gt;findCertificatesByExpireTimeAndTypeWithLimit(), time=&quot;
              + expireTime
              + &quot;  - type=&quot;
              + certificateType
              + &quot;  - maxNumberOfResults=&quot;
              + maxNumberOfResults);
    }
<span class="nc bnc" id="L1061" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1062">      LOG.debug(</span>
          &quot;Looking for certs that expire before &quot;
              + expireTime
              + &quot; and of type &quot;
              + certificateType);
    }
<span class="nc" id="L1068">    List&lt;CertificateData&gt; coll =</span>
<span class="nc" id="L1069">        certificateDataSession.findByExpireDateAndTypeWithLimit(</span>
<span class="nc" id="L1070">            expireTime.getTime(), certificateType, maxNumberOfResults);</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1072">      LOG.debug(</span>
          &quot;Found &quot;
<span class="nc" id="L1074">              + coll.size()</span>
              + &quot; certificates that expire before &quot;
              + expireTime
              + &quot; and of type &quot;
              + certificateType);
    }
<span class="nc" id="L1080">    List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">    for (CertificateData certData : coll) {</span>
<span class="nc" id="L1082">      ret.add(certData.getCertificate(entityManager));</span>
<span class="nc" id="L1083">    }</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1085">      LOG.trace(</span>
          &quot;&lt;findCertificatesByExpireTimeAndTypeWithLimit(), time=&quot;
              + expireTime
              + &quot;  - type=&quot;
              + certificateType
              + &quot;  - maxNumberOfResults=&quot;
              + maxNumberOfResults);
    }
<span class="nc" id="L1093">    return ret;</span>
  }

  @Override
  public Collection&lt;String&gt; findUsernamesByExpireTimeWithLimit(
      final Date expiretime) {
<span class="nc bnc" id="L1099" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1100">      LOG.trace(&quot;&gt;findCertificatesByExpireTimeWithLimit: &quot; + expiretime);</span>
    }
<span class="nc" id="L1102">    return certificateDataSession.findUsernamesByExpireTimeWithLimit(</span>
<span class="nc" id="L1103">        new Date().getTime(),</span>
<span class="nc" id="L1104">        expiretime.getTime(),</span>
<span class="nc" id="L1105">        getGlobalCesecoreConfiguration().getMaximumQueryCount());</span>
  }

  @Override
  public boolean existsByIssuerAndSerno(
      final String issuerDN, final BigInteger serno) {
<span class="nc bnc" id="L1111" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1112">      LOG.trace(</span>
          &quot;&gt;existsByIssuerAndSerno(), dn:&quot;
              + issuerDN
              + &quot;, serno=&quot;
<span class="nc" id="L1116">              + serno.toString(16));</span>
    }
    // Selecting an int column is optimal speed
<span class="nc" id="L1119">    final Query query =</span>
<span class="nc" id="L1120">        entityManager.createQuery(</span>
            &quot;SELECT 1 FROM CertificateData a WHERE a.issuerDN=:issuerDN AND&quot;
                + &quot; a.serialNumber=:serialNumber&quot;);
    // First make a DN in our well-known format
<span class="nc" id="L1124">    query.setParameter(</span>
<span class="nc" id="L1125">        &quot;issuerDN&quot;, CertTools.stringToBCDNString(StringTools.strip(issuerDN)));</span>
<span class="nc" id="L1126">    query.setParameter(&quot;serialNumber&quot;, serno.toString());</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">    final boolean ret = query.getResultList().size() &gt; 0;</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1129">      LOG.trace(</span>
          &quot;&lt;existsByIssuerAndSerno(), dn:&quot;
              + issuerDN
              + &quot;, serno=&quot;
<span class="nc" id="L1133">              + serno.toString(16)</span>
              + &quot;, ret=&quot;
              + ret);
    }
<span class="nc" id="L1137">    return ret;</span>
  }

  @Override
  public Certificate findCertificateByIssuerAndSerno(
      final String issuerDN, final BigInteger serno) {
<span class="nc bnc" id="L1143" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1144">      LOG.trace(</span>
          &quot;&gt;findCertificateByIssuerAndSerno(), dn:&quot;
              + issuerDN
              + &quot;, serno=&quot;
<span class="nc" id="L1148">              + serno.toString(16));</span>
    }
    // First make a DN in our well-known format
<span class="nc" id="L1151">    String dn = CertTools.stringToBCDNString(StringTools.strip(issuerDN));</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1153">      LOG.debug(&quot;Looking for cert with (transformed)DN: &quot; + dn);</span>
    }
<span class="nc" id="L1155">    Collection&lt;CertificateData&gt; coll =</span>
<span class="nc" id="L1156">        certificateDataSession.findByIssuerDNSerialNumber(dn, serno.toString());</span>
<span class="nc" id="L1157">    Certificate ret = null;</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">    if (coll.size() &gt; 1) {</span>
<span class="nc" id="L1159">      String msg =</span>
<span class="nc" id="L1160">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1161">              &quot;store.errorseveralissuerserno&quot;, issuerDN, serno.toString(16));</span>
<span class="nc" id="L1162">      LOG.error(msg);</span>
    }
<span class="nc" id="L1164">    Certificate cert = null;</span>
    // There are several certs, we will try to find the latest issued one
<span class="nc bnc" id="L1166" title="All 2 branches missed.">    for (CertificateData certificateData : coll) {</span>
<span class="nc" id="L1167">      cert = certificateData.getCertificate(this.entityManager);</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">      if (ret != null) {</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">        if (CertTools.getNotBefore(cert).after(CertTools.getNotBefore(ret))) {</span>
          // cert is never than ret
<span class="nc" id="L1171">          ret = cert;</span>
        }
      } else {
<span class="nc" id="L1174">        ret = cert;</span>
      }
<span class="nc" id="L1176">    }</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1178">      LOG.trace(</span>
          &quot;&lt;findCertificateByIssuerAndSerno(), dn:&quot;
              + issuerDN
              + &quot;, serno=&quot;
<span class="nc" id="L1182">              + serno.toString(16));</span>
    }
<span class="nc" id="L1184">    return ret;</span>
  }

  @Override
  public CertificateDataWrapper getCertificateDataByIssuerAndSerno(
      final String issuerDN, final BigInteger serno) {
    // First make a DN in our well-known format
<span class="nc" id="L1191">    final String dn = CertTools.stringToBCDNString(StringTools.strip(issuerDN));</span>
<span class="nc" id="L1192">    final List&lt;CertificateData&gt; certs =</span>
<span class="nc" id="L1193">        certificateDataSession.findByIssuerDNSerialNumber(dn, serno.toString());</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1195">      LOG.debug(</span>
          &quot;Found &quot;
<span class="nc" id="L1197">              + certs.size()</span>
              + &quot; cert(s) with (transformed) DN: &quot;
              + dn
              + &quot; serialNumber: &quot;
<span class="nc" id="L1201">              + serno.toString());</span>
    }
<span class="nc bnc" id="L1203" title="All 2 branches missed.">    if (certs.size() &gt; 1) {</span>
<span class="nc" id="L1204">      LOG.error(</span>
<span class="nc" id="L1205">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1206">              &quot;store.errorseveralissuerserno&quot;, issuerDN, serno.toString(16)));</span>
    }
<span class="nc bnc" id="L1208" title="All 2 branches missed.">    if (certs.size() == 0) {</span>
<span class="nc" id="L1209">      return null;</span>
    }
<span class="nc" id="L1211">    final List&lt;CertificateDataWrapper&gt; cdws = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">    for (final CertificateData certificateData : certs) {</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">      if (CesecoreConfiguration.useBase64CertTable()) {</span>
<span class="nc" id="L1214">        final Base64CertData base64CertData =</span>
<span class="nc" id="L1215">            Base64CertData.findByFingerprint(</span>
<span class="nc" id="L1216">                entityManager, certificateData.getFingerprint());</span>
<span class="nc" id="L1217">        cdws.add(new CertificateDataWrapper(certificateData, base64CertData));</span>
<span class="nc" id="L1218">      } else {</span>
<span class="nc" id="L1219">        cdws.add(new CertificateDataWrapper(certificateData, null));</span>
      }
<span class="nc" id="L1221">    }</span>
<span class="nc" id="L1222">    Collections.sort(cdws);</span>
<span class="nc" id="L1223">    return cdws.get(0);</span>
  }

  @Override
  public CertificateInfo findFirstCertificateInfo(
      final String issuerDN, final BigInteger serno) {
<span class="nc" id="L1229">    return certificateDataSession.findFirstCertificateInfo(</span>
<span class="nc" id="L1230">        CertTools.stringToBCDNString(issuerDN), serno.toString());</span>
  }

  @Override
  public int getFirstStatusByIssuerAndSerno(
      final String issuerDN, final BigInteger serno) {
<span class="nc" id="L1236">    final Query query =</span>
<span class="nc" id="L1237">        entityManager.createQuery(</span>
            &quot;SELECT a.status FROM CertificateData a WHERE a.issuerDN=:issuerDN&quot;
                + &quot; AND a.serialNumber=:serialNumber&quot;);
<span class="nc" id="L1240">    query.setParameter(&quot;issuerDN&quot;, CertTools.stringToBCDNString(issuerDN));</span>
<span class="nc" id="L1241">    query.setParameter(&quot;serialNumber&quot;, serno.toString());</span>
    final int status;
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L1244">    final List result = query.getResultList();</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">    if (result.size() &gt; 0) {</span>
<span class="nc" id="L1246">      status = ValueExtractor.extractIntValue(result.get(0));</span>
    } else {
<span class="nc" id="L1248">      status = -1;</span>
    }
<span class="nc" id="L1250">    return status;</span>
  }

  @Override
  public Collection&lt;Certificate&gt; findCertificatesByIssuerAndSernos(
      final String issuerDN, final Collection&lt;BigInteger&gt; sernos) {
<span class="nc bnc" id="L1256" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1257">      LOG.trace(&quot;&gt;findCertificateByIssuerAndSernos()&quot;);</span>
    }
<span class="nc" id="L1259">    List&lt;Certificate&gt; ret = null;</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">    if (null == issuerDN</span>
<span class="nc bnc" id="L1261" title="All 4 branches missed.">        || issuerDN.length() &lt;= 0</span>
        || null == sernos
<span class="nc bnc" id="L1263" title="All 2 branches missed.">        || sernos.isEmpty()) {</span>
<span class="nc" id="L1264">      ret = new ArrayList&lt;&gt;();</span>
    } else {
<span class="nc" id="L1266">      String dn = CertTools.stringToBCDNString(issuerDN);</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1268">        LOG.debug(&quot;Looking for cert with (transformed)DN: &quot; + dn);</span>
      }
<span class="nc" id="L1270">      ret =</span>
<span class="nc" id="L1271">          certificateDataSession.findCertificatesByIssuerDnAndSerialNumbers(</span>
              dn, sernos);
    }
<span class="nc bnc" id="L1274" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1275">      LOG.trace(&quot;&lt;findCertificateByIssuerAndSernos()&quot;);</span>
    }
<span class="nc" id="L1277">    return ret;</span>
  }

  @Override
  public List&lt;CertificateDataWrapper&gt; getCertificateDataBySerno(
      final BigInteger serno) {
<span class="nc bnc" id="L1283" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1284">      LOG.trace(&quot;&gt;findCertificatesBySerno(),  serno=&quot; + serno);</span>
    }
<span class="nc" id="L1286">    final List&lt;CertificateDataWrapper&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1287">    final List&lt;CertificateData&gt; coll =</span>
<span class="nc" id="L1288">        certificateDataSession.findBySerialNumber(serno.toString());</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">    for (final CertificateData certificateData : coll) {</span>
<span class="nc" id="L1290">      ret.add(</span>
          new CertificateDataWrapper(
              certificateData,
<span class="nc" id="L1293">              Base64CertData.findByFingerprint(</span>
<span class="nc" id="L1294">                  entityManager, certificateData.getFingerprint())));</span>
<span class="nc" id="L1295">    }</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1297">      LOG.trace(&quot;&lt;findCertificatesBySerno(), serno=&quot; + serno);</span>
    }
<span class="nc" id="L1299">    return ret;</span>
  }

  @Override
  public String findUsernameByCertSerno(
      final BigInteger serno, final String issuerdn) {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1306">      LOG.trace(</span>
          &quot;&gt;findUsernameByCertSerno(), serno: &quot;
<span class="nc" id="L1308">              + serno.toString(16)</span>
              + &quot;, issuerdn: &quot;
              + issuerdn);
    }
<span class="nc" id="L1312">    final String ret =</span>
<span class="nc" id="L1313">        certificateDataSession.findLastUsernameByIssuerDNSerialNumber(</span>
<span class="nc" id="L1314">            CertTools.stringToBCDNString(issuerdn), serno.toString());</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1316">      LOG.trace(&quot;&lt;findUsernameByCertSerno(), ret=&quot; + ret);</span>
    }
<span class="nc" id="L1318">    return ret;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public List&lt;CertificateDataWrapper&gt; getCertificateDataByUsername(
      final String username,
      final boolean excludeExpired,
      final List&lt;Integer&gt; excludedStatuses) {
<span class="nc" id="L1327">    final List&lt;CertificateDataWrapper&gt; ret = new ArrayList&lt;&gt;();</span>
    final List&lt;CertificateData&gt; certificateDatas;
<span class="nc bnc" id="L1329" title="All 2 branches missed.">    if (excludeExpired) {</span>
<span class="nc bnc" id="L1330" title="All 4 branches missed.">      if (excludedStatuses == null || excludedStatuses.isEmpty()) {</span>
<span class="nc" id="L1331">        final Query query =</span>
<span class="nc" id="L1332">            entityManager.createQuery(</span>
                &quot;SELECT a FROM CertificateData a WHERE a.username=:username&quot;
                    + &quot; AND (a.expireDate&gt;=:afterExpireDate OR a.expireDate=0)&quot;
                    + &quot; ORDER BY a.expireDate DESC, a.serialNumber DESC&quot;);
<span class="nc" id="L1336">        query.setParameter(&quot;username&quot;, username);</span>
<span class="nc" id="L1337">        query.setParameter(&quot;afterExpireDate&quot;, System.currentTimeMillis());</span>
<span class="nc" id="L1338">        certificateDatas = query.getResultList();</span>
<span class="nc" id="L1339">      } else {</span>
<span class="nc" id="L1340">        final Query query =</span>
<span class="nc" id="L1341">            entityManager.createQuery(</span>
                &quot;SELECT a FROM CertificateData a WHERE a.username=:username&quot;
                    + &quot; AND a.status NOT IN (:statusExcluded) AND&quot;
                    + &quot; (a.expireDate&gt;=:afterExpireDate OR a.expireDate=0)&quot;
                    + &quot; ORDER BY a.expireDate DESC, a.serialNumber DESC&quot;);
<span class="nc" id="L1346">        query.setParameter(&quot;username&quot;, username);</span>
<span class="nc" id="L1347">        query.setParameter(&quot;statusExcluded&quot;, excludedStatuses);</span>
<span class="nc" id="L1348">        query.setParameter(&quot;afterExpireDate&quot;, System.currentTimeMillis());</span>
<span class="nc" id="L1349">        certificateDatas = query.getResultList();</span>
<span class="nc" id="L1350">      }</span>
    } else {
<span class="nc bnc" id="L1352" title="All 4 branches missed.">      if (excludedStatuses == null || excludedStatuses.isEmpty()) {</span>
<span class="nc" id="L1353">        certificateDatas =</span>
<span class="nc" id="L1354">            certificateDataSession.findByUsernameOrdered(username);</span>
      } else {
<span class="nc" id="L1356">        final Query query =</span>
<span class="nc" id="L1357">            entityManager.createQuery(</span>
                &quot;SELECT a FROM CertificateData a WHERE a.username=:username&quot;
                    + &quot; AND a.status NOT IN (:statusExcluded) ORDER BY&quot;
                    + &quot; a.expireDate DESC, a.serialNumber DESC&quot;);
<span class="nc" id="L1361">        query.setParameter(&quot;username&quot;, username);</span>
<span class="nc" id="L1362">        query.setParameter(&quot;statusExcluded&quot;, excludedStatuses);</span>
<span class="nc" id="L1363">        certificateDatas = query.getResultList();</span>
      }
    }
<span class="nc bnc" id="L1366" title="All 2 branches missed.">    for (final CertificateData certificateData : certificateDatas) {</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">      if (CesecoreConfiguration.useBase64CertTable()) {</span>
<span class="nc" id="L1368">        ret.add(</span>
            new CertificateDataWrapper(
                certificateData,
<span class="nc" id="L1371">                Base64CertData.findByFingerprint(</span>
<span class="nc" id="L1372">                    entityManager, certificateData.getFingerprint())));</span>
      } else {
<span class="nc" id="L1374">        ret.add(new CertificateDataWrapper(certificateData, null));</span>
      }
<span class="nc" id="L1376">    }</span>
<span class="nc" id="L1377">    return ret;</span>
  }

  @Override
  public Collection&lt;CertificateWrapper&gt; findCertificatesByUsername(
      final String username) {
<span class="nc bnc" id="L1383" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1384">      LOG.trace(&quot;&gt;findCertificatesByUsername(),  username=&quot; + username);</span>
    }
    // This method on the entity bean does the ordering in the database
<span class="nc" id="L1387">    final List&lt;CertificateData&gt; certificateDatas =</span>
<span class="nc" id="L1388">        certificateDataSession.findByUsernameOrdered(username);</span>
<span class="nc" id="L1389">    final List&lt;Certificate&gt; ret =</span>
<span class="nc" id="L1390">        getAsCertificateListWithoutNulls(certificateDatas);</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1392">      LOG.trace(&quot;&lt;findCertificatesByUsername(), username=&quot; + username);</span>
    }
<span class="nc" id="L1394">    return EJBTools.wrapCertCollection(ret);</span>
  }

  @Override
  public Collection&lt;Certificate&gt; findCertificatesByUsernameAndStatus(
      final String username, final int status) {
<span class="nc bnc" id="L1400" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1401">      LOG.trace(</span>
          &quot;&gt;findCertificatesByUsernameAndStatus(),  username=&quot; + username);
    }
    // This method on the entity bean does the ordering in the database
<span class="nc" id="L1405">    final List&lt;CertificateData&gt; certificateDatas =</span>
<span class="nc" id="L1406">        certificateDataSession.findByUsernameAndStatus(username, status);</span>
<span class="nc" id="L1407">    final List&lt;Certificate&gt; ret =</span>
<span class="nc" id="L1408">        getAsCertificateListWithoutNulls(certificateDatas);</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1410">      LOG.trace(&quot;&lt;findCertificatesByUsernameAndStatus(), username=&quot; + username);</span>
    }
<span class="nc" id="L1412">    return ret;</span>
  }

  @Override
  public Collection&lt;Certificate&gt;
      findCertificatesByUsernameAndStatusAfterExpireDate(
          final String username, final int status, final long afterExpireDate) {
<span class="nc bnc" id="L1419" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1420">      LOG.trace(</span>
          &quot;&gt;findCertificatesByUsernameAndStatusAfterExpireDate(),  username=&quot;
              + username);
    }
    // This method on the data bean does the ordering in the database
<span class="nc" id="L1425">    final List&lt;CertificateData&gt; certificateDatas =</span>
<span class="nc" id="L1426">        certificateDataSession.findByUsernameAndStatusAfterExpireDate(</span>
            username, status, afterExpireDate);
<span class="nc" id="L1428">    final List&lt;Certificate&gt; ret =</span>
<span class="nc" id="L1429">        getAsCertificateListWithoutNulls(certificateDatas);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1431">      LOG.trace(</span>
          &quot;&lt;findCertificatesByUsernameAndStatusAfterExpireDate(), username=&quot;
              + username);
    }
<span class="nc" id="L1435">    return ret;</span>
  }

  /**
   * Fetch the actual certificate is stored in a separate table and filter out
   * entries where we don't store base64CertData at all.
   *
   * @param certificateDatas Data
   * @return Certs
   */
  private List&lt;Certificate&gt; getAsCertificateListWithoutNulls(
      final List&lt;CertificateData&gt; certificateDatas) {
<span class="nc" id="L1447">    final ArrayList&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">    for (final CertificateData certificateData : certificateDatas) {</span>
<span class="nc" id="L1449">      final Certificate certificate =</span>
<span class="nc" id="L1450">          certificateData.getCertificate(this.entityManager);</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">      if (certificate != null) {</span>
<span class="nc" id="L1452">        ret.add(certificate);</span>
      }
<span class="nc" id="L1454">    }</span>
<span class="nc" id="L1455">    return ret;</span>
  }

  @Override
  public CertificateInfo getCertificateInfo(final String fingerprint) {
<span class="nc bnc" id="L1460" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1461">      LOG.trace(&quot;&gt;getCertificateInfo(): &quot; + fingerprint);</span>
    }
<span class="nc bnc" id="L1463" title="All 2 branches missed.">    if (fingerprint == null) {</span>
<span class="nc" id="L1464">      return null;</span>
    }
<span class="nc" id="L1466">    return certificateDataSession.getCertificateInfo(fingerprint);</span>
  }

  @Override
  public Certificate findCertificateByFingerprint(final String fingerprint) {
<span class="nc bnc" id="L1471" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1472">      LOG.trace(&quot;&gt;findCertificateByFingerprint()&quot;);</span>
    }
<span class="nc" id="L1474">    Certificate ret = null;</span>
    try {
<span class="nc" id="L1476">      CertificateData res =</span>
<span class="nc" id="L1477">          certificateDataSession.findByFingerprint(fingerprint);</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">      if (res != null) {</span>
<span class="nc" id="L1479">        ret = res.getCertificate(this.entityManager);</span>
      }
<span class="nc" id="L1481">    } catch (Exception e) {</span>
<span class="nc" id="L1482">      LOG.error(&quot;Error finding certificate with fp: &quot; + fingerprint);</span>
<span class="nc" id="L1483">      throw new EJBException(e);</span>
<span class="nc" id="L1484">    }</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1486">      LOG.trace(&quot;&lt;findCertificateByFingerprint()&quot;);</span>
    }
<span class="nc" id="L1488">    return ret;</span>
  }

  @Override
  public CertificateWrapper findCertificateByFingerprintRemote(
      final String fingerprint) {
<span class="nc bnc" id="L1494" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1495">      LOG.trace(&quot;&gt;findCertificateByFingerprintRemote()&quot;);</span>
    }
<span class="nc" id="L1497">    final CertificateWrapper ret =</span>
<span class="nc" id="L1498">        EJBTools.wrap(findCertificateByFingerprint(fingerprint));</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1500">      LOG.trace(&quot;&lt;findCertificateByFingerprintRemote()&quot;);</span>
    }
<span class="nc" id="L1502">    return ret;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public Collection&lt;Certificate&gt; findCertificatesBySubjectKeyId(
      final byte[] subjectKeyId) {
<span class="nc" id="L1509">    final Query query =</span>
<span class="nc" id="L1510">        entityManager.createQuery(</span>
            &quot;SELECT a FROM CertificateData a WHERE&quot;
                + &quot; a.subjectKeyId=:subjectKeyId&quot;);
<span class="nc" id="L1513">    query.setParameter(</span>
<span class="nc" id="L1514">        &quot;subjectKeyId&quot;, new String(Base64.encode(subjectKeyId, false)));</span>

<span class="nc" id="L1516">    Collection&lt;Certificate&gt; result = new ArrayList&lt;&gt;();</span>
    for (CertificateData certificateData
<span class="nc bnc" id="L1518" title="All 2 branches missed.">        : (Collection&lt;CertificateData&gt;) query.getResultList()) {</span>
<span class="nc" id="L1519">      result.add(certificateData.getCertificate(this.entityManager));</span>
<span class="nc" id="L1520">    }</span>
<span class="nc" id="L1521">    return result;</span>
  }

  @Override
  public Collection&lt;CertificateWrapper&gt; findCertificatesByType(
      final int type, final String issuerDN) throws IllegalArgumentException {
<span class="nc bnc" id="L1527" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1528">      LOG.trace(&quot;&gt;findCertificatesByType()&quot;);</span>
    }
<span class="nc bnc" id="L1530" title="All 4 branches missed.">    if (type &lt;= 0</span>
        || type
            &gt; CertificateConstants.CERTTYPE_SUBCA
                + CertificateConstants.CERTTYPE_ENDENTITY
                + CertificateConstants.CERTTYPE_ROOTCA) {
<span class="nc" id="L1535">      throw new IllegalArgumentException();</span>
    }
<span class="nc" id="L1537">    Collection&lt;Integer&gt; ctypes = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">    if ((type &amp; CertificateConstants.CERTTYPE_SUBCA) &gt; 0) {</span>
<span class="nc" id="L1539">      ctypes.add(CertificateConstants.CERTTYPE_SUBCA);</span>
    }
<span class="nc bnc" id="L1541" title="All 2 branches missed.">    if ((type &amp; CertificateConstants.CERTTYPE_ENDENTITY) &gt; 0) {</span>
<span class="nc" id="L1542">      ctypes.add(CertificateConstants.CERTTYPE_ENDENTITY);</span>
    }
<span class="nc bnc" id="L1544" title="All 2 branches missed.">    if ((type &amp; CertificateConstants.CERTTYPE_ROOTCA) &gt; 0) {</span>
<span class="nc" id="L1545">      ctypes.add(CertificateConstants.CERTTYPE_ROOTCA);</span>
    }
    List&lt;Certificate&gt; ret;
    // FIXME: These queries can easily make the server run out of memory on a
    // large database
<span class="nc bnc" id="L1550" title="All 4 branches missed.">    if (null != issuerDN &amp;&amp; issuerDN.length() &gt; 0) {</span>
<span class="nc" id="L1551">      ret =</span>
<span class="nc" id="L1552">          certificateDataSession.findActiveCertificatesByTypeAndIssuer(</span>
<span class="nc" id="L1553">              ctypes, CertTools.stringToBCDNString(issuerDN));</span>
    } else {
<span class="nc" id="L1555">      ret = certificateDataSession.findActiveCertificatesByType(ctypes);</span>
    }
<span class="nc bnc" id="L1557" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1558">      LOG.trace(&quot;&lt;findCertificatesByType()&quot;);</span>
    }
<span class="nc" id="L1560">    return EJBTools.wrapCertCollection(ret);</span>
  }

  @Override
  public List&lt;Certificate&gt; getCertificateChain(final CertificateInfo certinfo) {
<span class="nc" id="L1565">    final List&lt;Certificate&gt; chain = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1566">    final Set&lt;String&gt; seenFingerprints = new HashSet&lt;&gt;();</span>

<span class="nc" id="L1568">    CertificateInfo certInChain = certinfo;</span>
    do {
<span class="nc" id="L1570">      final String fingerprint = certInChain.getFingerprint();</span>
<span class="nc" id="L1571">      final Certificate thecert = findCertificateByFingerprint(fingerprint);</span>
<span class="nc bnc" id="L1572" title="All 4 branches missed.">      if (!seenFingerprints.add(fingerprint) || thecert == null) {</span>
<span class="nc" id="L1573">        break; // detected loop or missing cert. should not happen</span>
      }
<span class="nc" id="L1575">      chain.add(thecert);</span>
      // roots are self-signed
<span class="nc bnc" id="L1577" title="All 2 branches missed.">      if (certInChain.getCAFingerprint().equals(fingerprint)) {</span>
<span class="nc" id="L1578">        break;</span>
      }
      // proceed with issuer
<span class="nc" id="L1581">      certInChain = getCertificateInfo(certInChain.getCAFingerprint());</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">    } while (certInChain != null); // should not happen</span>
<span class="nc" id="L1583">    return chain;</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public boolean setRevokeStatus(
      final AuthenticationToken admin,
      final CertificateDataWrapper cdw,
      final Date revokedDate,
      final int reason)
      throws CertificateRevokeException, AuthorizationDeniedException {
<span class="nc bnc" id="L1594" title="All 2 branches missed.">    if (cdw == null) {</span>
<span class="nc" id="L1595">      throw new IllegalArgumentException(</span>
          &quot;Passed certificate data may not be null.&quot;);
    }
<span class="nc" id="L1598">    final BaseCertificateData certificateData = cdw.getBaseCertificateData();</span>
<span class="nc" id="L1599">    final int caid = certificateData.getIssuerDN().hashCode();</span>
<span class="nc" id="L1600">    authorizedToCA(admin, caid);</span>
<span class="nc" id="L1601">    return setRevokeStatusNoAuth(admin, certificateData, revokedDate, reason);</span>
  }

  @Override
  public boolean setRevokeStatusNoAuth(
      final AuthenticationToken admin,
      final BaseCertificateData certificateData,
      final Date revokeDate,
      final int reason)
      throws CertificateRevokeException {
<span class="nc" id="L1611">    String serialNumber = &quot;unknown&quot;;</span>
    try {
      // This will work for X.509
<span class="nc" id="L1614">      serialNumber =</span>
<span class="nc" id="L1615">          new BigInteger(certificateData.getSerialNumber(), 10)</span>
<span class="nc" id="L1616">              .toString(16)</span>
<span class="nc" id="L1617">              .toUpperCase();</span>
<span class="nc" id="L1618">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L1619">      serialNumber = certificateData.getSerialNumber();</span>
<span class="nc" id="L1620">    }</span>
<span class="nc" id="L1621">    final String issuerDn = certificateData.getIssuerDN();</span>
<span class="nc" id="L1622">    final int caid = issuerDn.hashCode();</span>
<span class="nc" id="L1623">    final String username = certificateData.getUsername();</span>
<span class="nc" id="L1624">    final Date now = new Date();</span>

<span class="nc" id="L1626">    boolean returnVal = false;</span>
    // A normal revocation
<span class="nc bnc" id="L1628" title="All 2 branches missed.">    if ((certificateData.getStatus() != CertificateConstants.CERT_REVOKED</span>
<span class="nc bnc" id="L1629" title="All 6 branches missed.">            || certificateData.getRevocationReason()</span>
                == RevokedCertInfo.REVOCATION_REASON_CERTIFICATEHOLD)
        &amp;&amp; reason != RevokedCertInfo.NOT_REVOKED
        &amp;&amp; reason != RevokedCertInfo.REVOCATION_REASON_REMOVEFROMCRL) {
<span class="nc bnc" id="L1633" title="All 2 branches missed.">      if (certificateData.getStatus() != CertificateConstants.CERT_REVOKED) {</span>
<span class="nc" id="L1634">        certificateData.setStatus(CertificateConstants.CERT_REVOKED);</span>
<span class="nc" id="L1635">        certificateData.setRevocationDate(</span>
            revokeDate); // keep date if certificate on hold.
      }
<span class="nc" id="L1638">      certificateData.setUpdateTime(now.getTime());</span>
<span class="nc" id="L1639">      certificateData.setRevocationReason(reason);</span>

<span class="nc" id="L1641">      final String msg =</span>
<span class="nc" id="L1642">          INTRES.getLocalizedMessage(</span>
              &quot;store.revokedcert&quot;,
              username,
<span class="nc" id="L1645">              certificateData.getFingerprint(),</span>
<span class="nc" id="L1646">              Integer.valueOf(reason),</span>
<span class="nc" id="L1647">              certificateData.getSubjectDnNeverNull(),</span>
<span class="nc" id="L1648">              certificateData.getIssuerDN(),</span>
              serialNumber);
<span class="nc" id="L1650">      Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L1651">      details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L1652">      logSession.log(</span>
          EventTypes.CERT_REVOKED,
          EventStatus.SUCCESS,
          ModuleTypes.CERTIFICATE,
          ServiceTypes.CORE,
<span class="nc" id="L1657">          admin.toString(),</span>
<span class="nc" id="L1658">          String.valueOf(caid),</span>
          serialNumber,
          username,
          details);
<span class="nc" id="L1662">      returnVal = true; // we did change status</span>
<span class="nc bnc" id="L1663" title="All 4 branches missed.">    } else if (((reason == RevokedCertInfo.NOT_REVOKED)</span>
            || (reason == RevokedCertInfo.REVOCATION_REASON_REMOVEFROMCRL))
<span class="nc bnc" id="L1665" title="All 2 branches missed.">        &amp;&amp; (certificateData.getRevocationReason()</span>
            == RevokedCertInfo.REVOCATION_REASON_CERTIFICATEHOLD)) {
      // Unrevoke, can only be done when the certificate was previously revoked
      // with reason CertificateHold
      // Only allow unrevocation if the certificate is revoked and the
      // revocation reason is CERTIFICATE_HOLD
<span class="nc" id="L1671">      int status = CertificateConstants.CERT_ACTIVE;</span>
<span class="nc" id="L1672">      certificateData.setStatus(status);</span>
<span class="nc" id="L1673">      certificateData.setRevocationDate(revokeDate);</span>
<span class="nc" id="L1674">      certificateData.setUpdateTime(now.getTime());</span>
<span class="nc" id="L1675">      certificateData.setRevocationReason(RevokedCertInfo.NOT_REVOKED);</span>

<span class="nc" id="L1677">      final String msg =</span>
<span class="nc" id="L1678">          INTRES.getLocalizedMessage(</span>
              &quot;store.unrevokedcert&quot;,
              username,
<span class="nc" id="L1681">              certificateData.getFingerprint(),</span>
<span class="nc" id="L1682">              Integer.valueOf(reason),</span>
<span class="nc" id="L1683">              certificateData.getSubjectDnNeverNull(),</span>
<span class="nc" id="L1684">              certificateData.getIssuerDN(),</span>
              serialNumber);
<span class="nc" id="L1686">      Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L1687">      details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L1688">      logSession.log(</span>
          EventTypes.CERT_REVOKED,
          EventStatus.SUCCESS,
          ModuleTypes.CERTIFICATE,
          ServiceTypes.CORE,
<span class="nc" id="L1693">          admin.toString(),</span>
<span class="nc" id="L1694">          String.valueOf(caid),</span>
          serialNumber,
          username,
          details);
<span class="nc" id="L1698">      returnVal = true; // we did change status</span>
<span class="nc" id="L1699">    } else {</span>
<span class="nc" id="L1700">      final String msg =</span>
<span class="nc" id="L1701">          INTRES.getLocalizedMessage(</span>
              &quot;store.ignorerevoke&quot;,
              serialNumber,
<span class="nc" id="L1704">              Integer.valueOf(certificateData.getStatus()),</span>
<span class="nc" id="L1705">              Integer.valueOf(reason));</span>
<span class="nc" id="L1706">      LOG.info(msg);</span>
<span class="nc" id="L1707">      returnVal = false; // we did _not_ change status in the database</span>
    }
<span class="nc bnc" id="L1709" title="All 2 branches missed.">    if (returnVal) {</span>
      // Persist changes
<span class="nc bnc" id="L1711" title="All 2 branches missed.">      if (certificateData instanceof NoConflictCertificateData) {</span>
<span class="nc" id="L1712">        entityManager.persist(certificateData); // Ensure append-only operation</span>
      } else {
<span class="nc" id="L1714">        entityManager.merge(certificateData);</span>
      }
    }
<span class="nc bnc" id="L1717" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1718">      LOG.trace(</span>
          &quot;&lt;private setRevokeStatusNoAuth(), issuerdn=&quot;
              + issuerDn
              + &quot;, serno=&quot;
              + serialNumber);
    }
<span class="nc" id="L1724">    return returnVal;</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public void revokeAllCertByCA(
      final AuthenticationToken admin, final String issuerdn, final int reason)
      throws AuthorizationDeniedException {
<span class="nc" id="L1732">    int revoked = 0;</span>

    // Must be authorized to CA in order to change status is certificates issued
    // by the CA
<span class="nc" id="L1736">    String bcdn = CertTools.stringToBCDNString(issuerdn);</span>
<span class="nc" id="L1737">    int caid = bcdn.hashCode();</span>
<span class="nc" id="L1738">    authorizedToCA(admin, caid);</span>
    try {
<span class="nc" id="L1740">      final int maxRows = 10000;</span>
<span class="nc" id="L1741">      int firstResult = 0;</span>
      // Revoking all non revoked certificates.

      // Update 10000 records at a time
<span class="nc" id="L1745">      firstResult = 0;</span>
<span class="nc" id="L1746">      List&lt;CertificateData&gt; list =</span>
<span class="nc" id="L1747">          findAllNonRevokedCertificates(bcdn, firstResult, maxRows);</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">      while (list.size() &gt; 0) {</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="nc" id="L1750">          CertificateData d = list.get(i);</span>
<span class="nc" id="L1751">          d.setStatus(CertificateConstants.CERT_REVOKED);</span>
<span class="nc" id="L1752">          d.setRevocationDate(System.currentTimeMillis());</span>
<span class="nc" id="L1753">          d.setRevocationReason(reason);</span>
<span class="nc" id="L1754">          revoked++;</span>
        }
<span class="nc" id="L1756">        firstResult += maxRows;</span>
<span class="nc" id="L1757">        list = findAllNonRevokedCertificates(bcdn, firstResult, maxRows);</span>
      }
<span class="nc" id="L1759">      final String msg =</span>
<span class="nc" id="L1760">          INTRES.getLocalizedMessage(</span>
              &quot;store.revokedallbyca&quot;,
              issuerdn,
<span class="nc" id="L1763">              Integer.valueOf(revoked),</span>
<span class="nc" id="L1764">              Integer.valueOf(reason));</span>
<span class="nc" id="L1765">      Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L1766">      details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L1767">      logSession.log(</span>
          EventTypes.CERT_REVOKED,
          EventStatus.SUCCESS,
          ModuleTypes.CERTIFICATE,
          ServiceTypes.CORE,
<span class="nc" id="L1772">          admin.toString(),</span>
<span class="nc" id="L1773">          String.valueOf(caid),</span>
          null,
          null,
          details);
<span class="nc" id="L1777">    } catch (Exception e) {</span>
<span class="nc" id="L1778">      final String msg =</span>
<span class="nc" id="L1779">          INTRES.getLocalizedMessage(&quot;store.errorrevokeallbyca&quot;, issuerdn);</span>
<span class="nc" id="L1780">      LOG.info(msg);</span>
<span class="nc" id="L1781">      throw new EJBException(e);</span>
<span class="nc" id="L1782">    }</span>
<span class="nc" id="L1783">  }</span>

  /**
   * @param issuerDN DN
   * @return the certificates that have CertificateConstants.CERT_REVOKED.
   * @param firstResult pagination variable, 0 for the first call, insrease by
   *     maxRows for further calls if return value is == maxRows
   * @param maxRows pagination variable max number of rows that should be
   *     returned, used in order to make it somewhat efficient on large data
   *     volumes
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;CertificateData&gt; findAllNonRevokedCertificates(
      final String issuerDN, final int firstResult, final int maxRows) {
<span class="nc" id="L1797">    final Query query =</span>
<span class="nc" id="L1798">        entityManager.createQuery(</span>
            &quot;SELECT a FROM CertificateData a WHERE a.issuerDN=:issuerDN AND&quot;
                + &quot; a.status &lt;&gt; :status&quot;);
<span class="nc" id="L1801">    query.setParameter(&quot;issuerDN&quot;, issuerDN);</span>
<span class="nc" id="L1802">    query.setParameter(&quot;status&quot;, CertificateConstants.CERT_REVOKED);</span>
<span class="nc" id="L1803">    query.setFirstResult(firstResult);</span>
<span class="nc" id="L1804">    query.setMaxResults(maxRows);</span>
<span class="nc" id="L1805">    return query.getResultList();</span>
  }

  @Override
  public boolean isRevoked(final String issuerDN, final BigInteger serno) {
<span class="nc bnc" id="L1810" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1811">      LOG.trace(</span>
<span class="nc" id="L1812">          &quot;&gt;isRevoked(), dn:&quot; + issuerDN + &quot;, serno=&quot; + serno.toString(16));</span>
    }
    // First make a DN in our well-known format
<span class="nc" id="L1815">    String dn = CertTools.stringToBCDNString(issuerDN);</span>
<span class="nc" id="L1816">    boolean ret = false;</span>
    try {
<span class="nc" id="L1818">      Collection&lt;CertificateData&gt; coll =</span>
<span class="nc" id="L1819">          certificateDataSession.findByIssuerDNSerialNumber(</span>
<span class="nc" id="L1820">              dn, serno.toString());</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">      if (coll.size() &gt; 0) {</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (coll.size() &gt; 1) {</span>
<span class="nc" id="L1823">          final String msg =</span>
<span class="nc" id="L1824">              INTRES.getLocalizedMessage(</span>
                  &quot;store.errorseveralissuerserno&quot;,
                  issuerDN,
<span class="nc" id="L1827">                  serno.toString(16));</span>
<span class="nc" id="L1828">          LOG.error(msg);</span>
        }
<span class="nc" id="L1830">        Iterator&lt;CertificateData&gt; iter = coll.iterator();</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1832">          CertificateData data = iter.next();</span>
          // if any of the certificates with this serno is revoked, return true
<span class="nc bnc" id="L1834" title="All 2 branches missed.">          if (data.getStatus() == CertificateConstants.CERT_REVOKED) {</span>
<span class="nc" id="L1835">            ret = true;</span>
<span class="nc" id="L1836">            break;</span>
          }
<span class="nc" id="L1838">        }</span>
<span class="nc" id="L1839">      } else {</span>
        // If there are no certificates with this serial number, return true
        // (=revoked). Better safe than sorry!
<span class="nc" id="L1842">        ret = true;</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1844">          LOG.trace(</span>
              &quot;isRevoked() did not find certificate with dn &quot;
                  + dn
                  + &quot; and serno &quot;
<span class="nc" id="L1848">                  + serno.toString(16));</span>
        }
      }
<span class="nc" id="L1851">    } catch (Exception e) {</span>
<span class="nc" id="L1852">      throw new EJBException(e);</span>
<span class="nc" id="L1853">    }</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1855">      LOG.trace(&quot;&lt;isRevoked() returned &quot; + ret);</span>
    }
<span class="nc" id="L1857">    return ret;</span>
  }

  @Override
  public CertificateStatus getStatus(
      final String issuerDN, final BigInteger serno) {
<span class="nc bnc" id="L1863" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1864">      LOG.trace(</span>
<span class="nc" id="L1865">          &quot;&gt;getStatus(), dn:&quot; + issuerDN + &quot;, serno=&quot; + serno.toString(16));</span>
    }
    // First make a DN in our well-known format
<span class="nc" id="L1868">    final String dn = CertTools.stringToBCDNString(issuerDN);</span>

    try {
<span class="nc" id="L1871">      Collection&lt;CertificateData&gt; coll =</span>
<span class="nc" id="L1872">          certificateDataSession.findByIssuerDNSerialNumber(</span>
<span class="nc" id="L1873">              dn, serno.toString());</span>

<span class="nc bnc" id="L1875" title="All 2 branches missed.">      if (coll.size() &gt; 1) {</span>
<span class="nc" id="L1876">        final String msg =</span>
<span class="nc" id="L1877">            INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1878">                &quot;store.errorseveralissuerserno&quot;, issuerDN, serno.toString(16));</span>
<span class="nc" id="L1879">        LOG.error(msg);</span>
      }

<span class="nc bnc" id="L1882" title="All 2 branches missed.">      for (CertificateData data : coll) {</span>
<span class="nc" id="L1883">        final CertificateStatus result =</span>
<span class="nc" id="L1884">            CertificateStatusHelper.getCertificateStatus(data);</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1886">          LOG.trace(</span>
              &quot;&lt;getStatus() returned &quot;
                  + result
                  + &quot; for cert number &quot;
<span class="nc" id="L1890">                  + serno.toString(16));</span>
        }
<span class="nc" id="L1892">        return result;</span>
      }
<span class="nc bnc" id="L1894" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1895">        LOG.trace(</span>
            &quot;&lt;getStatus() did not find certificate with dn &quot;
                + dn
                + &quot; and serno &quot;
<span class="nc" id="L1899">                + serno.toString(16));</span>
      }
<span class="nc" id="L1901">    } catch (Exception e) {</span>
<span class="nc" id="L1902">      throw new EJBException(e);</span>
<span class="nc" id="L1903">    }</span>
<span class="nc" id="L1904">    return CertificateStatus.NOT_AVAILABLE;</span>
  }

  @Override
  public CertificateStatusHolder getCertificateAndStatus(
      final String issuerDN, final BigInteger serno) {
<span class="nc bnc" id="L1910" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1911">      LOG.trace(</span>
          &quot;&gt;getCertificateAndStatus(), dn:&quot;
              + issuerDN
              + &quot;, serno=&quot;
<span class="nc" id="L1915">              + serno.toString(16));</span>
    }
    // First make a DN in our well-known format
<span class="nc" id="L1918">    final String dn = CertTools.stringToBCDNString(issuerDN);</span>
<span class="nc" id="L1919">    Collection&lt;CertificateData&gt; collection =</span>
<span class="nc" id="L1920">        certificateDataSession.findByIssuerDNSerialNumber(dn, serno.toString());</span>
<span class="nc bnc" id="L1921" title="All 2 branches missed.">    if (collection.size() &gt; 1) {</span>
<span class="nc" id="L1922">      final String msg =</span>
<span class="nc" id="L1923">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1924">              &quot;store.errorseveralissuerserno&quot;, issuerDN, serno.toString(16));</span>
<span class="nc" id="L1925">      LOG.error(msg);</span>
    }
<span class="nc bnc" id="L1927" title="All 2 branches missed.">    for (CertificateData data : collection) {</span>
<span class="nc" id="L1928">      final CertificateStatus result =</span>
<span class="nc" id="L1929">          CertificateStatusHelper.getCertificateStatus(data);</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1931">        LOG.trace(</span>
            &quot;&lt;getStatus() returned &quot;
                + result
                + &quot; for cert number &quot;
<span class="nc" id="L1935">                + serno.toString(16));</span>
      }
<span class="nc" id="L1937">      return new CertificateStatusHolder(</span>
<span class="nc" id="L1938">          data.getCertificate(entityManager), result);</span>
    }
<span class="nc bnc" id="L1940" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1941">      LOG.trace(</span>
          &quot;&lt;getCertificateAndStatus() did not find certificate with dn &quot;
              + dn
              + &quot; and serno &quot;
<span class="nc" id="L1945">              + serno.toString(16));</span>
    }
<span class="nc" id="L1947">    return new CertificateStatusHolder(null, CertificateStatus.NOT_AVAILABLE);</span>
  }

  @Override
  public List&lt;Object[]&gt; findExpirationInfo(
      final Collection&lt;String&gt; cas,
      final Collection&lt;Integer&gt; certificateProfiles,
      final long activeNotifiedExpireDateMin,
      final long activeNotifiedExpireDateMax,
      final long activeExpireDateMin) {
<span class="nc" id="L1957">    return certificateDataSession.findExpirationInfo(</span>
        cas,
        certificateProfiles,
        activeNotifiedExpireDateMin,
        activeNotifiedExpireDateMax,
        activeExpireDateMin);
  }

  private void changeStatus(
      final AuthenticationToken admin,
      final CertificateData certificateData,
      final int status)
      throws AuthorizationDeniedException {
<span class="nc bnc" id="L1970" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1971">      LOG.debug(</span>
          &quot;Set status &quot;
              + status
              + &quot; for certificate with fp: &quot;
<span class="nc" id="L1975">              + certificateData.getFingerprint());</span>
    }

    // Must be authorized to CA in order to change status is certificates issued
    // by the CA
<span class="nc" id="L1980">    String bcdn = CertTools.stringToBCDNString(certificateData.getIssuerDN());</span>
<span class="nc" id="L1981">    int caid = bcdn.hashCode();</span>
<span class="nc" id="L1982">    authorizedToCA(admin, caid);</span>

<span class="nc" id="L1984">    certificateData.setStatus(status);</span>
<span class="nc" id="L1985">    final Certificate certificate =</span>
<span class="nc" id="L1986">        certificateData.getCertificate(this.entityManager);</span>
    String serialNo;
<span class="nc bnc" id="L1988" title="All 2 branches missed.">    if (certificate == null) {</span>
<span class="nc" id="L1989">      serialNo = certificateData.getSerialNumberHex();</span>
    } else {
<span class="nc" id="L1991">      serialNo = CertTools.getSerialNumberAsString(certificate);</span>
    }
<span class="nc" id="L1993">    final String msg =</span>
<span class="nc" id="L1994">        INTRES.getLocalizedMessage(</span>
            &quot;store.setstatus&quot;,
<span class="nc" id="L1996">            certificateData.getUsername(),</span>
<span class="nc" id="L1997">            certificateData.getFingerprint(),</span>
<span class="nc" id="L1998">            status,</span>
<span class="nc" id="L1999">            certificateData.getSubjectDnNeverNull(),</span>
<span class="nc" id="L2000">            certificateData.getIssuerDN(),</span>
            serialNo);
<span class="nc" id="L2002">    Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L2003">    details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L2004">    logSession.log(</span>
        EventTypes.CERT_CHANGEDSTATUS,
        EventStatus.SUCCESS,
        ModuleTypes.CERTIFICATE,
        ServiceTypes.CORE,
<span class="nc" id="L2009">        admin.toString(),</span>
<span class="nc" id="L2010">        String.valueOf(caid),</span>
        serialNo,
<span class="nc" id="L2012">        certificateData.getUsername(),</span>
        details);
<span class="nc" id="L2014">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public boolean setStatus(
      final AuthenticationToken admin,
      final String fingerprint,
      final int status)
      throws IllegalArgumentException, AuthorizationDeniedException {

<span class="nc bnc" id="L2024" title="All 4 branches missed.">    if (status == CertificateConstants.CERT_REVOKED</span>
        || status == CertificateConstants.CERT_ACTIVE) {
<span class="nc" id="L2026">      final String msg =</span>
<span class="nc" id="L2027">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L2028">              &quot;store.errorsetstatusargument&quot;, fingerprint, status);</span>
<span class="nc" id="L2029">      throw new IllegalArgumentException(msg);</span>
    }
<span class="nc" id="L2031">    CertificateData certificateData =</span>
<span class="nc" id="L2032">        certificateDataSession.findByFingerprint(fingerprint);</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">    if (certificateData != null) {</span>
<span class="nc" id="L2034">      changeStatus(admin, certificateData, status);</span>
    } else {
<span class="nc bnc" id="L2036" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2037">        final String msg =</span>
<span class="nc" id="L2038">            INTRES.getLocalizedMessage(</span>
<span class="nc" id="L2039">                &quot;store.setstatusfailed&quot;, fingerprint, status);</span>
<span class="nc" id="L2040">        LOG.debug(msg);</span>
      }
    }
<span class="nc bnc" id="L2043" title="All 2 branches missed.">    return (certificateData != null);</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public void setRolloverDoneStatus(
      final AuthenticationToken admin, final String fingerprint)
      throws IllegalArgumentException, AuthorizationDeniedException {

<span class="nc" id="L2052">    CertificateData certificateData =</span>
<span class="nc" id="L2053">        certificateDataSession.findByFingerprint(fingerprint);</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">    if (certificateData == null) {</span>
<span class="nc" id="L2055">      throw new IllegalStateException(</span>
          &quot;CA certificate with fingerprint '&quot;
              + fingerprint
              + &quot;' does not exist.&quot;);
    }

<span class="nc" id="L2061">    final int prevStatus = certificateData.getStatus();</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">    if (prevStatus == CertificateConstants.CERT_ACTIVE) {</span>
<span class="nc" id="L2063">      return; // Nothing to do</span>
    }

<span class="nc bnc" id="L2066" title="All 2 branches missed.">    if (prevStatus != CertificateConstants.CERT_ROLLOVERPENDING) {</span>
<span class="nc" id="L2067">      throw new IllegalStateException(</span>
          &quot;Certificate was not in the CERT_ROLLOVERPENDING state&quot;);
    }
<span class="nc" id="L2070">    changeStatus(admin, certificateData, CertificateConstants.CERT_ACTIVE);</span>
<span class="nc" id="L2071">  }</span>

  private void authorizedToCA(final AuthenticationToken admin, final int caid)
      throws AuthorizationDeniedException {
<span class="nc bnc" id="L2075" title="All 2 branches missed.">    if (!authorizationSession.isAuthorized(</span>
<span class="nc" id="L2076">        admin, StandardRules.CAACCESS.resource() + caid)) {</span>
<span class="nc" id="L2077">      final String msg =</span>
<span class="nc" id="L2078">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L2079">              &quot;caadmin.notauthorizedtoca&quot;, admin.toString(), caid);</span>
<span class="nc" id="L2080">      throw new AuthorizationDeniedException(msg);</span>
    }
<span class="nc" id="L2082">  }</span>

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public Certificate findMostRecentlyUpdatedActiveCertificate(
      final byte[] subjectKeyId) {
<span class="nc" id="L2088">    Certificate certificate = null;</span>
<span class="nc" id="L2089">    final String subjectKeyIdString =</span>
<span class="nc" id="L2090">        new String(Base64.encode(subjectKeyId, false));</span>
<span class="nc" id="L2091">    LOG.debug(&quot;Searching for subjectKeyIdString &quot; + subjectKeyIdString);</span>
<span class="nc" id="L2092">    final Query query =</span>
<span class="nc" id="L2093">        this.entityManager.createQuery(</span>
            &quot;SELECT a FROM CertificateData a WHERE&quot;
                + &quot; a.subjectKeyId=:subjectKeyId AND a.status=:status ORDER BY&quot;
                + &quot; a.updateTime DESC&quot;);
<span class="nc" id="L2097">    query.setParameter(&quot;subjectKeyId&quot;, subjectKeyIdString);</span>
<span class="nc" id="L2098">    query.setParameter(&quot;status&quot;, CertificateConstants.CERT_ACTIVE);</span>
<span class="nc" id="L2099">    query.setMaxResults(1);</span>
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2101">    final List&lt;CertificateData&gt; resultList = query.getResultList();</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">    if (resultList.size() == 1) {</span>
<span class="nc" id="L2103">      certificate = resultList.get(0).getCertificate(this.entityManager);</span>
<span class="nc bnc" id="L2104" title="All 4 branches missed.">      if (certificate == null &amp;&amp; LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2105">        LOG.debug(</span>
            &quot;Reference to an issued certificate with subjectKeyId &quot;
                + subjectKeyId
                + &quot; found, but the certificate is not stored in the database.&quot;);
      }
    }
<span class="nc" id="L2111">    return certificate;</span>
  }

  @Override
  public String getCADnFromRequest(final RequestMessage req) {
<span class="nc" id="L2116">    String dn = req.getIssuerDN();</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2118">      LOG.debug(&quot;Got an issuerDN: &quot; + dn);</span>
    }
    // If we have issuer and serialNo, we must find the CA certificate, to get
    // the CAs subject name
    // If we don't have a serialNumber, we take a chance that it was actually
    // the subjectDN (for example a RootCA)
<span class="nc" id="L2124">    final BigInteger serno = req.getSerialNo();</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">    if (serno != null) {</span>
<span class="nc bnc" id="L2126" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2127">        LOG.debug(&quot;Got a serialNumber: &quot; + serno.toString(16));</span>
      }

<span class="nc" id="L2130">      final Certificate cert = findCertificateByIssuerAndSerno(dn, serno);</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">      if (cert != null) {</span>
<span class="nc" id="L2132">        dn = CertTools.getSubjectDN(cert);</span>
      }
    }
<span class="nc bnc" id="L2135" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2136">      LOG.debug(&quot;Using DN: &quot; + dn);</span>
    }
<span class="nc" id="L2138">    return dn;</span>
  }

  //
  // Classes for checking Unique issuerDN/serialNumber index in the database. If
  // we have such an index, we can allow
  // certificate serial number override, where user specifies the serial number
  // to be put in the certificate.
  //

  @Override
  public void resetUniqueCertificateSerialNumberIndex() {
<span class="nc" id="L2150">    LOG.info(&quot;Resetting isUniqueCertificateSerialNumberIndex to null.&quot;);</span>
<span class="nc" id="L2151">    UniqueSernoHelper.setIsUniqueCertificateSerialNumberIndex(null);</span>
<span class="nc" id="L2152">  }</span>

  @Override
  public void setUniqueCertificateSerialNumberIndex(final Boolean value) {
<span class="nc" id="L2156">    LOG.info(&quot;Setting isUniqueCertificateSerialNumberIndex to: &quot; + value);</span>
<span class="nc" id="L2157">    UniqueSernoHelper.setIsUniqueCertificateSerialNumberIndex(value);</span>
<span class="nc" id="L2158">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  public boolean isUniqueCertificateSerialNumberIndex() {
    // Must always run in a transaction in order to store certificates,
    // EntityManager requires use within a transaction
<span class="nc bnc" id="L2165" title="All 2 branches missed.">    if (UniqueSernoHelper.getIsUniqueCertificateSerialNumberIndex() == null) {</span>
      // Only create new transactions to store certificates and call this, if
      // the variable is not initialized.
      // If it is already set we don't have to waste time creating a new
      // transaction

      // Sets variables (but only once) that can be checked with
      // isUniqueCertificateSerialNumberIndex().
      // This part must be called first (at least once).
<span class="nc" id="L2174">      final String userName =</span>
          &quot;checkUniqueIndexTestUserNotToBeUsed_fjasdfjsdjfsad&quot;; // This name
                                                                // should only
                                                                // be used for
                                                                // this test.
                                                                // Made complex
                                                                // so that no
                                                                // one else will
                                                                // use the same.
      // Loading two dummy certificates. These certificates has same serial
      // number and issuer.
      // It should not be possible to store both of them in the DB.
<span class="nc" id="L2186">      final X509Certificate cert1 = UniqueSernoHelper.getTestCertificate1();</span>
<span class="nc" id="L2187">      final X509Certificate cert2 = UniqueSernoHelper.getTestCertificate2();</span>
<span class="nc" id="L2188">      final Certificate c1 =</span>
<span class="nc" id="L2189">          findCertificateByFingerprint(CertTools.getFingerprintAsString(cert1));</span>
<span class="nc" id="L2190">      final Certificate c2 =</span>
<span class="nc" id="L2191">          findCertificateByFingerprint(CertTools.getFingerprintAsString(cert2));</span>
<span class="nc bnc" id="L2192" title="All 4 branches missed.">      if ((c1 != null) &amp;&amp; (c2 != null)) {</span>
        // already proved that not checking index for serial number.
<span class="nc" id="L2194">        UniqueSernoHelper.setIsUniqueCertificateSerialNumberIndex(</span>
            Boolean.FALSE);
      }
<span class="nc" id="L2197">      final AuthenticationToken admin =</span>
          new AlwaysAllowLocalAuthenticationToken(
              new UsernamePrincipal(&quot;Internal database constraint test&quot;));
<span class="nc bnc" id="L2200" title="All 2 branches missed.">      if (c1</span>
          == null) { // storing initial certificate if no test certificate
                     // created.
        try {
          // needs to call using &quot;certificateStoreSession.&quot; in order to honor
          // the transaction annotations
<span class="nc" id="L2206">          certificateStoreSession</span>
<span class="nc" id="L2207">              .checkForUniqueCertificateSerialNumberIndexInTransaction(</span>
                  admin,
                  cert1,
                  userName,
                  &quot;abcdef0123456789&quot;,
                  CertificateConstants.CERT_INACTIVE,
                  0,
                  CertificateProfileConstants.NO_CERTIFICATE_PROFILE,
                  EndEntityConstants.NO_END_ENTITY_PROFILE,
                  &quot;&quot;,
<span class="nc" id="L2217">                  new Date().getTime());</span>
<span class="nc" id="L2218">        } catch (</span>
            Throwable e) { // NOPMD, we really need to catch all, never crash
<span class="nc" id="L2220">          throw new RuntimeException(</span>
              &quot;It should always be possible to store initial dummy&quot;
                  + &quot; certificate.&quot;,
              e);
<span class="nc" id="L2224">        }</span>
      }
<span class="nc" id="L2226">      UniqueSernoHelper.setIsUniqueCertificateSerialNumberIndex(Boolean.FALSE);</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">      if (c2 == null) { // storing a second certificate with same issuer</span>
        try {
          // needs to call using &quot;certificateStoreSession.&quot; in order to honor
          // the transaction annotations
<span class="nc" id="L2231">          certificateStoreSession</span>
<span class="nc" id="L2232">              .checkForUniqueCertificateSerialNumberIndexInTransaction(</span>
                  admin,
                  cert2,
                  userName,
                  &quot;fedcba9876543210&quot;,
                  CertificateConstants.CERT_INACTIVE,
                  0,
                  CertificateProfileConstants.NO_CERTIFICATE_PROFILE,
                  EndEntityConstants.NO_END_ENTITY_PROFILE,
                  &quot;&quot;,
<span class="nc" id="L2242">                  new Date().getTime());</span>
<span class="nc" id="L2243">        } catch (</span>
            Throwable e) { // NOPMD, we really need to catch all, never crash
<span class="nc" id="L2245">          LOG.info(</span>
              &quot;certificateStoreSession.&quot;
              + &quot;checkForUniqueCertificateSerialNumberIndexInTransaction&quot;
                  + &quot; threw Throwable (normal if there is a unique&quot;
                  + &quot; issuerDN/serialNumber index): &quot;
<span class="nc" id="L2250">                  + e.getMessage());</span>
<span class="nc" id="L2251">          LOG.info(</span>
              &quot;Unique index in CertificateData table for certificate serial&quot;
                  + &quot; number&quot;);
          // Exception is thrown when unique index is working and a certificate
          // with same serial number is in the database.
<span class="nc" id="L2256">          UniqueSernoHelper.setIsUniqueCertificateSerialNumberIndex(</span>
              Boolean.TRUE);
<span class="nc" id="L2258">        }</span>
      }
<span class="nc" id="L2260">      if (!UniqueSernoHelper.getIsUniqueCertificateSerialNumberIndex()</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">          .booleanValue()) {</span>
        // It was possible to store a second certificate with same serial
        // number. Unique number not working.
<span class="nc" id="L2264">        LOG.info(</span>
<span class="nc" id="L2265">            INTRES.getLocalizedMessage(</span>
                &quot;createcert.not_unique_certserialnumberindex&quot;));
      }
      // Remove potentially stored certificates so anyone can create the unique
      // index if wanted
      try {
<span class="nc" id="L2271">        certificateStoreSession</span>
<span class="nc" id="L2272">            .removeUniqueCertificateSerialNumberTestCertificates();</span>
<span class="nc" id="L2273">        LOG.info(</span>
            &quot;Removed rows used during test for unique certificate serial&quot;
                + &quot; number database constraint.&quot;);
<span class="nc" id="L2276">      } catch (Throwable e) { // NOPMD, we really need to catch all, never crash</span>
<span class="nc" id="L2277">        LOG.debug(</span>
            &quot;Unable to clean up database rows used during test for unique&quot;
                + &quot; certificate serial number. This is expected if DELETE is&quot;
                + &quot; not granted to the EJBCA database user.&quot;,
            e);
<span class="nc" id="L2282">      }</span>
    }
<span class="nc bnc" id="L2284" title="All 2 branches missed.">    return UniqueSernoHelper.getIsUniqueCertificateSerialNumberIndex() != null</span>
<span class="nc" id="L2285">        &amp;&amp; UniqueSernoHelper.getIsUniqueCertificateSerialNumberIndex()</span>
<span class="nc bnc" id="L2286" title="All 2 branches missed.">            .booleanValue();</span>
  }

  // We want each storage of a certificate to run in a new transactions, so we
  // can catch errors as they happen..
  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
  public void checkForUniqueCertificateSerialNumberIndexInTransaction(
      final AuthenticationToken admin,
      final Certificate incert,
      final String username,
      final String cafp,
      final int status,
      final int type,
      final int certificateProfileId,
      final int endEntityProfileId,
      final String tag,
      final long updateTime)
      throws AuthorizationDeniedException {
<span class="nc" id="L2305">    storeCertificateNoAuthInternal(</span>
        admin,
        incert,
        username,
        cafp,
        status,
        type,
        certificateProfileId,
        endEntityProfileId,
        tag,
        updateTime,
        false);
<span class="nc" id="L2317">  }</span>

  // We want deletion of a certificates to run in a new transactions, so we can
  // catch errors as they happen..
  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
  public void removeUniqueCertificateSerialNumberTestCertificates() {
    final X509Certificate x509Certificate1 =
<span class="nc" id="L2325">        UniqueSernoHelper.getTestCertificate1();</span>
    final X509Certificate x509Certificate2 =
<span class="nc" id="L2327">        UniqueSernoHelper.getTestCertificate2();</span>
<span class="nc" id="L2328">    final String fingerprint1 =</span>
<span class="nc" id="L2329">        CertTools.getFingerprintAsString(x509Certificate1);</span>
<span class="nc" id="L2330">    final String fingerprint2 =</span>
<span class="nc" id="L2331">        CertTools.getFingerprintAsString(x509Certificate2);</span>
<span class="nc" id="L2332">    entityManager</span>
<span class="nc" id="L2333">        .createNativeQuery(</span>
            &quot;DELETE FROM Base64CertData WHERE fingerprint IN (?1, ?2)&quot;)
<span class="nc" id="L2335">        .setParameter(1, fingerprint1)</span>
<span class="nc" id="L2336">        .setParameter(2, fingerprint2)</span>
<span class="nc" id="L2337">        .executeUpdate();</span>
<span class="nc" id="L2338">    entityManager</span>
<span class="nc" id="L2339">        .createNativeQuery(</span>
            &quot;DELETE FROM CertificateData WHERE fingerprint IN (?1, ?2)&quot;)
<span class="nc" id="L2341">           .setParameter(1, fingerprint1)</span>
<span class="nc" id="L2342">           .setParameter(2, fingerprint2)</span>
<span class="nc" id="L2343">        .executeUpdate();</span>
<span class="nc" id="L2344">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public void updateLimitedCertificateDataStatus(
      final AuthenticationToken admin,
      final int caId,
      final String issuerDn,
      final BigInteger serialNumber,
      final Date revocationDate,
      final int reasonCode,
      final String caFingerprint)
      throws AuthorizationDeniedException {
    // The idea is to set SubjectDN to an empty string. However, since Oracle
    // treats an empty String as NULL,
    // and since CertificateData.SubjectDN has a constraint that it should not
    // be NULL, we are setting it to
    // &quot;CN=limited&quot; instead of an empty string
<span class="nc" id="L2362">    updateLimitedCertificateDataStatus(</span>
        admin,
        caId,
        issuerDn,
        &quot;CN=limited&quot;,
        null,
        serialNumber,
        CertificateConstants.CERT_REVOKED,
        revocationDate,
        reasonCode,
        caFingerprint);
<span class="nc" id="L2373">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public void updateLimitedCertificateDataStatus(
      final AuthenticationToken admin,
      final int caId,
      final String issuerDn,
      final String subjectDn,
      final String username,
      final BigInteger serialNumber,
      final int status,
      final Date revocationDate,
      final int reasonCode,
      final String caFingerprint)
      throws AuthorizationDeniedException {
<span class="nc bnc" id="L2389" title="All 2 branches missed.">    if (!authorizationSession.isAuthorizedNoLogging(</span>
<span class="nc" id="L2390">        admin, StandardRules.CAACCESS.resource() + caId)) {</span>
<span class="nc" id="L2391">      final String msg =</span>
<span class="nc" id="L2392">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L2393">              &quot;caadmin.notauthorizedtoca&quot;, admin.toString(), caId);</span>
<span class="nc" id="L2394">      throw new AuthorizationDeniedException(msg);</span>
    }
<span class="nc" id="L2396">    final String limitedFingerprint =</span>
<span class="nc" id="L2397">        getLimitedCertificateDataFingerprint(issuerDn, serialNumber);</span>
<span class="nc" id="L2398">    final CertificateDataWrapper cdw =</span>
<span class="nc" id="L2399">        getCertificateDataByIssuerAndSerno(issuerDn, serialNumber);</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">    if (cdw == null) {</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">      if (reasonCode == RevokedCertInfo.REVOCATION_REASON_REMOVEFROMCRL) {</span>
<span class="nc" id="L2402">        deleteLimitedCertificateData(limitedFingerprint);</span>
      } else {
        // Create a limited entry
<span class="nc" id="L2405">        final CertificateData limitedCertificateData = new CertificateData();</span>
<span class="nc" id="L2406">        limitedCertificateData.setFingerprint(limitedFingerprint);</span>
<span class="nc" id="L2407">        limitedCertificateData.setSerialNumber(serialNumber.toString());</span>
<span class="nc" id="L2408">        limitedCertificateData.setIssuer(issuerDn);</span>
<span class="nc" id="L2409">        limitedCertificateData.setSubjectDN(subjectDn);</span>
<span class="nc" id="L2410">        limitedCertificateData.setUsername(username);</span>
<span class="nc" id="L2411">        limitedCertificateData.setCertificateProfileId(</span>
<span class="nc" id="L2412">            Integer.valueOf(</span>
                CertificateProfileConstants.CERTPROFILE_NO_PROFILE));
<span class="nc" id="L2414">        limitedCertificateData.setStatus(status);</span>
<span class="nc" id="L2415">        limitedCertificateData.setRevocationReason(reasonCode);</span>
<span class="nc" id="L2416">        limitedCertificateData.setRevocationDate(revocationDate);</span>
<span class="nc" id="L2417">        limitedCertificateData.setUpdateTime(</span>
<span class="nc" id="L2418">            Long.valueOf(System.currentTimeMillis()));</span>
<span class="nc" id="L2419">        limitedCertificateData.setCaFingerprint(caFingerprint);</span>
<span class="nc" id="L2420">        LOG.info(</span>
            &quot;Adding limited CertificateData entry with fingerprint=&quot;
                + limitedFingerprint
                + &quot;, serialNumber=&quot;
<span class="nc" id="L2424">                + serialNumber.toString(16).toUpperCase()</span>
                + &quot;, issuerDn='&quot;
                + issuerDn
                + &quot;'&quot;);
<span class="nc" id="L2428">        entityManager.persist(limitedCertificateData);</span>
<span class="nc" id="L2429">      }</span>
<span class="nc bnc" id="L2430" title="All 2 branches missed.">    } else if (limitedFingerprint.equals(</span>
<span class="nc" id="L2431">        cdw.getCertificateData().getFingerprint())) {</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">      if (reasonCode == RevokedCertInfo.REVOCATION_REASON_REMOVEFROMCRL) {</span>
<span class="nc" id="L2433">        deleteLimitedCertificateData(limitedFingerprint);</span>
      } else {
<span class="nc" id="L2435">        final CertificateData limitedCertificateData = cdw.getCertificateData();</span>
<span class="nc" id="L2436">        if (cdw.getCertificateData().getRevocationDate()</span>
<span class="nc bnc" id="L2437" title="All 2 branches missed.">                != revocationDate.getTime()</span>
<span class="nc bnc" id="L2438" title="All 2 branches missed.">            || cdw.getCertificateData().getRevocationReason() != reasonCode) {</span>
          // Update the limited entry
<span class="nc" id="L2440">          LOG.info(</span>
              &quot;Updating limited CertificateData entry with fingerprint=&quot;
                  + limitedFingerprint
                  + &quot;, serialNumber=&quot;
<span class="nc" id="L2444">                  + serialNumber.toString(16).toUpperCase()</span>
                  + &quot;, issuerDn='&quot;
                  + issuerDn
                  + &quot;'&quot;);
<span class="nc" id="L2448">          limitedCertificateData.setStatus(CertificateConstants.CERT_REVOKED);</span>
<span class="nc" id="L2449">          limitedCertificateData.setRevocationReason(reasonCode);</span>
<span class="nc" id="L2450">          limitedCertificateData.setRevocationDate(revocationDate);</span>
<span class="nc" id="L2451">          limitedCertificateData.setUpdateTime(</span>
<span class="nc" id="L2452">              Long.valueOf(System.currentTimeMillis()));</span>
<span class="nc" id="L2453">          entityManager.merge(limitedCertificateData);</span>
        } else {
<span class="nc bnc" id="L2455" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2456">            LOG.debug(</span>
                &quot;Limited CertificateData entry with fingerprint=&quot;
                    + limitedFingerprint
                    + &quot;, serialNumber=&quot;
<span class="nc" id="L2460">                    + serialNumber.toString(16).toUpperCase()</span>
                    + &quot;, issuerDn='&quot;
                    + issuerDn
                    + &quot;' was already up to date.&quot;);
          }
        }
<span class="nc" id="L2466">      }</span>
    } else {
      // Refuse to update a normal entry with this method
<span class="nc" id="L2469">      throw new UnsupportedOperationException(</span>
          &quot;Only limited certificate entries can be updated using this method.&quot;);
    }
<span class="nc" id="L2472">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  public void reloadCaCertificateCache() {
<span class="nc" id="L2477">    LOG.info(&quot;Reloading CA certificate cache.&quot;);</span>
<span class="nc" id="L2478">    Collection&lt;Certificate&gt; certs =</span>
<span class="nc" id="L2479">        EJBTools.unwrapCertCollection(</span>
<span class="nc" id="L2480">            certificateStoreSession.findCertificatesByType(</span>
                CertificateConstants.CERTTYPE_SUBCA
                    + CertificateConstants.CERTTYPE_ROOTCA,
                null));
<span class="nc" id="L2484">    CaCertificateCache.INSTANCE.loadCertificates(certs);</span>
<span class="nc" id="L2485">    LOG.info(</span>
<span class="nc" id="L2486">        &quot;Reloaded CA certificate cache with &quot; + certs.size() + &quot; certificates&quot;);</span>
<span class="nc" id="L2487">  }</span>

  /**
   * When a timer expires, this method will update
   *
   * &lt;p&gt;According to JSR 220 FR (18.2.2), this method may not throw any
   * exceptions.
   *
   * @param timer The timer whose expiration caused this notification.
   */
  @Timeout
  /* Glassfish 2.1.1:
   * &quot;Timeout method ....timeoutHandler(javax.ejb.Timer)must have TX
   *  attribute of TX_REQUIRES_NEW or TX_REQUIRED or TX_NOT_SUPPORTED&quot;
   * JBoss 5.1.0.GA: We cannot mix timer updates with our EJBCA DataSource
   * transactions.
   */
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void timeoutHandler(final Timer timer) {
<span class="nc bnc" id="L2506" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2507">      LOG.trace(&quot;&gt;timeoutHandler: &quot; + timer.getInfo().toString());</span>
    }
<span class="nc bnc" id="L2509" title="All 2 branches missed.">    if (timer.getInfo() instanceof Integer) {</span>
<span class="nc" id="L2510">      final int currentTimerId = ((Integer) timer.getInfo()).intValue();</span>
<span class="nc bnc" id="L2511" title="All 2 branches missed.">      if (currentTimerId == TIMERID_CACERTIFICATECACHE) {</span>
<span class="nc" id="L2512">        reloadCaCertificateCacheAndSetTimeout();</span>
      }
    }
<span class="nc bnc" id="L2515" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2516">      LOG.trace(&quot;&lt;timeoutHandler&quot;);</span>
    }
<span class="nc" id="L2518">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void reloadCaCertificateCacheAndSetTimeout() {
<span class="nc bnc" id="L2523" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2524">      LOG.trace(&quot;&gt;timeOutReloadCaCertificateCache&quot;);</span>
    }
    // Cancel any waiting timers of this type
<span class="nc" id="L2527">    final Collection&lt;Timer&gt; timers = timerService.getTimers();</span>
<span class="nc bnc" id="L2528" title="All 2 branches missed.">    for (final Timer timer : timers) {</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">      if (timer.getInfo() instanceof Integer) {</span>
<span class="nc" id="L2530">        final int currentTimerId = ((Integer) timer.getInfo()).intValue();</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">        if (currentTimerId == TIMERID_CACERTIFICATECACHE) {</span>
<span class="nc" id="L2532">          timer.cancel();</span>
        }
      }
<span class="nc" id="L2535">    }</span>
    try {
<span class="nc" id="L2537">      certificateStoreSession.reloadCaCertificateCache();</span>
    } finally {
      // Schedule a new timer of this type
      final long interval =
<span class="nc" id="L2541">          OcspConfiguration.getSigningCertsValidTimeInMilliseconds();</span>
<span class="nc bnc" id="L2542" title="All 2 branches missed.">      if (interval &gt; 0) {</span>
<span class="nc" id="L2543">        timerService.createSingleActionTimer(</span>
            interval,
            new TimerConfig(
<span class="nc" id="L2546">                Integer.valueOf(TIMERID_CACERTIFICATECACHE), false));</span>
      }
    }
<span class="nc" id="L2549">  }</span>

  /**
   * @param id ID
   * @return the number of timers where TimerInfo is an Integer and hold the
   *     specified value
   */
  private int getTimerCount(final int id) {
<span class="nc bnc" id="L2557" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2558">      LOG.trace(&quot;&gt;getTimerCount&quot;);</span>
    }
<span class="nc" id="L2560">    int count = 0;</span>
<span class="nc" id="L2561">    final Collection&lt;Timer&gt; timers = timerService.getTimers();</span>
<span class="nc bnc" id="L2562" title="All 2 branches missed.">    for (final Timer timer : timers) {</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">      if (timer.getInfo() instanceof Integer) {</span>
<span class="nc" id="L2564">        final int currentTimerId = ((Integer) timer.getInfo()).intValue();</span>
<span class="nc bnc" id="L2565" title="All 2 branches missed.">        if (currentTimerId == id) {</span>
<span class="nc" id="L2566">          count++;</span>
        }
      }
<span class="nc" id="L2569">    }</span>
<span class="nc bnc" id="L2570" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2571">      LOG.trace(&quot;&lt;getTimerCount, timers: &quot; + count);</span>
    }
<span class="nc" id="L2573">    return count;</span>
  }

  /**
   * @param issuerDn DN
   * @param serialNumber Serial
   * @return something that looks like a normal certificate fingerprint and is
   *     unique for each certificate entry
   */
  private String getLimitedCertificateDataFingerprint(
      final String issuerDn, final BigInteger serialNumber) {
<span class="nc" id="L2584">    return CertTools.getFingerprintAsString(</span>
<span class="nc" id="L2585">        (issuerDn + &quot;;&quot; + serialNumber).getBytes());</span>
  }

  /**
   * Remove limited CertificateData by fingerprint (and ensures that this is not
   * a full entry by making sure that subjectKeyId is NULL.
   *
   * @param fingerprint FP
   * @return success
   */
  private boolean deleteLimitedCertificateData(final String fingerprint) {
<span class="nc" id="L2596">    LOG.info(</span>
        &quot;Removing CertificateData entry with fingerprint=&quot;
            + fingerprint
            + &quot; and no subjectKeyId is defined.&quot;);
<span class="nc" id="L2600">    final Query query =</span>
<span class="nc" id="L2601">        entityManager.createQuery(</span>
            &quot;DELETE FROM CertificateData a WHERE a.fingerprint=:fingerprint&quot;
                + &quot; AND subjectKeyId IS NULL&quot;);
<span class="nc" id="L2604">    query.setParameter(&quot;fingerprint&quot;, fingerprint);</span>
<span class="nc" id="L2605">    final int deletedRows = query.executeUpdate();</span>
<span class="nc bnc" id="L2606" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2607">      LOG.debug(</span>
          &quot;Deleted &quot; + deletedRows + &quot; rows with fingerprint &quot; + fingerprint);
    }
<span class="nc bnc" id="L2610" title="All 2 branches missed.">    return deletedRows == 1;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>