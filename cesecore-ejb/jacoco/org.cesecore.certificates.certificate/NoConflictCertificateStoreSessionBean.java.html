<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NoConflictCertificateStoreSessionBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security EJB Implementation</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.certificate</a> &gt; <span class="el_source">NoConflictCertificateStoreSessionBean.java</span></div><h1>NoConflictCertificateStoreSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.certificate;

import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.apache.commons.collections.CollectionUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.audit.enums.EventStatus;
import org.cesecore.audit.enums.EventTypes;
import org.cesecore.audit.enums.ModuleTypes;
import org.cesecore.audit.enums.ServiceTypes;
import org.cesecore.audit.log.SecurityEventsLoggerSessionLocal;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.authorization.AuthorizationSessionLocal;
import org.cesecore.authorization.control.StandardRules;
import org.cesecore.certificates.ca.CAInfo;
import org.cesecore.certificates.ca.CaSessionLocal;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificateprofile.CertificateProfileSessionLocal;
import org.cesecore.certificates.crl.RevocationReasons;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.util.CertTools;
import org.cesecore.util.StringTools;
import org.cesecore.util.ValidityDate;

/**
 * These methods call CertificateStoreSession for certificates that are plain
 * CertificateData entities. See {@link CertificateStoreSession} for method
 * descriptions.
 *
 * &lt;p&gt;For NoConflictCertificateData the methods perform additional logic to
 * check that it gets the most recent entry if there's more than one (taking
 * permanent revocations into account), and for updates it appends new entries
 * instead of updating existing ones.
 *
 * @version $Id: NoConflictCertificateStoreSessionBean.java 29433 2018-07-02
 *     16:55:26Z mikekushner $
 */
@Stateless(
    mappedName =
        JndiConstants.APP_JNDI_PREFIX
            + &quot;NoConflictCertificateStoreSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.SUPPORTS)
<span class="nc" id="L72">public class NoConflictCertificateStoreSessionBean</span>
    implements NoConflictCertificateStoreSessionRemote,
        NoConflictCertificateStoreSessionLocal {

    /** Logger. */
<span class="nc" id="L77">  private static final Logger LOG =</span>
<span class="nc" id="L78">      Logger.getLogger(NoConflictCertificateStoreSessionBean.class);</span>

  /** Internal localization of logs and errors. */
<span class="nc" id="L81">  private static final InternalResources INTRES =</span>
<span class="nc" id="L82">      InternalResources.getInstance();</span>

  /** EM. */
  @PersistenceContext(unitName = CesecoreConfiguration.PERSISTENCE_UNIT)
  private EntityManager entityManager;

  /** Auth. */
  @EJB private AuthorizationSessionLocal authorizationSession;
  /** CA. */
  @EJB private CaSessionLocal caSession;
  /** Profile. */
  @EJB private CertificateProfileSessionLocal certificateProfileSession;
  /** Store. */
  @EJB private CertificateStoreSessionLocal certificateStoreSession;
  /** Log. */
  @EJB private SecurityEventsLoggerSessionLocal logSession;

  /** Session. */
  @EJB
  private NoConflictCertificateDataSessionLocal
      noConflictCertificateDataSession;

  private void authorizedToCA(final AuthenticationToken admin, final int caid)
      throws AuthorizationDeniedException {
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if (!authorizationSession.isAuthorized(</span>
<span class="nc" id="L107">        admin, StandardRules.CAACCESS.resource() + caid)) {</span>
<span class="nc" id="L108">      final String msg =</span>
<span class="nc" id="L109">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L110">              &quot;caadmin.notauthorizedtoca&quot;, admin.toString(), caid);</span>
<span class="nc" id="L111">      throw new AuthorizationDeniedException(msg);</span>
    }
<span class="nc" id="L113">  }</span>

  /**
   * Returns true if the CA allows revocation of non-existing certificates.
   *
   * @param issuerDN Subject DN of CA.
   */
  @Override
  public boolean canRevokeNonExisting(final String issuerDN) {
<span class="nc" id="L122">    final int caid =</span>
<span class="nc" id="L123">        CertTools.stringToBCDNString(StringTools.strip(issuerDN)).hashCode();</span>
<span class="nc" id="L124">    final CAInfo cainfo = caSession.getCAInfoInternal(caid);</span>
<span class="nc" id="L125">    return canRevokeNonExisting(cainfo, issuerDN);</span>
  }

  /**
   * @return true if the CA allows revocation of non-existing certificates.
   * @param cainfo CA
   * @param issuerDN Subject DN of CA, for safety check against CAId collisions.
   */
  private boolean canRevokeNonExisting(
      final CAInfo cainfo, final String issuerDN) {
<span class="nc" id="L135">    String dn = CertTools.stringToBCDNString(StringTools.strip(issuerDN));</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (cainfo == null</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        || !cainfo.getSubjectDN().equals(dn)</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        || !cainfo.isAcceptRevocationNonExistingEntry()) {</span>
<span class="nc" id="L139">      return false;</span>
    }
    // XXX this option can be set in the certificate profile as well! does it
    // make sense to have mixed locations? it would make CRL generation more
    // complex!
<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (cainfo.isUseCertificateStorage()) {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L146">        LOG.debug(</span>
            &quot;CA '&quot;
<span class="nc" id="L148">                + cainfo.getName()</span>
                + &quot;' is misconfigured. Revocation of non-existing certificates&quot;
                + &quot; is currently only supported for 'throw away CAs'.&quot;);
      }
<span class="nc" id="L152">      return false;</span>
    }
<span class="nc" id="L154">    return true;</span>
  }

  @Override
  public CertificateDataWrapper getCertificateDataByIssuerAndSerno(
      final String issuerdn, final BigInteger certserno) {
<span class="nc" id="L160">    CertificateDataWrapper cdw =</span>
<span class="nc" id="L161">        certificateStoreSession.getCertificateDataByIssuerAndSerno(</span>
            issuerdn, certserno);
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (cdw != null) {</span>
      // Full certificate is available, return it
<span class="nc" id="L165">      return cdw;</span>
    }

    // Throw away CA or missing certificate
<span class="nc" id="L169">    final int caid =</span>
<span class="nc" id="L170">        CertTools.stringToBCDNString(StringTools.strip(issuerdn)).hashCode();</span>
<span class="nc" id="L171">    final CAInfo cainfo = caSession.getCAInfoInternal(caid);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">    if (!canRevokeNonExisting(cainfo, issuerdn)) {</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">      if (cainfo == null &amp;&amp; LOG.isDebugEnabled()) {</span>
<span class="nc" id="L174">        LOG.debug(</span>
            &quot;Tried to look up certificate &quot;
<span class="nc" id="L176">                + certserno.toString(16)</span>
                + &quot;, but neither certificate nor CA was found. CA Id: &quot;
                + caid
                + &quot;. Issuer DN: '&quot;
                + issuerdn
                + &quot;'&quot;);
      }
<span class="nc" id="L183">      return null;</span>
    }
<span class="nc bnc" id="L185" title="All 2 branches missed.">    if (cainfo.isUseNoConflictCertificateData()) {</span>
<span class="nc" id="L186">      final NoConflictCertificateData certificateData =</span>
<span class="nc" id="L187">          getLimitedNoConflictCertDataRow(cainfo, certserno);</span>
<span class="nc" id="L188">      return new CertificateDataWrapper(certificateData);</span>
    } else {
<span class="nc" id="L190">      final CertificateData certificateData = new CertificateData();</span>
<span class="nc" id="L191">      fillInLimitedCertificateData(certificateData, cainfo, certserno);</span>
<span class="nc" id="L192">      certificateData.setUpdateTime(System.currentTimeMillis());</span>
<span class="nc" id="L193">      return new CertificateDataWrapper(certificateData, null);</span>
    }
  }

  @Override
  public CertificateStatus getStatus(
      final String issuerDN, final BigInteger serno) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L201">      LOG.trace(</span>
<span class="nc" id="L202">          &quot;&gt;getStatus(), dn:&quot; + issuerDN + &quot;, serno=&quot; + serno.toString(16));</span>
    }
    // First, try to look up in CertificateData
<span class="nc" id="L205">    final String dn = CertTools.stringToBCDNString(issuerDN);</span>
<span class="nc" id="L206">    CertificateStatus status =</span>
<span class="nc" id="L207">        certificateStoreSession.getStatus(issuerDN, serno);</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">    if (!canRevokeNonExisting(issuerDN)</span>
        || status != CertificateStatus.NOT_AVAILABLE) {
<span class="nc" id="L210">      LOG.trace(&quot;&lt;getStatus()&quot;);</span>
<span class="nc" id="L211">      return status;</span>
    }
    // If not found, take most recent certificate from NoConflictCertificateData
<span class="nc" id="L214">    final NoConflictCertificateData noConflictCert =</span>
<span class="nc" id="L215">        findMostRecentCertData(dn, serno);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (noConflictCert == null) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L218">        LOG.trace(</span>
            &quot;&lt;getStatus() did not find certificate with dn &quot;
                + dn
                + &quot; and serno &quot;
<span class="nc" id="L222">                + serno.toString(16));</span>
      }
      // For throw-away CAs that allow revocation of non-existing certificates,
      // we pretend that non-existing is OK
<span class="nc" id="L226">      return CertificateStatus.OK;</span>
    }
<span class="nc" id="L228">    status = CertificateStatusHelper.getCertificateStatus(noConflictCert);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L230">      LOG.trace(</span>
          &quot;&lt;getStatus() returned &quot;
              + status
              + &quot; for cert number &quot;
<span class="nc" id="L234">              + serno.toString(16));</span>
    }
<span class="nc" id="L236">    return status;</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public CertificateDataWrapper getCertificateData(final String fingerprint) {
<span class="nc" id="L242">    CertificateDataWrapper cdw =</span>
<span class="nc" id="L243">        certificateStoreSession.getCertificateData(fingerprint);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">    if (cdw != null) {</span>
<span class="nc" id="L245">      return cdw;</span>
    }
    // If not found, take most recent certificate from NoConflictCertificateData
<span class="nc" id="L248">    final Collection&lt;NoConflictCertificateData&gt; certDatas =</span>
<span class="nc" id="L249">        noConflictCertificateDataSession.findByFingerprint(fingerprint);</span>
<span class="nc" id="L250">    return new CertificateDataWrapper(filterMostRecentCertData(certDatas));</span>
  }

  @Override
  public Collection&lt;RevokedCertInfo&gt; listRevokedCertInfo(
      final String issuerdn, final long lastbasecrldate) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L257">      LOG.trace(</span>
          &quot;&gt;listRevokedCertInfo('&quot; + issuerdn + &quot;', &quot; + lastbasecrldate + &quot;)&quot;);
    }
<span class="nc" id="L260">    final Collection&lt;RevokedCertInfo&gt; revokedInCertData =</span>
<span class="nc" id="L261">        certificateStoreSession.listRevokedCertInfo(issuerdn, lastbasecrldate);</span>
<span class="nc" id="L262">    final Collection&lt;RevokedCertInfo&gt; revokedInNoConflictData =</span>
<span class="nc" id="L263">        noConflictCertificateDataSession.getRevokedCertInfosWithDuplicates(</span>
            issuerdn, lastbasecrldate);
<span class="nc bnc" id="L265" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L266">      LOG.debug(</span>
          &quot;listRevokedCertInfo: Got &quot;
<span class="nc" id="L268">              + revokedInCertData.size()</span>
              + &quot; entries from CertificateData and &quot;
<span class="nc" id="L270">              + revokedInNoConflictData.size()</span>
              + &quot; entries from NoConflictCertificateData&quot;);
    }
<span class="nc" id="L273">    return RevokedCertInfo.mergeByDateAndStatus(</span>
        revokedInCertData, revokedInNoConflictData, lastbasecrldate);
  }

  /**
   * Locates the most recent entry in NoConflictCertificateData for a given
   * issuerdn/serial number combination.
   *
   * @param issuerdn Issuer DN
   * @param serno Certificate serial number
   * @return NoConflictCertificateData entry, or null if not found. Entity is
   *     append-only, so do not modify it.
   */
  private NoConflictCertificateData findMostRecentCertData(
      final String issuerdn, final BigInteger serno) {
<span class="nc" id="L288">    final Collection&lt;NoConflictCertificateData&gt; certDatas =</span>
<span class="nc" id="L289">        noConflictCertificateDataSession.findByIssuerDNSerialNumber(</span>
<span class="nc" id="L290">            issuerdn, serno.toString());</span>
<span class="nc" id="L291">    return filterMostRecentCertData(certDatas);</span>
  }

  /**
   * Filters out the most recent entry in NoConflictCertificateData for a given
   * issuerDN/serial number combination. Permanent revocations always take
   * precedence over other updates, the first one wins. Otherwise, the most
   * recent update wins.
   *
   * @param certDatas Collection of NoConflictCertificateData to filter.
   * @return NoConflictCertificateData entry, or null if not found. Entity is
   *     append-only, so do not modify it.
   */
  private NoConflictCertificateData filterMostRecentCertData(
      final Collection&lt;NoConflictCertificateData&gt; certDatas) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">    if (CollectionUtils.isEmpty(certDatas)) {</span>
<span class="nc" id="L307">      LOG.trace(&quot;&lt;findMostRecentCertData(): no certificates found&quot;);</span>
<span class="nc" id="L308">      return null;</span>
    }
<span class="nc" id="L310">    NoConflictCertificateData mostRecentData = null;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">    for (final NoConflictCertificateData data : certDatas) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">      if (mostRecentData == null) {</span>
<span class="nc" id="L313">        mostRecentData = data;</span>
<span class="nc" id="L314">        continue;</span>
      }
      long timestampThis =
<span class="nc bnc" id="L317" title="All 2 branches missed.">          data.getUpdateTime() != null ? data.getUpdateTime() : 0;</span>
      long timestampRecent =
<span class="nc bnc" id="L319" title="All 2 branches missed.">          mostRecentData.getUpdateTime() != null</span>
<span class="nc" id="L320">              ? mostRecentData.getUpdateTime()</span>
<span class="nc" id="L321">              : 0;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      if (RevokedCertInfo.isPermanentlyRevoked(data.getRevocationReason())) {</span>
        // Permanently revoked certificate always takes precedence over
        // non-permanently revoked one.
        // Older permanent revocations take precedence over newer ones.
<span class="nc bnc" id="L326" title="All 4 branches missed.">        if (!RevokedCertInfo.isPermanentlyRevoked(</span>
<span class="nc" id="L327">                mostRecentData.getRevocationReason())</span>
            || timestampRecent &gt; timestampThis) {
<span class="nc" id="L329">          mostRecentData = data;</span>
<span class="nc" id="L330">          continue;</span>
        }
      }
      // Permanent revocations take precedence over temporary ones
<span class="nc bnc" id="L334" title="All 2 branches missed.">      if (RevokedCertInfo.isPermanentlyRevoked(</span>
<span class="nc" id="L335">          mostRecentData.getRevocationReason())) {</span>
<span class="nc" id="L336">        continue;</span>
      }
      // Otherwise, most recent status takes precedence
<span class="nc bnc" id="L339" title="All 2 branches missed.">      if (timestampThis &gt; timestampRecent) {</span>
<span class="nc" id="L340">        mostRecentData = data;</span>
      }
<span class="nc" id="L342">    }</span>
<span class="nc" id="L343">    return mostRecentData;</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public boolean setRevokeStatus(
      final AuthenticationToken admin,
      final CertificateDataWrapper cdw,
      final Date revokedDate,
      final int reason)
      throws CertificateRevokeException, AuthorizationDeniedException {
<span class="nc bnc" id="L354" title="All 2 branches missed.">    if (cdw.getBaseCertificateData() instanceof NoConflictCertificateData) {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">      if (entityManager.contains(cdw.getBaseCertificateData())) {</span>
<span class="nc" id="L356">        throw new IllegalStateException(</span>
            &quot;Cannot update existing row in NoConflictCertificateData. It is&quot;
                + &quot; append-only.&quot;);
      }
    }
<span class="nc" id="L361">    return certificateStoreSession.setRevokeStatus(</span>
        admin, cdw, revokedDate, reason);
  }

  @Override
  public boolean setStatus(
      final AuthenticationToken admin,
      final String fingerprint,
      final int status)
      throws AuthorizationDeniedException {
<span class="nc bnc" id="L371" title="All 2 branches missed.">    if (!certificateStoreSession.setStatus(admin, fingerprint, status)) {</span>
      // Perhaps stored in NoConflictCertificateData
<span class="nc" id="L373">      final List&lt;NoConflictCertificateData&gt; certDatas =</span>
<span class="nc" id="L374">          noConflictCertificateDataSession.findByFingerprint(fingerprint);</span>
<span class="nc" id="L375">      NoConflictCertificateData certData = filterMostRecentCertData(certDatas);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">      if (certData != null) {</span>
<span class="nc" id="L377">        changeStatus(admin, certData, status);</span>
      }
    }
<span class="nc" id="L380">    return false;</span>
  }

  private void changeStatus(
      final AuthenticationToken admin,
      final NoConflictCertificateData certificateData,
      final int status)
      throws AuthorizationDeniedException {
<span class="nc bnc" id="L388" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L389">      LOG.debug(</span>
          &quot;Set status &quot;
              + status
              + &quot; for certificate with serial: &quot;
<span class="nc" id="L393">              + certificateData.getSerialNumberHex());</span>
    }

    // Must be authorized to CA in order to change status is certificates issued
    // by the CA
<span class="nc" id="L398">    String bcdn = CertTools.stringToBCDNString(certificateData.getIssuerDN());</span>
<span class="nc" id="L399">    int caid = bcdn.hashCode();</span>
<span class="nc" id="L400">    authorizedToCA(admin, caid);</span>

<span class="nc" id="L402">    final NoConflictCertificateData newCertData =</span>
        new NoConflictCertificateData(certificateData);
<span class="nc" id="L404">    newCertData.setStatus(status);</span>
<span class="nc" id="L405">    setUniqueIdAndUpdateTime(newCertData);</span>
<span class="nc" id="L406">    entityManager.persist(newCertData);</span>

<span class="nc" id="L408">    final String serialNo = certificateData.getSerialNumberHex();</span>
<span class="nc" id="L409">    final String msg =</span>
<span class="nc" id="L410">        INTRES.getLocalizedMessage(</span>
            &quot;store.setstatus&quot;,
<span class="nc" id="L412">            certificateData.getUsername(),</span>
<span class="nc" id="L413">            certificateData.getFingerprint(),</span>
<span class="nc" id="L414">            status,</span>
<span class="nc" id="L415">            certificateData.getSubjectDnNeverNull(),</span>
<span class="nc" id="L416">            certificateData.getIssuerDN(),</span>
            serialNo);
<span class="nc" id="L418">    Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L419">    details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L420">    logSession.log(</span>
        EventTypes.CERT_CHANGEDSTATUS,
        EventStatus.SUCCESS,
        ModuleTypes.CERTIFICATE,
        ServiceTypes.CORE,
<span class="nc" id="L425">        admin.toString(),</span>
<span class="nc" id="L426">        String.valueOf(caid),</span>
        serialNo,
<span class="nc" id="L428">        certificateData.getUsername(),</span>
        details);
<span class="nc" id="L430">  }</span>

  /**
   * Returns a row in the append-only NoConflictCertificateData table, or a new
   * row that can be added. The row is initialized with the data from the most
   * recent entry in the table, or as a new unrevoked entry if non-existent.
   *
   * @param cainfo Issuer.
   * @param certserno Certificate serial number.
   * @return New row, or copy of an existing row. Always has a fresh UUID and
   *     timestamp, so it can be appended directly.
   */
  private NoConflictCertificateData getLimitedNoConflictCertDataRow(
      final CAInfo cainfo, final BigInteger certserno) {
<span class="nc" id="L444">    NoConflictCertificateData certificateData =</span>
<span class="nc" id="L445">        findMostRecentCertData(cainfo.getSubjectDN(), certserno);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">    if (certificateData != null) {</span>
      // Make a copy, to prevent overwrites
<span class="nc" id="L448">      certificateData = new NoConflictCertificateData(certificateData);</span>
    } else {
<span class="nc" id="L450">      certificateData = new NoConflictCertificateData();</span>
<span class="nc" id="L451">      fillInLimitedCertificateData(certificateData, cainfo, certserno);</span>
    }
<span class="nc" id="L453">    setUniqueIdAndUpdateTime(certificateData);</span>
<span class="nc" id="L454">    return certificateData;</span>
  }

  private void setUniqueIdAndUpdateTime(
      final NoConflictCertificateData certificateData) {
    // Always generate new UUID and timestamp, so updates are stored as a new
    // row
<span class="nc" id="L461">    certificateData.setId(UUID.randomUUID().toString());</span>
<span class="nc" id="L462">    certificateData.setUpdateTime(System.currentTimeMillis());</span>
<span class="nc" id="L463">  }</span>

  /**
   * @param certificateData Data
   * @param cainfo CA
   * @param certserno Serial
   * @see
   *     org.cesecore.certificates.certificate.CertificateStoreSessionBean#updateLimitedCertificateDataStatus(AuthenticationToken,
   *     int, String, String, String, BigInteger, int, Date, int, String)
   */
  private void fillInLimitedCertificateData(
      final BaseCertificateData certificateData,
      final CAInfo cainfo,
      final BigInteger certserno) {
<span class="nc" id="L477">    final int certProfId = cainfo.getDefaultCertificateProfileId();</span>
<span class="nc" id="L478">    certificateData.setSerialNumber(certserno.toString());</span>
    // A fingerprint is needed by the publisher session, so we put a dummy
    // fingerprint here
<span class="nc" id="L481">    certificateData.setFingerprint(</span>
<span class="nc" id="L482">        generateDummyFingerprint(cainfo.getSubjectDN(), certserno));</span>
<span class="nc" id="L483">    certificateData.setIssuerDN(cainfo.getSubjectDN());</span>
<span class="nc" id="L484">    certificateData.setSubject(&quot;CN=limited&quot;);</span>
<span class="nc" id="L485">    certificateData.setUsername(null);</span>
<span class="nc" id="L486">    certificateData.setCertificateProfileId(certProfId);</span>
<span class="nc" id="L487">    certificateData.setStatus(CertificateConstants.CERT_ACTIVE);</span>
<span class="nc" id="L488">    certificateData.setRevocationReason(</span>
<span class="nc" id="L489">        RevocationReasons.NOT_REVOKED.getDatabaseValue());</span>
<span class="nc" id="L490">    certificateData.setRevocationDate(-1L);</span>
<span class="nc" id="L491">    certificateData.setCaFingerprint(</span>
<span class="nc" id="L492">        CertTools.getFingerprintAsString(cainfo.getCertificateChain().get(0)));</span>
<span class="nc" id="L493">    certificateData.setEndEntityProfileId(-1);</span>
    // Set expire date to the maximum possible expire date this certificate
    // could have (now + cert profile validity)
<span class="nc" id="L496">    final CertificateProfile certProf =</span>
<span class="nc" id="L497">        certificateProfileSession.getCertificateProfile(certProfId);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">    if (certProf == null) {</span>
<span class="nc" id="L499">      LOG.info(&quot;Missing certificate profile ID: &quot; + certProfId);</span>
    } else {
<span class="nc" id="L501">      final String encodedValidity = certProf.getEncodedValidity();</span>
<span class="nc" id="L502">      final Date expireDate = ValidityDate.getDate(encodedValidity, new Date());</span>
<span class="nc" id="L503">      certificateData.setExpireDate(expireDate);</span>
    }
<span class="nc" id="L505">  }</span>

  @Override
  public String generateDummyFingerprint(
      final String issuerdn, final BigInteger certserno) {
<span class="nc" id="L510">    final byte[] fingerprintBytes =</span>
<span class="nc" id="L511">        CertTools.generateSHA1Fingerprint(</span>
<span class="nc" id="L512">            (certserno.toString() + ';' + issuerdn)</span>
<span class="nc" id="L513">                .getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L514">    return new String(Hex.encode(fingerprintBytes));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>