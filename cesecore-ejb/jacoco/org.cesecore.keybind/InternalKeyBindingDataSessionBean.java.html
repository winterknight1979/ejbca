<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InternalKeyBindingDataSessionBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security EJB Implementation</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keybind</a> &gt; <span class="el_source">InternalKeyBindingDataSessionBean.java</span></div><h1>InternalKeyBindingDataSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keybind;

import java.security.SecureRandom;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import org.apache.log4j.Logger;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.util.QueryResultWrapper;

/**
 * @see org.cesecore.keybind.InternalKeyBindingDataSessionLocal
 * @version $Id: InternalKeyBindingDataSessionBean.java 25609 2017-03-24
 *     00:00:29Z jeklund $
 */
@Stateless // (mappedName = JndiConstants.APP_JNDI_PREFIX +
           // &quot;InternalKeyBindingDataSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
<span class="nc" id="L42">public class InternalKeyBindingDataSessionBean</span>
    implements InternalKeyBindingDataSessionLocal {

    /** Logger. */
<span class="nc" id="L46">  private static final Logger LOG =</span>
<span class="nc" id="L47">      Logger.getLogger(InternalKeyBindingDataSessionBean.class);</span>
  /** tesource. */
  private static final InternalResources INTRES =
<span class="nc" id="L50">      InternalResources.getInstance();</span>
  /** Random. */
<span class="nc" id="L52">  private static final Random RND = new SecureRandom();</span>

  /** EM. */
  @PersistenceContext(unitName = CesecoreConfiguration.PERSISTENCE_UNIT)
  private EntityManager entityManager;

  /** Myself needs to be looked up in postConstruct. */
  @Resource private SessionContext sessionContext;
  /** Session. */
  private InternalKeyBindingDataSessionLocal keyBindSession;

  /** Init. */
  @PostConstruct
  public void postConstruct() {
    // We lookup the reference to our-self in PostConstruct, since we cannot
    // inject this.
    // We can not inject ourself, JBoss will not start then therefore we use
    // this to get a reference to this session bean
    // to call readData we want to do it on the real bean in order to get
    // the transaction setting (REQUIRED) which creates a new transaction if one
    // was not running (required to read LOBs in PostgreSQL)
<span class="nc" id="L73">    keyBindSession =</span>
<span class="nc" id="L74">        sessionContext.getBusinessObject(</span>
            InternalKeyBindingDataSessionLocal.class);
<span class="nc" id="L76">  }</span>

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public void flushCache() {
<span class="nc" id="L81">    InternalKeyBindingCache.INSTANCE.flush();</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L83">      LOG.debug(&quot;Flushed &quot; + InternalKeyBindingCache.class.getSimpleName());</span>
    }
<span class="nc" id="L85">  }</span>

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public InternalKeyBinding getInternalKeyBinding(final int id) {
    // 1. Check (new) InternalKeyBindingCache if it is time to sync-up with
    // database
<span class="nc bnc" id="L92" title="All 2 branches missed.">    if (InternalKeyBindingCache.INSTANCE.shouldCheckForUpdates(id)) {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L94">        LOG.debug(&quot;Object with ID &quot; + id + &quot; will be checked for updates.&quot;);</span>
      }
      // 2. If cache is expired or missing, first thread to discover this
      // reloads item from database and sends it to the cache
<span class="nc" id="L98">      final InternalKeyBindingData internalKeyBindingData =</span>
<span class="nc" id="L99">          keyBindSession.readData(id);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      if (internalKeyBindingData == null) {</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L102">          LOG.debug(</span>
              &quot;Requested object did not exist in database and will be purged&quot;
                  + &quot; from cache if present: &quot;
                  + id);
        }
        // Ensure that it is removed from cache
<span class="nc" id="L108">        InternalKeyBindingCache.INSTANCE.removeEntry(id);</span>
      } else {
<span class="nc" id="L110">        final int digest =</span>
<span class="nc" id="L111">            internalKeyBindingData.getProtectString(0).hashCode();</span>
<span class="nc" id="L112">        final String type = internalKeyBindingData.getKeyBindingType();</span>
<span class="nc" id="L113">        final String name = internalKeyBindingData.getName();</span>
<span class="nc" id="L114">        final InternalKeyBindingStatus status =</span>
<span class="nc" id="L115">            internalKeyBindingData.getStatusEnum();</span>
<span class="nc" id="L116">        final String certificateId = internalKeyBindingData.getCertificateId();</span>
<span class="nc" id="L117">        final int cryptoTokenId = internalKeyBindingData.getCryptoTokenId();</span>
<span class="nc" id="L118">        final String keyPairAlias = internalKeyBindingData.getKeyPairAlias();</span>
<span class="nc" id="L119">        final LinkedHashMap&lt;Object, Object&gt; dataMapToLoad =</span>
<span class="nc" id="L120">            internalKeyBindingData.getDataMap();</span>
        // Create new token and store it in the cache.
<span class="nc" id="L122">        final InternalKeyBinding internalKeyBinding =</span>
<span class="nc" id="L123">            InternalKeyBindingFactory.INSTANCE.create(</span>
                type,
                id,
                name,
                status,
                certificateId,
                cryptoTokenId,
                keyPairAlias,
                dataMapToLoad);
<span class="nc" id="L132">        InternalKeyBindingCache.INSTANCE.updateWith(</span>
            id, digest, name, internalKeyBinding);
      }
      // 3. The cache compares the database data with what is in the cache
      // 4. If database is different from cache, replace it in the cache (while
      // trying to keep activation)
    }
    // 5. Get InternalKeyBinding from cache (or null) and be merry
<span class="nc" id="L140">    return InternalKeyBindingCache.INSTANCE.getEntry(id);</span>
  }

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public InternalKeyBinding getInternalKeyBindingForEdit(final int id) {
<span class="nc" id="L146">    final InternalKeyBinding internalKeyBinding = getInternalKeyBinding(id);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (internalKeyBinding == null) {</span>
<span class="nc" id="L148">      return null;</span>
    } else {
      // 6. Create and return a clone (so clients don't mess with the cached
      // object)
<span class="nc" id="L152">      final InternalKeyBinding internalKeyBindingClone =</span>
<span class="nc" id="L153">          InternalKeyBindingFactory.INSTANCE.create(</span>
<span class="nc" id="L154">              internalKeyBinding.getImplementationAlias(),</span>
              id,
<span class="nc" id="L156">              internalKeyBinding.getName(),</span>
<span class="nc" id="L157">              internalKeyBinding.getStatus(),</span>
<span class="nc" id="L158">              internalKeyBinding.getCertificateId(),</span>
<span class="nc" id="L159">              internalKeyBinding.getCryptoTokenId(),</span>
<span class="nc" id="L160">              internalKeyBinding.getKeyPairAlias(),</span>
<span class="nc" id="L161">              internalKeyBinding.getDataMapToPersist());</span>
<span class="nc" id="L162">      return internalKeyBindingClone;</span>
    }
  }

  @Override
  public int mergeInternalKeyBinding(
          final InternalKeyBinding ointernalKeyBinding)
      throws InternalKeyBindingNameInUseException {
<span class="nc" id="L170">      InternalKeyBinding internalKeyBinding = ointernalKeyBinding;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L172">      LOG.debug(</span>
          &quot;&gt;mergeInternalKeyBinding &quot;
<span class="nc" id="L174">              + internalKeyBinding.getName()</span>
              + &quot; &quot;
<span class="nc" id="L176">              + internalKeyBinding.getClass().getName());</span>
    }
<span class="nc" id="L178">    int internalKeyBindingId = internalKeyBinding.getId();</span>
<span class="nc" id="L179">    final String name = internalKeyBinding.getName();</span>
<span class="nc" id="L180">    final InternalKeyBindingStatus status = internalKeyBinding.getStatus();</span>
<span class="nc" id="L181">    final String type =</span>
<span class="nc" id="L182">        InternalKeyBindingFactory.INSTANCE.getTypeFromImplementation(</span>
            internalKeyBinding);
<span class="nc" id="L184">    final String certificateId = internalKeyBinding.getCertificateId();</span>
<span class="nc" id="L185">    final int cryptoTokenId = internalKeyBinding.getCryptoTokenId();</span>
<span class="nc" id="L186">    final String keyPairAlias = internalKeyBinding.getKeyPairAlias();</span>
<span class="nc" id="L187">    final LinkedHashMap&lt;Object, Object&gt; dataMap =</span>
<span class="nc" id="L188">        internalKeyBinding.getDataMapToPersist();</span>
    // Allocate a new internalKeyBindingId if we create the InternalKeyBinding
<span class="nc" id="L190">    InternalKeyBindingData internalKeyBindingData = null;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">    if (internalKeyBindingId == 0) {</span>
<span class="nc" id="L192">      final List&lt;Integer&gt; allUsedIds = getIds(null);</span>
<span class="nc" id="L193">      Integer allocatedId = null;</span>
<span class="nc" id="L194">      final int max = 100;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      for (int i = 0; i &lt; max; i++) {</span>
<span class="nc" id="L196">        final int current = Integer.valueOf(RND.nextInt());</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (!allUsedIds.contains(current)) {</span>
<span class="nc" id="L198">          allocatedId = current;</span>
<span class="nc" id="L199">          break;</span>
        }
      }
<span class="nc bnc" id="L202" title="All 2 branches missed.">      if (allocatedId == null) {</span>
<span class="nc" id="L203">        throw new RuntimeException(</span>
            &quot;Failed to allocate a new internalKeyBindingId.&quot;);
      }
<span class="nc" id="L206">      internalKeyBindingId = allocatedId.intValue();</span>
      // We need to replace this object with an object that has the correct ID
      // if we are going to cache it later
<span class="nc" id="L209">      internalKeyBinding =</span>
<span class="nc" id="L210">          InternalKeyBindingFactory.INSTANCE.create(</span>
              type,
              internalKeyBindingId,
              name,
              status,
              certificateId,
              cryptoTokenId,
              keyPairAlias,
              dataMap);
<span class="nc bnc" id="L219" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L220">        LOG.debug(</span>
            &quot;Allocated a new internalKeyBindingId: &quot; + internalKeyBindingId);
      }
<span class="nc" id="L223">    } else {</span>
      // The one invoking the method has specified an id and expects the object
      // to exist
<span class="nc" id="L226">      internalKeyBindingData =</span>
<span class="nc" id="L227">          entityManager.find(</span>
<span class="nc" id="L228">              InternalKeyBindingData.class, internalKeyBindingId);</span>
    }
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (internalKeyBindingData == null) {</span>
      // The InternalKeyBinding does not exist in the database, before we add it
      // we want to check that the name is not in use
<span class="nc bnc" id="L233" title="All 2 branches missed.">      if (isNameUsed(name)) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L235">          LOG.debug(&quot;isNameUsed(&quot; + name + &quot;)&quot;);</span>
        }
<span class="nc" id="L237">        throw new InternalKeyBindingNameInUseException(</span>
<span class="nc" id="L238">            INTRES.getLocalizedMessage(&quot;internalkeybinding.nameisinuse&quot;, name));</span>
      }
<span class="nc" id="L240">      internalKeyBindingData =</span>
          new InternalKeyBindingData(
              internalKeyBindingId,
              name,
              status,
              type,
              certificateId,
              cryptoTokenId,
              keyPairAlias,
              dataMap);
    } else {
<span class="nc bnc" id="L251" title="All 2 branches missed.">      if (!isNameUsedByIdOnly(</span>
<span class="nc" id="L252">          internalKeyBindingData.getName(), internalKeyBindingId)) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L254">          LOG.debug(</span>
              &quot;!isNameUsedByIdOnly(&quot;
                  + name
                  + &quot;, &quot;
                  + internalKeyBindingId
                  + &quot;)&quot;);
        }
<span class="nc" id="L261">        throw new InternalKeyBindingNameInUseException(</span>
<span class="nc" id="L262">            INTRES.getLocalizedMessage(&quot;internalkeybinding.nameisinuse&quot;, name));</span>
      }
      // It might be the case that the calling transaction has already loaded a
      // reference to this token
      // and hence we need to get the same one and perform updates on this
      // object instead of trying to
      // merge a new object.
<span class="nc" id="L269">      internalKeyBindingData.setName(name);</span>
<span class="nc" id="L270">      internalKeyBindingData.setStatusEnum(status);</span>
<span class="nc" id="L271">      internalKeyBindingData.setKeyBindingType(type);</span>
<span class="nc" id="L272">      internalKeyBindingData.setCertificateId(certificateId);</span>
<span class="nc" id="L273">      internalKeyBindingData.setCryptoTokenId(cryptoTokenId);</span>
<span class="nc" id="L274">      internalKeyBindingData.setKeyPairAlias(keyPairAlias);</span>
<span class="nc" id="L275">      internalKeyBindingData.setDataMap(dataMap);</span>
<span class="nc" id="L276">      internalKeyBindingData.setLastUpdate(System.currentTimeMillis());</span>
    }
<span class="nc" id="L278">    internalKeyBindingData = createOrUpdateData(internalKeyBindingData);</span>
    // Update cache with provided token (it might be active and we like keeping
    // things active)
<span class="nc" id="L281">    InternalKeyBindingCache.INSTANCE.updateWith(</span>
        internalKeyBindingId,
<span class="nc" id="L283">        internalKeyBindingData.getProtectString(0).hashCode(),</span>
        name,
        internalKeyBinding);
<span class="nc bnc" id="L286" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L287">      LOG.debug(&quot;&lt;mergeInternalKeyBinding &quot; + internalKeyBinding.getName());</span>
    }
<span class="nc" id="L289">    return internalKeyBindingId; // tokenId</span>
  }

  @Override
  public boolean removeInternalKeyBinding(final int id) {
<span class="nc" id="L294">    final boolean ret = deleteData(id);</span>
<span class="nc" id="L295">    InternalKeyBindingCache.INSTANCE.updateWith(id, 0, null, null);</span>
<span class="nc" id="L296">    return ret;</span>
  }

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public Map&lt;String, Integer&gt; getCachedNameToIdMap() {
<span class="nc" id="L302">    return InternalKeyBindingCache.INSTANCE.getNameToIdMap();</span>
  }

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public boolean isNameUsed(final String name) {
<span class="nc" id="L308">    final Query query =</span>
<span class="nc" id="L309">        entityManager.createQuery(</span>
            &quot;SELECT a FROM InternalKeyBindingData a WHERE a.name=:name&quot;);
<span class="nc" id="L311">    query.setParameter(&quot;name&quot;, name);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">    return !query.getResultList().isEmpty();</span>
  }

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public boolean isNameUsedByIdOnly(final String name, final int id) {
<span class="nc" id="L318">    final Query query =</span>
<span class="nc" id="L319">        entityManager.createQuery(</span>
            &quot;SELECT a FROM InternalKeyBindingData a WHERE a.name=:name&quot;);
<span class="nc" id="L321">    query.setParameter(&quot;name&quot;, name);</span>
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L323">    final List&lt;InternalKeyBindingData&gt; internalKeyBindingDatas =</span>
<span class="nc" id="L324">        query.getResultList();</span>
    for (final InternalKeyBindingData internalKeyBindingData
<span class="nc bnc" id="L326" title="All 2 branches missed.">        : internalKeyBindingDatas) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">      if (internalKeyBindingData.getId() != id) {</span>
<span class="nc" id="L328">        return false;</span>
      }
<span class="nc" id="L330">    }</span>
<span class="nc" id="L331">    return true;</span>
  }

  //
  // Create Read Update Delete (CRUD) methods
  //

  @Override
  public InternalKeyBindingData readData(final int id) {
<span class="nc" id="L340">    final Query query =</span>
<span class="nc" id="L341">        entityManager.createQuery(</span>
            &quot;SELECT a FROM InternalKeyBindingData a WHERE a.id=:id&quot;);
<span class="nc" id="L343">    query.setParameter(&quot;id&quot;, id);</span>
<span class="nc" id="L344">    return QueryResultWrapper.getSingleResult(query);</span>
  }

  private InternalKeyBindingData createOrUpdateData(
      final InternalKeyBindingData data) {
<span class="nc" id="L349">    return entityManager.merge(data);</span>
  }

  private boolean deleteData(final int id) {
<span class="nc" id="L353">    final Query query =</span>
<span class="nc" id="L354">        entityManager.createQuery(</span>
            &quot;DELETE FROM InternalKeyBindingData a WHERE a.id=:id&quot;);
<span class="nc" id="L356">    query.setParameter(&quot;id&quot;, id);</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">    return query.executeUpdate() == 1;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public List&lt;Integer&gt; getIds(final String keyBindingType) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">    if (keyBindingType == null) {</span>
<span class="nc" id="L365">      return entityManager</span>
<span class="nc" id="L366">          .createQuery(&quot;SELECT a.id FROM InternalKeyBindingData a&quot;)</span>
<span class="nc" id="L367">          .getResultList();</span>
    } else {
<span class="nc" id="L369">      final Query query =</span>
<span class="nc" id="L370">          entityManager.createQuery(</span>
              &quot;SELECT a.id FROM InternalKeyBindingData a WHERE&quot;
                  + &quot; a.keyBindingType=:keyBindingType&quot;);
<span class="nc" id="L373">      query.setParameter(&quot;keyBindingType&quot;, keyBindingType);</span>
<span class="nc" id="L374">      return query.getResultList();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>