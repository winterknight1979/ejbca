<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OcspResponseGeneratorSessionBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security EJB Implementation</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ocsp</a> &gt; <span class="el_source">OcspResponseGeneratorSessionBean.java</span></div><h1>OcspResponseGeneratorSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ocsp;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.InvalidParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.UnrecoverableEntryException;
import java.security.cert.CertPathValidatorException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.EJBException;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.ejb.Timeout;
import javax.ejb.Timer;
import javax.ejb.TimerConfig;
import javax.ejb.TimerService;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1GeneralizedTime;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERNull;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.nist.NISTObjectIdentifiers;
import org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers;
import org.bouncycastle.asn1.ocsp.RevokedInfo;
import org.bouncycastle.asn1.oiw.OIWObjectIdentifiers;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.CRLReason;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.KeyPurposeId;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;
import org.bouncycastle.cert.ocsp.BasicOCSPResp;
import org.bouncycastle.cert.ocsp.BasicOCSPRespBuilder;
import org.bouncycastle.cert.ocsp.CertificateID;
import org.bouncycastle.cert.ocsp.OCSPException;
import org.bouncycastle.cert.ocsp.OCSPReq;
import org.bouncycastle.cert.ocsp.OCSPResp;
import org.bouncycastle.cert.ocsp.OCSPRespBuilder;
import org.bouncycastle.cert.ocsp.Req;
import org.bouncycastle.cert.ocsp.RevokedStatus;
import org.bouncycastle.cert.ocsp.UnknownStatus;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.bc.BcDigestCalculatorProvider;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.authentication.tokens.AlwaysAllowLocalAuthenticationToken;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authentication.tokens.UsernamePrincipal;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.certificates.ca.CAConstants;
import org.cesecore.certificates.ca.CAInfo;
import org.cesecore.certificates.ca.CaSessionLocal;
import org.cesecore.certificates.ca.InvalidAlgorithmException;
import org.cesecore.certificates.ca.SignRequestException;
import org.cesecore.certificates.ca.SignRequestSignatureException;
import org.cesecore.certificates.ca.catoken.CAToken;
import org.cesecore.certificates.ca.catoken.CATokenConstants;
import org.cesecore.certificates.ca.internal.CaCertificateCache;
import org.cesecore.certificates.certificate.CertificateInfo;
import org.cesecore.certificates.certificate.CertificateStatus;
import org.cesecore.certificates.certificate.CertificateStatusHolder;
import org.cesecore.certificates.certificate.CertificateStoreSessionLocal;
import org.cesecore.certificates.certificate.HashID;
import org.cesecore.certificates.certificateprofile.CertificateProfileConstants;
import org.cesecore.certificates.certificatetransparency.CertificateTransparency;
import org.cesecore.certificates.certificatetransparency.CertificateTransparencyFactory;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.certificates.ocsp.cache.OcspConfigurationCache;
import org.cesecore.certificates.ocsp.cache.OcspExtensionsCache;
import org.cesecore.certificates.ocsp.cache.OcspRequestSignerStatusCache;
import org.cesecore.certificates.ocsp.cache.OcspSigningCache;
import org.cesecore.certificates.ocsp.cache.OcspSigningCacheEntry;
import org.cesecore.certificates.ocsp.exception.CryptoProviderException;
import org.cesecore.certificates.ocsp.exception.IllegalNonceException;
import org.cesecore.certificates.ocsp.exception.MalformedRequestException;
import org.cesecore.certificates.ocsp.exception.OcspFailureException;
import org.cesecore.certificates.ocsp.extension.OCSPExtension;
import org.cesecore.certificates.ocsp.extension.OCSPExtensionType;
import org.cesecore.certificates.ocsp.keys.CardKeys;
import org.cesecore.certificates.ocsp.logging.AuditLogger;
import org.cesecore.certificates.ocsp.logging.PatternLogger;
import org.cesecore.certificates.ocsp.logging.TransactionLogger;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.config.AvailableExtendedKeyUsagesConfiguration;
import org.cesecore.config.ConfigurationHolder;
import org.cesecore.config.GlobalOcspConfiguration;
import org.cesecore.config.OcspConfiguration;
import org.cesecore.configuration.GlobalConfigurationSessionLocal;
import org.cesecore.internal.InternalResources;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.keybind.CertificateImportException;
import org.cesecore.keybind.InternalKeyBindingDataSessionLocal;
import org.cesecore.keybind.InternalKeyBindingInfo;
import org.cesecore.keybind.InternalKeyBindingMgmtSessionLocal;
import org.cesecore.keybind.InternalKeyBindingNameInUseException;
import org.cesecore.keybind.InternalKeyBindingStatus;
import org.cesecore.keybind.InternalKeyBindingTrustEntry;
import org.cesecore.keybind.impl.AuthenticationKeyBinding;
import org.cesecore.keybind.impl.OcspKeyBinding;
import org.cesecore.keybind.impl.OcspKeyBinding.ResponderIdType;
import org.cesecore.keys.token.BaseCryptoToken;
import org.cesecore.keys.token.CachingKeyStoreWrapper;
import org.cesecore.keys.token.CryptoToken;
import org.cesecore.keys.token.CryptoTokenManagementSessionLocal;
import org.cesecore.keys.token.CryptoTokenOfflineException;
import org.cesecore.keys.token.CryptoTokenSessionLocal;
import org.cesecore.keys.token.PKCS11CryptoToken;
import org.cesecore.keys.token.SoftCryptoToken;
import org.cesecore.keys.token.p11.Pkcs11SlotLabelType;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.util.CeSecoreNameStyle;
import org.cesecore.util.CertTools;
import org.cesecore.util.log.ProbableErrorHandler;
import org.cesecore.util.log.SaferAppenderListener;
import org.cesecore.util.provider.EkuPKIXCertPathChecker;

/**
 * This SSB generates OCSP responses.
 *
 * @version $Id: OcspResponseGeneratorSessionBean.java 30346 2018-11-01
 *     13:14:39Z samuellb $
 */
@Stateless(
    mappedName =
        JndiConstants.APP_JNDI_PREFIX + &quot;OcspResponseGeneratorSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.SUPPORTS)
<span class="fc" id="L184">public class OcspResponseGeneratorSessionBean</span>
    implements OcspResponseGeneratorSessionRemote,
        OcspResponseGeneratorSessionLocal,
        SaferAppenderListener {

  /** Max size of a request is 100000 bytes. */
  private static final int MAX_REQUEST_SIZE = 100000;
  /** Timer identifiers. */
  private static final int TIMERID_OCSPSIGNINGCACHE = 1;

  /** Name. */
  private static final String HARD_TOKEN_CLASS_NAME =
<span class="fc" id="L196">      OcspConfiguration.getHardTokenClassName();</span>

  /** Logger. */
<span class="fc" id="L199">  private static final Logger LOG =</span>
<span class="fc" id="L200">      Logger.getLogger(OcspResponseGeneratorSessionBean.class);</span>

  /** Resource. */
  private static final InternalResources INTRES =
<span class="fc" id="L204">      InternalResources.getInstance();</span>

  /** Service. */
<span class="fc" id="L207">  private static volatile ExecutorService service =</span>
<span class="fc" id="L208">      Executors.newCachedThreadPool();</span>

  /** Context. */
  @Resource private SessionContext sessionContext;
  /** When the sessionContext is injected,
   * the timerService should be looked up.
   * This is due to the Glassfish EJB verifier complaining.
   */
  private TimerService timerService;

  /** CA. */
  @EJB private CaSessionLocal caSession;
  /** Store. */
  @EJB private CertificateStoreSessionLocal certificateStoreSession;
  /** Crypto. */
  @EJB private CryptoTokenSessionLocal cryptoTokenSession;
  /** Crypto. */
  @EJB private CryptoTokenManagementSessionLocal cryptoTokenManagementSession;
  /** Binding. */
  @EJB private InternalKeyBindingDataSessionLocal internalKeyBindingDataSession;
  /** Binding. */
  @EJB private InternalKeyBindingMgmtSessionLocal internalKeyBindingMgmtSession;
  /** Config. */
  @EJB private GlobalConfigurationSessionLocal globalConfigurationSession;

  /** Converter. */
<span class="fc" id="L234">  private final JcaX509CertificateConverter certificateConverter =</span>
      new JcaX509CertificateConverter();

  /** Setup. */
  @PostConstruct
  public void init() {
   
<span class="nc" id="L241">    timerService = sessionContext.getTimerService();</span>
<span class="nc" id="L242">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void initTimers() {
    // Reload OCSP signing cache, and cancel/create timers if there are no
    // timers or if the cache is empty (probably a fresh startup)
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if (getTimerCount(TIMERID_OCSPSIGNINGCACHE) == 0</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        || OcspSigningCache.INSTANCE.getEntries().isEmpty()) {</span>
<span class="nc" id="L251">      reloadOcspSigningCache();</span>
    } else {
<span class="nc" id="L253">      LOG.info(&quot;Not initing OCSP reload timers, there are already some.&quot;);</span>
    }
<span class="nc" id="L255">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void reloadOcspExtensionsCache() {
<span class="nc" id="L260">    OcspExtensionsCache.INSTANCE.reloadCache();</span>
<span class="nc" id="L261">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void clearCTFailFastCache() {
    final CertificateTransparency ct =
<span class="nc" id="L267">        CertificateTransparencyFactory.getInstance();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">    if (ct != null) {</span>
<span class="nc" id="L269">      ct.clearCaches();</span>
    }
<span class="nc" id="L271">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void clearOcspRequestSignerRevocationStatusCache() {
<span class="nc" id="L276">    OcspRequestSignerStatusCache.INSTANCE.flush();</span>
<span class="nc" id="L277">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void reloadOcspSigningCache() {
<span class="nc bnc" id="L282" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L283">      LOG.trace(&quot;&gt;reloadOcspSigningCache&quot;);</span>
    }
    // Cancel any waiting timers of this type
<span class="nc" id="L286">    cancelTimers(TIMERID_OCSPSIGNINGCACHE);</span>
    try {
      // Verify card key holder
<span class="nc bnc" id="L289" title="All 2 branches missed.">      if (LOG.isDebugEnabled()</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">          &amp;&amp; (CardKeyHolder.getInstance().getCardKeys() == null)) {</span>
<span class="nc" id="L291">        LOG.debug(</span>
<span class="nc" id="L292">            INTRES.getLocalizedMessage(</span>
                &quot;ocsp.classnotfound&quot;, HARD_TOKEN_CLASS_NAME));
      }
<span class="nc" id="L295">      GlobalOcspConfiguration ocspConfiguration =</span>
          (GlobalOcspConfiguration)
<span class="nc" id="L297">              globalConfigurationSession.getCachedConfiguration(</span>
                  GlobalOcspConfiguration.OCSP_CONFIGURATION_ID);
<span class="nc" id="L299">      OcspSigningCache.INSTANCE.stagingStart();</span>
      try {
        // Populate OcspSigningCache
        // Add all potential CA's as OCSP responders to the staging area
<span class="nc bnc" id="L303" title="All 2 branches missed.">        for (final Integer caId : caSession.getAllCaIds()) {</span>
<span class="nc" id="L304">          final List&lt;X509Certificate&gt; caCertificateChain =</span>
              new ArrayList&lt;X509Certificate&gt;();

<span class="nc" id="L307">          final CAInfo caInfo = caSession.getCAInfoInternal(caId.intValue());</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">          if (caInfo == null || caInfo.getCAType() == CAInfo.CATYPE_CVC) {</span>
            // Bravely ignore OCSP for CVC CAs
<span class="nc" id="L310">            continue;</span>
          }
<span class="nc bnc" id="L312" title="All 2 branches missed.">          if (caInfo.getStatus() == CAConstants.CA_ACTIVE) {</span>
            // Cache active CAs as signers
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L315">              LOG.debug(</span>
                  &quot;Processing X509 CA &quot;
<span class="nc" id="L317">                      + caInfo.getName()</span>
                      + &quot; (&quot;
<span class="nc" id="L319">                      + caInfo.getCAId()</span>
                      + &quot;).&quot;);
            }
<span class="nc" id="L322">            final CAToken caToken = caInfo.getCAToken();</span>
<span class="nc" id="L323">            final CryptoToken cryptoToken =</span>
<span class="nc" id="L324">                cryptoTokenSession.getCryptoToken(caToken.getCryptoTokenId());</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (cryptoToken == null) {</span>
<span class="nc" id="L326">              LOG.info(</span>
                  &quot;Excluding CA with id &quot;
                      + caId
                      + &quot; for OCSP signing consideration due to missing&quot;
                      + &quot; CryptoToken.&quot;);
<span class="nc" id="L331">              continue;</span>
            }
<span class="nc bnc" id="L333" title="All 2 branches missed.">            for (final Certificate certificate : caInfo.getCertificateChain()) {</span>
<span class="nc" id="L334">              caCertificateChain.add((X509Certificate) certificate);</span>
<span class="nc" id="L335">            }</span>
            final String keyPairAlias;
            try {
<span class="nc" id="L338">              keyPairAlias =</span>
<span class="nc" id="L339">                  caToken.getAliasFromPurpose(</span>
                      CATokenConstants.CAKEYPURPOSE_CERTSIGN);
<span class="nc" id="L341">            } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L342">              LOG.warn(</span>
                  &quot;Referenced private key with purpose &quot;
                      + CATokenConstants.CAKEYPURPOSE_CERTSIGN
                      + &quot; could not be used. CryptoToken is off-line for CA&quot;
                      + &quot; with id &quot;
                      + caId
                      + &quot;: &quot;
<span class="nc" id="L349">                      + e.getMessage());</span>
<span class="nc" id="L350">              continue;</span>
<span class="nc" id="L351">            }</span>
            final PrivateKey privateKey;
            try {
<span class="nc" id="L354">              privateKey = cryptoToken.getPrivateKey(keyPairAlias);</span>
<span class="nc" id="L355">            } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L356">              LOG.warn(</span>
                  &quot;Referenced private key with alias &quot;
                      + keyPairAlias
                      + &quot; could not be used. CryptoToken is off-line for CA&quot;
                      + &quot; with id &quot;
                      + caId
                      + &quot;: &quot;
<span class="nc" id="L363">                      + e.getMessage());</span>
<span class="nc" id="L364">              continue;</span>
<span class="nc" id="L365">            }</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (privateKey == null) {</span>
<span class="nc" id="L367">              LOG.warn(</span>
                  &quot;Referenced private key with alias &quot;
                      + keyPairAlias
                      + &quot; does not exist. Ignoring CA with id &quot;
                      + caId);
<span class="nc" id="L372">              continue;</span>
            }
<span class="nc" id="L374">            final String signatureProviderName =</span>
<span class="nc" id="L375">                cryptoToken.getSignProviderName();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (caCertificateChain.size() &gt; 0) {</span>
<span class="nc" id="L377">              X509Certificate caCertificate = caCertificateChain.get(0);</span>
<span class="nc" id="L378">              final CertificateStatus caCertificateStatus =</span>
<span class="nc" id="L379">                  getRevocationStatusWhenCasPrivateKeyIsCompromised(</span>
                      caCertificate, false);
<span class="nc" id="L381">              OcspSigningCache.INSTANCE.stagingAdd(</span>
                  new OcspSigningCacheEntry(
                      caCertificate,
                      caCertificateStatus,
                      caCertificateChain,
                      null,
                      privateKey,
                      signatureProviderName,
                      null,
<span class="nc" id="L390">                      ocspConfiguration.getOcspResponderIdType()));</span>
              // Check if CA cert has been revoked (only key compromise as
              // returned above). Always make this check, even if this CA has an
              // OCSP signing certificate, because
              // signing will still fail even if the signing cert is valid.
              // Shouldn't happen, but log it just in case.
<span class="nc bnc" id="L396" title="All 2 branches missed.">              if (caCertificateStatus.equals(CertificateStatus.REVOKED)) {</span>
<span class="nc" id="L397">                LOG.warn(</span>
                    &quot;Active CA with subject DN '&quot;
<span class="nc" id="L399">                        + CertTools.getSubjectDN(caCertificate)</span>
                        + &quot;' and serial number &quot;
<span class="nc" id="L401">                        + CertTools.getSerialNumber(caCertificate)</span>
                        + &quot; has a revoked certificate with reason &quot;
<span class="nc" id="L403">                        + caCertificateStatus.getRevocationReason()</span>
                        + &quot;.&quot;);
              }
              // Check if CA cert is expired
<span class="nc bnc" id="L407" title="All 2 branches missed.">              if (!CertTools.isCertificateValid(caCertificate, true)) {</span>
<span class="nc" id="L408">                LOG.warn(</span>
                    &quot;Active CA with subject DN '&quot;
<span class="nc" id="L410">                        + CertTools.getSubjectDN(caCertificate)</span>
                        + &quot;' and serial number &quot;
<span class="nc" id="L412">                        + CertTools.getSerialNumber(caCertificate)</span>
                        + &quot; has an expired certificate with expiration date &quot;
<span class="nc" id="L414">                        + CertTools.getNotAfter(caCertificate)</span>
                        + &quot;.&quot;);
              }
<span class="nc" id="L417">            } else {</span>
<span class="nc" id="L418">              LOG.warn(</span>
                  &quot;CA with ID &quot;
                      + caId
                      + &quot; appears to lack a certificate in the database. This&quot;
                      + &quot; may be a serious error if not in a test&quot;
                      + &quot; environment.&quot;);
            }
<span class="nc bnc" id="L425" title="All 2 branches missed.">          } else if (caInfo.getStatus() == CAConstants.CA_EXTERNAL) {</span>
            // If set, all external CA's without a keybinding (set below) will
            // be responded to by the default responder.
<span class="nc bnc" id="L428" title="All 2 branches missed.">            for (final Certificate certificate : caInfo.getCertificateChain()) {</span>
<span class="nc" id="L429">              caCertificateChain.add((X509Certificate) certificate);</span>
<span class="nc" id="L430">            }</span>
<span class="nc" id="L431">            final CertificateStatus caCertificateStatus =</span>
<span class="nc" id="L432">                getRevocationStatusWhenCasPrivateKeyIsCompromised(</span>
<span class="nc" id="L433">                    caCertificateChain.get(0), false);</span>
            // Check if CA cert has been revoked (only key compromise as
            // returned above). Always make this check, even if this CA has an
            // OCSP signing certificate, because
            // signing will still fail even if the signing cert is valid.
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (caCertificateStatus.equals(CertificateStatus.REVOKED)) {</span>
<span class="nc" id="L439">              LOG.info(</span>
                  &quot;External CA with subject DN '&quot;
<span class="nc" id="L441">                      + CertTools.getSubjectDN(caCertificateChain.get(0))</span>
                      + &quot;' and serial number &quot;
<span class="nc" id="L443">                      + CertTools.getSerialNumber(caCertificateChain.get(0))</span>
                      + &quot; has a revoked certificate with reason &quot;
<span class="nc" id="L445">                      + caCertificateStatus.getRevocationReason()</span>
                      + &quot;.&quot;);
            }
            // Check if CA cert is expired
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (!CertTools.isCertificateValid(</span>
<span class="nc" id="L450">                caCertificateChain.get(0), false)) {</span>
<span class="nc" id="L451">              LOG.info(</span>
                  &quot;External CA with subject DN '&quot;
<span class="nc" id="L453">                      + CertTools.getSubjectDN(caCertificateChain.get(0))</span>
                      + &quot;' and serial number &quot;
<span class="nc" id="L455">                      + CertTools.getSerialNumber(caCertificateChain.get(0))</span>
                      + &quot; has an expired certificate with expiration date &quot;
<span class="nc" id="L457">                      + CertTools.getNotAfter(caCertificateChain.get(0))</span>
                      + &quot;.&quot;);
            }
            // Add an entry with just a chain and nothing else
<span class="nc" id="L461">            OcspSigningCache.INSTANCE.stagingAdd(</span>
                new OcspSigningCacheEntry(
<span class="nc" id="L463">                    caCertificateChain.get(0),</span>
                    caCertificateStatus,
                    null,
                    null,
                    null,
                    null,
                    null,
<span class="nc" id="L470">                    ocspConfiguration.getOcspResponderIdType()));</span>
          }
<span class="nc" id="L472">        }</span>
        // Add all potential InternalKeyBindings as OCSP responders to the
        // staging area, overwriting CA entries from before
        for (final int internalKeyBindingId
<span class="nc bnc" id="L476" title="All 2 branches missed.">            : internalKeyBindingDataSession.getIds(</span>
                OcspKeyBinding.IMPLEMENTATION_ALIAS)) {
<span class="nc" id="L478">          final OcspKeyBinding ocspKeyBinding =</span>
              (OcspKeyBinding)
<span class="nc" id="L480">                  internalKeyBindingDataSession.getInternalKeyBinding(</span>
                      internalKeyBindingId);
<span class="nc bnc" id="L482" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L483">            LOG.debug(</span>
                &quot;Processing &quot;
<span class="nc" id="L485">                    + ocspKeyBinding.getName()</span>
                    + &quot; (&quot;
<span class="nc" id="L487">                    + ocspKeyBinding.getId()</span>
                    + &quot;)&quot;);
          }
<span class="nc" id="L490">          if (!ocspKeyBinding</span>
<span class="nc" id="L491">              .getStatus()</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">              .equals(InternalKeyBindingStatus.ACTIVE)) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L494">              LOG.debug(&quot;Ignoring OcspKeyBinding since it is not active.&quot;);</span>
            }
            continue;
          }
<span class="nc" id="L498">          final X509Certificate ocspSigningCertificate =</span>
              (X509Certificate)
<span class="nc" id="L500">                  certificateStoreSession.findCertificateByFingerprint(</span>
<span class="nc" id="L501">                      ocspKeyBinding.getCertificateId());</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">          if (ocspSigningCertificate == null) {</span>
<span class="nc" id="L503">            LOG.warn(</span>
                &quot;OCSP signing certificate with referenced fingerprint &quot;
<span class="nc" id="L505">                    + ocspKeyBinding.getCertificateId()</span>
                    + &quot; does not exist. Ignoring internalKeyBinding with id &quot;
<span class="nc" id="L507">                    + ocspKeyBinding.getId());</span>
<span class="nc" id="L508">            continue;</span>
          }
          // Make the same check as above
<span class="nc" id="L511">          if (certificateStoreSession</span>
<span class="nc" id="L512">              .getStatus(</span>
<span class="nc" id="L513">                  CertTools.getIssuerDN(ocspSigningCertificate),</span>
<span class="nc" id="L514">                  CertTools.getSerialNumber(ocspSigningCertificate))</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">              .equals(CertificateStatus.REVOKED)) {</span>
<span class="nc" id="L516">            LOG.warn(</span>
                &quot;OCSP Responder certificate with subject DN '&quot;
<span class="nc" id="L518">                    + CertTools.getSubjectDN(ocspSigningCertificate)</span>
                    + &quot;' and serial number &quot;
<span class="nc" id="L520">                    + CertTools.getSerialNumber(ocspSigningCertificate)</span>
                    + &quot; is revoked.&quot;);
          }
          // Check if signing cert is expired
<span class="nc bnc" id="L524" title="All 2 branches missed.">          if (!CertTools.isCertificateValid(ocspSigningCertificate, true)) {</span>
<span class="nc" id="L525">            LOG.warn(</span>
                &quot;OCSP Responder certificate with subject DN '&quot;
<span class="nc" id="L527">                    + CertTools.getSubjectDN(ocspSigningCertificate)</span>
                    + &quot;' and serial number &quot;
<span class="nc" id="L529">                    + CertTools.getSerialNumber(ocspSigningCertificate)</span>
                    + &quot; is expired.&quot;);
          }

<span class="nc" id="L533">          OcspSigningCacheEntry ocspSigningCacheEntry =</span>
<span class="nc" id="L534">              makeOcspSigningCacheEntry(ocspSigningCertificate, ocspKeyBinding);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">          if (ocspSigningCacheEntry == null) {</span>
<span class="nc" id="L536">            continue;</span>
          } else {
<span class="nc" id="L538">            OcspSigningCache.INSTANCE.stagingAdd(ocspSigningCacheEntry);</span>
          }
<span class="nc" id="L540">        }</span>
<span class="nc" id="L541">        OcspSigningCache.INSTANCE.stagingCommit(</span>
<span class="nc" id="L542">            ocspConfiguration.getOcspDefaultResponderReference());</span>
      } finally {
<span class="nc" id="L544">        OcspSigningCache.INSTANCE.stagingRelease();</span>
      }
    } finally {
      // Schedule a new timer of this type
<span class="nc" id="L548">      addTimer(</span>
<span class="nc" id="L549">          OcspConfiguration.getSigningCertsValidTimeInMilliseconds(),</span>
<span class="nc" id="L550">          TIMERID_OCSPSIGNINGCACHE);</span>
    }
<span class="nc" id="L552">  }</span>

  /**
   * Constructs an OcspSigningCacheEntry from the given parameters.
   *
   * @param ocspSigningCertificate The signing certificate associated with the
   *     key binding. May be found separately, so given as a separate parameter
   * @param ocspKeyBinding the Key Binding to base the cache entry off of.
   * @return an OcspSigningCacheEntry, or null if any error was encountered.
   */
  private OcspSigningCacheEntry makeOcspSigningCacheEntry(
      final X509Certificate ocspSigningCertificate,
      final OcspKeyBinding ocspKeyBinding) {
<span class="nc" id="L565">    final List&lt;X509Certificate&gt; caCertificateChain =</span>
<span class="nc" id="L566">        getCaCertificateChain(ocspSigningCertificate);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">    if (caCertificateChain == null) {</span>
<span class="nc" id="L568">      LOG.warn(</span>
          &quot;OcspKeyBinding &quot;
<span class="nc" id="L570">              + ocspKeyBinding.getName()</span>
              + &quot; ( &quot;
<span class="nc" id="L572">              + ocspKeyBinding.getId()</span>
              + &quot;) has a signing certificate, but no chain and will be&quot;
              + &quot; ignored.&quot;);
<span class="nc" id="L575">      return null;</span>
    }
<span class="nc" id="L577">    final CryptoToken cryptoToken =</span>
<span class="nc" id="L578">        cryptoTokenSession.getCryptoToken(ocspKeyBinding.getCryptoTokenId());</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">    if (cryptoToken == null) {</span>
<span class="nc" id="L580">      LOG.warn(</span>
          &quot;Referenced CryptoToken with id &quot;
<span class="nc" id="L582">              + ocspKeyBinding.getCryptoTokenId()</span>
              + &quot; does not exist. Ignoring OcspKeyBinding with id &quot;
<span class="nc" id="L584">              + ocspKeyBinding.getId());</span>
<span class="nc" id="L585">      return null;</span>
    }
    final PrivateKey privateKey;
    try {
<span class="nc" id="L589">      privateKey = cryptoToken.getPrivateKey(ocspKeyBinding.getKeyPairAlias());</span>
<span class="nc" id="L590">    } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L591">      LOG.warn(</span>
          &quot;Referenced private key with alias &quot;
<span class="nc" id="L593">              + ocspKeyBinding.getKeyPairAlias()</span>
              + &quot; could not be used. CryptoToken is off-line for&quot;
              + &quot; OcspKeyBinding with id &quot;
<span class="nc" id="L596">              + ocspKeyBinding.getId()</span>
              + &quot;: &quot;
<span class="nc" id="L598">              + e.getMessage());</span>
<span class="nc" id="L599">      return null;</span>
<span class="nc" id="L600">    }</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">    if (privateKey == null) {</span>
<span class="nc" id="L602">      LOG.warn(</span>
          &quot;Referenced private key with alias &quot;
<span class="nc" id="L604">              + ocspKeyBinding.getKeyPairAlias()</span>
              + &quot; does not exist. Ignoring OcspKeyBinding with id &quot;
<span class="nc" id="L606">              + ocspKeyBinding.getId());</span>
<span class="nc" id="L607">      return null;</span>
    }
<span class="nc" id="L609">    final String signatureProviderName = cryptoToken.getSignProviderName();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L611">      LOG.debug(</span>
          &quot;Adding OcspKeyBinding &quot;
<span class="nc" id="L613">              + ocspKeyBinding.getId()</span>
              + &quot;, &quot;
<span class="nc" id="L615">              + ocspKeyBinding.getName());</span>
    }
<span class="nc" id="L617">    final CertificateStatus certificateStatus =</span>
<span class="nc" id="L618">        getRevocationStatusWhenCasPrivateKeyIsCompromised(</span>
<span class="nc" id="L619">            caCertificateChain.get(0), true);</span>
    OcspKeyBinding.ResponderIdType respIdType;
<span class="nc bnc" id="L621" title="All 2 branches missed.">    if (ResponderIdType.NAME.equals(ocspKeyBinding.getResponderIdType())) {</span>
<span class="nc" id="L622">      respIdType = OcspKeyBinding.ResponderIdType.NAME;</span>
    } else {
<span class="nc" id="L624">      respIdType = OcspKeyBinding.ResponderIdType.KEYHASH;</span>
    }
<span class="nc" id="L626">    return new OcspSigningCacheEntry(</span>
<span class="nc" id="L627">        caCertificateChain.get(0),</span>
        certificateStatus,
        caCertificateChain,
        ocspSigningCertificate,
        privateKey,
        signatureProviderName,
        ocspKeyBinding,
        respIdType);
  }

  /**
   * RFC 6960 Section 2.7 states that if it is known CA's private key has been
   * compromised, it MAY return the &quot;revoked&quot; state for all certificates issued
   * by that CA.
   *
   * &lt;p&gt;We interpret this as if the revocation reasons is one of
   * &quot;keyCompromise&quot;, &quot;cACompromise&quot; or &quot;aACompromise&quot; we know this.
   * Additionally, if the &quot;unspecified&quot; reason is used we will consider this as
   * a known private key compromise. (Safety first!)
   *
   * @param caCertificate the X.509 CA certificate to check
   * @param suppressInfo set to true to only do debug logging instead of info
   *     logging
   * @return OK or the revocation status that we will use if the CA is revoked
   *     (same revocation date, but with reasonCode &quot;cACompromise&quot;)
   */
  private CertificateStatus getRevocationStatusWhenCasPrivateKeyIsCompromised(
      final X509Certificate caCertificate, final boolean suppressInfo) {
<span class="nc" id="L655">    final String issuerDn = CertTools.getIssuerDN(caCertificate);</span>
<span class="nc" id="L656">    final BigInteger serialNumber = CertTools.getSerialNumber(caCertificate);</span>
<span class="nc" id="L657">    final CertificateStatus certificateStatus =</span>
<span class="nc" id="L658">        certificateStoreSession.getStatus(issuerDn, serialNumber);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">    if (certificateStatus.isRevoked()) {</span>
<span class="nc" id="L660">      final String subjectDn = CertTools.getSubjectDN(caCertificate);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">      if (certificateStatus.getRevocationReason()</span>
              == RevokedCertInfo.REVOCATION_REASON_UNSPECIFIED
<span class="nc bnc" id="L663" title="All 2 branches missed.">          || certificateStatus.getRevocationReason()</span>
              == RevokedCertInfo.REVOCATION_REASON_AACOMPROMISE
<span class="nc bnc" id="L665" title="All 2 branches missed.">          || certificateStatus.getRevocationReason()</span>
              == RevokedCertInfo.REVOCATION_REASON_CACOMPROMISE
<span class="nc bnc" id="L667" title="All 2 branches missed.">          || certificateStatus.getRevocationReason()</span>
              == RevokedCertInfo.REVOCATION_REASON_KEYCOMPROMISE) {
<span class="nc" id="L669">        final String msg =</span>
            &quot;CA certificate Subject DN '&quot;
                + subjectDn
                + &quot;', Issuer DN '&quot;
                + issuerDn
                + &quot;' and serial number &quot;
<span class="nc" id="L675">                + serialNumber.toString()</span>
                + &quot; (0x&quot;
<span class="nc" id="L677">                + serialNumber.toString(16)</span>
                + &quot;) is revoked with reason code &quot;
<span class="nc" id="L679">                + certificateStatus.getRevocationReason()</span>
                + &quot;. The cACompromise revocation reason will be used for all&quot;
                + &quot; certs issued by this CA.&quot;;
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (suppressInfo) {</span>
<span class="nc" id="L683">          LOG.debug(msg);</span>
        } else {
<span class="nc" id="L685">          LOG.info(msg);</span>
        }
<span class="nc" id="L687">        return new CertificateStatus(</span>
<span class="nc" id="L688">            certificateStatus.toString(),</span>
<span class="nc" id="L689">            certificateStatus.getRevocationDate().getTime(),</span>
            RevokedCertInfo.REVOCATION_REASON_CACOMPROMISE,
<span class="nc" id="L691">            certificateStatus.getCertificateProfileId());</span>
      }
<span class="nc" id="L693">      final String msg =</span>
          &quot;CA certificate Subject DN '&quot;
              + subjectDn
              + &quot;', Issuer DN '&quot;
              + issuerDn
              + &quot;' and serial number &quot;
<span class="nc" id="L699">              + serialNumber.toString()</span>
              + &quot; (0x&quot;
<span class="nc" id="L701">              + serialNumber.toString(16)</span>
              + &quot;) is revoked with reason code &quot;
<span class="nc" id="L703">              + certificateStatus.getRevocationReason()</span>
              + &quot;. &quot;
              + &quot;Status of individual leaf certificate will still be checked.&quot;;
<span class="nc bnc" id="L706" title="All 2 branches missed.">      if (suppressInfo) {</span>
<span class="nc" id="L707">        LOG.debug(msg);</span>
      } else {
<span class="nc" id="L709">        LOG.info(msg);</span>
      }
    }
<span class="nc" id="L712">    return CertificateStatus.OK;</span>
  }

  private List&lt;X509Certificate&gt; getCaCertificateChain(
      final X509Certificate leafCertificate) {
<span class="nc" id="L717">    final List&lt;X509Certificate&gt; caCertificateChain =</span>
        new ArrayList&lt;X509Certificate&gt;();
<span class="nc" id="L719">    X509Certificate currentLevelCertificate = leafCertificate;</span>
<span class="nc" id="L720">    while (!CertTools.getIssuerDN(currentLevelCertificate)</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">        .equals(CertTools.getSubjectDN(currentLevelCertificate))) {</span>
<span class="nc" id="L722">      final String issuerDn = CertTools.getIssuerDN(currentLevelCertificate);</span>
<span class="nc" id="L723">      currentLevelCertificate =</span>
<span class="nc" id="L724">          certificateStoreSession.findLatestX509CertificateBySubject(issuerDn);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">      if (currentLevelCertificate == null) {</span>
<span class="nc" id="L726">        LOG.warn(</span>
            &quot;Unable to build certificate chain for OCSP signing certificate&quot;
                + &quot; with Subject DN '&quot;
<span class="nc" id="L729">                + CertTools.getSubjectDN(leafCertificate)</span>
                + &quot;'. CA with Subject DN '&quot;
                + issuerDn
                + &quot;' is missing in the database.&quot;);
<span class="nc" id="L733">        return null;</span>
      }
<span class="nc" id="L735">      caCertificateChain.add(currentLevelCertificate);</span>
<span class="nc" id="L736">    }</span>
    try {
<span class="nc" id="L738">      CertTools.verify(</span>
          leafCertificate,
          caCertificateChain,
          new Date(),
<span class="nc" id="L742">          new EkuPKIXCertPathChecker(KeyPurposeId.id_kp_OCSPSigning.getId()));</span>
<span class="nc" id="L743">    } catch (CertPathValidatorException e) {</span>
      // Apparently the built chain could not be used to validate the leaf
      // certificate
      // this could happen if the CA keys were renewed, but the subject DN did
      // not change
<span class="nc" id="L748">      LOG.info(</span>
          &quot;Unable to build a valid certificate chain for OCSP signing&quot;
              + &quot; certificate with Subject DN '&quot;
<span class="nc" id="L751">              + CertTools.getSubjectDN(leafCertificate)</span>
              + &quot;' and Issuer DN &quot;
<span class="nc" id="L753">              + CertTools.getIssuerDN(leafCertificate)</span>
              + &quot;' using the latest CA certificate(s) in the database. Trying&quot;
              + &quot; to recover from exception: &quot;
<span class="nc" id="L756">              + e.getMessage());</span>
<span class="nc" id="L757">      final CertificateInfo certificateInfo =</span>
<span class="nc" id="L758">          certificateStoreSession.getCertificateInfo(</span>
<span class="nc" id="L759">              CertTools.getFingerprintAsString(leafCertificate));</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">      if (certificateInfo == null) {</span>
<span class="nc" id="L761">        return null;</span>
      }
<span class="nc" id="L763">      final List&lt;Certificate&gt; chainByFingerPrints =</span>
<span class="nc" id="L764">          certificateStoreSession.getCertificateChain(certificateInfo);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">      if (chainByFingerPrints.size() &gt; 0) {</span>
        // Remove the leaf certificate itself
<span class="nc" id="L767">        chainByFingerPrints.remove(0);</span>
      }
<span class="nc" id="L769">      caCertificateChain.clear();</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">      for (final Certificate current : chainByFingerPrints) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (current instanceof X509Certificate) {</span>
<span class="nc" id="L772">          caCertificateChain.add((X509Certificate) current);</span>
        } else {
<span class="nc" id="L774">          LOG.warn(</span>
              &quot;Unable to build certificate chain for OCSP signing certificate&quot;
                  + &quot; with Subject DN '&quot;
<span class="nc" id="L777">                  + CertTools.getSubjectDN(leafCertificate)</span>
                  + &quot;' and Issuer DN '&quot;
<span class="nc" id="L779">                  + CertTools.getIssuerDN(leafCertificate)</span>
                  + &quot;'. CA certificate chain contains non-X509 certificates.&quot;);
<span class="nc" id="L781">          return null;</span>
        }
<span class="nc" id="L783">      }</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">      if (caCertificateChain.isEmpty()) {</span>
<span class="nc" id="L785">        LOG.warn(</span>
            &quot;Unable to build certificate chain for OCSP signing certificate&quot;
                + &quot; with Subject DN '&quot;
<span class="nc" id="L788">                + CertTools.getSubjectDN(leafCertificate)</span>
                + &quot;' and Issuer DN '&quot;
<span class="nc" id="L790">                + CertTools.getIssuerDN(leafCertificate)</span>
                + &quot;''. CA certificate(s) are missing in the database.&quot;);
<span class="nc" id="L792">        return null;</span>
      }
      try {
<span class="nc" id="L795">        CertTools.verify(</span>
            leafCertificate,
            caCertificateChain,
            new Date(),
<span class="nc" id="L799">            new EkuPKIXCertPathChecker(KeyPurposeId.id_kp_OCSPSigning.getId()));</span>
<span class="nc" id="L800">      } catch (Exception e2) {</span>
<span class="nc" id="L801">        LOG.warn(</span>
            &quot;Unable to build certificate chain for OCSP signing certificate&quot;
                + &quot; with Subject DN '&quot;
<span class="nc" id="L804">                + CertTools.getSubjectDN(leafCertificate)</span>
                + &quot;' and Issuer DN '&quot;
<span class="nc" id="L806">                + CertTools.getIssuerDN(leafCertificate)</span>
                + &quot;''. Found CA certificate(s) cannot be used for validation: &quot;
<span class="nc" id="L808">                + e2.getMessage());</span>
<span class="nc" id="L809">        return null;</span>
<span class="nc" id="L810">      }</span>
<span class="nc" id="L811">      LOG.info(</span>
          &quot;Recovered and managed to build a valid certificate chain for OCSP&quot;
              + &quot; signing certificate with Subject DN '&quot;
<span class="nc" id="L814">              + CertTools.getSubjectDN(leafCertificate)</span>
              + &quot;' and Issuer DN '&quot;
<span class="nc" id="L816">              + CertTools.getIssuerDN(leafCertificate)</span>
              + &quot;'.&quot;);
<span class="nc" id="L818">    }</span>
<span class="nc" id="L819">    return caCertificateChain;</span>
  }

  @Override
  public void setCanlog(final boolean canLog) {
<span class="nc" id="L824">    CanLogCache.INSTANCE.setCanLog(canLog);</span>
<span class="nc" id="L825">  }</span>

  /**
   * This method exists solely to avoid code duplication when error handling in
   * getOcspResponse.
   *
   * @param responseGenerator A OCSPRespBuilder for generating a response with
   *     state INTERNAL_ERROR.
   * @param transactionLogger The TransactionLogger for this call.
   * @param auditLogger The AuditLogger for this call.
   * @param e The thrown exception.
   * @return a response with state INTERNAL_ERROR.
   * @throws OCSPException if generation of the response failed.
   */
  private OCSPResp processDefaultError(
      final OCSPRespBuilder responseGenerator,
      final TransactionLogger transactionLogger,
      final AuditLogger auditLogger,
      final Throwable e)
      throws OCSPException {
<span class="nc bnc" id="L845" title="All 2 branches missed.">    if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L846">      transactionLogger.paramPut(</span>
          PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
    }
<span class="nc bnc" id="L849" title="All 2 branches missed.">    if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L850">      auditLogger.paramPut(</span>
          PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
    }
<span class="nc" id="L853">    String errMsg =</span>
<span class="nc" id="L854">        INTRES.getLocalizedMessage(&quot;ocsp.errorprocessreq&quot;, e.getMessage());</span>
<span class="nc" id="L855">    LOG.error(errMsg, e);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">    if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L857">      transactionLogger.paramPut(</span>
<span class="nc" id="L858">          TransactionLogger.STATUS, OCSPRespBuilder.INTERNAL_ERROR);</span>
<span class="nc" id="L859">      transactionLogger.writeln();</span>
    }
<span class="nc bnc" id="L861" title="All 2 branches missed.">    if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L862">      auditLogger.paramPut(AuditLogger.STATUS, OCSPRespBuilder.INTERNAL_ERROR);</span>
    }
<span class="nc" id="L864">    return responseGenerator.build(</span>
        OCSPRespBuilder.INTERNAL_ERROR,
        null); // RFC 2560: responseBytes are not set on error.
  }

  /**
   * Select the preferred OCSP response sigAlg according to RFC6960 Section
   * 4.4.7 in the following order:
   *
   * &lt;p&gt;1. Select an algorithm specified as a preferred signature algorithm in
   * the client request if it is an acceptable algorithm by EJBCA. 2. Select the
   * signature algorithm used to sign a certificate revocation list (CRL) issued
   * by the certificate issuer providing status information for the certificate
   * specified by CertID. (NOT APPLIED) 3. Select the signature algorithm used
   * to sign the OCSPRequest if it is an acceptable algorithm in EJBCA. 4.
   * Select a signature algorithm that has been advertised as being the default
   * signature algorithm for the signing service using an out-of-band mechanism.
   * 5. Select a mandatory or recommended signature algorithm specified for the
   * version of OCSP in use, aka. specified in the properties file.
   *
   * &lt;p&gt;The acceptable algorithm by EJBCA are the algorithms specified in
   * ocsp.properties file in 'ocsp.signaturealgorithm'
   *
   * @param req request
   * @param ocspSigningCacheEntry Signing cache
   * @param signerCert Certificate
   * @return Algorithm
   */
  private String getSigAlg(
      final OCSPReq req,
      final OcspSigningCacheEntry ocspSigningCacheEntry,
      final X509Certificate signerCert) {
<span class="nc" id="L896">    String sigAlg = null;</span>
<span class="nc" id="L897">    PublicKey pk = signerCert.getPublicKey();</span>
    // Start with the preferred signature algorithm in the OCSP request
<span class="nc" id="L899">    final Extension preferredSigAlgExtension =</span>
<span class="nc" id="L900">        req.getExtension(</span>
            new ASN1ObjectIdentifier(
                OCSPObjectIdentifiers.id_pkix_ocsp + &quot;.8&quot;));
<span class="nc bnc" id="L903" title="All 2 branches missed.">    if (preferredSigAlgExtension != null) {</span>
<span class="nc" id="L904">      final ASN1Sequence preferredSignatureAlgorithms =</span>
<span class="nc" id="L905">          ASN1Sequence.getInstance(preferredSigAlgExtension.getParsedValue());</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">      for (int i = 0; i &lt; preferredSignatureAlgorithms.size(); i++) {</span>
<span class="nc" id="L907">        final ASN1Encodable asn1Encodable =</span>
<span class="nc" id="L908">            preferredSignatureAlgorithms.getObjectAt(i);</span>
        final ASN1ObjectIdentifier algorithmOid;
<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (asn1Encodable instanceof ASN1ObjectIdentifier) {</span>
          // Handle client requests that were adapted to EJBCA 6.1.0's
          // implementation
<span class="nc" id="L913">          LOG.info(</span>
              &quot;OCSP request's PreferredSignatureAlgorithms did not contain an&quot;
                  + &quot; PreferredSignatureAlgorithm, but instead an algorithm&quot;
                  + &quot; OID. This will not be supported in a future versions of&quot;
                  + &quot; EJBCA.&quot;);
<span class="nc" id="L918">          algorithmOid = (ASN1ObjectIdentifier) asn1Encodable;</span>
        } else {
          // Handle client requests that provide a proper AlgorithmIdentifier as
          // specified in RFC 6960 + RFC 5280
<span class="nc" id="L922">          final ASN1Sequence preferredSignatureAlgorithm =</span>
<span class="nc" id="L923">              ASN1Sequence.getInstance(asn1Encodable);</span>
<span class="nc" id="L924">          final AlgorithmIdentifier algorithmIdentifier =</span>
<span class="nc" id="L925">              AlgorithmIdentifier.getInstance(</span>
<span class="nc" id="L926">                  preferredSignatureAlgorithm.getObjectAt(0));</span>
<span class="nc" id="L927">          algorithmOid = algorithmIdentifier.getAlgorithm();</span>
        }
<span class="nc bnc" id="L929" title="All 2 branches missed.">        if (algorithmOid != null) {</span>
<span class="nc" id="L930">          sigAlg = AlgorithmTools.getAlgorithmNameFromOID(algorithmOid);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">          if (sigAlg != null</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">              &amp;&amp; OcspConfiguration.isAcceptedSignatureAlgorithm(sigAlg)</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">              &amp;&amp; AlgorithmTools.isCompatibleSigAlg(pk, sigAlg)) {</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L935">              LOG.debug(</span>
                  &quot;Using OCSP response signature algorithm extracted from OCSP&quot;
                      + &quot; request extension. &quot;
                      + algorithmOid);
            }
<span class="nc" id="L940">            return sigAlg;</span>
          }
        }
      }
    }
    // the signature algorithm used to sign the OCSPRequest
<span class="nc bnc" id="L946" title="All 2 branches missed.">    if (req.getSignatureAlgOID() != null) {</span>
<span class="nc" id="L947">      sigAlg = AlgorithmTools.getAlgorithmNameFromOID(req.getSignatureAlgOID());</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">      if (OcspConfiguration.isAcceptedSignatureAlgorithm(sigAlg)</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">          &amp;&amp; AlgorithmTools.isCompatibleSigAlg(pk, sigAlg)) {</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L951">          LOG.debug(</span>
              &quot;OCSP response signature algorithm: the signature algorithm used&quot;
                  + &quot; to sign the OCSPRequest. &quot;
                  + sigAlg);
        }
<span class="nc" id="L956">        return sigAlg;</span>
      }
    }
    // The signature algorithm that has been advertised as being the default
    // signature algorithm for the signing service using an
    // out-of-band mechanism.
<span class="nc bnc" id="L962" title="All 2 branches missed.">    if (ocspSigningCacheEntry.isUsingSeparateOcspSigningCertificate()) {</span>
      // If we have an OcspKeyBinding we use this configuration to override the
      // default
<span class="nc" id="L965">      sigAlg =</span>
<span class="nc" id="L966">          ocspSigningCacheEntry.getOcspKeyBinding().getSignatureAlgorithm();</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L968">        LOG.debug(</span>
            &quot;OCSP response signature algorithm: the signature algorithm that&quot;
                + &quot; has been advertised as being the default signature&quot;
                + &quot; algorithm for the signing service using an out-of-band&quot;
                + &quot; mechanism. &quot;
                + sigAlg);
      }
<span class="nc" id="L975">      return sigAlg;</span>
    }
    // The signature algorithm specified for the version of OCSP in use.
<span class="nc" id="L978">    String sigAlgs = OcspConfiguration.getSignatureAlgorithm();</span>
<span class="nc" id="L979">    sigAlg = getSigningAlgFromAlgSelection(sigAlgs, pk);</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L981">      LOG.debug(</span>
          &quot;Using configured signature algorithm to sign OCSP response. &quot;
              + sigAlg);
    }
<span class="nc" id="L985">    return sigAlg;</span>
  }

  /**
   * This method takes byte array and translates it onto a OCSPReq class.
   *
   * @param request the byte array in question.
   * @param remoteAddress The remote address of the HttpRequest associated with
   *     this array.
   * @param transactionLogger A transaction logger.
   * @return OCSP Request
   * @throws MalformedRequestException if malformed
   * @throws SignRequestException thrown if an unsigned request was processed
   *     when system configuration requires that all requests be signed.
   * @throws CertificateException if cert is invalid
   * @throws NoSuchAlgorithmException if algo not found
   * @throws SignRequestSignatureException if sigs fails
   */
  private OCSPReq translateRequestFromByteArray(
      final byte[] request,
      final String remoteAddress,
      final TransactionLogger transactionLogger)
      throws MalformedRequestException, SignRequestException,
          SignRequestSignatureException, CertificateException,
          NoSuchAlgorithmException {
    final OCSPReq ocspRequest;
    try {
<span class="nc" id="L1012">      ocspRequest = new OCSPReq(request);</span>
<span class="nc" id="L1013">    } catch (IOException e) {</span>
<span class="nc" id="L1014">      throw new MalformedRequestException(&quot;Could not form OCSP request&quot;, e);</span>
<span class="nc" id="L1015">    }</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">    if (ocspRequest.getRequestorName() == null) {</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1018">        LOG.debug(&quot;Requestor name is null&quot;);</span>
      }
    } else {
<span class="nc bnc" id="L1021" title="All 4 branches missed.">      if (transactionLogger.isEnabled() || LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1022">        final X500Name requestorDirectoryName =</span>
<span class="nc" id="L1023">            (X500Name) ocspRequest.getRequestorName().getName();</span>
<span class="nc" id="L1024">        final String requestor =</span>
<span class="nc" id="L1025">            CertTools.stringToBCDNString(requestorDirectoryName.toString());</span>
<span class="nc" id="L1026">        final String requestorRaw =</span>
            GeneralName.directoryName
                + &quot;: &quot;
<span class="nc" id="L1029">                + X500Name.getInstance(</span>
                        CeSecoreNameStyle.INSTANCE, requestorDirectoryName)
<span class="nc" id="L1031">                    .toString();</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1033">          transactionLogger.paramPut(TransactionLogger.REQ_NAME, requestor);</span>
<span class="nc" id="L1034">          transactionLogger.paramPut(</span>
              TransactionLogger.REQ_NAME_RAW, requestorRaw);
        }
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1038">          LOG.debug(</span>
              &quot;Requestor name is: '&quot;
                  + requestor
                  + &quot;' Raw: '&quot;
                  + requestorRaw
                  + &quot;'&quot;);
        }
      }
    }
    /*
     * check the signature if contained in request. if the request does not
     * contain a signature and the servlet is configured in the way the a
     * signature is required we send back 'sigRequired' response.
     */
<span class="nc bnc" id="L1052" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1053">      LOG.debug(&quot;Incoming OCSP request is signed : &quot; + ocspRequest.isSigned());</span>
    }
<span class="nc bnc" id="L1055" title="All 2 branches missed.">    if (ocspRequest.isSigned()) {</span>
<span class="nc" id="L1056">      final X509Certificate signercert =</span>
<span class="nc" id="L1057">          checkRequestSignature(remoteAddress, ocspRequest);</span>
<span class="nc" id="L1058">      final String signercertIssuerName = CertTools.getIssuerDN(signercert);</span>
<span class="nc" id="L1059">      final BigInteger signercertSerNo = CertTools.getSerialNumber(signercert);</span>
<span class="nc" id="L1060">      final String signercertSubjectName = CertTools.getSubjectDN(signercert);</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1062">        transactionLogger.paramPut(</span>
            TransactionLogger.SIGN_ISSUER_NAME_DN, signercertIssuerName);
<span class="nc" id="L1064">        transactionLogger.paramPut(</span>
            TransactionLogger.SIGN_SERIAL_NO,
<span class="nc" id="L1066">            signercert.getSerialNumber().toByteArray());</span>
<span class="nc" id="L1067">        transactionLogger.paramPut(</span>
            TransactionLogger.SIGN_SUBJECT_NAME, signercertSubjectName);
<span class="nc" id="L1069">        transactionLogger.paramPut(</span>
            PatternLogger.REPLY_TIME, TransactionLogger.REPLY_TIME);
      }
      // Check if we have configured request verification using the old property
      // file way..
      boolean enforceRequestSigning =
<span class="nc" id="L1075">          OcspConfiguration.getEnforceRequestSigning();</span>
      // Next, check if there is an OcspKeyBinding where signing is required and
      // configured for this request
      // In the case where multiple requests are bundled together they all must
      // be trusting the signer
<span class="nc bnc" id="L1080" title="All 2 branches missed.">      for (final Req req : ocspRequest.getRequestList()) {</span>
<span class="nc" id="L1081">        OcspSigningCacheEntry ocspSigningCacheEntry =</span>
<span class="nc" id="L1082">            OcspSigningCache.INSTANCE.getEntry(req.getCertID());</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (ocspSigningCacheEntry == null) {</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">          if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1085">            LOG.trace(&quot;Using default responder to check signature.&quot;);</span>
          }
<span class="nc" id="L1087">          ocspSigningCacheEntry = OcspSigningCache.INSTANCE.getDefaultEntry();</span>
        }
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (ocspSigningCacheEntry != null</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            &amp;&amp; ocspSigningCacheEntry.isUsingSeparateOcspSigningCertificate()) {</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">          if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1092">            LOG.trace(</span>
                &quot;ocspSigningCacheEntry.isUsingSeparateOcspSigningCertificate: &quot;
                    + ocspSigningCacheEntry
<span class="nc" id="L1095">                        .isUsingSeparateOcspSigningCertificate());</span>
          }
<span class="nc" id="L1097">          final OcspKeyBinding ocspKeyBinding =</span>
<span class="nc" id="L1098">              ocspSigningCacheEntry.getOcspKeyBinding();</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">          if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1100">            LOG.trace(</span>
                &quot;OcspKeyBinding &quot;
<span class="nc" id="L1102">                    + ocspKeyBinding.getId()</span>
                    + &quot;, RequireTrustedSignature: &quot;
<span class="nc" id="L1104">                    + ocspKeyBinding.getRequireTrustedSignature());</span>
          }
<span class="nc bnc" id="L1106" title="All 2 branches missed.">          if (ocspKeyBinding.getRequireTrustedSignature()) {</span>
<span class="nc" id="L1107">            enforceRequestSigning = true;</span>
<span class="nc" id="L1108">            boolean isTrusted = false;</span>
            final List&lt;InternalKeyBindingTrustEntry&gt;
<span class="nc" id="L1110">                trustedCertificateReferences =</span>
<span class="nc" id="L1111">                    ocspKeyBinding.getTrustedCertificateReferences();</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">            if (trustedCertificateReferences.isEmpty()) {</span>
              // We trust ANY cert from a known CA
<span class="nc" id="L1114">              isTrusted = true;</span>
            } else {
              for (final InternalKeyBindingTrustEntry trustEntry
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                 : trustedCertificateReferences) {</span>
<span class="nc" id="L1118">                final int trustedCaId = trustEntry.getCaId();</span>
<span class="nc" id="L1119">                final BigInteger trustedSerialNumber =</span>
<span class="nc" id="L1120">                    trustEntry.fetchCertificateSerialNumber();</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1122">                  LOG.trace(</span>
                      &quot;Processing trustedCaId=&quot;
                          + trustedCaId
                          + &quot; trustedSerialNumber=&quot;
                          + trustedSerialNumber
                          + &quot; signercertIssuerName.hashCode()=&quot;
<span class="nc" id="L1128">                          + signercertIssuerName.hashCode()</span>
                          + &quot; signercertSerNo=&quot;
                          + signercertSerNo);
                }
<span class="nc bnc" id="L1132" title="All 2 branches missed.">                if (trustedCaId == signercertIssuerName.hashCode()) {</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                  if (trustedSerialNumber == null) {</span>
                    // We trust any certificate from this CA
<span class="nc" id="L1135">                    isTrusted = true;</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1137">                      LOG.trace(</span>
                          &quot;Trusting request signature since ANY certificate&quot;
                              + &quot; from issuer &quot;
                              + trustedCaId
                              + &quot; is trusted.&quot;);
                    }
                    break;
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                  } else if (signercertSerNo.equals(trustedSerialNumber)) {</span>
                    // We trust this particular certificate from this CA
<span class="nc" id="L1146">                    isTrusted = true;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1148">                      LOG.trace(</span>
                          &quot;Trusting request signature since certificate with&quot;
                              + &quot; serialnumber &quot;
                              + trustedSerialNumber
                              + &quot; from issuer &quot;
                              + trustedCaId
                              + &quot; is trusted.&quot;);
                    }
                    break;
                  }
                }
<span class="nc" id="L1159">              }</span>
            }
<span class="nc bnc" id="L1161" title="All 2 branches missed.">            if (!isTrusted) {</span>
<span class="nc" id="L1162">              final String infoMsg =</span>
<span class="nc" id="L1163">                  INTRES.getLocalizedMessage(</span>
                      &quot;ocsp.infosigner.notallowed&quot;,
                      signercertSubjectName,
                      signercertIssuerName,
<span class="nc" id="L1167">                      signercertSerNo.toString(16));</span>
<span class="nc" id="L1168">              LOG.info(infoMsg);</span>
<span class="nc" id="L1169">              throw new SignRequestSignatureException(infoMsg);</span>
            }
          }
        }
      }
<span class="nc bnc" id="L1174" title="All 2 branches missed.">      if (enforceRequestSigning) {</span>
        // If it verifies OK, check if it is revoked
<span class="nc" id="L1176">        final String cacheLookupKey =</span>
<span class="nc" id="L1177">            OcspRequestSignerStatusCache.INSTANCE.createCacheLookupKey(</span>
                signercertIssuerName, signercertSerNo);
<span class="nc" id="L1179">        CertificateStatus status =</span>
<span class="nc" id="L1180">            OcspRequestSignerStatusCache.INSTANCE.getCachedCertificateStatus(</span>
                cacheLookupKey);
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (status == null) {</span>
<span class="nc" id="L1183">          status =</span>
<span class="nc" id="L1184">              certificateStoreSession.getStatus(</span>
                  signercertIssuerName, signercertSerNo);
<span class="nc" id="L1186">          OcspRequestSignerStatusCache.INSTANCE.updateCachedCertificateStatus(</span>
              cacheLookupKey, status);
        }
        /*
         * CertificateStatus.NOT_AVAILABLE means that the certificate does not
         * exist in database. We treat this as ok, because it may be
         *  so that only revoked
         * certificates is in the (external) OCSP database.
         */
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        if (status.equals(CertificateStatus.REVOKED)) {</span>
<span class="nc" id="L1196">          String serno = signercertSerNo.toString(16);</span>
<span class="nc" id="L1197">          String infoMsg =</span>
<span class="nc" id="L1198">              INTRES.getLocalizedMessage(</span>
                  &quot;ocsp.infosigner.revoked&quot;,
                  signercertSubjectName,
                  signercertIssuerName,
                  serno);
<span class="nc" id="L1203">          LOG.info(infoMsg);</span>
<span class="nc" id="L1204">          throw new SignRequestSignatureException(infoMsg);</span>
        }
      }
<span class="nc" id="L1207">    } else {</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">      if (OcspConfiguration.getEnforceRequestSigning()) {</span>
        // Signature required
<span class="nc" id="L1210">        throw new SignRequestException(&quot;Signature required&quot;);</span>
      }
      // Next, check if there is an OcspKeyBinding where signing is required and
      // configured for this request
      // In the case where multiple requests are bundled together they all must
      // be trusting the signer
<span class="nc bnc" id="L1216" title="All 2 branches missed.">      for (final Req req : ocspRequest.getRequestList()) {</span>
<span class="nc" id="L1217">        OcspSigningCacheEntry ocspSigningCacheEntry =</span>
<span class="nc" id="L1218">            OcspSigningCache.INSTANCE.getEntry(req.getCertID());</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (ocspSigningCacheEntry == null) {</span>
<span class="nc" id="L1220">          ocspSigningCacheEntry = OcspSigningCache.INSTANCE.getDefaultEntry();</span>
        }
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        if (ocspSigningCacheEntry != null</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">            &amp;&amp; ocspSigningCacheEntry.isUsingSeparateOcspSigningCertificate()) {</span>
<span class="nc" id="L1224">          final OcspKeyBinding ocspKeyBinding =</span>
<span class="nc" id="L1225">              ocspSigningCacheEntry.getOcspKeyBinding();</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">          if (ocspKeyBinding.getRequireTrustedSignature()) {</span>
<span class="nc" id="L1227">            throw new SignRequestException(&quot;Signature required&quot;);</span>
          }
        }
      }
    }
<span class="nc" id="L1232">    return ocspRequest;</span>
  }

  /**
   * Checks the signature on an OCSP request. Does not check for revocation of
   * the signer certificate
   *
   * @param clientRemoteAddr The IP address or host name of the remote client
   *     that sent the request, can be null.
   * @param req The signed OCSPReq
   * @return X509Certificate which is the certificate that signed the OCSP
   *     request
   * @throws SignRequestSignatureException if signature verification fail, or if
   *     the signing certificate is not authorized
   * @throws SignRequestException if there is no signature on the OCSPReq
   * @throws CertificateException if the certificate can not be parsed
   * @throws NoSuchAlgorithmException if the certificate contains an unsupported
   *     algorithm
   */
  private X509Certificate checkRequestSignature(
      final String clientRemoteAddr, final OCSPReq req)
      throws SignRequestException, SignRequestSignatureException,
          CertificateException, NoSuchAlgorithmException {
<span class="nc" id="L1255">    X509Certificate signercert = null;</span>
    // Get all certificates embedded in the request (probably a certificate
    // chain)
    try {
<span class="nc" id="L1259">      final X509CertificateHolder[] certs = req.getCerts();</span>
<span class="nc" id="L1260">      String signerSubjectDn = null;</span>
      // We must find a certificate to verify the signature with...
<span class="nc" id="L1262">      boolean verifyOK = false;</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">      for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="nc" id="L1264">        final X509Certificate certificate =</span>
<span class="nc" id="L1265">            certificateConverter.getCertificate(certs[i]);</span>
        try {
<span class="nc bnc" id="L1267" title="All 2 branches missed.">          if (req.isSignatureValid(</span>
<span class="nc" id="L1268">              CertTools.genContentVerifierProvider(</span>
<span class="nc" id="L1269">                  certificate.getPublicKey()))) {</span>
<span class="nc" id="L1270">            signercert =</span>
                certificate; // if the request signature verifies by this
                             // certificate, this is the signer cert
<span class="nc" id="L1273">            signerSubjectDn = CertTools.getSubjectDN(signercert);</span>
<span class="nc" id="L1274">            LOG.info(</span>
<span class="nc" id="L1275">                INTRES.getLocalizedMessage(&quot;ocsp.infosigner&quot;, signerSubjectDn));</span>
<span class="nc" id="L1276">            verifyOK = true;</span>
            // Check that the signer certificate can be verified by one of the
            // CA-certificates that we answer for
<span class="nc" id="L1279">            final X509Certificate signerca =</span>
<span class="nc" id="L1280">                CaCertificateCache.INSTANCE.findLatestBySubjectDN(</span>
<span class="nc" id="L1281">                    HashID.getFromIssuerDN(signercert));</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            if (signerca != null) {</span>
              try {
<span class="nc" id="L1284">                signercert.verify(signerca.getPublicKey());</span>
<span class="nc" id="L1285">                final Date now = new Date();</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1287">                  LOG.debug(</span>
                      &quot;Checking validity. Now: &quot;
                          + now
                          + &quot;, signerNotAfter: &quot;
<span class="nc" id="L1291">                          + signercert.getNotAfter());</span>
                }
                try {
                  // Check validity of the request signing certificate
<span class="nc" id="L1295">                  CertTools.checkValidity(signercert, now);</span>
<span class="nc" id="L1296">                } catch (CertificateNotYetValidException e) {</span>
<span class="nc" id="L1297">                  LOG.info(</span>
<span class="nc" id="L1298">                      INTRES.getLocalizedMessage(</span>
                          &quot;ocsp.infosigner.certnotyetvalid&quot;,
                          signerSubjectDn,
<span class="nc" id="L1301">                          CertTools.getIssuerDN(signercert),</span>
<span class="nc" id="L1302">                          e.getMessage()));</span>
<span class="nc" id="L1303">                  verifyOK = false;</span>
<span class="nc" id="L1304">                } catch (CertificateExpiredException e) {</span>
<span class="nc" id="L1305">                  LOG.info(</span>
<span class="nc" id="L1306">                      INTRES.getLocalizedMessage(</span>
                          &quot;ocsp.infosigner.certexpired&quot;,
                          signerSubjectDn,
<span class="nc" id="L1309">                          CertTools.getIssuerDN(signercert),</span>
<span class="nc" id="L1310">                          e.getMessage()));</span>
<span class="nc" id="L1311">                  verifyOK = false;</span>
<span class="nc" id="L1312">                }</span>
                try {
                  // Check validity of the CA certificate
<span class="nc" id="L1315">                  CertTools.checkValidity(signerca, now);</span>
<span class="nc" id="L1316">                } catch (CertificateNotYetValidException e) {</span>
<span class="nc" id="L1317">                  LOG.info(</span>
<span class="nc" id="L1318">                      INTRES.getLocalizedMessage(</span>
                          &quot;ocsp.infosigner.certnotyetvalid&quot;,
<span class="nc" id="L1320">                          CertTools.getSubjectDN(signerca),</span>
<span class="nc" id="L1321">                          CertTools.getIssuerDN(signerca),</span>
<span class="nc" id="L1322">                          e.getMessage()));</span>
<span class="nc" id="L1323">                  verifyOK = false;</span>
<span class="nc" id="L1324">                } catch (CertificateExpiredException e) {</span>
<span class="nc" id="L1325">                  LOG.info(</span>
<span class="nc" id="L1326">                      INTRES.getLocalizedMessage(</span>
                          &quot;ocsp.infosigner.certexpired&quot;,
<span class="nc" id="L1328">                          CertTools.getSubjectDN(signerca),</span>
<span class="nc" id="L1329">                          CertTools.getIssuerDN(signerca),</span>
<span class="nc" id="L1330">                          e.getMessage()));</span>
<span class="nc" id="L1331">                  verifyOK = false;</span>
<span class="nc" id="L1332">                }</span>
<span class="nc" id="L1333">              } catch (SignatureException e) {</span>
<span class="nc" id="L1334">                LOG.info(</span>
<span class="nc" id="L1335">                    INTRES.getLocalizedMessage(</span>
                        &quot;ocsp.infosigner.invalidcertsignature&quot;,
                        signerSubjectDn,
<span class="nc" id="L1338">                        CertTools.getIssuerDN(signercert),</span>
<span class="nc" id="L1339">                        e.getMessage()));</span>
<span class="nc" id="L1340">                verifyOK = false;</span>
<span class="nc" id="L1341">              } catch (InvalidKeyException e) {</span>
<span class="nc" id="L1342">                LOG.info(</span>
<span class="nc" id="L1343">                    INTRES.getLocalizedMessage(</span>
                        &quot;ocsp.infosigner.invalidcertsignature&quot;,
                        signerSubjectDn,
<span class="nc" id="L1346">                        CertTools.getIssuerDN(signercert),</span>
<span class="nc" id="L1347">                        e.getMessage()));</span>
<span class="nc" id="L1348">                verifyOK = false;</span>
<span class="nc" id="L1349">              }</span>
            } else {
<span class="nc" id="L1351">              LOG.info(</span>
<span class="nc" id="L1352">                  INTRES.getLocalizedMessage(</span>
                      &quot;ocsp.infosigner.nocacert&quot;,
                      signerSubjectDn,
<span class="nc" id="L1355">                      CertTools.getIssuerDN(signercert)));</span>
<span class="nc" id="L1356">              verifyOK = false;</span>
            }
<span class="nc" id="L1358">            break;</span>
          }
<span class="nc" id="L1360">        } catch (OperatorCreationException e) {</span>
          // Very fatal error
<span class="nc" id="L1362">          throw new EJBException(&quot;Can not create Jca content signer: &quot;, e);</span>
<span class="nc" id="L1363">        }</span>
      }
<span class="nc bnc" id="L1365" title="All 2 branches missed.">      if (!verifyOK) {</span>
<span class="nc bnc" id="L1366" title="All 4 branches missed.">        if (signerSubjectDn == null &amp;&amp; certs.length &gt; 0) {</span>
<span class="nc" id="L1367">          signerSubjectDn =</span>
<span class="nc" id="L1368">              CertTools.getSubjectDN(</span>
<span class="nc" id="L1369">                  certificateConverter.getCertificate(certs[0]));</span>
        }
<span class="nc" id="L1371">        String errMsg =</span>
<span class="nc" id="L1372">            INTRES.getLocalizedMessage(</span>
                &quot;ocsp.errorinvalidsignature&quot;, signerSubjectDn);
<span class="nc" id="L1374">        LOG.info(errMsg);</span>
<span class="nc" id="L1375">        throw new SignRequestSignatureException(errMsg);</span>
      }
<span class="nc" id="L1377">    } catch (OCSPException e) {</span>
<span class="nc" id="L1378">      throw new CryptoProviderException(</span>
          &quot;BouncyCastle was not initialized properly.&quot;, e);
<span class="nc" id="L1380">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L1381">      throw new CryptoProviderException(</span>
          &quot;BouncyCastle was not found as a provider.&quot;, e);
<span class="nc" id="L1383">    }</span>
<span class="nc" id="L1384">    return signercert;</span>
  }

  private void assertAcceptableResponseExtension(final OCSPReq req)
      throws OcspFailureException {
<span class="nc bnc" id="L1389" title="All 2 branches missed.">    if (null == req) {</span>
<span class="nc" id="L1390">      throw new IllegalArgumentException();</span>
    }
<span class="nc bnc" id="L1392" title="All 2 branches missed.">    if (req.hasExtensions()) {</span>
<span class="nc" id="L1393">      final Extension acceptableResponsesExtension =</span>
<span class="nc" id="L1394">          req.getExtension(OCSPObjectIdentifiers.id_pkix_ocsp_response);</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">      if (acceptableResponsesExtension != null) {</span>
        // RFC 6960 4.4.3 AcceptableResponses ::= SEQUENCE OF OBJECT IDENTIFIER
<span class="nc" id="L1397">        final ASN1Sequence sequence =</span>
<span class="nc" id="L1398">            ASN1Sequence.getInstance(</span>
<span class="nc" id="L1399">                acceptableResponsesExtension.getExtnValue().getOctets());</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1401">        final Enumeration&lt;ASN1ObjectIdentifier&gt; oids = sequence.getObjects();</span>
<span class="nc" id="L1402">        boolean supportsResponseType = false;</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">        while (oids.hasMoreElements()) {</span>
<span class="nc" id="L1404">          final ASN1ObjectIdentifier oid = oids.nextElement();</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">          if (oid.equals(OCSPObjectIdentifiers.id_pkix_ocsp_basic)) {</span>
            // This is the response type we support, so we are happy! Break the
            // loop.
<span class="nc" id="L1408">            supportsResponseType = true;</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1410">              LOG.debug(&quot;Response type supported: &quot; + oid.getId());</span>
            }
            break;
          }
<span class="nc" id="L1414">        }</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">        if (!supportsResponseType) {</span>
<span class="nc" id="L1416">          final String msg =</span>
              &quot;Required response type not supported, this responder only&quot;
                  + &quot; supports id-pkix-ocsp-basic.&quot;;
<span class="nc" id="L1419">          LOG.info(&quot;OCSP Request type not supported: &quot; + msg);</span>
<span class="nc" id="L1420">          throw new OcspFailureException(msg);</span>
        }
      }
    }
<span class="nc" id="L1424">  }</span>

  /**
   * When a timer expires, this method will update
   *
   * &lt;p&gt;According to JSR 220 FR (18.2.2), this method may not throw any
   * exceptions.
   *
   * @param timer The timer whose expiration caused this notification.
   */
  @Timeout
  /* Glassfish 2.1.1:
   * &quot;Timeout method ....timeoutHandler(javax.ejb.Timer)must have TX
   * attribute of TX_REQUIRES_NEW or TX_REQUIRED or TX_NOT_SUPPORTED&quot;
   * JBoss 5.1.0.GA: We cannot mix timer updates with our EJBCA
   * DataSource transactions.
   */
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public void timeoutHandler(final Timer timer) {
<span class="nc bnc" id="L1443" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1444">      LOG.trace(&quot;&gt;timeoutHandler: &quot; + timer.getInfo().toString());</span>
    }
    // reloadTokenAndChainCache cancels old timers and adds a new timer
<span class="nc" id="L1447">    reloadOcspSigningCache();</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1449">      LOG.trace(&quot;&lt;timeoutHandler&quot;);</span>
    }
<span class="nc" id="L1451">  }</span>

  /**
   * This method cancels all timers associated with this bean.
   *
   * @param id ID
   */
  // We don't want the appserver to persist/update the timer in the same
  // transaction if they are stored in different non XA DataSources. This method
  // should not be run from within a transaction.
  private void cancelTimers(final int id) {
<span class="nc bnc" id="L1462" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1463">      LOG.trace(&quot;&gt;cancelTimers&quot;);</span>
    }
<span class="nc" id="L1465">    final Collection&lt;Timer&gt; timers = timerService.getTimers();</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">    for (final Timer timer : timers) {</span>
<span class="nc" id="L1467">      final int currentTimerId = ((Integer) timer.getInfo()).intValue();</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">      if (currentTimerId == id) {</span>
<span class="nc" id="L1469">        timer.cancel();</span>
      }
<span class="nc" id="L1471">    }</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1473">      LOG.trace(&quot;&lt;cancelTimers, timers canceled: &quot; + timers.size());</span>
    }
<span class="nc" id="L1475">  }</span>

  private int getTimerCount(final int id) {
<span class="nc bnc" id="L1478" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1479">      LOG.trace(&quot;&gt;getTimerCount&quot;);</span>
    }
<span class="nc" id="L1481">    int count = 0;</span>
<span class="nc" id="L1482">    final Collection&lt;Timer&gt; timers = timerService.getTimers();</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">    for (final Timer timer : timers) {</span>
<span class="nc" id="L1484">      final int currentTimerId = ((Integer) timer.getInfo()).intValue();</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">      if (currentTimerId == id) {</span>
<span class="nc" id="L1486">        count++;</span>
      }
<span class="nc" id="L1488">    }</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1490">      LOG.trace(&quot;&lt;getTimerCount, timers: &quot; + count);</span>
    }
<span class="nc" id="L1492">    return count;</span>
  }

  /**
   * Adds a timer to the bean.
   *
   * @param interval Interval
   * @param id the id of the timer
   * @return Timer
   */
  // We don't want the appserver to persist/update the timer in the same
  // transaction if they are stored in different non XA DataSources. This method
  // should not be run from within a transaction.
  private Timer addTimer(final long interval, final Integer id) {
<span class="nc bnc" id="L1506" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1507">      LOG.trace(&quot;&gt;addTimer: &quot; + id + &quot;, interval: &quot; + interval);</span>
    }
<span class="nc" id="L1509">    Timer ret = null;</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">    if (interval &gt; 0) {</span>
      // Create non-persistent timer that fires once
<span class="nc" id="L1512">      ret =</span>
<span class="nc" id="L1513">          timerService.createSingleActionTimer(</span>
              interval, new TimerConfig(id, false));
<span class="nc bnc" id="L1515" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1516">        LOG.trace(</span>
            &quot;&lt;addTimer: &quot;
                + id
                + &quot;, interval: &quot;
                + interval
                + &quot;, &quot;
<span class="nc" id="L1522">                + ret.getNextTimeout().toString());</span>
      }
    }
<span class="nc" id="L1525">    return ret;</span>
  }

  @Override
  public OcspResponseInformation getOcspResponse(
      final byte[] request,
      final X509Certificate[] requestCertificates,
      final String remoteAddress,
      final String xForwardedFor,
      final StringBuffer requestUrl,
      final AuditLogger auditLogger,
      final TransactionLogger transactionLogger)
      throws MalformedRequestException, OCSPException {
    // Check parameters
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">    if (auditLogger == null) {</span>
<span class="nc" id="L1540">      throw new InvalidParameterException(</span>
          &quot;Illegal to pass a null audit logger to&quot;
              + &quot; OcspResponseSession.getOcspResponse&quot;);
    }
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">    if (transactionLogger == null) {</span>
<span class="nc" id="L1545">      throw new InvalidParameterException(</span>
          &quot;Illegal to pass a null transaction logger to&quot;
              + &quot; OcspResponseSession.getOcspResponse&quot;);
    }
    // Validate byte array.
<span class="pc bpc" id="L1550" title="1 of 2 branches missed.">    if (request.length &gt; MAX_REQUEST_SIZE) {</span>
<span class="fc" id="L1551">      final String msg =</span>
<span class="fc" id="L1552">          INTRES.getLocalizedMessage(</span>
<span class="fc" id="L1553">              &quot;request.toolarge&quot;, MAX_REQUEST_SIZE, request.length);</span>
<span class="fc" id="L1554">      throw new MalformedRequestException(msg);</span>
    }
<span class="nc" id="L1556">    byte[] respBytes = null;</span>
<span class="nc" id="L1557">    final Date startTime = new Date();</span>
<span class="nc" id="L1558">    OCSPResp ocspResponse = null;</span>
    // Start logging process time after we have received the request
<span class="nc bnc" id="L1560" title="All 2 branches missed.">    if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1561">      transactionLogger.paramPut(</span>
          PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
    }
<span class="nc bnc" id="L1564" title="All 2 branches missed.">    if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L1565">      auditLogger.paramPut(</span>
          PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
<span class="nc" id="L1567">      auditLogger.paramPut(</span>
<span class="nc" id="L1568">          AuditLogger.OCSPREQUEST, new String(Hex.encode(request)));</span>
    }
    OCSPReq req;
<span class="nc" id="L1571">    long maxAge =</span>
<span class="nc" id="L1572">        OcspConfiguration.getMaxAge(</span>
            CertificateProfileConstants.CERTPROFILE_NO_PROFILE);
<span class="nc" id="L1574">    OCSPRespBuilder responseGenerator = new OCSPRespBuilder();</span>
<span class="nc" id="L1575">    X509Certificate signerCert = null;</span>
    try {
<span class="nc" id="L1577">      req =</span>
<span class="nc" id="L1578">          translateRequestFromByteArray(</span>
              request, remoteAddress, transactionLogger);
      // Get the certificate status requests that are inside this OCSP req
<span class="nc" id="L1581">      Req[] ocspRequests = req.getRequestList();</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">      if (ocspRequests.length &lt;= 0) {</span>
<span class="nc" id="L1583">        String infoMsg = INTRES.getLocalizedMessage(&quot;ocsp.errornoreqentities&quot;);</span>
<span class="nc" id="L1584">        LOG.info(infoMsg);</span>
<span class="nc" id="L1585">        throw new MalformedRequestException(infoMsg);</span>
      }
<span class="nc" id="L1587">      final int maxRequests = 100;</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">      if (ocspRequests.length &gt; maxRequests) {</span>
<span class="nc" id="L1589">        String infoMsg =</span>
<span class="nc" id="L1590">            INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1591">                &quot;ocsp.errortoomanyreqentities&quot;, maxRequests);</span>
<span class="nc" id="L1592">        LOG.info(infoMsg);</span>
<span class="nc" id="L1593">        throw new MalformedRequestException(infoMsg);</span>
      }
<span class="nc bnc" id="L1595" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1596">        LOG.debug(</span>
            &quot;The OCSP request contains &quot;
                + ocspRequests.length
                + &quot; simpleRequests.&quot;);
      }
<span class="nc bnc" id="L1601" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1602">        transactionLogger.paramPut(</span>
<span class="nc" id="L1603">            TransactionLogger.NUM_CERT_ID, ocspRequests.length);</span>
<span class="nc" id="L1604">        transactionLogger.paramPut(</span>
<span class="nc" id="L1605">            TransactionLogger.STATUS, OCSPRespBuilder.SUCCESSFUL);</span>
      }
<span class="nc bnc" id="L1607" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L1608">        auditLogger.paramPut(AuditLogger.STATUS, OCSPRespBuilder.SUCCESSFUL);</span>
      }
<span class="nc" id="L1610">      OcspSigningCacheEntry ocspSigningCacheEntry = null;</span>
<span class="nc" id="L1611">      long nextUpdate =</span>
<span class="nc" id="L1612">          OcspConfiguration.getUntilNextUpdate(</span>
              CertificateProfileConstants.CERTPROFILE_NO_PROFILE);
<span class="nc" id="L1614">      Map&lt;ASN1ObjectIdentifier, Extension&gt; responseExtensions = new HashMap&lt;&gt;();</span>

      // Look over the status requests
<span class="nc" id="L1617">      List&lt;OCSPResponseItem&gt; responseList = new ArrayList&lt;OCSPResponseItem&gt;();</span>
<span class="nc" id="L1618">      boolean addExtendedRevokedExtension = false;</span>
<span class="nc" id="L1619">      Date producedAt = null;</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">      for (Req ocspRequest : ocspRequests) {</span>
<span class="nc" id="L1621">        CertificateID certId = ocspRequest.getCertID();</span>
<span class="nc" id="L1622">        ASN1ObjectIdentifier certIdhash = certId.getHashAlgOID();</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">        if (!OIWObjectIdentifiers.idSHA1.equals(certIdhash)</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">            &amp;&amp; !NISTObjectIdentifiers.id_sha256.equals(certIdhash)) {</span>
<span class="nc" id="L1625">          throw new InvalidAlgorithmException(</span>
              &quot;CertID with SHA1 and SHA256 are supported, not: &quot;
<span class="nc" id="L1627">                  + certIdhash.getId());</span>
        }
<span class="nc bnc" id="L1629" title="All 2 branches missed.">        if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1630">          transactionLogger.paramPut(</span>
              TransactionLogger.SERIAL_NOHEX,
<span class="nc" id="L1632">              certId.getSerialNumber().toByteArray());</span>
<span class="nc" id="L1633">          transactionLogger.paramPut(</span>
              TransactionLogger.DIGEST_ALGOR,
<span class="nc" id="L1635">              certId.getHashAlgOID().toString());</span>
<span class="nc" id="L1636">          transactionLogger.paramPut(</span>
<span class="nc" id="L1637">              TransactionLogger.ISSUER_NAME_HASH, certId.getIssuerNameHash());</span>
<span class="nc" id="L1638">          transactionLogger.paramPut(</span>
<span class="nc" id="L1639">              TransactionLogger.ISSUER_KEY, certId.getIssuerKeyHash());</span>
        }
<span class="nc bnc" id="L1641" title="All 2 branches missed.">        if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L1642">          auditLogger.paramPut(</span>
<span class="nc" id="L1643">              AuditLogger.ISSUER_KEY, certId.getIssuerKeyHash());</span>
<span class="nc" id="L1644">          auditLogger.paramPut(</span>
<span class="nc" id="L1645">              AuditLogger.SERIAL_NOHEX, certId.getSerialNumber().toByteArray());</span>
<span class="nc" id="L1646">          auditLogger.paramPut(</span>
<span class="nc" id="L1647">              AuditLogger.ISSUER_NAME_HASH, certId.getIssuerNameHash());</span>
        }
<span class="nc" id="L1649">        byte[] hashbytes = certId.getIssuerNameHash();</span>
<span class="nc" id="L1650">        String hash = null;</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">        if (hashbytes != null) {</span>
<span class="nc" id="L1652">          hash = new String(Hex.encode(hashbytes));</span>
        }
<span class="nc bnc" id="L1654" title="All 2 branches missed.">        if (xForwardedFor == null) {</span>
<span class="nc" id="L1655">          LOG.info(</span>
<span class="nc" id="L1656">              INTRES.getLocalizedMessage(</span>
                  &quot;ocsp.inforeceivedrequest&quot;,
<span class="nc" id="L1658">                  certId.getSerialNumber().toString(16),</span>
                  hash,
                  remoteAddress));
        } else {
<span class="nc" id="L1662">          LOG.info(</span>
<span class="nc" id="L1663">              INTRES.getLocalizedMessage(</span>
                  &quot;ocsp.inforeceivedrequestwxff&quot;,
<span class="nc" id="L1665">                  certId.getSerialNumber().toString(16),</span>
                  hash,
                  remoteAddress,
                  xForwardedFor));
        }
        // Locate the CA which gave out the certificate
<span class="nc" id="L1671">        ocspSigningCacheEntry = OcspSigningCache.INSTANCE.getEntry(certId);</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">        if (ocspSigningCacheEntry == null) {</span>
          // Could it be that we haven't updated the OCSP Signing Cache?
<span class="nc" id="L1674">          ocspSigningCacheEntry = findAndAddMissingCacheEntry(certId);</span>
        }
<span class="nc bnc" id="L1676" title="All 2 branches missed.">        if (ocspSigningCacheEntry != null) {</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">          if (transactionLogger.isEnabled()) {</span>
            // This will be the issuer DN of the signing certificate, whether an
            // OCSP responder or an internal CA
<span class="nc" id="L1680">            transactionLogger.paramPut(</span>
                TransactionLogger.ISSUER_NAME_DN,
<span class="nc" id="L1682">                ocspSigningCacheEntry.getSigningCertificateIssuerDn());</span>
<span class="nc" id="L1683">            transactionLogger.paramPut(</span>
                TransactionLogger.ISSUER_NAME_DN_RAW,
<span class="nc" id="L1685">                ocspSigningCacheEntry.getSigningCertificateIssuerDnRaw());</span>
          }
        } else {
          /*
           * if the certId was issued by an unknown CA
           *
           * The algorithm here:
           * We will sign the response with the CA that issued the last
           * certificate(certId) in the request. If the issuing CA is not
           * available on
           * this server, we sign the response with the default responderId
           * (from params in web.xml). We have to look up the ca-certificate for
           * each certId in the request though, as we will check for revocation
           * on the ca-cert as well when checking for revocation on the certId.
           */
          // We could not find certificate for this request so get certificate
          // for default responder
<span class="nc" id="L1702">          ocspSigningCacheEntry = OcspSigningCache.INSTANCE.getDefaultEntry();</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">          if (ocspSigningCacheEntry != null) {</span>
<span class="nc" id="L1704">            String errMsg =</span>
<span class="nc" id="L1705">                INTRES.getLocalizedMessage(</span>
                    &quot;ocsp.errorfindcacertusedefault&quot;,
<span class="nc" id="L1707">                    new String(Hex.encode(certId.getIssuerNameHash())));</span>
<span class="nc" id="L1708">            LOG.info(errMsg);</span>
            // If we can not find the CA, answer UnknowStatus
<span class="nc" id="L1710">            responseList.add(</span>
                new OCSPResponseItem(certId, new UnknownStatus(), nextUpdate));
<span class="nc bnc" id="L1712" title="All 2 branches missed.">            if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1713">              transactionLogger.paramPut(</span>
<span class="nc" id="L1714">                  TransactionLogger.CERT_STATUS, OCSPResponseItem.OCSP_UNKNOWN);</span>
<span class="nc" id="L1715">              transactionLogger.writeln();</span>
            }
            continue;
          } else {
<span class="nc" id="L1719">            GlobalOcspConfiguration ocspConfiguration =</span>
                (GlobalOcspConfiguration)
<span class="nc" id="L1721">                    globalConfigurationSession.getCachedConfiguration(</span>
                        GlobalOcspConfiguration.OCSP_CONFIGURATION_ID);
<span class="nc" id="L1723">            String defaultResponder =</span>
<span class="nc" id="L1724">                ocspConfiguration.getOcspDefaultResponderReference();</span>
<span class="nc" id="L1725">            String errMsg =</span>
<span class="nc" id="L1726">                INTRES.getLocalizedMessage(</span>
                    &quot;ocsp.errorfindcacert&quot;,
<span class="nc" id="L1728">                    new String(Hex.encode(certId.getIssuerNameHash())),</span>
                    defaultResponder);
<span class="nc" id="L1730">            LOG.error(errMsg);</span>
            // If we are responding to multiple requests, the last found
            // ocspSigningCacheEntry will be used in the end
            // so even if there are not any one now, it might be later when it
            // is time to sign the responses.
            // Since we only will sign the entire response once if there is at
            // least one valid ocspSigningCacheEntry
            // we might as well include the unknown requests.
<span class="nc" id="L1738">            responseList.add(</span>
                new OCSPResponseItem(certId, new UnknownStatus(), nextUpdate));
<span class="nc" id="L1740">            continue;</span>
          }
        }

<span class="nc" id="L1744">        Collection&lt;String&gt; extensionOids = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">        if (ocspSigningCacheEntry.getOcspKeyBinding() != null) {</span>
<span class="nc" id="L1746">          extensionOids =</span>
<span class="nc" id="L1747">              ocspSigningCacheEntry.getOcspKeyBinding().getOcspExtensions();</span>
        }

        // Intended for debugging. Will usually be null
        String alwaysUseOid =
<span class="nc" id="L1752">            OcspConfiguration.getAlwaysSendCustomOCSPExtension();</span>
<span class="nc bnc" id="L1753" title="All 4 branches missed.">        if (alwaysUseOid != null &amp;&amp; !extensionOids.contains(alwaysUseOid)) {</span>
<span class="nc" id="L1754">          extensionOids.add(alwaysUseOid);</span>
        }

        final org.bouncycastle.cert.ocsp.CertificateStatus certStatus;
        // Check if the cacert (or the default responderid) is revoked
<span class="nc" id="L1759">        X509Certificate caCertificate =</span>
<span class="nc" id="L1760">            ocspSigningCacheEntry.getIssuerCaCertificate();</span>
<span class="nc" id="L1761">        final CertificateStatus signerIssuerCertStatus =</span>
<span class="nc" id="L1762">            ocspSigningCacheEntry.getIssuerCaCertificateStatus();</span>
<span class="nc" id="L1763">        final String caCertificateSubjectDn =</span>
<span class="nc" id="L1764">            CertTools.getSubjectDN(caCertificate);</span>
<span class="nc" id="L1765">        CertificateStatusHolder certificateStatusHolder = null;</span>
        OCSPResponseItem respItem;
<span class="nc bnc" id="L1767" title="All 2 branches missed.">        if (signerIssuerCertStatus.equals(CertificateStatus.REVOKED)) {</span>
          /*
           * According to chapter 2.7 in RFC2560:
           *
           * 2.7 CA Key Compromise If an OCSP responder knows that a particular
           *  CA's private key has been compromised, it MAY return the revoked
           * state for all certificates issued by that CA.
           */
          // If we've ended up here it's because the signer issuer certificate
          // was revoked.
<span class="nc" id="L1777">          certStatus =</span>
              new RevokedStatus(
                  new RevokedInfo(
                      new ASN1GeneralizedTime(
<span class="nc" id="L1781">                          signerIssuerCertStatus.getRevocationDate()),</span>
<span class="nc" id="L1782">                      CRLReason.lookup(</span>
<span class="nc" id="L1783">                          signerIssuerCertStatus.getRevocationReason())));</span>
<span class="nc" id="L1784">          LOG.info(</span>
<span class="nc" id="L1785">              INTRES.getLocalizedMessage(</span>
                  &quot;ocsp.signcertissuerrevoked&quot;,
<span class="nc" id="L1787">                  CertTools.getSerialNumberAsString(caCertificate),</span>
<span class="nc" id="L1788">                  CertTools.getSubjectDN(caCertificate)));</span>
<span class="nc" id="L1789">          respItem = new OCSPResponseItem(certId, certStatus, nextUpdate);</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">          if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1791">            transactionLogger.paramPut(</span>
<span class="nc" id="L1792">                TransactionLogger.CERT_STATUS, OCSPResponseItem.OCSP_REVOKED);</span>
<span class="nc" id="L1793">            transactionLogger.paramPut(</span>
                TransactionLogger.REV_REASON,
<span class="nc" id="L1795">                signerIssuerCertStatus.getRevocationReason());</span>
<span class="nc" id="L1796">            transactionLogger.writeln();</span>
          }
        } else {
          /*
           * Here is the actual check for the status of the sought certificate
           * (easy to miss). Here we grab just the status if there aren't any
           * OIDs defined (default case), but if there are we'll probably need
           * the certificate as well. If that's the case, we'll grab the
           * certificate in the same transaction.
           */
          final CertificateStatus status;
<span class="nc" id="L1807">          final long k = 1000L;</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">          if (extensionOids.isEmpty()) {</span>
<span class="nc" id="L1809">            status =</span>
<span class="nc" id="L1810">                certificateStoreSession.getStatus(</span>
<span class="nc" id="L1811">                    caCertificateSubjectDn, certId.getSerialNumber());</span>
          } else {
<span class="nc" id="L1813">            certificateStatusHolder =</span>
<span class="nc" id="L1814">                certificateStoreSession.getCertificateAndStatus(</span>
<span class="nc" id="L1815">                    caCertificateSubjectDn, certId.getSerialNumber());</span>
<span class="nc" id="L1816">            status = certificateStatusHolder.getCertificateStatus();</span>
          }
<span class="nc bnc" id="L1818" title="All 2 branches missed.">          if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1819">            transactionLogger.paramPut(</span>
                TransactionLogger.CERT_PROFILE_ID,
<span class="nc" id="L1821">                String.valueOf(status.getCertificateProfileId()));</span>
          }
          // If we have an OcspKeyBinding configured for this request, we
          // override the default value
<span class="nc bnc" id="L1825" title="All 2 branches missed.">          if (ocspSigningCacheEntry.isUsingSeparateOcspSigningCertificate()) {</span>
<span class="nc" id="L1826">            nextUpdate =</span>
<span class="nc" id="L1827">                ocspSigningCacheEntry.getOcspKeyBinding().getUntilNextUpdate()</span>
                    * k;
          }
          // If we have an explicit value configured for this certificate
          // profile, we override the the current value with this value
<span class="nc bnc" id="L1832" title="All 2 branches missed.">          if (status.getCertificateProfileId()</span>
                  != CertificateProfileConstants.CERTPROFILE_NO_PROFILE
<span class="nc bnc" id="L1834" title="All 2 branches missed.">              &amp;&amp; OcspConfiguration.isUntilNextUpdateConfigured(</span>
<span class="nc" id="L1835">                  status.getCertificateProfileId())) {</span>
<span class="nc" id="L1836">            nextUpdate =</span>
<span class="nc" id="L1837">                OcspConfiguration.getUntilNextUpdate(</span>
<span class="nc" id="L1838">                    status.getCertificateProfileId());</span>
          }
          // If we have an OcspKeyBinding configured for this request, we
          // override the default value
<span class="nc bnc" id="L1842" title="All 2 branches missed.">          if (ocspSigningCacheEntry.isUsingSeparateOcspSigningCertificate()) {</span>
<span class="nc" id="L1843">            maxAge =</span>
<span class="nc" id="L1844">                ocspSigningCacheEntry.getOcspKeyBinding().getMaxAge() * k;</span>
          }
          // If we have an explicit value configured for this certificate
          // profile, we override the the current value with this value
<span class="nc bnc" id="L1848" title="All 2 branches missed.">          if (status.getCertificateProfileId()</span>
                  != CertificateProfileConstants.CERTPROFILE_NO_PROFILE
<span class="nc bnc" id="L1850" title="All 2 branches missed.">              &amp;&amp; OcspConfiguration.isMaxAgeConfigured(</span>
<span class="nc" id="L1851">                  status.getCertificateProfileId())) {</span>
<span class="nc" id="L1852">            maxAge =</span>
<span class="nc" id="L1853">                OcspConfiguration.getMaxAge(status.getCertificateProfileId());</span>
          }

          final String sStatus;
<span class="nc" id="L1857">          boolean addArchiveCutoff = false;</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">          if (status.equals(CertificateStatus.NOT_AVAILABLE)) {</span>
            // No revocation info available for this cert, handle it
<span class="nc bnc" id="L1860" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1861">              LOG.debug(</span>
                  &quot;Unable to find revocation information for certificate with&quot;
                      + &quot; serial '&quot;
<span class="nc" id="L1864">                      + certId.getSerialNumber().toString(16)</span>
                      + &quot;'&quot;
                      + &quot; from issuer '&quot;
                      + caCertificateSubjectDn
                      + &quot;'&quot;);
            }
            /*
             * If we do not treat non existing certificates as good or revoked
             * OR
             * we don't actually handle requests for the CA issuing
             * the certificate asked about
             * then we return unknown
             * */
<span class="nc bnc" id="L1877" title="All 2 branches missed.">            if (OcspConfigurationCache.INSTANCE.isNonExistingGood(</span>
<span class="nc" id="L1878">                    requestUrl, ocspSigningCacheEntry.getOcspKeyBinding())</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">                &amp;&amp; OcspSigningCache.INSTANCE.getEntry(certId) != null) {</span>
<span class="nc" id="L1880">              sStatus = &quot;good&quot;;</span>
<span class="nc" id="L1881">              certStatus = null; // null means &quot;good&quot; in OCSP</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">              if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1883">                transactionLogger.paramPut(</span>
<span class="nc" id="L1884">                    TransactionLogger.CERT_STATUS, OCSPResponseItem.OCSP_GOOD);</span>
<span class="nc" id="L1885">                transactionLogger.paramPut(</span>
<span class="nc" id="L1886">                    TransactionLogger.REV_REASON, CRLReason.certificateHold);</span>
              }
<span class="nc bnc" id="L1888" title="All 2 branches missed.">            } else if (OcspConfigurationCache.INSTANCE.isNonExistingRevoked(</span>
<span class="nc" id="L1889">                    requestUrl, ocspSigningCacheEntry.getOcspKeyBinding())</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">                &amp;&amp; OcspSigningCache.INSTANCE.getEntry(certId) != null) {</span>
<span class="nc" id="L1891">              sStatus = &quot;revoked&quot;;</span>
<span class="nc" id="L1892">              certStatus =</span>
                  new RevokedStatus(
                      new RevokedInfo(
                          new ASN1GeneralizedTime(new Date(0)),
<span class="nc" id="L1896">                          CRLReason.lookup(CRLReason.certificateHold)));</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">              if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1898">                transactionLogger.paramPut(</span>
                    TransactionLogger.CERT_STATUS,
<span class="nc" id="L1900">                    OCSPResponseItem.OCSP_REVOKED);</span>
<span class="nc" id="L1901">                transactionLogger.paramPut(</span>
<span class="nc" id="L1902">                    TransactionLogger.REV_REASON, CRLReason.certificateHold);</span>
              }
<span class="nc" id="L1904">              addExtendedRevokedExtension = true;</span>
<span class="nc" id="L1905">            } else if (OcspConfigurationCache.INSTANCE</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">                    .isNonExistingUnauthorized(</span>
<span class="nc" id="L1907">                        ocspSigningCacheEntry.getOcspKeyBinding())</span>
<span class="nc bnc" id="L1908" title="All 2 branches missed.">                &amp;&amp; OcspSigningCache.INSTANCE.getEntry(certId) != null) {</span>
              // In order to save on cycles and mitigate the chances of a DOS
              // attack, we'll return a unsigned unauthorized reply.
<span class="nc" id="L1911">              ocspResponse =</span>
<span class="nc" id="L1912">                  responseGenerator.build(OCSPRespBuilder.UNAUTHORIZED, null);</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">              if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L1914">                auditLogger.paramPut(</span>
<span class="nc" id="L1915">                    AuditLogger.STATUS, OCSPRespBuilder.UNAUTHORIZED);</span>
              }
<span class="nc bnc" id="L1917" title="All 2 branches missed.">              if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1918">                transactionLogger.paramPut(</span>
<span class="nc" id="L1919">                    TransactionLogger.STATUS, OCSPRespBuilder.UNAUTHORIZED);</span>
              }
<span class="nc" id="L1921">              LOG.info(</span>
<span class="nc" id="L1922">                  INTRES.getLocalizedMessage(</span>
                      &quot;ocsp.errorfindcert&quot;,
<span class="nc" id="L1924">                      certId.getSerialNumber().toString(16),</span>
                      caCertificateSubjectDn));
              // Return early here
<span class="nc" id="L1927">              return new OcspResponseInformation(ocspResponse, maxAge, null);</span>
            } else {
<span class="nc" id="L1929">              sStatus = &quot;unknown&quot;;</span>
<span class="nc" id="L1930">              certStatus = new UnknownStatus();</span>
<span class="nc bnc" id="L1931" title="All 2 branches missed.">              if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1932">                transactionLogger.paramPut(</span>
                    TransactionLogger.CERT_STATUS,
<span class="nc" id="L1934">                    OCSPResponseItem.OCSP_UNKNOWN);</span>
<span class="nc" id="L1935">                transactionLogger.paramPut(</span>
<span class="nc" id="L1936">                    TransactionLogger.REV_REASON, CRLReason.certificateHold);</span>
              }
            }
<span class="nc bnc" id="L1939" title="All 2 branches missed.">          } else if (status.equals(CertificateStatus.REVOKED)) {</span>
            // Revocation info available for this cert, handle it
<span class="nc" id="L1941">            sStatus = &quot;revoked&quot;;</span>
<span class="nc" id="L1942">            certStatus =</span>
                new RevokedStatus(
                    new RevokedInfo(
<span class="nc" id="L1945">                        new ASN1GeneralizedTime(status.getRevocationDate()),</span>
<span class="nc" id="L1946">                        CRLReason.lookup(status.getRevocationReason())));</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">            if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1948">              transactionLogger.paramPut(</span>
<span class="nc" id="L1949">                  TransactionLogger.CERT_STATUS, OCSPResponseItem.OCSP_REVOKED);</span>
<span class="nc" id="L1950">              transactionLogger.paramPut(</span>
<span class="nc" id="L1951">                  TransactionLogger.REV_REASON, status.getRevocationReason());</span>
            }
            // If we have an explicit value configured for this certificate
            // profile, we override the the current value with this value
<span class="nc bnc" id="L1955" title="All 2 branches missed.">            if (status.getCertificateProfileId()</span>
                    != CertificateProfileConstants.CERTPROFILE_NO_PROFILE
<span class="nc bnc" id="L1957" title="All 2 branches missed.">                &amp;&amp; OcspConfiguration.isRevokedUntilNextUpdateConfigured(</span>
<span class="nc" id="L1958">                    status.getCertificateProfileId())) {</span>
<span class="nc" id="L1959">              nextUpdate =</span>
<span class="nc" id="L1960">                  OcspConfiguration.getRevokedUntilNextUpdate(</span>
<span class="nc" id="L1961">                      status.getCertificateProfileId());</span>
            }
            // If we have an explicit value configured for this certificate
            // profile, we override the the current value with this value
<span class="nc bnc" id="L1965" title="All 2 branches missed.">            if (status.getCertificateProfileId()</span>
                    != CertificateProfileConstants.CERTPROFILE_NO_PROFILE
<span class="nc bnc" id="L1967" title="All 2 branches missed.">                &amp;&amp; OcspConfiguration.isRevokedMaxAgeConfigured(</span>
<span class="nc" id="L1968">                    status.getCertificateProfileId())) {</span>
<span class="nc" id="L1969">              maxAge =</span>
<span class="nc" id="L1970">                  OcspConfiguration.getRevokedMaxAge(</span>
<span class="nc" id="L1971">                      status.getCertificateProfileId());</span>
            }
          } else {
<span class="nc" id="L1974">            sStatus = &quot;good&quot;;</span>
<span class="nc" id="L1975">            certStatus = null;</span>
<span class="nc bnc" id="L1976" title="All 2 branches missed.">            if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L1977">              transactionLogger.paramPut(</span>
<span class="nc" id="L1978">                  TransactionLogger.CERT_STATUS, OCSPResponseItem.OCSP_GOOD);</span>
            }
<span class="nc" id="L1980">            addArchiveCutoff =</span>
<span class="nc" id="L1981">                checkAddArchiveCuttoff(caCertificateSubjectDn, certId);</span>
          }
<span class="nc bnc" id="L1983" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1984">            LOG.debug(</span>
                &quot;Set nextUpdate=&quot;
                    + nextUpdate
                    + &quot;, and maxAge=&quot;
                    + maxAge
                    + &quot; for certificateProfileId=&quot;
<span class="nc" id="L1990">                    + status.getCertificateProfileId());</span>
          }
<span class="nc" id="L1992">          LOG.info(</span>
<span class="nc" id="L1993">              INTRES.getLocalizedMessage(</span>
                  &quot;ocsp.infoaddedstatusinfo&quot;,
                  sStatus,
<span class="nc" id="L1996">                  certId.getSerialNumber().toString(16),</span>
                  caCertificateSubjectDn));
<span class="nc" id="L1998">          respItem = new OCSPResponseItem(certId, certStatus, nextUpdate);</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">          if (addArchiveCutoff) {</span>
<span class="nc" id="L2000">            addArchiveCutoff(respItem);</span>
<span class="nc" id="L2001">            producedAt = new Date();</span>
          }
<span class="nc bnc" id="L2003" title="All 2 branches missed.">          if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2004">            transactionLogger.writeln();</span>
          }
        }

<span class="nc bnc" id="L2008" title="All 2 branches missed.">        for (String oidstr : extensionOids) {</span>
<span class="nc" id="L2009">          boolean useAlways = false;</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">          if (oidstr.equals(alwaysUseOid)) {</span>
<span class="nc" id="L2011">            useAlways = true;</span>
          }
<span class="nc" id="L2013">          ASN1ObjectIdentifier oid = new ASN1ObjectIdentifier(oidstr);</span>
<span class="nc" id="L2014">          Extension extension = null;</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">          if (!useAlways) {</span>
            // Only check if extension exists if we are not already bound to use
            // it
<span class="nc bnc" id="L2018" title="All 2 branches missed.">            if (req.hasExtensions()) {</span>
<span class="nc" id="L2019">              extension = req.getExtension(oid);</span>
            }
          }
          // If found, or if it should be used anyway
<span class="nc bnc" id="L2023" title="All 4 branches missed.">          if (useAlways || extension != null) {</span>
            // We found an extension, call the extension class
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2026">              LOG.debug(&quot;Found OCSP extension oid: &quot; + oidstr);</span>
            }
<span class="nc" id="L2028">            OCSPExtension extObj =</span>
<span class="nc" id="L2029">                OcspExtensionsCache.INSTANCE.getExtensions().get(oidstr);</span>
<span class="nc bnc" id="L2030" title="All 2 branches missed.">            if (extObj != null) {</span>
              // Find the certificate from the certId
<span class="nc bnc" id="L2032" title="All 2 branches missed.">              if (certificateStatusHolder != null</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">                  &amp;&amp; certificateStatusHolder.getCertificate() != null) {</span>
<span class="nc" id="L2034">                X509Certificate cert =</span>
<span class="nc" id="L2035">                    (X509Certificate) certificateStatusHolder.getCertificate();</span>
                // From EJBCA 6.2.10 and 6.3.2 the extension must perform the
                // reverse DNS lookup by itself if needed.
<span class="nc" id="L2038">                final String remoteHost = remoteAddress;</span>
                // Call the OCSP extension
<span class="nc" id="L2040">                Map&lt;ASN1ObjectIdentifier, Extension&gt; retext = null;</span>
<span class="nc" id="L2041">                retext =</span>
<span class="nc" id="L2042">                    extObj.process(</span>
                        requestCertificates,
                        remoteAddress,
                        remoteHost,
                        cert,
                        certStatus,
<span class="nc" id="L2048">                        ocspSigningCacheEntry.getOcspKeyBinding());</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">                if (retext != null) {</span>
                  // Add the returned X509Extensions to the responseExtension we
                  // will add to the basic OCSP response
<span class="nc" id="L2052">                  if (extObj</span>
<span class="nc" id="L2053">                      .getExtensionType()</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">                      .contains(OCSPExtensionType.RESPONSE)) {</span>
<span class="nc" id="L2055">                    responseExtensions.putAll(retext);</span>
                  }
<span class="nc" id="L2057">                  if (extObj</span>
<span class="nc" id="L2058">                      .getExtensionType()</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">                      .contains(OCSPExtensionType.SINGLE_RESPONSE)) {</span>
<span class="nc" id="L2060">                    respItem.addExtensions(retext);</span>
                  }
                } else {
<span class="nc" id="L2063">                  LOG.error(</span>
<span class="nc" id="L2064">                      INTRES.getLocalizedMessage(</span>
                          &quot;ocsp.errorprocessextension&quot;,
<span class="nc" id="L2066">                          extObj.getClass().getName(),</span>
<span class="nc" id="L2067">                          Integer.valueOf(extObj.getLastErrorCode())));</span>
                }
              }
            }
          }
<span class="nc" id="L2072">        }</span>
<span class="nc" id="L2073">        responseList.add(respItem);</span>
      }
<span class="nc bnc" id="L2075" title="All 2 branches missed.">      if (addExtendedRevokedExtension) {</span>
        // id-pkix-ocsp-extended-revoke OBJECT IDENTIFIER ::= {id-pkix-ocsp 9}
<span class="nc" id="L2077">        final ASN1ObjectIdentifier extendedRevokedOID =</span>
            OCSPObjectIdentifiers.id_pkix_ocsp_extended_revoke;
        try {
<span class="nc" id="L2080">          responseExtensions.put(</span>
              extendedRevokedOID,
              new Extension(
<span class="nc" id="L2083">                  extendedRevokedOID, false, DERNull.INSTANCE.getEncoded()));</span>
<span class="nc" id="L2084">        } catch (IOException e) {</span>
<span class="nc" id="L2085">          throw new IllegalStateException(</span>
              &quot;Could not get encoding from DERNull.&quot;, e);
<span class="nc" id="L2087">        }</span>
      }
<span class="nc bnc" id="L2089" title="All 2 branches missed.">      if (ocspSigningCacheEntry != null) {</span>
        // Add standard response extensions
<span class="nc" id="L2091">        responseExtensions.putAll(</span>
<span class="nc" id="L2092">            getStandardResponseExtensions(req, ocspSigningCacheEntry));</span>

        // Add responseExtensions
<span class="nc" id="L2095">        Extensions exts =</span>
            new Extensions(
<span class="nc" id="L2097">                responseExtensions.values().toArray(new Extension[0]));</span>
        // generate the signed response object
<span class="nc" id="L2099">        BasicOCSPResp basicresp =</span>
<span class="nc" id="L2100">            signOcspResponse(</span>
                req, responseList, exts, ocspSigningCacheEntry, producedAt);
<span class="nc" id="L2102">        signerCert = ocspSigningCacheEntry.getSigningCertificate();</span>
<span class="nc" id="L2103">        ocspResponse =</span>
<span class="nc" id="L2104">            responseGenerator.build(OCSPRespBuilder.SUCCESSFUL, basicresp);</span>
<span class="nc bnc" id="L2105" title="All 2 branches missed.">        if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2106">          auditLogger.paramPut(AuditLogger.STATUS, OCSPRespBuilder.SUCCESSFUL);</span>
        }
<span class="nc bnc" id="L2108" title="All 2 branches missed.">        if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2109">          transactionLogger.paramPut(</span>
<span class="nc" id="L2110">              TransactionLogger.STATUS, OCSPRespBuilder.SUCCESSFUL);</span>
        }
<span class="nc" id="L2112">      } else {</span>
        // Only unknown CAs in requests and no default responder's cert, return
        // an unsigned response
<span class="nc bnc" id="L2115" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2116">          LOG.debug(INTRES.getLocalizedMessage(&quot;ocsp.errornocacreateresp&quot;));</span>
        }
<span class="nc" id="L2118">        ocspResponse =</span>
<span class="nc" id="L2119">            responseGenerator.build(OCSPRespBuilder.UNAUTHORIZED, null);</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">        if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2121">          auditLogger.paramPut(</span>
<span class="nc" id="L2122">              AuditLogger.STATUS, OCSPRespBuilder.UNAUTHORIZED);</span>
        }
<span class="nc bnc" id="L2124" title="All 2 branches missed.">        if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2125">          transactionLogger.paramPut(</span>
<span class="nc" id="L2126">              TransactionLogger.STATUS, OCSPRespBuilder.UNAUTHORIZED);</span>
        }
      }
<span class="nc" id="L2129">    } catch (SignRequestException e) {</span>
<span class="nc bnc" id="L2130" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2131">        transactionLogger.paramPut(</span>
            PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
      }
<span class="nc bnc" id="L2134" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2135">        auditLogger.paramPut(</span>
            PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
      }
<span class="nc" id="L2138">      String errMsg =</span>
<span class="nc" id="L2139">          INTRES.getLocalizedMessage(&quot;ocsp.errorprocessreq&quot;, e.getMessage());</span>
<span class="nc" id="L2140">      LOG.info(errMsg); // No need to log the full exception here</span>
      // RFC 2560: responseBytes are not set on error.
<span class="nc" id="L2142">      ocspResponse =</span>
<span class="nc" id="L2143">          responseGenerator.build(OCSPRespBuilder.SIG_REQUIRED, null);</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2145">        transactionLogger.paramPut(</span>
<span class="nc" id="L2146">            TransactionLogger.STATUS, OCSPRespBuilder.SIG_REQUIRED);</span>
<span class="nc" id="L2147">        transactionLogger.writeln();</span>
      }
<span class="nc bnc" id="L2149" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2150">        auditLogger.paramPut(AuditLogger.STATUS, OCSPRespBuilder.SIG_REQUIRED);</span>
      }
<span class="nc" id="L2152">    } catch (SignRequestSignatureException | IllegalNonceException e) {</span>
<span class="nc bnc" id="L2153" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2154">        transactionLogger.paramPut(</span>
            PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
      }
<span class="nc bnc" id="L2157" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2158">        auditLogger.paramPut(</span>
            PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
      }
<span class="nc" id="L2161">      String errMsg =</span>
<span class="nc" id="L2162">          INTRES.getLocalizedMessage(&quot;ocsp.errorprocessreq&quot;, e.getMessage());</span>
<span class="nc" id="L2163">      LOG.info(errMsg); // No need to log the full exception here</span>
      // RFC 2560: responseBytes are not set on error.
<span class="nc" id="L2165">      ocspResponse =</span>
<span class="nc" id="L2166">          responseGenerator.build(OCSPRespBuilder.UNAUTHORIZED, null);</span>
<span class="nc bnc" id="L2167" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2168">        transactionLogger.paramPut(</span>
<span class="nc" id="L2169">            TransactionLogger.STATUS, OCSPRespBuilder.UNAUTHORIZED);</span>
<span class="nc" id="L2170">        transactionLogger.writeln();</span>
      }
<span class="nc bnc" id="L2172" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2173">        auditLogger.paramPut(AuditLogger.STATUS, OCSPRespBuilder.UNAUTHORIZED);</span>
      }
<span class="nc" id="L2175">    } catch (InvalidAlgorithmException e) {</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2177">        transactionLogger.paramPut(</span>
            PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
      }
<span class="nc bnc" id="L2180" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2181">        auditLogger.paramPut(</span>
            PatternLogger.PROCESS_TIME, PatternLogger.PROCESS_TIME);
      }
<span class="nc" id="L2184">      String errMsg =</span>
<span class="nc" id="L2185">          INTRES.getLocalizedMessage(&quot;ocsp.errorprocessreq&quot;, e.getMessage());</span>
<span class="nc" id="L2186">      LOG.info(errMsg); // No need to log the full exception here</span>
      // RFC 2560: responseBytes are not set on error.
<span class="nc" id="L2188">      ocspResponse =</span>
<span class="nc" id="L2189">          responseGenerator.build(OCSPRespBuilder.MALFORMED_REQUEST, null);</span>
<span class="nc bnc" id="L2190" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2191">        transactionLogger.paramPut(</span>
<span class="nc" id="L2192">            TransactionLogger.STATUS, OCSPRespBuilder.MALFORMED_REQUEST);</span>
<span class="nc" id="L2193">        transactionLogger.writeln();</span>
      }
<span class="nc bnc" id="L2195" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2196">        auditLogger.paramPut(</span>
<span class="nc" id="L2197">            AuditLogger.STATUS, OCSPRespBuilder.MALFORMED_REQUEST);</span>
      }
<span class="nc" id="L2199">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2200">      ocspResponse =</span>
<span class="nc" id="L2201">          processDefaultError(</span>
              responseGenerator, transactionLogger, auditLogger, e);
<span class="nc" id="L2203">    } catch (CertificateException e) {</span>
<span class="nc" id="L2204">      ocspResponse =</span>
<span class="nc" id="L2205">          processDefaultError(</span>
              responseGenerator, transactionLogger, auditLogger, e);
<span class="nc" id="L2207">    } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L2208">      ocspResponse =</span>
<span class="nc" id="L2209">          processDefaultError(</span>
              responseGenerator, transactionLogger, auditLogger, e);
<span class="nc" id="L2211">    }</span>
    try {
<span class="nc" id="L2213">      respBytes = ocspResponse.getEncoded();</span>
<span class="nc bnc" id="L2214" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2215">        auditLogger.paramPut(</span>
<span class="nc" id="L2216">            AuditLogger.OCSPRESPONSE, new String(Hex.encode(respBytes)));</span>
<span class="nc" id="L2217">        auditLogger.writeln();</span>
<span class="nc" id="L2218">        auditLogger.flush();</span>
      }
<span class="nc bnc" id="L2220" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2221">        transactionLogger.flush();</span>
      }
<span class="nc bnc" id="L2223" title="All 2 branches missed.">      if (OcspConfiguration.getLogSafer()) {</span>
        // See if the Errorhandler has found any problems
<span class="nc bnc" id="L2225" title="All 2 branches missed.">        if (hasErrorHandlerFailedSince(startTime)) {</span>
<span class="nc" id="L2226">          LOG.info(</span>
              &quot;ProbableErrorhandler reported error, cannot answer request&quot;);
          // RFC 2560: responseBytes are not set on error.
<span class="nc" id="L2229">          ocspResponse =</span>
<span class="nc" id="L2230">              responseGenerator.build(OCSPRespBuilder.INTERNAL_ERROR, null);</span>
        }
        // See if the Appender has reported any problems
<span class="nc bnc" id="L2233" title="All 2 branches missed.">        if (!CanLogCache.INSTANCE.canLog()) {</span>
<span class="nc" id="L2234">          LOG.info(</span>
              &quot;SaferDailyRollingFileAppender reported error, cannot answer&quot;
                  + &quot; request&quot;);
          // RFC 2560: responseBytes are not set on error.
<span class="nc" id="L2238">          ocspResponse =</span>
<span class="nc" id="L2239">              responseGenerator.build(OCSPRespBuilder.INTERNAL_ERROR, null);</span>
        }
      }
<span class="nc" id="L2242">    } catch (IOException e) {</span>
<span class="nc" id="L2243">      LOG.error(&quot;Unexpected IOException caught.&quot;, e);</span>
<span class="nc bnc" id="L2244" title="All 2 branches missed.">      if (transactionLogger.isEnabled()) {</span>
<span class="nc" id="L2245">        transactionLogger.flush();</span>
      }
<span class="nc bnc" id="L2247" title="All 2 branches missed.">      if (auditLogger.isEnabled()) {</span>
<span class="nc" id="L2248">        auditLogger.flush();</span>
      }
<span class="nc" id="L2250">    }</span>
<span class="nc" id="L2251">    return new OcspResponseInformation(ocspResponse, maxAge, signerCert);</span>
  }

  private boolean checkAddArchiveCuttoff(
      final String caCertificateSubjectDn, final CertificateID certId) {
<span class="nc bnc" id="L2256" title="All 2 branches missed.">    if (OcspConfiguration.getExpiredArchiveCutoff() == -1) {</span>
<span class="nc" id="L2257">      return false;</span>
    }
<span class="nc" id="L2259">    CertificateInfo info =</span>
<span class="nc" id="L2260">        certificateStoreSession.findFirstCertificateInfo(</span>
<span class="nc" id="L2261">            caCertificateSubjectDn, certId.getSerialNumber());</span>
<span class="nc" id="L2262">    Date expDate = info.getExpireDate();</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">    if (expDate.before(new Date())) {</span>
<span class="nc" id="L2264">      LOG.info(</span>
          &quot;Certificate with serial number '&quot;
<span class="nc" id="L2266">              + certId.getSerialNumber()</span>
              + &quot;' is not valid. &quot;
              + &quot;Adding singleExtension id-pkix-ocsp-archive-cutoff&quot;);
<span class="nc" id="L2269">      return true;</span>
    }
<span class="nc" id="L2271">    return false;</span>
  }

  private void addArchiveCutoff(final OCSPResponseItem respItem) {
<span class="nc" id="L2275">    long archPeriod = OcspConfiguration.getExpiredArchiveCutoff();</span>
<span class="nc bnc" id="L2276" title="All 2 branches missed.">    if (archPeriod == -1) {</span>
<span class="nc" id="L2277">      return;</span>
    }
<span class="nc" id="L2279">    long res = System.currentTimeMillis() - archPeriod;</span>
    ASN1OctetString archiveCutoffValue;
    try {
<span class="nc" id="L2282">      archiveCutoffValue =</span>
          new DEROctetString(new ASN1GeneralizedTime(new Date(res)));
<span class="nc" id="L2284">    } catch (IOException e) {</span>
<span class="nc" id="L2285">      throw new IllegalStateException(</span>
          &quot;IOException was caught when decoding static value.&quot;, e);
<span class="nc" id="L2287">    }</span>
<span class="nc" id="L2288">    Extension archiveCutoff =</span>
        new Extension(
            OCSPObjectIdentifiers.id_pkix_ocsp_archive_cutoff,
            false,
            archiveCutoffValue);
<span class="nc" id="L2293">    respItem.addExtensions(</span>
<span class="nc" id="L2294">        Collections.singletonMap(</span>
            OCSPObjectIdentifiers.id_pkix_ocsp_archive_cutoff, archiveCutoff));
<span class="nc" id="L2296">  }</span>

  /**
   * returns a Map of responseExtensions to be added to the
   * BacisOCSPResponseGenerator with &lt;code&gt;
   * X509Extensions exts = new X509Extensions(table);
   * basicRes.setResponseExtensions(responseExtensions).
   * &lt;/code&gt;
   *
   * @param req the OCSP request
   * @param ocspSigningCacheEntry the OCSP signing cache entry used
   * @return a HashMap, can be empty but not null
   * @throws IllegalNonceException if Nonce is larger than 32 bytes
   */
  private Map&lt;ASN1ObjectIdentifier, Extension&gt; getStandardResponseExtensions(
      final OCSPReq req, final OcspSigningCacheEntry ocspSigningCacheEntry)
      throws IllegalNonceException {
<span class="nc" id="L2313">    HashMap&lt;ASN1ObjectIdentifier, Extension&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2314" title="All 2 branches missed.">    if (req.hasExtensions()) {</span>
      // Table of extensions to include in the response
      // OCSP Nonce, if included in the request, the response must include the
      // same according to RFC6960
<span class="nc" id="L2318">      Extension ext =</span>
<span class="nc" id="L2319">          req.getExtension(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);</span>
      // Check the keybinding firsthand if nonce's are enabled, if there is no
      // keybinding (because a CA is replying), check the global value.
      boolean nonceEnable =
<span class="nc bnc" id="L2323" title="All 2 branches missed.">          (ocspSigningCacheEntry.getOcspKeyBinding() != null</span>
<span class="nc" id="L2324">              ? ocspSigningCacheEntry.getOcspKeyBinding().isNonceEnabled()</span>
              : ((GlobalOcspConfiguration)
<span class="nc" id="L2326">                      globalConfigurationSession.getCachedConfiguration(</span>
                          GlobalOcspConfiguration.OCSP_CONFIGURATION_ID))
<span class="nc" id="L2328">                  .getNonceEnabled());</span>
<span class="nc bnc" id="L2329" title="All 4 branches missed.">      if (null != ext &amp;&amp; nonceEnable) {</span>
<span class="nc" id="L2330">        ASN1OctetString noncestr = ext.getExtnValue();</span>
        // Limit Nonce to 32 bytes to avoid chosen-prefix attack on hash
        // collisions.
        // See
        // https://groups.google.com/forum/#!topic/mozilla.dev.security.policy/x3TOIJL7MGw
<span class="nc" id="L2335">        final int max = 32;</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">        if ((noncestr != null)</span>
<span class="nc bnc" id="L2337" title="All 2 branches missed.">            &amp;&amp; (noncestr.getOctets() != null)</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">            &amp;&amp; (noncestr.getOctets().length &gt; max)) {</span>
<span class="nc" id="L2339">          LOG.info(</span>
              &quot;Received OCSP request with Nonce larger than 32 bytes,&quot;
                  + &quot; rejecting.&quot;);
<span class="nc" id="L2342">          throw new IllegalNonceException(&quot;Nonce too large&quot;);</span>
        }
<span class="nc" id="L2344">        result.put(OCSPObjectIdentifiers.id_pkix_ocsp_nonce, ext);</span>
      }
    }
<span class="nc" id="L2347">    return result;</span>
  }

  /**
   * This method handles cache misses where there exists an active key binding
   * which hasn't been cached.
   *
   * @param certId the CertificateID for the certificate being requested.
   * @return the now cached entry, or null if none was found.
   * @throws CertificateEncodingException on fail
   */
  private OcspSigningCacheEntry findAndAddMissingCacheEntry(
      final CertificateID certId) throws CertificateEncodingException {
<span class="nc" id="L2360">    OcspSigningCacheEntry ocspSigningCacheEntry = null;</span>
    for (final int internalKeyBindingId
<span class="nc bnc" id="L2362" title="All 2 branches missed.">        : internalKeyBindingDataSession.getIds(</span>
            OcspKeyBinding.IMPLEMENTATION_ALIAS)) {
<span class="nc" id="L2364">      final OcspKeyBinding ocspKeyBinding =</span>
          (OcspKeyBinding)
<span class="nc" id="L2366">              internalKeyBindingDataSession.getInternalKeyBinding(</span>
                  internalKeyBindingId);
<span class="nc bnc" id="L2368" title="All 2 branches missed.">      if (ocspKeyBinding.getStatus().equals(InternalKeyBindingStatus.ACTIVE)) {</span>
<span class="nc" id="L2369">        X509Certificate ocspCertificate =</span>
            (X509Certificate)
<span class="nc" id="L2371">                certificateStoreSession.findCertificateByFingerprint(</span>
<span class="nc" id="L2372">                    ocspKeyBinding.getCertificateId());</span>
<span class="nc bnc" id="L2373" title="All 2 branches missed.">        if (ocspCertificate == null) {</span>
          // There may be key binding with missing certificates normally
          // (waiting for certificate response?), so don't spam the log
<span class="nc bnc" id="L2376" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2377">            LOG.debug(</span>
                &quot;Could not find certificate for OCSP Key Binding '&quot;
<span class="nc" id="L2379">                    + ocspKeyBinding.getName()</span>
                    + &quot;'. Certificate fingerprint: &quot;
<span class="nc" id="L2381">                    + ocspKeyBinding.getCertificateId());</span>
          }
        } else {
<span class="nc" id="L2384">          X509Certificate issuingCertificate =</span>
<span class="nc" id="L2385">              certificateStoreSession.findLatestX509CertificateBySubject(</span>
<span class="nc" id="L2386">                  CertTools.getIssuerDN(ocspCertificate));</span>
<span class="nc bnc" id="L2387" title="All 2 branches missed.">          if (issuingCertificate == null) {</span>
            // There may be key binding with missing certificates normally
            // (waiting for certificate response?), so don't spam the log
<span class="nc bnc" id="L2390" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2391">              LOG.info(</span>
                  &quot;Could not find issuer certificate for OCSP Key Binding '&quot;
<span class="nc" id="L2393">                      + ocspKeyBinding.getName()</span>
                      + &quot;'. Issuer DN: &quot;
<span class="nc" id="L2395">                      + ocspKeyBinding.getCertificateId());</span>
            }
          } else {
            try {
<span class="nc bnc" id="L2399" title="All 2 branches missed.">              if (certId.matchesIssuer(</span>
                  new JcaX509CertificateHolder(issuingCertificate),
                  new BcDigestCalculatorProvider())) {
                // We found it! Unless it's not active, or something else was
                // wrong with it.
<span class="nc" id="L2404">                ocspSigningCacheEntry =</span>
<span class="nc" id="L2405">                    makeOcspSigningCacheEntry(ocspCertificate, ocspKeyBinding);</span>
                // If it was all right, add it to the cache for future use.
<span class="nc bnc" id="L2407" title="All 2 branches missed.">                if (ocspSigningCacheEntry != null) {</span>
<span class="nc" id="L2408">                  OcspSigningCache.INSTANCE.addSingleEntry(</span>
                      ocspSigningCacheEntry);
<span class="nc" id="L2410">                  break;</span>
                }
              }
<span class="nc" id="L2413">            } catch (OCSPException e) {</span>
<span class="nc" id="L2414">              throw new IllegalStateException(</span>
                  &quot;Could not create BcDigestCalculatorProvider&quot;, e);
<span class="nc" id="L2416">            }</span>
          }
        }
      }
<span class="nc" id="L2420">    }</span>
<span class="nc" id="L2421">    return ocspSigningCacheEntry;</span>
  }

  private BasicOCSPResp signOcspResponse(
      final OCSPReq req,
      final List&lt;OCSPResponseItem&gt; responseList,
      final Extensions exts,
      final OcspSigningCacheEntry ocspSigningCacheEntry,
      final Date producedAt)
      throws CryptoTokenOfflineException {
<span class="nc" id="L2431">    assertAcceptableResponseExtension(req);</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">    if (!ocspSigningCacheEntry.isSigningCertificateForOcspSigning()) {</span>
<span class="nc" id="L2433">      LOG.warn(</span>
          &quot;Signing with non OCSP certificate (no 'OCSP Signing' Extended Key&quot;
              + &quot; Usage) bound by OcspKeyBinding '&quot;
<span class="nc" id="L2436">              + ocspSigningCacheEntry.getOcspKeyBinding().getName()</span>
              + &quot;'.&quot;);
    }
<span class="nc" id="L2439">    final X509Certificate signerCert =</span>
<span class="nc" id="L2440">        ocspSigningCacheEntry.getSigningCertificate();</span>
<span class="nc" id="L2441">    final String sigAlg = getSigAlg(req, ocspSigningCacheEntry, signerCert);</span>
<span class="nc bnc" id="L2442" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2443">      LOG.debug(&quot;Signing algorithm: &quot; + sigAlg);</span>
    }
    try {
      // Now we can use the returned OCSPServiceResponse to get private key and
      // certificate chain to sign the ocsp response
<span class="nc" id="L2448">      final BasicOCSPResp ocspresp =</span>
<span class="nc" id="L2449">          generateBasicOcspResp(</span>
              exts,
              responseList,
              sigAlg,
              signerCert,
              ocspSigningCacheEntry,
              producedAt);
<span class="nc bnc" id="L2456" title="All 2 branches missed.">      if (CertTools.isCertificateValid(</span>
          signerCert,
          false)) { // Don't warn about signer validity for each OCSP
                    // response...
<span class="nc" id="L2460">        return ocspresp;</span>
      } else {
<span class="nc" id="L2462">        throw new OcspFailureException(&quot;Response was not validly signed.&quot;);</span>
      }
<span class="nc" id="L2464">    } catch (OCSPException ocspe) {</span>
<span class="nc" id="L2465">      throw new OcspFailureException(ocspe);</span>
<span class="nc" id="L2466">    } catch (NoSuchProviderException nspe) {</span>
<span class="nc" id="L2467">      throw new OcspFailureException(nspe);</span>
<span class="nc" id="L2468">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L2469">      LOG.error(&quot;IllegalArgumentException: &quot;, e);</span>
<span class="nc" id="L2470">      throw new OcspFailureException(e);</span>
    }
  }

  private BasicOCSPResp generateBasicOcspResp(
      final Extensions exts,
      final List&lt;OCSPResponseItem&gt; responses,
      final String sigAlg,
      final X509Certificate signerCert,
      final OcspSigningCacheEntry ocspSigningCacheEntry,
      final Date producedAt)
      throws OCSPException, NoSuchProviderException,
          CryptoTokenOfflineException {
<span class="nc" id="L2483">    final PrivateKey signerKey = ocspSigningCacheEntry.getPrivateKey();</span>
<span class="nc" id="L2484">    final String provider = ocspSigningCacheEntry.getSignatureProviderName();</span>
<span class="nc" id="L2485">    BasicOCSPResp returnval = null;</span>
<span class="nc" id="L2486">    BasicOCSPRespBuilder basicRes =</span>
<span class="nc" id="L2487">        new BasicOCSPRespBuilder(ocspSigningCacheEntry.getRespId());</span>
<span class="nc bnc" id="L2488" title="All 2 branches missed.">    if (responses != null) {</span>
<span class="nc bnc" id="L2489" title="All 2 branches missed.">      for (OCSPResponseItem item : responses) {</span>
<span class="nc" id="L2490">        Date nextUpdate = item.getNextUpdate();</span>
        // Adjust nextUpdate so that it can never exceed the OCSP responder
        // signing certificate validity
<span class="nc bnc" id="L2493" title="All 4 branches missed.">        if (signerCert != null</span>
            &amp;&amp; nextUpdate != null
<span class="nc bnc" id="L2495" title="All 2 branches missed.">            &amp;&amp; signerCert.getNotAfter().before(nextUpdate)) {</span>
<span class="nc" id="L2496">          nextUpdate = signerCert.getNotAfter();</span>
        }
<span class="nc" id="L2498">        basicRes.addResponse(</span>
<span class="nc" id="L2499">            item.getCertID(),</span>
<span class="nc" id="L2500">            item.getCertStatus(),</span>
<span class="nc" id="L2501">            item.getThisUpdate(),</span>
            nextUpdate,
<span class="nc" id="L2503">            item.buildExtensions());</span>
<span class="nc" id="L2504">      }</span>
    }
<span class="nc bnc" id="L2506" title="All 2 branches missed.">    if (exts != null) {</span>
      @SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L2508">      Enumeration oids = exts.oids();</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">      if (oids.hasMoreElements()) {</span>
<span class="nc" id="L2510">        basicRes.setResponseExtensions(exts);</span>
      }
    }
<span class="nc" id="L2513">    final X509Certificate[] chain =</span>
<span class="nc" id="L2514">        ocspSigningCacheEntry.getResponseCertChain();</span>
<span class="nc bnc" id="L2515" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2516">      LOG.debug(</span>
          &quot;The response certificate chain contains &quot;
              + chain.length
              + &quot; certificates&quot;);
    }
    /*
     * The below code breaks the EJB standard by creating its own thread pool
     * and creating a single thread (of the HsmResponseThread
     * type). The reason for this is that the HSM may deadlock when requesting
     *  an OCSP response, which we need to guard against. Since
     * there is no way of performing this action within the EJB3.0 standard,
     * we are consciously creating threads here.
     *
     * Note that this does in no way break the spirit of the EJB standard,
     *  which is to not interrupt EJB's transaction handling by
     * competing with its own thread pool, since these operations have no
     * database impact.
     */
<span class="nc" id="L2534">    final Future&lt;BasicOCSPResp&gt; task =</span>
<span class="nc" id="L2535">        service.submit(</span>
            new HsmResponseThread(
                basicRes, sigAlg, signerKey, chain, provider, producedAt));
    try {
<span class="nc" id="L2539">      returnval =</span>
<span class="nc" id="L2540">          task.get(HsmResponseThread.HSM_TIMEOUT_SECONDS, TimeUnit.SECONDS);</span>
<span class="nc" id="L2541">    } catch (InterruptedException e) {</span>
<span class="nc" id="L2542">      task.cancel(true);</span>
<span class="nc" id="L2543">      throw new Error(</span>
          &quot;OCSP response retrieval was interrupted while running. This should&quot;
              + &quot; not happen&quot;,
          e);
<span class="nc" id="L2547">    } catch (ExecutionException e) {</span>
<span class="nc" id="L2548">      task.cancel(true);</span>
<span class="nc" id="L2549">      throw new OcspFailureException(</span>
          &quot;Failure encountered while retrieving OCSP response.&quot;, e);
<span class="nc" id="L2551">    } catch (TimeoutException e) {</span>
<span class="nc" id="L2552">      task.cancel(true);</span>
<span class="nc" id="L2553">      throw new CryptoTokenOfflineException(</span>
          &quot;HSM timed out while trying to get OCSP response&quot;, e);
<span class="nc" id="L2555">    }</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2557">      LOG.debug(</span>
          &quot;Signing OCSP response with OCSP signer cert: &quot;
<span class="nc" id="L2559">              + signerCert.getSubjectDN().getName());</span>
    }
<span class="nc bnc" id="L2561" title="All 2 branches missed.">    if (!returnval.getResponderId().equals(ocspSigningCacheEntry.getRespId())) {</span>
<span class="nc" id="L2562">      LOG.error(</span>
          &quot;Response responderId does not match signer certificate&quot;
              + &quot; responderId!&quot;);
<span class="nc" id="L2565">      throw new OcspFailureException(</span>
          &quot;Response responderId does not match signer certificate&quot;
              + &quot; responderId!&quot;);
    }
<span class="nc bnc" id="L2569" title="All 2 branches missed.">    if (!ocspSigningCacheEntry.checkResponseSignatureVerified()) {</span>
      // We only check the response signature the first time for each
      // OcspSigningCacheEntry to detect a misbehaving HSM.
      // The client is still responsible for validating the signature, see RFC
      // 6960 Section 3.2.2
      boolean verify;
      try {
<span class="nc" id="L2576">        verify =</span>
<span class="nc" id="L2577">            returnval.isSignatureValid(</span>
<span class="nc" id="L2578">                CertTools.genContentVerifierProvider(</span>
<span class="nc" id="L2579">                    signerCert.getPublicKey()));</span>
<span class="nc" id="L2580">      } catch (OperatorCreationException e) {</span>
        // Very fatal error
<span class="nc" id="L2582">        throw new EJBException(&quot;Can not create Jca content signer: &quot;, e);</span>
<span class="nc" id="L2583">      }</span>
<span class="nc bnc" id="L2584" title="All 2 branches missed.">      if (verify) {</span>
<span class="nc bnc" id="L2585" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2586">          LOG.debug(&quot;The OCSP response is verifying.&quot;);</span>
        }
      } else {
<span class="nc" id="L2589">        LOG.error(</span>
            &quot;The response is NOT verifying! Attempted to sign using &quot;
<span class="nc" id="L2591">                + CertTools.getSubjectDN(signerCert)</span>
                + &quot; but signature was not valid.&quot;);
<span class="nc" id="L2593">        throw new OcspFailureException(</span>
            &quot;Attempted to sign using &quot;
<span class="nc" id="L2595">                + CertTools.getSubjectDN(signerCert)</span>
                + &quot; but signature was not valid.&quot;);
      }
    }
<span class="nc" id="L2599">    return returnval;</span>
  }

  /**
   * Method that checks with ProbableErrorHandler if an error has happened since
   * a certain time. Uses reflection to call ProbableErrorHandler because it is
   * dependent on JBoss log4j logging, which is not available on other
   * application servers.
   *
   * @param startTime time
   * @return true if an error has occurred since startTime
   */
  private boolean hasErrorHandlerFailedSince(final Date startTime) {
<span class="nc" id="L2612">    boolean result = true; // Default true. If something goes wrong we will fail</span>
<span class="nc" id="L2613">    result = ProbableErrorHandler.hasFailedSince(startTime);</span>
<span class="nc bnc" id="L2614" title="All 2 branches missed.">    if (result) {</span>
<span class="nc" id="L2615">      LOG.error(&quot;Audit and/or account logging failed since &quot; + startTime);</span>
    }
<span class="nc" id="L2617">    return result;</span>
  }

  /**
   * Returns a signing algorithm to use selecting from a list of possible
   * algorithms.
   *
   * @param sigalgs the list of possible algorithms, ;-separated. Example
   *     &quot;SHA1WithRSA;SHA1WithECDSA&quot;.
   * @param pk public key of signer, so we can choose between RSA, DSA and ECDSA
   *     algorithms
   * @return A single algorithm to use Example: SHA1WithRSA, SHA1WithDSA or
   *     SHA1WithECDSA
   */
  private static String getSigningAlgFromAlgSelection(
      final String sigalgs, final PublicKey pk) {
<span class="nc" id="L2633">    String sigAlg = null;</span>
<span class="nc" id="L2634">    String[] algs = StringUtils.split(sigalgs, ';');</span>
<span class="nc bnc" id="L2635" title="All 2 branches missed.">    for (int i = 0; i &lt; algs.length; i++) {</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">      if (AlgorithmTools.isCompatibleSigAlg(pk, algs[i])) {</span>
<span class="nc" id="L2637">        sigAlg = algs[i];</span>
<span class="nc" id="L2638">        break;</span>
      }
    }
<span class="nc" id="L2641">    LOG.debug(&quot;Using signature algorithm for response: &quot; + sigAlg);</span>
<span class="nc" id="L2642">    return sigAlg;</span>
  }

<span class="nc" id="L2645">  private enum CanLogCache {</span>
      /** singleton. */
<span class="nc" id="L2647">    INSTANCE;</span>

      /** bool. */
    private boolean canLog;

<span class="nc" id="L2652">     CanLogCache() {</span>
<span class="nc" id="L2653">      this.canLog = true;</span>
<span class="nc" id="L2654">    }</span>

    public boolean canLog() {
<span class="nc" id="L2657">      return canLog;</span>
    }

    public void setCanLog(final boolean doCanLog) {
<span class="nc" id="L2661">      this.canLog = doCanLog;</span>
<span class="nc" id="L2662">    }</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
  @Deprecated // Remove this method once upgrading from 5-6 is dropped
  public void adhocUpgradeFromPre60(final char[] activationPassword) {
<span class="nc" id="L2669">    AuthenticationToken authenticationToken =</span>
        new AlwaysAllowLocalAuthenticationToken(
            new UsernamePrincipal(
<span class="nc" id="L2672">                OcspResponseGeneratorSessionBean.class.getSimpleName()</span>
                    + &quot;.adhocUpgradeFromPre60&quot;));
    // Check if there are any OcspKeyBindings already, if so return
<span class="nc" id="L2675">    if (!internalKeyBindingDataSession</span>
<span class="nc" id="L2676">        .getIds(OcspKeyBinding.IMPLEMENTATION_ALIAS)</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">        .isEmpty()) {</span>
<span class="nc" id="L2678">      return;</span>
    }
    // If ocsp.activation.doNotStorePasswordsInMemory=true, new Crypto Tokens
    // should not be auto-actived
    final boolean globalDoNotStorePasswordsInMemory =
<span class="nc" id="L2683">        OcspConfiguration.getDoNotStorePasswordsInMemory();</span>
<span class="nc bnc" id="L2684" title="All 4 branches missed.">    if (globalDoNotStorePasswordsInMemory &amp;&amp; activationPassword == null) {</span>
<span class="nc" id="L2685">      LOG.info(</span>
          &quot;Postponing conversion of ocsp.properties configuration to&quot;
              + &quot; OcspKeyBindings since password is not yet available.&quot;);
<span class="nc" id="L2688">      return;</span>
    }
<span class="nc" id="L2690">    LOG.info(</span>
        &quot;No OcspKeyBindings found. Processing ocsp.properties to see if we&quot;
            + &quot; need to perform conversion.&quot;);
<span class="nc" id="L2693">    final List&lt;InternalKeyBindingTrustEntry&gt; trustDefaults =</span>
<span class="nc" id="L2694">        getOcspKeyBindingTrustDefaults();</span>
    // Create CryptoTokens and AuthenticationKeyBinding from:
    //  ocsp.rekeying.swKeystorePath = wsKeyStore.jks
    //  ocsp.rekeying.swKeystorePassword = foo123
    //  if &quot;ocsp.rekeying.swKeystorePath&quot; isn't set, search the p11 slot later
    // on for an entry with an SSL certificate and use this
<span class="nc" id="L2700">    final String swKeystorePath =</span>
<span class="nc" id="L2701">        ConfigurationHolder.getString(&quot;ocsp.rekeying.swKeystorePath&quot;);</span>
<span class="nc" id="L2702">    final String swKeystorePassword =</span>
<span class="nc" id="L2703">        ConfigurationHolder.getString(&quot;ocsp.rekeying.swKeystorePassword&quot;);</span>
<span class="nc bnc" id="L2704" title="All 6 branches missed.">    if (swKeystorePath != null</span>
        &amp;&amp; (swKeystorePassword != null || activationPassword != null)) {
      final String password =
<span class="nc bnc" id="L2707" title="All 2 branches missed.">          swKeystorePassword == null</span>
<span class="nc" id="L2708">              ? new String(activationPassword)</span>
<span class="nc" id="L2709">              : swKeystorePassword;</span>
<span class="nc" id="L2710">      processSoftKeystore(</span>
          authenticationToken,
          new File(swKeystorePath),
          password,
          password,
          globalDoNotStorePasswordsInMemory,
          trustDefaults);
    }
<span class="nc bnc" id="L2718" title="All 4 branches missed.">    if (OcspConfiguration.getP11Password() != null</span>
        || activationPassword != null) {
<span class="nc" id="L2720">      LOG.info(&quot; Processing PKCS#11..&quot;);</span>
<span class="nc" id="L2721">      final String p11SharedLibrary = OcspConfiguration.getP11SharedLibrary();</span>
      final String sunP11ConfigurationFile =
<span class="nc" id="L2723">          OcspConfiguration.getSunP11ConfigurationFile();</span>
      try {
        final String p11password =
<span class="nc bnc" id="L2726" title="All 2 branches missed.">            OcspConfiguration.getP11Password() == null</span>
<span class="nc" id="L2727">                ? new String(activationPassword)</span>
<span class="nc" id="L2728">                : OcspConfiguration.getP11Password();</span>
<span class="nc" id="L2729">        String cryptoTokenName = null;</span>
<span class="nc" id="L2730">        final Properties cryptoTokenProperties = new Properties();</span>
<span class="nc bnc" id="L2731" title="All 4 branches missed.">        if (p11SharedLibrary != null &amp;&amp; p11SharedLibrary.length() != 0) {</span>
<span class="nc" id="L2732">          LOG.info(</span>
              &quot; Processing PKCS#11 with shared library &quot; + p11SharedLibrary);
<span class="nc" id="L2734">          final String p11slot = OcspConfiguration.getP11SlotIndex();</span>
<span class="nc" id="L2735">          cryptoTokenProperties.put(</span>
              PKCS11CryptoToken.SHLIB_LABEL_KEY, p11SharedLibrary);
<span class="nc" id="L2737">          cryptoTokenProperties.put(</span>
              PKCS11CryptoToken.SLOT_LABEL_VALUE, p11slot);
          // Guess label type in order index, number or label
          Pkcs11SlotLabelType type;
<span class="nc bnc" id="L2741" title="All 2 branches missed.">          if (Pkcs11SlotLabelType.SLOT_NUMBER.validate(p11slot)) {</span>
<span class="nc" id="L2742">            type = Pkcs11SlotLabelType.SLOT_NUMBER;</span>
<span class="nc bnc" id="L2743" title="All 2 branches missed.">          } else if (Pkcs11SlotLabelType.SLOT_INDEX.validate(p11slot)) {</span>
<span class="nc" id="L2744">            type = Pkcs11SlotLabelType.SLOT_INDEX;</span>
          } else {
<span class="nc" id="L2746">            type = Pkcs11SlotLabelType.SLOT_LABEL;</span>
          }
<span class="nc" id="L2748">          cryptoTokenProperties.put(</span>
<span class="nc" id="L2749">              PKCS11CryptoToken.SLOT_LABEL_TYPE, type.getKey());</span>
<span class="nc" id="L2750">          cryptoTokenName = &quot;PKCS11 slot &quot; + p11slot;</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">        } else if (sunP11ConfigurationFile != null</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">            &amp;&amp; sunP11ConfigurationFile.length() != 0) {</span>
<span class="nc" id="L2753">          LOG.info(</span>
              &quot; Processing PKCS#11 with Sun property file &quot;
                  + sunP11ConfigurationFile);
          // The following properties are of interest from this file
          // We will bravely ignore attributes.. it wouldn't be to hard for the
          // user to change the CryptoToken's attributes file later on
          // name=SafeNet
          // library=/opt/PTK/lib/libcryptoki.so
          // slot=1
          // slotListIndex=1
          // attributes(...) = {..}
          // ...
<span class="nc" id="L2765">          final Properties p11ConfigurationFileProperties = new Properties();</span>
<span class="nc" id="L2766">          p11ConfigurationFileProperties.load(</span>
              new FileInputStream(sunP11ConfigurationFile));
<span class="nc" id="L2768">          String p11slot = p11ConfigurationFileProperties.getProperty(&quot;slot&quot;);</span>
<span class="nc" id="L2769">          cryptoTokenProperties.put(</span>
              PKCS11CryptoToken.SLOT_LABEL_VALUE, p11slot);
          // Guess label type in order index, number or label
          Pkcs11SlotLabelType type;
<span class="nc bnc" id="L2773" title="All 2 branches missed.">          if (Pkcs11SlotLabelType.SLOT_NUMBER.validate(p11slot)) {</span>
<span class="nc" id="L2774">            type = Pkcs11SlotLabelType.SLOT_NUMBER;</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">          } else if (Pkcs11SlotLabelType.SLOT_INDEX.validate(p11slot)) {</span>
<span class="nc" id="L2776">            type = Pkcs11SlotLabelType.SLOT_INDEX;</span>
          } else {
<span class="nc" id="L2778">            type = Pkcs11SlotLabelType.SLOT_LABEL;</span>
          }
<span class="nc" id="L2780">          cryptoTokenProperties.put(</span>
<span class="nc" id="L2781">              PKCS11CryptoToken.SLOT_LABEL_TYPE, type.getKey());</span>

<span class="nc" id="L2783">          cryptoTokenProperties.put(</span>
              PKCS11CryptoToken.SHLIB_LABEL_KEY,
<span class="nc" id="L2785">              p11ConfigurationFileProperties.getProperty(&quot;library&quot;));</span>
          // cryptoTokenProperties.put(PKCS11CryptoToken.ATTRIB_LABEL_KEY,
          // null);
<span class="nc" id="L2788">          LOG.warn(</span>
              &quot;Any attributes(..) = { ... } will be ignored and system&quot;
                  + &quot; defaults will be used. You should reconfigure the&quot;
                  + &quot; CryptoToken later if this is not sufficient.&quot;);
<span class="nc" id="L2792">          cryptoTokenName =</span>
              &quot;PKCS11 slot &quot;
<span class="nc" id="L2794">                  + p11ConfigurationFileProperties.getProperty(</span>
                      &quot;slot&quot;,
                      &quot;i&quot;
<span class="nc" id="L2797">                          + p11ConfigurationFileProperties.getProperty(</span>
                              &quot;slotListIndex&quot;));
        }
<span class="nc bnc" id="L2800" title="All 2 branches missed.">        if (cryptoTokenName != null</span>
<span class="nc bnc" id="L2801" title="All 2 branches missed.">            &amp;&amp; cryptoTokenManagementSession.getIdFromName(cryptoTokenName)</span>
                == null) {
<span class="nc bnc" id="L2803" title="All 2 branches missed.">          if (!globalDoNotStorePasswordsInMemory) {</span>
<span class="nc" id="L2804">            LOG.info(&quot; Auto-activation will be used.&quot;);</span>
<span class="nc" id="L2805">            BaseCryptoToken.setAutoActivatePin(</span>
                cryptoTokenProperties, new String(p11password), true);
          } else {
<span class="nc" id="L2808">            LOG.info(&quot; Auto-activation will not be used.&quot;);</span>
          }
<span class="nc" id="L2810">          final int p11CryptoTokenId =</span>
<span class="nc" id="L2811">              cryptoTokenManagementSession.createCryptoToken(</span>
                  authenticationToken,
                  cryptoTokenName,
<span class="nc" id="L2814">                  PKCS11CryptoToken.class.getName(),</span>
                  cryptoTokenProperties,
                  null,
<span class="nc" id="L2817">                  p11password.toCharArray());</span>
          // Use reflection to dig out the certificate objects for each alias so
          // we can create an internal key binding for it
<span class="nc" id="L2820">          final Method m =</span>
<span class="nc" id="L2821">              BaseCryptoToken.class.getDeclaredMethod(&quot;getKeyStore&quot;);</span>
<span class="nc" id="L2822">          m.setAccessible(true);</span>
<span class="nc" id="L2823">          final CachingKeyStoreWrapper cachingKeyStoreWrapper =</span>
              (CachingKeyStoreWrapper)
<span class="nc" id="L2825">                  m.invoke(</span>
<span class="nc" id="L2826">                      cryptoTokenManagementSession.getCryptoToken(</span>
                          p11CryptoTokenId));
<span class="nc" id="L2828">          createInternalKeyBindings(</span>
              authenticationToken,
              p11CryptoTokenId,
<span class="nc" id="L2831">              cachingKeyStoreWrapper.getKeyStore(),</span>
              trustDefaults);
        }
<span class="nc" id="L2834">      } catch (Exception e) {</span>
<span class="nc" id="L2835">        LOG.error(&quot;&quot;, e);</span>
<span class="nc" id="L2836">      }</span>
    }
<span class="nc bnc" id="L2838" title="All 2 branches missed.">    if (OcspConfiguration.getSoftKeyDirectoryName() != null</span>
<span class="nc bnc" id="L2839" title="All 4 branches missed.">        &amp;&amp; (OcspConfiguration.getStorePassword() != null</span>
            || activationPassword != null)) {
      final String softStorePassword =
<span class="nc bnc" id="L2842" title="All 2 branches missed.">          OcspConfiguration.getStorePassword() == null</span>
<span class="nc" id="L2843">              ? new String(activationPassword)</span>
<span class="nc" id="L2844">              : OcspConfiguration.getStorePassword();</span>
      final String softKeyPassword =
<span class="nc bnc" id="L2846" title="All 2 branches missed.">          OcspConfiguration.getKeyPassword() == null</span>
<span class="nc" id="L2847">              ? new String(activationPassword)</span>
<span class="nc" id="L2848">              : OcspConfiguration.getKeyPassword();</span>
<span class="nc" id="L2849">      final String dirName = OcspConfiguration.getSoftKeyDirectoryName();</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">      if (dirName != null) {</span>
<span class="nc" id="L2851">        final File directory = new File(dirName);</span>
<span class="nc bnc" id="L2852" title="All 2 branches missed.">        if (directory.isDirectory()) {</span>
<span class="nc" id="L2853">          LOG.info(&quot; Processing Soft KeyStores..&quot;);</span>
<span class="nc bnc" id="L2854" title="All 2 branches missed.">          for (final File file : directory.listFiles()) {</span>
<span class="nc" id="L2855">            processSoftKeystore(</span>
                authenticationToken,
                file,
                softStorePassword,
                softKeyPassword,
                globalDoNotStorePasswordsInMemory,
                trustDefaults);
          }
        }
      }
    }
<span class="nc" id="L2866">  }</span>

  @Deprecated // Remove this method as soon as upgrading from 5.0-&gt;6.x is
              // dropped
  private void processSoftKeystore(
      final AuthenticationToken authenticationToken,
      final File file,
      final String softStorePassword,
      final String softKeyPassword,
      final boolean doNotStorePasswordsInMemory,
      final List&lt;InternalKeyBindingTrustEntry&gt; trustDefaults) {
    KeyStore keyStore;
<span class="nc" id="L2878">    final char[] passwordChars = softStorePassword.toCharArray();</span>
    // Load keystore (JKS or PKCS#12)
    try {
<span class="nc" id="L2881">      keyStore = KeyStore.getInstance(&quot;JKS&quot;);</span>
<span class="nc" id="L2882">      keyStore.load(new FileInputStream(file), passwordChars);</span>
<span class="nc" id="L2883">    } catch (Exception e) {</span>
      try {
<span class="nc" id="L2885">        keyStore = KeyStore.getInstance(&quot;PKCS12&quot;, &quot;BC&quot;);</span>
<span class="nc" id="L2886">        keyStore.load(new FileInputStream(file), passwordChars);</span>
<span class="nc" id="L2887">      } catch (Exception e2) {</span>
        try {
<span class="nc" id="L2889">          LOG.info(</span>
              &quot;Unable to process &quot;
<span class="nc" id="L2891">                  + file.getCanonicalPath()</span>
                  + &quot; as a KeyStore.&quot;);
<span class="nc" id="L2893">        } catch (IOException e3) {</span>
<span class="nc" id="L2894">          LOG.warn(e3.getMessage());</span>
<span class="nc" id="L2895">        }</span>
<span class="nc" id="L2896">        return;</span>
<span class="nc" id="L2897">      }</span>
<span class="nc" id="L2898">    }</span>

    // Strip issuer certs, etc. and convert to PKCS#12
    try {
<span class="nc" id="L2902">      keyStore = makeKeysOnlyP12(keyStore, passwordChars);</span>
<span class="nc" id="L2903">    } catch (Exception e) {</span>
<span class="nc" id="L2904">      throw new RuntimeException(</span>
          &quot;failed to convert keystore to P12 during keybindings upgrade&quot;, e);
<span class="nc" id="L2906">    }</span>

<span class="nc" id="L2908">    final String name = file.getName();</span>
<span class="nc bnc" id="L2909" title="All 2 branches missed.">    if (cryptoTokenManagementSession.getIdFromName(name) != null) {</span>
<span class="nc" id="L2910">      return; // already upgraded</span>
    }
<span class="nc" id="L2912">    LOG.info(</span>
        &quot; Processing Soft KeyStore '&quot;
            + name
            + &quot;' of type &quot;
<span class="nc" id="L2916">            + keyStore.getType());</span>
    try {
<span class="nc" id="L2918">      final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
      // Save the store using the same password as the keys are protected with
      // (not the store password)
      // so we don't have to replace the protection for each key
<span class="nc" id="L2922">      keyStore.store(baos, softKeyPassword.toCharArray());</span>
<span class="nc" id="L2923">      final Properties cryptoTokenProperties = new Properties();</span>
<span class="nc bnc" id="L2924" title="All 2 branches missed.">      if (!doNotStorePasswordsInMemory) {</span>
<span class="nc" id="L2925">        LOG.info(&quot; Auto-activation will be used.&quot;);</span>
<span class="nc" id="L2926">        BaseCryptoToken.setAutoActivatePin(</span>
            cryptoTokenProperties, new String(softKeyPassword), true);
      } else {
<span class="nc" id="L2929">        LOG.info(&quot; Auto-activation will not be used.&quot;);</span>
      }
<span class="nc" id="L2931">      final int softCryptoTokenId =</span>
<span class="nc" id="L2932">          cryptoTokenManagementSession.createCryptoToken(</span>
              authenticationToken,
              name,
<span class="nc" id="L2935">              SoftCryptoToken.class.getName(),</span>
              cryptoTokenProperties,
<span class="nc" id="L2937">              baos.toByteArray(),</span>
<span class="nc" id="L2938">              softKeyPassword.toCharArray());</span>
<span class="nc" id="L2939">      createInternalKeyBindings(</span>
          authenticationToken, softCryptoTokenId, keyStore, trustDefaults);
<span class="nc" id="L2941">    } catch (Exception e) {</span>
<span class="nc" id="L2942">      LOG.warn(e.getMessage());</span>
<span class="nc" id="L2943">    }</span>
<span class="nc" id="L2944">  }</span>

  /**
   * Creates a PKCS#12 KeyStore with keys only from an JKS file (no issuer certs
   * or trusted certs).
   *
   * @param keyStore key store
   * @param password password
   * @return new key store
   * @throws KeyStoreException on key store error
   * @throws NoSuchAlgorithmException if algo not found
   * @throws UnrecoverableEntryException if key store is corrupt
   * @throws NoSuchProviderException if algo not found
   * @throws CertificateException if cert is corrupt
   * @throws IOException On IO fail
   */
  @Deprecated // Remove this method as soon as upgrading from 5-&gt;6 is dropped
  private KeyStore makeKeysOnlyP12(
      final KeyStore keyStore, final char[] password)
      throws KeyStoreException, NoSuchAlgorithmException,
          UnrecoverableEntryException, NoSuchProviderException,
          CertificateException, IOException {
<span class="nc" id="L2966">    final KeyStore p12 = KeyStore.getInstance(&quot;PKCS12&quot;, &quot;BC&quot;);</span>
    final KeyStore.ProtectionParameter protParam =
<span class="nc bnc" id="L2968" title="All 2 branches missed.">        (password != null ? new KeyStore.PasswordProtection(password) : null);</span>
<span class="nc" id="L2969">    p12.load(null, password); // initialize</span>

<span class="nc" id="L2971">    final Enumeration&lt;String&gt; en = keyStore.aliases();</span>
<span class="nc bnc" id="L2972" title="All 2 branches missed.">    while (en.hasMoreElements()) {</span>
<span class="nc" id="L2973">      final String alias = en.nextElement();</span>
<span class="nc bnc" id="L2974" title="All 2 branches missed.">      if (!keyStore.isKeyEntry(alias)) {</span>
<span class="nc" id="L2975">          continue;</span>
      }
      try {
<span class="nc" id="L2978">        KeyStore.PrivateKeyEntry entry =</span>
<span class="nc" id="L2979">            (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias, protParam);</span>
<span class="nc" id="L2980">        Certificate[] chain = new Certificate[] {entry.getCertificate()};</span>
<span class="nc" id="L2981">        p12.setKeyEntry(alias, entry.getPrivateKey(), password, chain);</span>
<span class="nc" id="L2982">      } catch (UnsupportedOperationException uoe) {</span>
<span class="nc" id="L2983">        KeyStore.PrivateKeyEntry entry =</span>
<span class="nc" id="L2984">            (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias, null);</span>
<span class="nc" id="L2985">        Certificate[] chain = new Certificate[] {entry.getCertificate()};</span>
<span class="nc" id="L2986">        p12.setKeyEntry(alias, entry.getPrivateKey(), null, chain);</span>
<span class="nc" id="L2987">      }</span>
<span class="nc" id="L2988">    }</span>
<span class="nc" id="L2989">    return p12;</span>
  }

  /**
   * Create InternalKeyBindings for Ocsp signing and SSL client authentication
   * certs during ad-hoc upgrades.
   *
   * @param authenticationToken Auth
   * @param cryptoTokenId Token ID
   * @param keyStore Key store
   * @param trustDefaults Defaults
   * @throws KeyStoreException on key store error
   * @throws CryptoTokenOfflineException if offline
   * @throws InternalKeyBindingNameInUseException if binding name is in use
   * @throws AuthorizationDeniedException if access denied
   * @throws CertificateEncodingException If cert is corrupt
   * @throws CertificateImportException if import fails
   * @throws InvalidAlgorithmException if algo cannot be found
   */
  @Deprecated // Remove this method as soon as upgrading from 5-&gt;6 is dropped
  private void createInternalKeyBindings(
      final AuthenticationToken authenticationToken,
      final int cryptoTokenId,
      final KeyStore keyStore,
      final List&lt;InternalKeyBindingTrustEntry&gt; trustDefaults)
      throws KeyStoreException, CryptoTokenOfflineException,
          InternalKeyBindingNameInUseException, AuthorizationDeniedException,
          CertificateEncodingException, CertificateImportException,
          InvalidAlgorithmException {
<span class="nc" id="L3018">    final Enumeration&lt;String&gt; aliases = keyStore.aliases();</span>
<span class="nc" id="L3019">    boolean noAliases = true;</span>
<span class="nc bnc" id="L3020" title="All 2 branches missed.">    while (aliases.hasMoreElements()) {</span>
<span class="nc" id="L3021">      final String keyPairAlias = aliases.nextElement();</span>
<span class="nc" id="L3022">      noAliases = false;</span>
<span class="nc" id="L3023">      LOG.info(</span>
          &quot;Found alias &quot;
              + keyPairAlias
              + &quot;, trying to figure out if this is something we should convert&quot;
              + &quot; into a new KeyBinding...&quot;);
<span class="nc" id="L3028">      final Certificate[] chain = keyStore.getCertificateChain(keyPairAlias);</span>
<span class="nc bnc" id="L3029" title="All 4 branches missed.">      if (chain == null || chain.length == 0) {</span>
<span class="nc" id="L3030">        LOG.info(</span>
            &quot;Alias &quot;
                + keyPairAlias
                + &quot; does not contain any certificate and will be ignored.&quot;);
<span class="nc" id="L3034">        continue; // Ignore entry</span>
      }
      // Extract the default signature algorithm
      final String signatureAlgorithm =
<span class="nc" id="L3038">          getSigningAlgFromAlgSelection(</span>
<span class="nc" id="L3039">              OcspConfiguration.getSignatureAlgorithm(),</span>
<span class="nc" id="L3040">              chain[0].getPublicKey());</span>
<span class="nc bnc" id="L3041" title="All 2 branches missed.">      if (OcspKeyBinding.isOcspSigningCertificate(</span>
          chain[0],
          (AvailableExtendedKeyUsagesConfiguration)
<span class="nc" id="L3044">              globalConfigurationSession.getCachedConfiguration(</span>
                  AvailableExtendedKeyUsagesConfiguration.CONFIGURATION_ID))) {
        // Create the actual OcspKeyBinding
<span class="nc" id="L3047">        LOG.info(</span>
            &quot;Alias &quot;
                + keyPairAlias
                + &quot; contains an OCSP certificate and will be converted to an&quot;
                + &quot; OcspKeyBinding.&quot;);
<span class="nc" id="L3052">        int internalKeyBindingId =</span>
<span class="nc" id="L3053">            internalKeyBindingMgmtSession.createInternalKeyBinding(</span>
                authenticationToken,
                OcspKeyBinding.IMPLEMENTATION_ALIAS,
                &quot;OcspKeyBinding for &quot; + keyPairAlias,
                InternalKeyBindingStatus.DISABLED,
                null,
                cryptoTokenId,
                keyPairAlias,
                signatureAlgorithm,
<span class="nc" id="L3062">                getOcspKeyBindingDefaultProperties(),</span>
                trustDefaults);
<span class="nc" id="L3064">        internalKeyBindingMgmtSession.importCertificateForInternalKeyBinding(</span>
<span class="nc" id="L3065">            authenticationToken, internalKeyBindingId, chain[0].getEncoded());</span>
<span class="nc" id="L3066">        internalKeyBindingMgmtSession.setStatus(</span>
            authenticationToken,
            internalKeyBindingId,
            InternalKeyBindingStatus.ACTIVE);
<span class="nc bnc" id="L3070" title="All 2 branches missed.">      } else if (AuthenticationKeyBinding.isClientSSLCertificate(</span>
          chain[0],
          (AvailableExtendedKeyUsagesConfiguration)
<span class="nc" id="L3073">              globalConfigurationSession.getCachedConfiguration(</span>
                  AvailableExtendedKeyUsagesConfiguration.CONFIGURATION_ID))) {
<span class="nc" id="L3075">        LOG.info(</span>
            &quot;Alias &quot;
                + keyPairAlias
                + &quot; contains an SSL client certificate and will be converted&quot;
                + &quot; to an AuthenticationKeyBinding.&quot;);
        // We are looking for an SSL cert, use this to create an
        // AuthenticationKeyBinding
<span class="nc" id="L3082">        int internalKeyBindingId =</span>
<span class="nc" id="L3083">            internalKeyBindingMgmtSession.createInternalKeyBinding(</span>
                authenticationToken,
                AuthenticationKeyBinding.IMPLEMENTATION_ALIAS,
                &quot;AuthenticationKeyBinding for &quot; + keyPairAlias,
                InternalKeyBindingStatus.DISABLED,
                null,
                cryptoTokenId,
                keyPairAlias,
                signatureAlgorithm,
                null,
                null);
<span class="nc" id="L3094">        internalKeyBindingMgmtSession.importCertificateForInternalKeyBinding(</span>
<span class="nc" id="L3095">            authenticationToken, internalKeyBindingId, chain[0].getEncoded());</span>
<span class="nc" id="L3096">        internalKeyBindingMgmtSession.setStatus(</span>
            authenticationToken,
            internalKeyBindingId,
            InternalKeyBindingStatus.ACTIVE);
<span class="nc" id="L3100">      } else {</span>
<span class="nc" id="L3101">        LOG.info(</span>
            &quot;Alias &quot;
                + keyPairAlias
                + &quot; contains certificate of unknown type and will be ignored.&quot;);
      }
<span class="nc" id="L3106">    }</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">    if (noAliases) {</span>
<span class="nc" id="L3108">      LOG.info(&quot;No aliases to process were found in the key store.&quot;);</span>
    }
<span class="nc" id="L3110">  }</span>

  /** @return a list of trusted signers or CAs */
  @Deprecated // This method is only used for upgrading to version 6
  private List&lt;InternalKeyBindingTrustEntry&gt; getOcspKeyBindingTrustDefaults() {
    // Import certificates used to verify OCSP request signatures and add these
    // to each OcspKeyBinding's trust-list
    //  ocsp.signtrustdir=signtrustdir
    //  ocsp.signtrustvalidtime should be ignored
<span class="nc" id="L3119">    final List&lt;InternalKeyBindingTrustEntry&gt; trustedCertificateReferences =</span>
        new ArrayList&lt;InternalKeyBindingTrustEntry&gt;();
<span class="nc bnc" id="L3121" title="All 2 branches missed.">    if (OcspConfiguration.getEnforceRequestSigning()</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">        &amp;&amp; OcspConfiguration.getRestrictSignatures()) {</span>
      // Import certificates and configure Issuer+serialnumber in trustlist for
      // each
<span class="nc" id="L3125">      final String dirName = OcspConfiguration.getSignTrustDir();</span>
<span class="nc bnc" id="L3126" title="All 2 branches missed.">      if (dirName != null) {</span>
<span class="nc" id="L3127">        final File directory = new File(dirName);</span>
<span class="nc bnc" id="L3128" title="All 2 branches missed.">        if (directory.isDirectory()) {</span>
<span class="nc bnc" id="L3129" title="All 2 branches missed.">          for (final File file : directory.listFiles()) {</span>
            try {
<span class="nc" id="L3131">              final List&lt;Certificate&gt; chain =</span>
<span class="nc" id="L3132">                  CertTools.getCertsFromPEM(new FileInputStream(file));</span>
<span class="nc bnc" id="L3133" title="All 2 branches missed.">              if (!chain.isEmpty()) {</span>
<span class="nc" id="L3134">                final String issuerDn = CertTools.getIssuerDN(chain.get(0));</span>
<span class="nc" id="L3135">                final String subjectDn = CertTools.getSubjectDN(chain.get(0));</span>
<span class="nc bnc" id="L3136" title="All 2 branches missed.">                if (OcspConfiguration.getRestrictSignaturesByMethod()</span>
                    == OcspConfiguration.RESTRICTONSIGNER) {
<span class="nc" id="L3138">                  final int caId = issuerDn.hashCode();</span>
<span class="nc" id="L3139">                  final BigInteger serialNumber =</span>
<span class="nc" id="L3140">                      CertTools.getSerialNumber(chain.get(0));</span>
<span class="nc bnc" id="L3141" title="All 2 branches missed.">                  if (!caSession.existsCa(caId)) {</span>
<span class="nc" id="L3142">                    LOG.warn(</span>
                        &quot;Trusted certificate with serialNumber &quot;
<span class="nc" id="L3144">                            + serialNumber.toString(16)</span>
                            + &quot; is issued by an unknown CA with subject '&quot;
                            + issuerDn
                            + &quot;'. You should import this CA certificate as en&quot;
                            + &quot; external CA to make it known to the system.&quot;);
                  }
<span class="nc" id="L3150">                  trustedCertificateReferences.add(</span>
                      new InternalKeyBindingTrustEntry(caId, serialNumber));
<span class="nc" id="L3152">                } else {</span>
<span class="nc" id="L3153">                  final int caId = subjectDn.hashCode();</span>
<span class="nc bnc" id="L3154" title="All 2 branches missed.">                  if (!caSession.existsCa(caId)) {</span>
<span class="nc" id="L3155">                    LOG.warn(</span>
                        &quot;Trusted CA certificate with with subject '&quot;
                            + subjectDn
                            + &quot;' should be imported as en external CA to make&quot;
                            + &quot; it known to the system.&quot;);
                  }
<span class="nc" id="L3161">                  trustedCertificateReferences.add(</span>
                      new InternalKeyBindingTrustEntry(caId, null));
                }
              }
<span class="nc" id="L3165">            } catch (CertificateException e) {</span>
<span class="nc" id="L3166">              LOG.warn(e.getMessage());</span>
<span class="nc" id="L3167">            } catch (FileNotFoundException e) {</span>
<span class="nc" id="L3168">              LOG.warn(e.getMessage());</span>
<span class="nc" id="L3169">            }</span>
          }
        }
      }
    }
<span class="nc" id="L3174">    return trustedCertificateReferences;</span>
  }

  /**
   * @return OcspKeyBinding properties set to the current file-based
   *     configuration (per cert profile config is ignored here)
   */
  @SuppressWarnings(&quot;deprecation&quot;)
  private Map&lt;String, Serializable&gt; getOcspKeyBindingDefaultProperties() {
<span class="nc" id="L3183">    final long k = 1000L;</span>
    // Use global config as defaults for each new OcspKeyBinding
<span class="nc" id="L3185">    final Map&lt;String, Serializable&gt; dataMap =</span>
        new HashMap&lt;String, Serializable&gt;();
<span class="nc" id="L3187">    dataMap.put(</span>
        OcspKeyBinding.PROPERTY_INCLUDE_CERT_CHAIN,
<span class="nc" id="L3189">        Boolean.valueOf(OcspConfiguration.getIncludeCertChain()));</span>
<span class="nc bnc" id="L3190" title="All 2 branches missed.">    if (OcspConfiguration.getResponderIdType()</span>
        == OcspConfiguration.RESPONDERIDTYPE_NAME) {
<span class="nc" id="L3192">      dataMap.put(</span>
          OcspKeyBinding.PROPERTY_RESPONDER_ID_TYPE,
<span class="nc" id="L3194">          ResponderIdType.NAME.name());</span>
    } else {
<span class="nc" id="L3196">      dataMap.put(</span>
          OcspKeyBinding.PROPERTY_RESPONDER_ID_TYPE,
<span class="nc" id="L3198">          ResponderIdType.KEYHASH.name());</span>
    }
<span class="nc" id="L3200">    dataMap.put(</span>
        OcspKeyBinding.PROPERTY_MAX_AGE,
<span class="nc" id="L3202">        (long)</span>
<span class="nc" id="L3203">            (OcspConfiguration.getMaxAge(</span>
                    CertificateProfileConstants.CERTPROFILE_NO_PROFILE)
                / k));
<span class="nc" id="L3206">    dataMap.put(</span>
        OcspKeyBinding.PROPERTY_NON_EXISTING_GOOD,
<span class="nc" id="L3208">        Boolean.valueOf(OcspConfiguration.getNonExistingIsGood()));</span>
<span class="nc" id="L3209">    dataMap.put(</span>
        OcspKeyBinding.PROPERTY_NON_EXISTING_REVOKED,
<span class="nc" id="L3211">        Boolean.valueOf(OcspConfiguration.getNonExistingIsRevoked()));</span>
<span class="nc" id="L3212">    dataMap.put(</span>
        OcspKeyBinding.PROPERTY_UNTIL_NEXT_UPDATE,
<span class="nc" id="L3214">        (long)</span>
<span class="nc" id="L3215">            (OcspConfiguration.getUntilNextUpdate(</span>
                    CertificateProfileConstants.CERTPROFILE_NO_PROFILE)
                / k));
<span class="nc" id="L3218">    dataMap.put(</span>
        OcspKeyBinding.PROPERTY_REQUIRE_TRUSTED_SIGNATURE,
<span class="nc" id="L3220">        Boolean.valueOf(OcspConfiguration.getEnforceRequestSigning()));</span>
<span class="nc" id="L3221">    return dataMap;</span>
  }

  @Override
  public String healthCheck() {
<span class="nc" id="L3226">    final StringBuilder sb = new StringBuilder();</span>
    // Check that there are no ACTIVE OcspKeyBindings that are not in the cache
    // before checking usability..
    for (InternalKeyBindingInfo internalKeyBindingInfo
<span class="nc bnc" id="L3230" title="All 2 branches missed.">       : internalKeyBindingMgmtSession.getAllInternalKeyBindingInfos(</span>
            OcspKeyBinding.IMPLEMENTATION_ALIAS)) {
<span class="nc" id="L3232">      if (internalKeyBindingInfo</span>
<span class="nc" id="L3233">          .getStatus()</span>
<span class="nc bnc" id="L3234" title="All 2 branches missed.">          .equals(InternalKeyBindingStatus.ACTIVE)) {</span>
<span class="nc" id="L3235">        final Certificate ocspCertificate =</span>
<span class="nc" id="L3236">            certificateStoreSession.findCertificateByFingerprint(</span>
<span class="nc" id="L3237">                internalKeyBindingInfo.getCertificateId());</span>
<span class="nc" id="L3238">        final X509Certificate issuingCertificate =</span>
<span class="nc" id="L3239">            certificateStoreSession.findLatestX509CertificateBySubject(</span>
<span class="nc" id="L3240">                CertTools.getIssuerDN(ocspCertificate));</span>
<span class="nc" id="L3241">        OcspSigningCacheEntry ocspSigningCacheEntry = null;</span>
<span class="nc bnc" id="L3242" title="All 2 branches missed.">        if (issuingCertificate != null) {</span>
<span class="nc" id="L3243">          final List&lt;CertificateID&gt; certIds =</span>
<span class="nc" id="L3244">              OcspSigningCache.getCertificateIDFromCertificate(</span>
                  issuingCertificate);
          // We only need to use the first certId type to find an entry in the
          // cache, certIds.get(0), since all of them should be in the cache
<span class="nc" id="L3248">          ocspSigningCacheEntry =</span>
<span class="nc" id="L3249">              OcspSigningCache.INSTANCE.getEntry(certIds.get(0));</span>
<span class="nc bnc" id="L3250" title="All 2 branches missed.">          if (ocspSigningCacheEntry == null) {</span>
            // Could be a cache issue?
            try {
<span class="nc" id="L3253">              ocspSigningCacheEntry =</span>
<span class="nc" id="L3254">                  findAndAddMissingCacheEntry(certIds.get(0));</span>
<span class="nc" id="L3255">            } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L3256">              throw new IllegalStateException(</span>
                  &quot;Could not process certificate&quot;, e);
<span class="nc" id="L3258">            }</span>
          }
<span class="nc" id="L3260">        } else {</span>
<span class="nc" id="L3261">          LOG.info(</span>
              &quot;Can not find issuer certificate from subject DN '&quot;
<span class="nc" id="L3263">                  + CertTools.getIssuerDN(ocspCertificate)</span>
                  + &quot;'.&quot;);
        }

<span class="nc bnc" id="L3267" title="All 2 branches missed.">        if (ocspSigningCacheEntry == null) {</span>
<span class="nc" id="L3268">          final String errMsg =</span>
<span class="nc" id="L3269">              INTRES.getLocalizedMessage(</span>
                  &quot;ocsp.signingkeynotincache&quot;,
<span class="nc" id="L3271">                  internalKeyBindingInfo.getName());</span>
<span class="nc" id="L3272">          sb.append('\n').append(errMsg);</span>
<span class="nc" id="L3273">          LOG.error(errMsg);</span>
        }
      }
<span class="nc" id="L3276">    }</span>
<span class="nc bnc" id="L3277" title="All 2 branches missed.">    if (!sb.toString().equals(&quot;&quot;)) {</span>
<span class="nc" id="L3278">      return sb.toString();</span>
    }
    try {
<span class="nc" id="L3281">      final Collection&lt;OcspSigningCacheEntry&gt; ocspSigningCacheEntries =</span>
<span class="nc" id="L3282">          OcspSigningCache.INSTANCE.getEntries();</span>
<span class="nc bnc" id="L3283" title="All 2 branches missed.">      if (ocspSigningCacheEntries.isEmpty()) {</span>
        // Only report this in the server log. It is not an erroneous state to
        // have no ACTIVE OcspKeyBindings.
<span class="nc bnc" id="L3286" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L3287">          LOG.debug(INTRES.getLocalizedMessage(&quot;ocsp.errornosignkeys&quot;));</span>
        }
      } else {
        for (OcspSigningCacheEntry ocspSigningCacheEntry
<span class="nc bnc" id="L3291" title="All 2 branches missed.">            : ocspSigningCacheEntries) {</span>
          // Only verify non-CA responders
<span class="nc" id="L3293">          final X509Certificate ocspSigningCertificate =</span>
<span class="nc" id="L3294">              ocspSigningCacheEntry.getOcspSigningCertificate();</span>
<span class="nc bnc" id="L3295" title="All 2 branches missed.">          if (ocspSigningCertificate == null) {</span>
<span class="nc" id="L3296">            continue;</span>
          }
<span class="nc" id="L3298">          final String subjectDn =</span>
<span class="nc" id="L3299">              CertTools.getSubjectDN(</span>
<span class="nc" id="L3300">                  ocspSigningCacheEntry.getCaCertificateChain().get(0));</span>
<span class="nc" id="L3301">          final String serialNumberForLog =</span>
<span class="nc" id="L3302">              CertTools.getSerialNumberAsString(</span>
<span class="nc" id="L3303">                  ocspSigningCacheEntry.getOcspSigningCertificate());</span>
<span class="nc" id="L3304">          final String errMsg =</span>
<span class="nc" id="L3305">              INTRES.getLocalizedMessage(</span>
                  &quot;ocsp.errorocspkeynotusable&quot;, subjectDn, serialNumberForLog);
<span class="nc" id="L3307">          final PrivateKey privateKey = ocspSigningCacheEntry.getPrivateKey();</span>
<span class="nc bnc" id="L3308" title="All 2 branches missed.">          if (privateKey == null) {</span>
<span class="nc" id="L3309">            sb.append('\n').append(errMsg);</span>
<span class="nc" id="L3310">            LOG.error(&quot;No key available. &quot; + errMsg);</span>
<span class="nc" id="L3311">            continue;</span>
          }
<span class="nc bnc" id="L3313" title="All 2 branches missed.">          if (OcspConfiguration.getHealthCheckCertificateValidity()</span>
<span class="nc bnc" id="L3314" title="All 2 branches missed.">              &amp;&amp; !CertTools.isCertificateValid(ocspSigningCertificate, true)) {</span>
<span class="nc" id="L3315">            sb.append('\n').append(errMsg);</span>
<span class="nc" id="L3316">            continue;</span>
          }
<span class="nc bnc" id="L3318" title="All 2 branches missed.">          if (OcspConfiguration.getHealthCheckSignTest()) {</span>
            try {
<span class="nc" id="L3320">              final String providerName =</span>
<span class="nc" id="L3321">                  ocspSigningCacheEntry.getSignatureProviderName();</span>
<span class="nc" id="L3322">              KeyTools.testKey(</span>
                  privateKey,
<span class="nc" id="L3324">                  ocspSigningCertificate.getPublicKey(),</span>
                  providerName);
<span class="nc" id="L3326">            } catch (InvalidKeyException e) {</span>
              // thrown by testKey
<span class="nc" id="L3328">              sb.append('\n').append(errMsg);</span>
<span class="nc" id="L3329">              LOG.error(</span>
                  &quot;Key not working. SubjectDN '&quot;
                      + subjectDn
                      + &quot;'. Error comment '&quot;
                      + errMsg
                      + &quot;'. Message '&quot;
<span class="nc" id="L3335">                      + e.getMessage());</span>
<span class="nc" id="L3336">              continue;</span>
<span class="nc" id="L3337">            }</span>
          }
<span class="nc bnc" id="L3339" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L3340">            final String name =</span>
<span class="nc" id="L3341">                ocspSigningCacheEntry.getOcspKeyBinding().getName();</span>
<span class="nc" id="L3342">            LOG.debug(&quot;Test of \&quot;&quot; + name + &quot;\&quot; OK!&quot;);</span>
          }
<span class="nc" id="L3344">        }</span>
      }
<span class="nc" id="L3346">    } catch (Exception e) {</span>
<span class="nc" id="L3347">      final String errMsg =</span>
<span class="nc" id="L3348">          INTRES.getLocalizedMessage(&quot;ocsp.errorloadsigningcerts&quot;);</span>
<span class="nc" id="L3349">      LOG.error(errMsg, e);</span>
<span class="nc" id="L3350">      sb.append(errMsg).append(&quot;: &quot;).append(errMsg);</span>
<span class="nc" id="L3351">    }</span>
<span class="nc" id="L3352">    return sb.toString();</span>
  }
}

final class CardKeyHolder {
    /** Resource. */
  private static final InternalResources INTRES =
<span class="nc" id="L3359">      InternalResources.getInstance();</span>
  /** Instance. */
<span class="nc" id="L3361">  private static CardKeyHolder instance = null;</span>
  /** keys. */
<span class="nc" id="L3363">  private CardKeys cardKeys = null;</span>

<span class="nc" id="L3365">  private CardKeyHolder() {</span>
<span class="nc" id="L3366">    Logger log = Logger.getLogger(CardKeyHolder.class);</span>
<span class="nc" id="L3367">    String hardTokenClassName = OcspConfiguration.getHardTokenClassName();</span>
    try {
<span class="nc" id="L3369">      this.cardKeys =</span>
          (CardKeys)
              OcspResponseGeneratorSessionBean.class
<span class="nc" id="L3372">                  .getClassLoader()</span>
<span class="nc" id="L3373">                  .loadClass(hardTokenClassName)</span>
<span class="nc" id="L3374">                  .getConstructor()</span>
<span class="nc" id="L3375">                  .newInstance();</span>
<span class="nc" id="L3376">      this.cardKeys.autenticate(OcspConfiguration.getCardPassword());</span>
<span class="nc" id="L3377">    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L3378">      log.debug(</span>
<span class="nc" id="L3379">          INTRES.getLocalizedMessage(&quot;ocsp.classnotfound&quot;, hardTokenClassName));</span>
<span class="nc" id="L3380">    } catch (Exception e) {</span>
<span class="nc" id="L3381">      log.info(&quot;Could not create CardKeyHolder&quot;, e);</span>
<span class="nc" id="L3382">    }</span>
<span class="nc" id="L3383">  }</span>

  public static synchronized CardKeyHolder getInstance() {
<span class="nc bnc" id="L3386" title="All 2 branches missed.">    if (instance == null) {</span>
<span class="nc" id="L3387">      instance = new CardKeyHolder();</span>
    }
<span class="nc" id="L3389">    return instance;</span>
  }

  public CardKeys getCardKeys() {
<span class="nc" id="L3393">    return cardKeys;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>