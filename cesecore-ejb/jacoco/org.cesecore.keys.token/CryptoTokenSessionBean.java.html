<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CryptoTokenSessionBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security EJB Implementation</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.token</a> &gt; <span class="el_source">CryptoTokenSessionBean.java</span></div><h1>CryptoTokenSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.token;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import javax.annotation.PostConstruct;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import org.apache.log4j.Logger;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.keys.token.p11.exception.NoSuchSlotException;
import org.cesecore.util.CryptoProviderTools;
import org.cesecore.util.QueryResultWrapper;

/**
 * Basic CRUD and activation caching of CryptoTokens is provided through this
 * local access SSB.
 *
 * @version $Id: CryptoTokenSessionBean.java 28332 2018-02-20 14:40:52Z anatom $
 */
@Stateless(
    mappedName = JndiConstants.APP_JNDI_PREFIX + &quot;CryptoTokenSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
<span class="nc" id="L43">public class CryptoTokenSessionBean</span>
    implements CryptoTokenSessionLocal, CryptoTokenSessionRemote {

    /** Logger. */
<span class="nc" id="L47">  private static final Logger LOG =</span>
<span class="nc" id="L48">      Logger.getLogger(CryptoTokenSessionBean.class);</span>
  /** Resource. */
<span class="nc" id="L50">  private static final InternalResources INTRES =</span>
<span class="nc" id="L51">      InternalResources.getInstance();</span>

  /** EM. */
  @PersistenceContext(unitName = CesecoreConfiguration.PERSISTENCE_UNIT)
  private EntityManager entityManager;

  /** Setup. */
  @PostConstruct
  public void postConstruct() {
<span class="nc" id="L60">    CryptoProviderTools.installBCProviderIfNotAvailable();</span>
<span class="nc" id="L61">  }</span>

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public void flushCache() {
<span class="nc" id="L66">    CryptoTokenCache.INSTANCE.flush();</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L68">      LOG.debug(&quot;Flushed CryptoToken cache.&quot;);</span>
    }
<span class="nc" id="L70">  }</span>

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public void flushExcludingIDs(final List&lt;Integer&gt; ids) {
<span class="nc" id="L75">    CryptoTokenCache.INSTANCE.replaceCacheWith(ids);</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L77">      LOG.debug(</span>
          &quot;Flushed CryptoToken cache except for &quot;
<span class="nc" id="L79">              + ids.size()</span>
              + &quot; specific entries.&quot;);
    }
<span class="nc" id="L82">  }</span>

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public CryptoToken getCryptoToken(final int cryptoTokenId) {
    // 1. Check (new) CryptoTokenCache if it is time to sync-up with database
<span class="nc bnc" id="L88" title="All 2 branches missed.">    if (CryptoTokenCache.INSTANCE.shouldCheckForUpdates(cryptoTokenId)) {</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L90">        LOG.debug(</span>
            &quot;CryptoToken with ID &quot;
                + cryptoTokenId
                + &quot; will be checked for updates.&quot;);
      }
      // 2. If cache is expired or missing, first thread to discover this
      // reloads item from database and sends it to the cache
<span class="nc" id="L97">      final CryptoTokenData cryptoTokenData =</span>
<span class="nc" id="L98">          readCryptoTokenData(cryptoTokenId);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">      if (cryptoTokenData == null) {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L101">          LOG.debug(</span>
              &quot;Requested cryptoTokenId did not exist in database and will be&quot;
                  + &quot; purged from cache if present: &quot;
                  + cryptoTokenId);
        }
        // Ensure that it is removed from cache
<span class="nc" id="L107">        CryptoTokenCache.INSTANCE.removeEntry(cryptoTokenId);</span>
      } else {
<span class="nc" id="L109">        final int digest = cryptoTokenData.getProtectString(0).hashCode();</span>
        // 3. The cache compares the database data with what is in the cache
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (CryptoTokenCache.INSTANCE.willUpdate(cryptoTokenId, digest)) {</span>
<span class="nc" id="L112">          final String tokenType = cryptoTokenData.getTokenType();</span>
<span class="nc" id="L113">          final Properties properties = cryptoTokenData.getTokenProperties();</span>
<span class="nc" id="L114">          final byte[] data = cryptoTokenData.getTokenDataAsBytes();</span>
<span class="nc" id="L115">          final String tokenName = cryptoTokenData.getTokenName();</span>
          // Create new token and store it in the cache.
<span class="nc" id="L117">          String inClassname = getClassNameForType(tokenType);</span>
          CryptoToken cryptoToken;
          // 4. If database is different from cache, create the crypto token and
          // replace it in the cache (while trying to keep activation)
          //    (Invokes
          // org.cesecore.keys.token.CryptoTokenFactory.createCryptoToken)
          try {
<span class="nc" id="L124">            cryptoToken =</span>
<span class="nc" id="L125">                CryptoTokenFactory.createCryptoToken(</span>
                    inClassname,
                    properties,
                    data,
                    cryptoTokenId,
                    tokenName,
                    true);
<span class="nc" id="L132">          } catch (NoSuchSlotException e) {</span>
            // This should never happen now, since the specify
            // allowNonExistingSlot in the createCryptoToken call
<span class="nc" id="L135">            throw new IllegalStateException(</span>
                &quot;Attempted to find a slot for a PKCS#11 crypto token, but it&quot;
                    + &quot; did not exists. Perhaps the token was removed?&quot;);
<span class="nc" id="L138">          }</span>
<span class="nc" id="L139">          CryptoTokenCache.INSTANCE.updateWith(</span>
              cryptoTokenId, digest, tokenName, cryptoToken);
        }
      }
    }
    // 5. Get CryptoToken from cache (or null) and be merry
<span class="nc" id="L145">    return CryptoTokenCache.INSTANCE.getEntry(cryptoTokenId);</span>
  }

  @Override
  public String getClassNameForType(final String tokenType) {
<span class="nc" id="L150">    String inClassname = null;</span>
    for (final AvailableCryptoToken act
<span class="nc bnc" id="L152" title="All 2 branches missed.">        : CryptoTokenFactory.instance().getAvailableCryptoTokens()) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">      if (act.getClassPath().endsWith(tokenType)) {</span>
        // We found a available token with the same Class.getSimpleName() as the
        // CryptoToken's type, so use it!
        // (By only storing the &quot;simple&quot; classname we can switch implementation
        // package without care)
<span class="nc" id="L158">        inClassname = act.getClassPath();</span>
      }
<span class="nc" id="L160">    }</span>
<span class="nc" id="L161">    return inClassname;</span>
  }

  @Override
  public int mergeCryptoToken(final CryptoToken cryptoToken)
      throws CryptoTokenNameInUseException {
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L168">      LOG.trace(</span>
          &quot;&gt;addCryptoToken &quot;
<span class="nc" id="L170">              + cryptoToken.getTokenName()</span>
              + &quot; &quot;
<span class="nc" id="L172">              + cryptoToken.getClass().getName());</span>
    }
<span class="nc" id="L174">    final int cryptoTokenId = cryptoToken.getId();</span>
<span class="nc" id="L175">    final String tokenName = cryptoToken.getTokenName();</span>
<span class="nc" id="L176">    String tokenType = &quot;null&quot;;</span>
    for (final AvailableCryptoToken act
<span class="nc bnc" id="L178" title="All 2 branches missed.">        : CryptoTokenFactory.instance().getAvailableCryptoTokens()) {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">      if (cryptoToken.getClass().getName().equals(act.getClassPath())) {</span>
<span class="nc" id="L180">        tokenType = cryptoToken.getClass().getSimpleName();</span>
<span class="nc" id="L181">        break;</span>
      }
<span class="nc" id="L183">    }</span>
<span class="nc" id="L184">    final long lastUpdate = System.currentTimeMillis();</span>
<span class="nc" id="L185">    final Properties tokenProperties = cryptoToken.getProperties();</span>
<span class="nc" id="L186">    final byte[] tokenDataAsBytes = cryptoToken.getTokenData();</span>
<span class="nc" id="L187">    CryptoTokenData cryptoTokenData =</span>
<span class="nc" id="L188">        entityManager.find(CryptoTokenData.class, cryptoTokenId);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">    if (cryptoTokenData == null) {</span>
      // The cryptoToken does not exist in the database, before we add it we
      // want to check that the name is not in use
<span class="nc bnc" id="L192" title="All 2 branches missed.">      if (isCryptoTokenNameUsed(tokenName)) {</span>
<span class="nc" id="L193">        throw new CryptoTokenNameInUseException(</span>
<span class="nc" id="L194">            INTRES.getLocalizedMessage(&quot;token.nameisinuse&quot;, tokenName));</span>
      }
<span class="nc" id="L196">      cryptoTokenData =</span>
          new CryptoTokenData(
              cryptoTokenId,
              tokenName,
              tokenType,
              lastUpdate,
              tokenProperties,
              tokenDataAsBytes);
    } else {
<span class="nc bnc" id="L205" title="All 2 branches missed.">      if (!isCryptoTokenNameUsedByIdOnly(tokenName, cryptoTokenId)) {</span>
<span class="nc" id="L206">        throw new CryptoTokenNameInUseException(</span>
<span class="nc" id="L207">            INTRES.getLocalizedMessage(&quot;token.nameisinuse&quot;, tokenName));</span>
      }
      // It might be the case that the calling transaction has already loaded a
      // reference to this token
      // and hence we need to get the same one and perform updates on this
      // object instead of trying to
      // merge a new object.
<span class="nc" id="L214">      cryptoTokenData.setTokenName(tokenName);</span>
<span class="nc" id="L215">      cryptoTokenData.setTokenType(tokenType);</span>
<span class="nc" id="L216">      cryptoTokenData.setLastUpdate(lastUpdate);</span>
<span class="nc" id="L217">      cryptoTokenData.setTokenProperties(tokenProperties);</span>
<span class="nc" id="L218">      cryptoTokenData.setTokenDataAsBytes(tokenDataAsBytes);</span>
    }
<span class="nc" id="L220">    cryptoTokenData = createOrUpdateCryptoTokenData(cryptoTokenData);</span>
    // Update cache with provided token (it might be active and we like keeping
    // things active)
<span class="nc" id="L223">    CryptoTokenCache.INSTANCE.updateWith(</span>
        cryptoTokenId,
<span class="nc" id="L225">        cryptoTokenData.getProtectString(0).hashCode(),</span>
        tokenName,
        cryptoToken);
<span class="nc bnc" id="L228" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L229">      LOG.trace(&quot;&lt;addCryptoToken &quot; + cryptoToken.getTokenName());</span>
    }
<span class="nc" id="L231">    return cryptoTokenId; // tokenId</span>
  }

  @Override
  public boolean removeCryptoToken(final int cryptoTokenId) {
<span class="nc" id="L236">    final boolean ret = deleteCryptoTokenData(cryptoTokenId);</span>
<span class="nc" id="L237">    CryptoTokenCache.INSTANCE.updateWith(cryptoTokenId, 0, null, null);</span>
<span class="nc" id="L238">    return ret;</span>
  }

  @Override
  public Map&lt;String, Integer&gt; getCachedNameToIdMap() {
<span class="nc" id="L243">    return CryptoTokenCache.INSTANCE.getNameToIdMap();</span>
  }

  @Override
  public String getCryptoTokenName(final int cryptoTokenId) {
<span class="nc" id="L248">    return CryptoTokenCache.INSTANCE.getName(cryptoTokenId);</span>
  }

  @Override
  public boolean isCryptoTokenNameUsed(final String cryptoTokenName) {
<span class="nc" id="L253">    final Query query =</span>
<span class="nc" id="L254">        entityManager.createQuery(</span>
            &quot;SELECT a FROM CryptoTokenData a WHERE a.tokenName=:tokenName&quot;);
<span class="nc" id="L256">    query.setParameter(&quot;tokenName&quot;, cryptoTokenName);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">    return !query.getResultList().isEmpty();</span>
  }

  @Override
  public boolean isCryptoTokenNameUsedByIdOnly(
      final String cryptoTokenName, final int cryptoTokenId) {
<span class="nc" id="L263">    final Query query =</span>
<span class="nc" id="L264">        entityManager.createQuery(</span>
            &quot;SELECT a FROM CryptoTokenData a WHERE a.tokenName=:tokenName&quot;);
<span class="nc" id="L266">    query.setParameter(&quot;tokenName&quot;, cryptoTokenName);</span>
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L268">    final List&lt;CryptoTokenData&gt; cryptoTokenDatas = query.getResultList();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">    for (final CryptoTokenData cryptoTokenData : cryptoTokenDatas) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">      if (cryptoTokenData.getId() != cryptoTokenId) {</span>
<span class="nc" id="L271">        return false;</span>
      }
<span class="nc" id="L273">    }</span>
<span class="nc" id="L274">    return true;</span>
  }

  //
  // Create Read Update Delete (CRUD) methods
  //

  private CryptoTokenData readCryptoTokenData(final int cryptoTokenId) {
<span class="nc" id="L282">    final Query query =</span>
<span class="nc" id="L283">        entityManager.createQuery(</span>
            &quot;SELECT a FROM CryptoTokenData a WHERE a.id=:id&quot;);
<span class="nc" id="L285">    query.setParameter(&quot;id&quot;, cryptoTokenId);</span>
<span class="nc" id="L286">    return QueryResultWrapper.getSingleResult(query);</span>
  }

  private CryptoTokenData createOrUpdateCryptoTokenData(
      final CryptoTokenData data) {
<span class="nc" id="L291">    return entityManager.merge(data);</span>
  }

  private boolean deleteCryptoTokenData(final int cryptoTokenId) {
<span class="nc" id="L295">    final Query query =</span>
<span class="nc" id="L296">        entityManager.createQuery(</span>
            &quot;DELETE FROM CryptoTokenData a WHERE a.id=:id&quot;);
<span class="nc" id="L298">    query.setParameter(&quot;id&quot;, cryptoTokenId);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">    return query.executeUpdate() == 1;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public List&lt;Integer&gt; getCryptoTokenIds() {
<span class="nc" id="L305">    return entityManager</span>
<span class="nc" id="L306">        .createQuery(&quot;SELECT a.id FROM CryptoTokenData a&quot;)</span>
<span class="nc" id="L307">        .getResultList();</span>
  }

  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  @Override
  public Map&lt;Integer, String&gt; getCryptoTokenIdToNameMap() {
<span class="nc" id="L313">    final Map&lt;Integer, String&gt; ret = new HashMap&lt;&gt;();</span>
    for (final CryptoTokenData cryptoTokenData
<span class="nc bnc" id="L315" title="All 2 branches missed.">        : entityManager</span>
<span class="nc" id="L316">            .createQuery(</span>
                &quot;SELECT a FROM CryptoTokenData a&quot;, CryptoTokenData.class)
<span class="nc" id="L318">            .getResultList()) {</span>
<span class="nc" id="L319">      ret.put(cryptoTokenData.getId(), cryptoTokenData.getTokenName());</span>
<span class="nc" id="L320">    }</span>
<span class="nc" id="L321">    return ret;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>