<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AccessRulesHelper.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-ejb</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.roles</a> &gt; <span class="el_source">AccessRulesHelper.java</span></div><h1>AccessRulesHelper.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.roles;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;

import org.apache.log4j.Logger;

/**
 * Helper methods for interactions with maps of access rules and resources.
 *
 * @version $Id: AccessRulesHelper.java 28354 2018-02-22 12:14:54Z anatom $
 */
<span class="nc" id="L30">public abstract class AccessRulesHelper {</span>

<span class="fc" id="L32">    private static final Logger log = Logger.getLogger(AccessRulesHelper.class);</span>

    /** @param accessRules Rules
     * @param resources list of resources
     * @return true if the provided map of access rules allows access to all the given resources */
    public static boolean hasAccessToResources(final HashMap&lt;String, Boolean&gt; accessRules, final String...resources) {
<span class="nc bnc" id="L38" title="All 2 branches missed.">        if (resources!=null) {</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">            for (final String resource : resources) {</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">                if (!AccessRulesHelper.hasAccessToResource(accessRules, resource)) {</span>
<span class="nc" id="L41">                    return false;</span>
                }
            }
        }
<span class="nc" id="L45">        return true;</span>
    }

    /** @param accessRules rules
     * @param resource resource
     * @return true if the provided map of access rules allows access to the given resource */
    public static boolean hasAccessToResource(final HashMap&lt;String, Boolean&gt; accessRules, final String resource) {
<span class="pc bpc" id="L52" title="2 of 4 branches missed.">        if (resource==null || resource.charAt(0)!='/') {</span>
<span class="nc" id="L53">            return false;</span>
        }
        // Normalize from &quot;/a/b/c&quot; to &quot;/a/b/c/&quot;
<span class="fc bfc" id="L56" title="All 2 branches covered.">        final String resourceWithTrailingSlash = resource.endsWith(&quot;/&quot;) ? resource : resource + &quot;/&quot;;</span>
<span class="fc" id="L57">        int lastSlashIndex = resourceWithTrailingSlash.length()+1;</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        while ((lastSlashIndex = resourceWithTrailingSlash.lastIndexOf('/', lastSlashIndex-1))!=-1) {</span>
<span class="fc" id="L59">            final String subString = resourceWithTrailingSlash.substring(0, lastSlashIndex);</span>
<span class="fc" id="L60">            Boolean state = accessRules.get(subString);</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">            if (state==null) {</span>
                // Check if the non-normalized form is present
<span class="fc" id="L63">                state = accessRules.get(subString + &quot;/&quot;);</span>
            }
<span class="fc bfc" id="L65" title="All 2 branches covered.">            if (state!=null) {</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">            	if (log.isTraceEnabled()) {</span>
<span class="nc" id="L67">            	    log.trace(&quot;hasAccessToResource: &quot;+resource+&quot;, &quot;+state.booleanValue());</span>
            	}
<span class="fc" id="L69">                return state.booleanValue();</span>
            }
<span class="fc" id="L71">        }</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L73">            log.trace(&quot;hasAccessToResource: &quot;+resource+&quot;, &quot;+false);</span>
        }
<span class="fc" id="L75">        return false;</span>
    }

    /** Normalize access rules tree (make sure rules always end with a '/') 
     * @param accessRules rules */
    public static void normalizeResources(final HashMap&lt;String, Boolean&gt; accessRules) {
        // For each rule, check if there are higher level rules (e.g. shorter path) with the same access state
<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (final String resource : new ArrayList&lt;&gt;(accessRules.keySet())) {</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">            if (!resource.endsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L84">                final String resourceWithTrailingSlash = resource + &quot;/&quot;;</span>
<span class="fc" id="L85">                final Boolean value = accessRules.remove(resource);</span>
<span class="fc" id="L86">                accessRules.put(resourceWithTrailingSlash, value);</span>
            }
<span class="fc" id="L88">        }</span>
<span class="fc" id="L89">    }</span>

    /** Normalize access rules (make sure rules always end with a '/') 
     * @param resource rules
     * @return normalized string */
    public static String normalizeResource(final String resource) {
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (!resource.endsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L96">            return resource + &quot;/&quot;;</span>
        }
<span class="fc" id="L98">        return resource;</span>
    }

    /** Remove redundant rules. Assumes parameter is in normalized form. 
     * @param accessRules rules */
    public static void minimizeAccessRules(final HashMap&lt;String, Boolean&gt; accessRules) {
        // For each rule, check if there are higher level rules (e.g. shorter path) with the same access state
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (final String resourceWithTrailingSlash : new ArrayList&lt;&gt;(accessRules.keySet())) {</span>
<span class="fc" id="L106">            final Boolean currentState = accessRules.get(resourceWithTrailingSlash);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">            if (currentState==null) {</span>
                // Already removed from map
<span class="nc" id="L109">                continue;</span>
            }
<span class="fc" id="L111">            int lastSlashIndex = resourceWithTrailingSlash.length()+1;</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            while ((lastSlashIndex = resourceWithTrailingSlash.lastIndexOf('/', lastSlashIndex-1))!=-1) {</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                if (lastSlashIndex==resourceWithTrailingSlash.length()-1) {</span>
<span class="fc" id="L114">                    continue;</span>
                }
<span class="fc" id="L116">                final String subString = resourceWithTrailingSlash.substring(0, lastSlashIndex+1);</span>
<span class="fc" id="L117">                final Boolean state = accessRules.get(subString);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">                if (state!=null) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">                    if (state.booleanValue()==currentState.booleanValue()) {</span>
                        // A short path already provides this rule
<span class="fc" id="L121">                        accessRules.remove(resourceWithTrailingSlash);</span>
                    } else {
                        // The rule is needed, since it reverts a short paths state
                    }
                    break;
                }
<span class="fc" id="L127">            }</span>
<span class="fc" id="L128">        }</span>
        // Remove all top level deny rules (if nothing is explicitly permitted, we don't need to deny it)
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (final String resourceWithTrailingSlash : new ArrayList&lt;&gt;(accessRules.keySet())) {</span>
<span class="fc" id="L131">            final Boolean currentState = accessRules.get(resourceWithTrailingSlash);</span>
<span class="pc bpc" id="L132" title="1 of 4 branches missed.">            if (currentState!=null &amp;&amp; !currentState.booleanValue()) {</span>
<span class="fc" id="L133">                boolean needed = false;</span>
<span class="fc" id="L134">                int lastSlashIndex = resourceWithTrailingSlash.length()+1;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">                while ((lastSlashIndex = resourceWithTrailingSlash.lastIndexOf('/', lastSlashIndex-1))!=-1) {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">                    if (lastSlashIndex==resourceWithTrailingSlash.length()-1) {</span>
<span class="fc" id="L137">                        continue;</span>
                    }
<span class="fc" id="L139">                    final String subString = resourceWithTrailingSlash.substring(0, lastSlashIndex+1);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">                    if (accessRules.get(subString)!=null) {</span>
<span class="fc" id="L141">                        needed = true;</span>
<span class="fc" id="L142">                        break;</span>
                    }
<span class="fc" id="L144">                }</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                if (!needed) {</span>
<span class="fc" id="L146">                    accessRules.remove(resourceWithTrailingSlash);</span>
                }
            }
<span class="fc" id="L149">        }</span>
<span class="fc" id="L150">    }</span>

    /** @param accessRules1 First set of rules
     * @param accessRules2 Second set of rules
     * @return the rules for all resources granted by either sets of normalized accessRules. (The union of the sets.) */
    public static HashMap&lt;String, Boolean&gt; getAccessRulesUnion(final HashMap&lt;String, Boolean&gt; accessRules1, final HashMap&lt;String, Boolean&gt; accessRules2) {
<span class="nc" id="L156">        final HashMap&lt;String, Boolean&gt; accessRules = new HashMap&lt;&gt;();</span>
        /*
         * Simple example of algorithm:
         *
         * /a/   allow
         * /a/b/ deny    (remove this deny, since it is granted by other role)
         * /b/   deny    (keep since it is not granted by other role)
         *
         * /a/   allow
         * /a/c/ deny    (remove this deny, since it is granted by other role)
         * /c/d  deny    (keep since it is not granted by other role)
         * →
         * /a/   allow
         * /b/   deny
         * /c/d  deny
         */
        // Keep allow rules from accessRules1 and deny rules from accessRules1 that are not granted by accessRules2
<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (final Entry&lt;String, Boolean&gt; entry : accessRules1.entrySet()) {</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">            if (entry.getValue().booleanValue() || !hasAccessToResource(accessRules2, entry.getKey())) {</span>
<span class="nc" id="L175">                accessRules.put(entry.getKey(), entry.getValue());</span>
            }
<span class="nc" id="L177">        }</span>
        // Keep allow rules from accessRules1 and deny rules from accessRules1 that are not granted by accessRules2
<span class="nc bnc" id="L179" title="All 2 branches missed.">        for (final Entry&lt;String, Boolean&gt; entry : accessRules2.entrySet()) {</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">            if (entry.getValue().booleanValue() || !hasAccessToResource(accessRules1, entry.getKey())) {</span>
<span class="nc" id="L181">                accessRules.put(entry.getKey(), entry.getValue());</span>
            }
<span class="nc" id="L183">        }</span>
<span class="nc" id="L184">        minimizeAccessRules(accessRules);</span>
<span class="nc" id="L185">        return accessRules;</span>
    }

    /** @param accessRules1 First set of rules
     * @param accessRules2 Second set of rules
     * @return the rules for all resources granted by both sets of normalized accessRules. (The intersection of the sets.) */
    public static HashMap&lt;String, Boolean&gt; getAccessRulesIntersection(final HashMap&lt;String, Boolean&gt; accessRules1, final HashMap&lt;String, Boolean&gt; accessRules2) {
<span class="nc" id="L192">        final HashMap&lt;String, Boolean&gt; accessRules = new HashMap&lt;&gt;();</span>
        /*
         * Simple example of algorithm:
         *
         * /a/   allow
         * /a/b/ deny
         * /b/   deny
         * /c/d/ allow
         *
         * /a/   allow
         * /a/c/ deny
         * /c/d/ deny
         * →
         * /a/   allow
         * /a/b/ deny
         * /a/c/ deny
         * /b/   deny
         * /c/d/ deny
         */
        // Keep deny rules from accessRules1 and allow rules from accessRules1 and that are also granted by accessRules2
<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (final Entry&lt;String, Boolean&gt; entry : accessRules1.entrySet()) {</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">            if (!entry.getValue().booleanValue() || hasAccessToResource(accessRules2, entry.getKey())) {</span>
<span class="nc" id="L214">                accessRules.put(entry.getKey(), entry.getValue());</span>
            }
<span class="nc" id="L216">        }</span>
        // Keep deny rules from accessRules2 and allow rules from accessRules2 and that are also granted by accessRules1
<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (final Entry&lt;String, Boolean&gt; entry : accessRules2.entrySet()) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (!entry.getValue().booleanValue()) {</span>
<span class="nc" id="L220">                accessRules.put(entry.getKey(), entry.getValue());</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            } else if (hasAccessToResource(accessRules1, entry.getKey())) {</span>
<span class="nc" id="L222">                final Boolean currentValue = accessRules.get(entry.getKey());</span>
<span class="nc bnc" id="L223" title="All 4 branches missed.">                if (currentValue==null || currentValue.booleanValue()) {</span>
                    // Only overwrite empty or allow rules
<span class="nc" id="L225">                    accessRules.put(entry.getKey(), entry.getValue());</span>
                }
            }
<span class="nc" id="L228">        }</span>
<span class="nc" id="L229">        minimizeAccessRules(accessRules);</span>
<span class="nc" id="L230">        return accessRules;</span>
    }

    /** Sort the provided access rules. (Useful for more readable persistence format.) 
     * @param accessRules  rules */
    public static void sortAccessRules(final LinkedHashMap&lt;String, Boolean&gt; accessRules) {
<span class="nc" id="L236">        final List&lt;Entry&lt;String, Boolean&gt;&gt; sortEntryList = getAsListSortedByKey(accessRules);</span>
<span class="nc" id="L237">        accessRules.clear();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (final Entry&lt;String, Boolean&gt; entry : sortEntryList) {</span>
<span class="nc" id="L239">            accessRules.put(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L240">        }</span>
<span class="nc" id="L241">    }</span>

    /** @param accessRulesMap Rules
     * @param &lt;T1&gt;  Type of key
     * @param &lt;T2&gt; Type of value
     * @return the map sorted by keys */
    public static &lt;T1, T2&gt; List&lt;Entry&lt;T1, T2&gt;&gt; getAsListSortedByKey(final HashMap&lt;T1, T2&gt; accessRulesMap) {
<span class="fc" id="L248">        final List&lt;Entry&lt;T1, T2&gt;&gt; accessRulesList = new ArrayList&lt;&gt;(accessRulesMap.entrySet());</span>
<span class="fc" id="L249">        Collections.sort(accessRulesList, new Comparator&lt;Entry&lt;T1, T2&gt;&gt;() {</span>
            @Override
            public int compare(final Entry&lt;T1, T2&gt; entry1, final Entry&lt;T1, T2&gt; entry2) {
<span class="fc" id="L252">                return String.valueOf(entry1.getKey()).compareTo(String.valueOf(entry2.getKey()));</span>
            }
        });
<span class="fc" id="L255">        return accessRulesList;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>