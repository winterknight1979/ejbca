<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RsaKeyValidator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-ejb</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.validation</a> &gt; <span class="el_source">RsaKeyValidator.java</span></div><h1>RsaKeyValidator.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General                  *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.keys.validation;

import java.math.BigInteger;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.math.Primes;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificateprofile.CertificateProfileConstants;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.profiles.Profile;
import org.cesecore.util.ui.DynamicUiActionCallback;
import org.cesecore.util.ui.DynamicUiCallbackException;
import org.cesecore.util.ui.DynamicUiModel;
import org.cesecore.util.ui.DynamicUiProperty;

/**
 * Default RSA key validator.
 *
 * The key validator is used to implement the CA/B-Forum requirements for RSA public
 * key quality requirements, including FIPS 186-4 and NIST (SP 800-89 and NIST SP 56A: Revision 2)
 * requirements. See: https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.4.2.pdf section 6.1.6
 *
 * @version $Id: RsaKeyValidator.java 29467 2018-07-05 16:23:04Z mikekushner $
 */
public class RsaKeyValidator extends KeyValidatorBase {

    private static final long serialVersionUID = -335429118359811926L;

    /** Class logger. */
<span class="fc" id="L53">    private static final Logger log = Logger.getLogger(RsaKeyValidator.class);</span>

    /** MUST be at least 2048 bits key size. */
    public static final int CAB_FORUM_BLR_142_KEY_SIZE_MIN = 2048;

    /** SHOULD be odd exponent. */
    public static final boolean CAB_FORUM_BLR_142_PUBLIC_EXPONENT_ONLY_ALLOW_ODD = true;

    /** MUST be &amp;gt;= 3, SHOULD be &amp;gt; 2^16+1 = 65.536+1 */
    public static final String CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MIN = &quot;65537&quot;;

    /** SHOULD be &amp;lt;= 2^256-1 = 115792089237316195423570985008687907853269984665640564039457584007913129639936-1 = 2^64*2^4-1 */
    public static final String CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MAX = &quot;115792089237316195423570985008687907853269984665640564039457584007913129639935&quot;;

    /** SHOULD be odd modulus. */
    public static final boolean CAB_FORUM_BLR_142_PUBLIC_MODULUS_ONLY_ALLOW_ODD = true;

    /** SHOULD not be the power of a prime. */
    public static final boolean CAB_FORUM_BLR_142_PUBLIC_MODULUS_DONT_ALLOW_POWER_OF_PRIME = true;

    /** SHOULD be with smallest factor &amp;gt;= 752 */
    public static final int CAB_FORUM_BLR_142_PUBLIC_MODULUS_SMALLEST_FACTOR = 752;

    /** The key validator type. */
    private static final String TYPE_IDENTIFIER = &quot;RSA_KEY_VALIDATOR&quot;;

    protected static final String BIT_LENGTHS = &quot;bitLengths&quot;;

    protected static final String PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD = &quot;publicKeyExponentOnlyAllowOdd&quot;;

    protected static final String PUBLIC_KEY_EXPONENT_MIN = &quot;publicKeyExponentMin&quot;;

    protected static final String PUBLIC_KEY_EXPONENT_MAX = &quot;publicKeyExponentMax&quot;;

    protected static final String PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD = &quot;publicKeyModulusOnlyAllowOdd&quot;;

    protected static final String PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME = &quot;publicKeyModulusDontAllowPowerOfPrime&quot;;

    protected static final String PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS = &quot;publicKeyModulusDontAllowRocaWeakKeys&quot;;

    protected static final String PUBLIC_KEY_MODULUS_MIN_FACTOR = &quot;publicKeyModulusMinFactor&quot;;

    protected static final String PUBLIC_KEY_MODULUS_MIN = &quot;publicKeyModulusMin&quot;;

    protected static final String PUBLIC_KEY_MODULUS_MAX = &quot;publicKeyModulusMax&quot;;

    /**
     * Tests if the factors of the BigInteger modulus are prime.
     * @param modulus the big integer modulus to test
     * @return true if the modulus is power of a prime, false otherwise.
     */
    protected static boolean isPowerOfPrime(BigInteger modulus) {
        // The isPowerOfPrime test is copied from org.bouncycastle.crypto.asymmetric.KeyUtils in the BC-FIPS package.
        // If we move to use the FIPS provider we can use the methods directly instead
        // --- Begin BC code
        // Use the same iterations as if we were testing a candidate p or q value with error probability 2^-100
<span class="fc" id="L109">        int bits = modulus.bitLength();</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        int iterations = bits &gt;= 1536 ? 3</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            : bits &gt;= 1024 ? 4</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            : bits &gt;= 512 ? 7</span>
<span class="fc" id="L113">            : 50;</span>
        // SP 800-89 requires use of an approved DRBG.
//        SecureRandom testRandom = FipsDRBG.SHA256.fromEntropySource(new SecureRandom(), false)
//            .build(Pack.longToBigEndian(System.currentTimeMillis()), false, Strings.toByteArray(Thread.currentThread().toString()));
<span class="fc" id="L117">        SecureRandom testRandom = new SecureRandom(); // we cheat a little and use regular SecureRandom, which is good</span>
<span class="fc" id="L118">        Primes.MROutput mr = Primes.enhancedMRProbablePrimeTest(modulus, testRandom, iterations);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (!mr.isProvablyComposite())</span>
        {
            // FSM_TRANS:5.16, &quot;FIPS 186-3/SP 800-89 ASSURANCES CHECK&quot;, &quot;CONDITIONAL TEST&quot;, &quot;FIPS 186-3/SP 800-89 Assurances test failed&quot;
<span class="nc" id="L122">            log.debug(&quot;RSA modulus is not composite&quot;);</span>
<span class="nc" id="L123">            return true;</span>
        }
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (!mr.isNotPrimePower())</span>
        {
            // FSM_TRANS:5.16, &quot;FIPS 186-3/SP 800-89 ASSURANCES CHECK&quot;, &quot;CONDITIONAL TEST&quot;, &quot;FIPS 186-3/SP 800-89 Assurances test failed&quot;
<span class="fc" id="L128">            log.debug(&quot;RSA modulus is a power of a prime&quot;);</span>
<span class="fc" id="L129">            return true;</span>
        }
        // --- end BC code
<span class="nc" id="L132">        return false;</span>
    }
//    public static boolean isPowerOfPrime(BigInteger modulus) {
//        BigInteger n = modulus;
//        final Set&lt;BigInteger&gt; result = new TreeSet&lt;BigInteger&gt;();
//        for (BigInteger i = BigInteger.valueOf(2); i.compareTo(n.divide(i).add(BigInteger.ONE)) == -1; i = i.add(BigInteger.ONE)) {
//            while (n.mod(i).compareTo(BigInteger.ZERO) == 0) {
//                if (result.contains(i)) { // is power of a prime.
//                    return true;
//                }
//                result.add(i);
//                n = n.divide(i);
//            }
//        }
//        if (n.compareTo(BigInteger.ONE) == 1) {
//            if (result.contains(n)) { // is power of a prime.
//                return true;
//            }
//            result.add(n);
//        }
//        return false;
//    }

//  /**
  //     * Checks if the given value is a prime.
  //     * @param value the positive integer value.
  //     * @return true if the value is a prime.
  //     */
  //    public static final boolean isPrime(BigInteger value) {
  //        if (!value.isProbablePrime(5)) {
  //            return false;
  //        }
  //        final BigInteger two = BigInteger.valueOf(2);
  //        if (!two.equals(value) &amp;&amp; BigInteger.ZERO.equals(value.mod(two))) {
  //            return false;
  //        }
  //        for (BigInteger i = BigInteger.valueOf(3); i.multiply(i).compareTo(value) &lt; 1; i = i.add(two)) {
  //            if (value.mod(i).equals(BigInteger.ZERO)) {
  //                return false;
  //            }
  //        }
  //        return true;
  //    }

    /**
     * Gets the smallest factor of the positive natural number greater than 2.
     * @param n the number
     * @param intFactor factor
     * @return the smallest factor or 2 for n=0.
     */
    protected static final boolean hasSmallerFactorThan(BigInteger n, int intFactor) {
        //        BigInteger factor = BigInteger.valueOf(intFactor);
<span class="fc" id="L184">        final BigInteger two = new BigInteger(&quot;2&quot;);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (intFactor &lt; 3) {</span>
<span class="fc" id="L186">            return false;</span>
        }
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">        if (n.mod(two).equals(BigInteger.ZERO) &amp;&amp; intFactor &gt; 2) {</span>
<span class="fc" id="L189">            return true;</span>
        }
<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (int i = intFactor; i &gt; 2; i = i - 2) {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (n.mod(BigInteger.valueOf(i)).equals(BigInteger.ZERO)) {</span>
<span class="fc" id="L193">                return true;</span>
            }
        }
<span class="fc" id="L196">        return false;</span>
    }


    /**
     * Public constructor needed for deserialization.
     */
    public RsaKeyValidator() {
<span class="fc" id="L204">        super();</span>
<span class="fc" id="L205">    }</span>

    /**
     * Creates a new instance.
     * @param name name
     */
    public RsaKeyValidator(final String name) {
<span class="fc" id="L212">        super(name);</span>
<span class="fc" id="L213">    }</span>

    @Override
    public void init() {
<span class="fc" id="L217">        super.init();</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (null == data.get(BIT_LENGTHS)) {</span>
<span class="fc" id="L219">            setBitLengths(new ArrayList&lt;String&gt;());</span>
        }
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (null == data.get(PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD)) {</span>
<span class="fc" id="L222">            setPublicKeyExponentOnlyAllowOdd(false);</span>
        }
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (null == data.get(PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD)) {</span>
<span class="fc" id="L225">            setPublicKeyModulusOnlyAllowOdd(false);</span>
        }
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">        if (null == data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME)) {</span>
<span class="fc" id="L228">            setPublicKeyModulusDontAllowPowerOfPrime(false);</span>
        }
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (null == data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS)) {</span>
<span class="fc" id="L231">            setPublicKeyModulusDontAllowRocaWeakKeys(true);</span>
        }
<span class="fc" id="L233">    }</span>

    @Override
    @SuppressWarnings({ &quot;serial&quot;, &quot;unchecked&quot; })
    public void initDynamicUiModel() {
<span class="nc" id="L238">        uiModel = new DynamicUiModel(data);</span>
<span class="nc" id="L239">        uiModel.add(new DynamicUiProperty&lt;String&gt;(&quot;settings&quot;));</span>
<span class="nc" id="L240">        final DynamicUiProperty&lt;Integer&gt; settingsTemplate = new DynamicUiProperty&lt;Integer&gt;(Integer.class, SETTINGS_TEMPLATE, getSettingsTemplate(), KeyValidatorSettingsTemplate.types());</span>
<span class="nc" id="L241">        settingsTemplate.setRenderingHint(DynamicUiProperty.RENDER_SELECT_ONE);</span>
<span class="nc" id="L242">        settingsTemplate.setLabels(KeyValidatorSettingsTemplate.map());</span>
<span class="nc" id="L243">        settingsTemplate.setRequired(true);</span>
<span class="nc" id="L244">        settingsTemplate.setActionCallback(new DynamicUiActionCallback() {</span>
            @Override
            public void action(final Object parameter) throws DynamicUiCallbackException {
<span class="nc" id="L247">                final Map&lt;Object, Object&gt; oldValues = (Map&lt;Object, Object&gt;) data.clone();</span>
<span class="nc" id="L248">                setKeyValidatorSettingsTemplate(KeyValidatorSettingsTemplate.optionOf(Integer.parseInt((String) parameter)));</span>
<span class="nc" id="L249">                uiModel.firePropertyChange(oldValues, data);</span>
<span class="nc" id="L250">            }</span>
            @Override
            public List&lt;String&gt; getRender() {
<span class="nc" id="L253">                return null;</span>
            }
        });
<span class="nc" id="L256">        uiModel.add(settingsTemplate);</span>
<span class="nc" id="L257">        final DynamicUiProperty&lt;String&gt; bitLengths = new DynamicUiProperty&lt;String&gt;(String.class, BIT_LENGTHS, getBitLengthsAsString(), getAvailableBitLengths(0)) {</span>
            @Override
<span class="nc" id="L259">            public boolean isDisabled() { return isBitLengthsDisabled(); }</span>
        };
<span class="nc" id="L261">        bitLengths.setHasMultipleValues(true);</span>
<span class="nc" id="L262">        bitLengths.setLabels(getAvailableBitLengthsAsMap(0));</span>
<span class="nc" id="L263">        bitLengths.setRequired(true);</span>
<span class="nc" id="L264">        uiModel.add(bitLengths);</span>
<span class="nc" id="L265">        uiModel.add(new DynamicUiProperty&lt;Boolean&gt;(Boolean.class, PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD, isPublicKeyExponentOnlyAllowOdd()) {</span>
            @Override
<span class="nc" id="L267">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L269">        uiModel.add(new DynamicUiProperty&lt;BigInteger&gt;(BigInteger.class, PUBLIC_KEY_EXPONENT_MIN, getPublicKeyExponentMin()) {</span>
            @Override
<span class="nc" id="L271">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L273">        uiModel.add(new DynamicUiProperty&lt;BigInteger&gt;(BigInteger.class, PUBLIC_KEY_EXPONENT_MAX, getPublicKeyExponentMax()) {</span>
            @Override
<span class="nc" id="L275">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L277">        uiModel.add(new DynamicUiProperty&lt;Boolean&gt;(Boolean.class, PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD, isPublicKeyModulusOnlyAllowOdd()) {</span>
            @Override
<span class="nc" id="L279">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L281">        uiModel.add(new DynamicUiProperty&lt;Boolean&gt;(Boolean.class, PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME, isPublicKeyModulusDontAllowPowerOfPrime()) {</span>
            @Override
<span class="nc" id="L283">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L285">        uiModel.add(new DynamicUiProperty&lt;Boolean&gt;(Boolean.class, PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS, isPublicKeyModulusDontAllowRocaWeakKeys()) {</span>
            @Override
<span class="nc" id="L287">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L289">        uiModel.add(new DynamicUiProperty&lt;Integer&gt;(Integer.class, PUBLIC_KEY_MODULUS_MIN_FACTOR, getPublicKeyModulusMinFactor()) {</span>
            @Override
<span class="nc" id="L291">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L293">        uiModel.add(new DynamicUiProperty&lt;BigInteger&gt;(BigInteger.class, PUBLIC_KEY_MODULUS_MIN, getPublicKeyModulusMin()) {</span>
            @Override
<span class="nc" id="L295">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L297">        uiModel.add(new DynamicUiProperty&lt;BigInteger&gt;(BigInteger.class, PUBLIC_KEY_MODULUS_MAX, getPublicKeyModulusMax()) {</span>
            @Override
<span class="nc" id="L299">            public boolean isDisabled() { return isPropertyDisabled(); }</span>
        });
<span class="nc" id="L301">    }</span>

    /**
     * Returns true if the dynamic property fields for this validator are supposed to be disabled.
     * @return true if disabled.
     */
    private final boolean isPropertyDisabled() {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        return KeyValidatorSettingsTemplate.USE_CAB_FORUM_SETTINGS.getOption() == getSettingsTemplate();</span>
    }

    /**
     * Returns true if the dynamic property fields for this validator are supposed to be disabled.
     * @return true if disabled.
     */
    private final boolean isBitLengthsDisabled() {
<span class="nc bnc" id="L316" title="All 2 branches missed.">        return KeyValidatorSettingsTemplate.USE_CUSTOM_SETTINGS.getOption() != getSettingsTemplate();</span>
    }

    @Override
    public void setKeyValidatorSettingsTemplate(final KeyValidatorSettingsTemplate template) {
<span class="nc" id="L321">        setSettingsTemplate(template.getOption());</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L323">            log.debug(&quot;Set configuration template for RSA key validator settings option: &quot; + template.getOption() + &quot;, &quot;</span>
<span class="nc" id="L324">                    + intres.getLocalizedMessage(template.getLabel()));</span>
        }
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (KeyValidatorSettingsTemplate.USE_CUSTOM_SETTINGS.equals(template)) {</span>
            // NOOP
<span class="nc bnc" id="L328" title="All 2 branches missed.">        } else if (KeyValidatorSettingsTemplate.USE_CAB_FORUM_SETTINGS.equals(template)) {</span>
<span class="nc" id="L329">            setCABForumBaseLineRequirements142Settings();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        } else if (KeyValidatorSettingsTemplate.USE_CERTIFICATE_PROFILE_SETTINGS.equals(template)) {</span>
            // NOOP: In the validation method, the key specification is matched against the certificate profile.
<span class="nc" id="L332">            setCertProfileSettings();</span>
        } else {
            // NOOP
        }
<span class="nc" id="L336">    }</span>

    /**
     * Sets the CA/B Forum requirements chapter 6.1.6 for RSA public keys.
     * @see &lt;a href=&quot;https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.4.2.pdf&quot;&gt; CA/B-Forum Baseline Requirements &lt;/a&gt;
    
     */
    private void setCertProfileSettings() {
<span class="nc" id="L344">        setBitLengths(new ArrayList&lt;String&gt;());</span>
        // We'll only reset the bit lengths, because this is what is passed on to the certificate profiles
        // The other settings must be set manually anyhow and should not be reset
//        setPublicKeyExponentOnlyAllowOdd(false);
//        setPublicKeyExponentMin(null);
//        setPublicKeyExponentMax(null);
//        setPublicKeyModulusOnlyAllowOdd(false);
//        setPublicKeyModulusDontAllowPowerOfPrime(false);
//        setPublicKeyModulusMinFactor(null);
//        setPublicKeyModulusMin(null);
//        setPublicKeyModulusMax(null);
<span class="nc" id="L355">    }</span>

    /**
     * Sets the CA/B Forum requirements chapter 6.1.6 for RSA public keys.
     * @see &lt;a href=&quot;https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.4.2.pdf&quot;&gt; CA/B-Forum Baseline Requirements &lt;/a&gt;
     * 
     */
    public void setCABForumBaseLineRequirements142Settings() {
        // Only apply most important conditions (sequence is Root-CA, Sub-CA, User-Certificate)!
        // But this is not required at the time, because certificate validity conditions are before
        // 2014 (now 2017). The minimal modulus size (2048 bits) is the same for all certificate types!
<span class="nc" id="L366">        setBitLengths(getAvailableBitLengths(2048));</span>
<span class="nc" id="L367">        final List&lt;Integer&gt; ids = getCertificateProfileIds();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (ids.contains(CertificateProfileConstants.CERTPROFILE_FIXED_ROOTCA)) {</span>
            // NOOP
<span class="nc bnc" id="L370" title="All 2 branches missed.">        } else if (ids.contains(CertificateProfileConstants.CERTPROFILE_FIXED_SUBCA)) {</span>
            // NOOP
        } else {
            // NOOP
        }
        // Reset to null before setting new values.
<span class="nc" id="L376">        setPublicKeyExponentMin(null);</span>
<span class="nc" id="L377">        setPublicKeyExponentMax(null);</span>

<span class="nc" id="L379">        setPublicKeyExponentOnlyAllowOdd(CAB_FORUM_BLR_142_PUBLIC_EXPONENT_ONLY_ALLOW_ODD);</span>
<span class="nc" id="L380">        setPublicKeyExponentMin(new BigInteger(CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MIN));</span>
<span class="nc" id="L381">        setPublicKeyExponentMax(new BigInteger(CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MAX));</span>
<span class="nc" id="L382">        setPublicKeyModulusOnlyAllowOdd(CAB_FORUM_BLR_142_PUBLIC_MODULUS_ONLY_ALLOW_ODD);</span>
<span class="nc" id="L383">        setPublicKeyModulusDontAllowPowerOfPrime(CAB_FORUM_BLR_142_PUBLIC_MODULUS_DONT_ALLOW_POWER_OF_PRIME);</span>
<span class="nc" id="L384">        setPublicKeyModulusMinFactor(CAB_FORUM_BLR_142_PUBLIC_MODULUS_SMALLEST_FACTOR);</span>
<span class="nc" id="L385">        setPublicKeyModulusMin(null);</span>
<span class="nc" id="L386">        setPublicKeyModulusMax(null);</span>

        // Not strictly a requirement according to the Baseline Requirements, but there is no reason to allow ROCA weak keys
<span class="nc" id="L389">        setPublicKeyModulusDontAllowRocaWeakKeys(true);</span>
<span class="nc" id="L390">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;String&gt; getBitLengths() {
<span class="fc" id="L394">        return (List&lt;String&gt;) data.get(BIT_LENGTHS);</span>
    }

    public String getBitLengthsAsString() {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        return getBitLengths() != null ? StringUtils.join(getBitLengths(), LIST_SEPARATOR) : StringUtils.EMPTY;</span>
    }

    public void setBitLengths(List&lt;String&gt; values) {
<span class="fc" id="L402">        Collections.sort(values);</span>
<span class="fc" id="L403">        data.put(BIT_LENGTHS, values);</span>
<span class="fc" id="L404">    }</span>

    public boolean isPublicKeyExponentOnlyAllowOdd() {
<span class="fc" id="L407">        return ((Boolean) data.get(PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD)).booleanValue();</span>
    }

    public void setPublicKeyExponentOnlyAllowOdd(boolean allowed) {
<span class="fc" id="L411">        data.put(PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD, Boolean.valueOf(allowed));</span>
<span class="fc" id="L412">    }</span>

    public BigInteger getPublicKeyExponentMin() {
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_EXPONENT_MIN))) {</span>
<span class="fc" id="L416">            return new BigInteger(((String) data.get(PUBLIC_KEY_EXPONENT_MIN)));</span>
        } else {
<span class="fc" id="L418">            return null;</span>
        }
    }

    public String getPublicKeyExponentMinAsString() {
<span class="fc" id="L423">        return (String) data.get(PUBLIC_KEY_EXPONENT_MIN);</span>
    }

    /**
     * Sets the validator minimum allowed public key exponent.
     * @param value The new minimum public key exponent as BigInteger
     */
    public void setPublicKeyExponentMin(BigInteger value) {
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (null == value) {</span>
<span class="fc" id="L432">            data.put(PUBLIC_KEY_EXPONENT_MIN, null);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        } else if (!(value.compareTo(BigInteger.ZERO) == -1)){</span>
<span class="fc bfc" id="L434" title="All 4 branches covered.">            if (getPublicKeyExponentMax() == null || value.compareTo(getPublicKeyExponentMax()) &lt; 1) {</span>
<span class="fc" id="L435">                data.put(PUBLIC_KEY_EXPONENT_MIN, value.toString());</span>
            } else {
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L438">                    final String message = intres.getLocalizedMessage(&quot;validator.error.minimum_bigger_log&quot;, value, getPublicKeyExponentMax());</span>
<span class="nc" id="L439">                    log.debug(message);</span>
<span class="nc" id="L440">                }</span>
            }
        } else {
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L444">                log.debug(intres.getLocalizedMessage(&quot;validator.error.set_key_validator_exp_min&quot;, value));</span>
            }
        }
<span class="fc" id="L447">    }</span>

    /**
     * Setting value for PublicKeyExponentMinAsString
     * @param value the string value for PublicKeyExponentMin
     */
    public void setPublicKeyExponentMinAsString(String value) {
<span class="fc" id="L454">        setPublicKeyExponentMin(new BigInteger(value));</span>
<span class="fc" id="L455">    }</span>

    public BigInteger getPublicKeyExponentMax() {
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_EXPONENT_MAX))) {</span>
<span class="fc" id="L459">            return new BigInteger(((String) data.get(PUBLIC_KEY_EXPONENT_MAX)));</span>
        } else {
<span class="fc" id="L461">            return null;</span>
        }
    }

    public String getPublicKeyExponentMaxAsString() {
<span class="fc" id="L466">        return (String) data.get(PUBLIC_KEY_EXPONENT_MAX);</span>
    }

    /**
     * Sets the validator maximum allowed public key exponent.
     * @param value The new maximum public key exponent as BigInteger
     */
    public void setPublicKeyExponentMax(BigInteger value) {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (null == value) {</span>
<span class="nc" id="L475">            data.put(PUBLIC_KEY_EXPONENT_MAX, null);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">        } else if (!(value.compareTo(BigInteger.ZERO) == -1)) {</span>
<span class="fc bfc" id="L477" title="All 4 branches covered.">            if (getPublicKeyExponentMin() == null || value.compareTo(getPublicKeyExponentMin()) &gt; -1) {</span>
<span class="fc" id="L478">                data.put(PUBLIC_KEY_EXPONENT_MAX, value.toString());</span>
            } else {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L481">                    final String message = intres.getLocalizedMessage(&quot;validator.error.minimum_bigger_log&quot;, getPublicKeyExponentMin(), value);</span>
<span class="nc" id="L482">                    log.debug(message);</span>
<span class="nc" id="L483">                }</span>
            }
        } else {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L487">                log.debug(intres.getLocalizedMessage(&quot;validator.error.set_key_validator_exp_max&quot;, value));</span>
            }
        }
<span class="fc" id="L490">    }</span>

    /**
     * Setting value for PublicKeyExponentMaxAsString
     * @param value the string value for PublicKeyExponentMax
     */
    public void setPublicKeyExponentMaxAsString(String value) {
<span class="fc" id="L497">        setPublicKeyExponentMax(new BigInteger(value));</span>
<span class="fc" id="L498">    }</span>

    public boolean isPublicKeyModulusOnlyAllowOdd() {
<span class="fc" id="L501">        return ((Boolean) data.get(PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD)).booleanValue();</span>
    }

    public void setPublicKeyModulusOnlyAllowOdd(boolean allowed) {
<span class="fc" id="L505">        data.put(PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD, Boolean.valueOf(allowed));</span>
<span class="fc" id="L506">    }</span>

    public boolean isPublicKeyModulusDontAllowPowerOfPrime() {
<span class="fc" id="L509">        return ((Boolean) data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME)).booleanValue();</span>
    }

    public boolean isPublicKeyModulusDontAllowRocaWeakKeys() {
<span class="fc" id="L513">        Boolean ret = (Boolean) data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS);</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        return ret != null ? ret.booleanValue() : false; // upgraded value, we must be null safe, default false</span>
    }

    public void setPublicKeyModulusDontAllowPowerOfPrime(boolean allowed) {
<span class="fc" id="L518">        data.put(PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME, Boolean.valueOf(allowed));</span>
<span class="fc" id="L519">    }</span>

    public void setPublicKeyModulusDontAllowRocaWeakKeys(boolean allowed) {
<span class="fc" id="L522">        data.put(PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS, Boolean.valueOf(allowed));</span>
<span class="fc" id="L523">    }</span>

    public Integer getPublicKeyModulusMinFactor() {
<span class="fc" id="L526">        return (Integer) data.get(PUBLIC_KEY_MODULUS_MIN_FACTOR);</span>
    }

    /**
     * Setting value for PublicKeyModulusMinFactor
     * @param type the value for PublicKeyModulusMinFactor
     */
    public void setPublicKeyModulusMinFactor(Integer type) {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        if (null == type) {</span>
<span class="nc" id="L535">            data.put(PUBLIC_KEY_MODULUS_MIN_FACTOR, null);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        } else if(!(type &lt; 0)) {</span>
<span class="fc" id="L537">            data.put(PUBLIC_KEY_MODULUS_MIN_FACTOR, type);</span>
        } else {
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            if( log.isDebugEnabled() ) {</span>
<span class="nc" id="L540">                log.debug(intres.getLocalizedMessage(&quot;validator.error.set_key_validator_fact_min&quot;, type));</span>
            }
        }
<span class="fc" id="L543">    }</span>

    public BigInteger getPublicKeyModulusMin() {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_MODULUS_MIN))) {</span>
<span class="fc" id="L547">            return new BigInteger(((String) data.get(PUBLIC_KEY_MODULUS_MIN)));</span>
        } else {
<span class="fc" id="L549">            return null;</span>
        }
    }

    public String getPublicKeyModulusMinAsString() {
<span class="fc" id="L554">        return (String) data.get(PUBLIC_KEY_MODULUS_MIN);</span>
    }

    /**
     * Setting value for PublicKeyModulusMin
     * @param value the value for PublicKeyModulusMin
     */
    public void setPublicKeyModulusMin(BigInteger value) {
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (null == value){</span>
<span class="fc" id="L563">            data.put(PUBLIC_KEY_MODULUS_MIN, null);</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">        } else if (!(value.compareTo(BigInteger.ZERO) == -1)) {</span>
<span class="fc bfc" id="L565" title="All 4 branches covered.">            if (getPublicKeyModulusMax() == null || value.compareTo(getPublicKeyModulusMax()) &lt; 1) {</span>
<span class="fc" id="L566">                data.put(PUBLIC_KEY_MODULUS_MIN, value.toString());</span>
            } else {
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L569">                    final String message = intres.getLocalizedMessage(&quot;validator.error.minimum_bigger_log&quot;, value, getPublicKeyModulusMax());</span>
<span class="nc" id="L570">                    log.debug(message);</span>
<span class="nc" id="L571">                }</span>
            }
        } else {
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L575">                log.debug(intres.getLocalizedMessage(&quot;validator.error.set_key_validator_mod_min&quot;, value));</span>
            }
        }
<span class="fc" id="L578">    }</span>

    /**
     * Setting value for PublicKeyModulusMinAsString
     * @param value the string value for PublicKeyModulusMin
     */
    public void setPublicKeyModulusMinAsString(String value) {
<span class="fc" id="L585">        setPublicKeyModulusMin(new BigInteger(value));</span>
<span class="fc" id="L586">    }</span>

    public BigInteger getPublicKeyModulusMax() {
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_MODULUS_MAX))) {</span>
<span class="fc" id="L590">            return new BigInteger((String) data.get(PUBLIC_KEY_MODULUS_MAX));</span>
        } else {
<span class="fc" id="L592">            return null;</span>
        }
    }

    public String getPublicKeyModulusMaxAsString() {
<span class="fc" id="L597">        return (String) data.get(PUBLIC_KEY_MODULUS_MAX);</span>
    }

    /**
     * Setting value for PublicKeyModulusMax
     * @param value the value for PublicKeyModulusMax
     */
    public void setPublicKeyModulusMax(BigInteger value) {
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        if (null == value){</span>
<span class="nc" id="L606">            data.put(PUBLIC_KEY_MODULUS_MAX, null);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">        } else if (!(value.compareTo(BigInteger.ZERO) == -1)) {</span>
<span class="fc bfc" id="L608" title="All 4 branches covered.">            if (getPublicKeyModulusMin() == null || value.compareTo(getPublicKeyModulusMin()) &gt; -1) {</span>
<span class="fc" id="L609">                data.put(PUBLIC_KEY_MODULUS_MAX, value.toString());</span>
            } else {
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L612">                    final String message = intres.getLocalizedMessage(&quot;validator.error.minimum_bigger_log&quot;, getPublicKeyModulusMin(), value);</span>
<span class="nc" id="L613">                    log.debug(message);</span>
<span class="nc" id="L614">                }</span>
            }
        } else {
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">            if (log.isDebugEnabled()){</span>
<span class="nc" id="L618">                log.debug(intres.getLocalizedMessage(&quot;validator.error.set_key_validator_mod_max&quot;, value));</span>
            }
        }
<span class="fc" id="L621">    }</span>

    /**
     * Setting value for PublicKeyModulusMaxAsString
     * @param value the string value for PublicKeyModulusMax
     */
    public void setPublicKeyModulusMaxAsString(String value) {
<span class="fc" id="L628">        setPublicKeyModulusMax(new BigInteger(value));</span>
<span class="fc" id="L629">    }</span>

    @Override
    public void upgrade() {
<span class="nc" id="L633">        super.upgrade();</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L635">            log.trace(&quot;&gt;upgrade: &quot; + getLatestVersion() + &quot;, &quot; + getVersion());</span>
        }
<span class="nc bnc" id="L637" title="All 2 branches missed.">        if (Float.compare(LATEST_VERSION, getVersion()) != 0) {</span>
            // New version of the class, upgrade.
<span class="nc" id="L639">            log.info(intres.getLocalizedMessage(&quot;rsakeyvalidator.upgrade&quot;,  Float.valueOf(getVersion())));</span>
<span class="nc" id="L640">            init();</span>
        }
<span class="nc" id="L642">    }</span>

    @Override
    public List&lt;String&gt; validate(final PublicKey publicKey, final CertificateProfile certificateProfile) throws ValidatorNotApplicableException, ValidationException {
<span class="fc" id="L646">        List&lt;String&gt; messages = new ArrayList&lt;String&gt;();</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L648">            log.debug(&quot;Validating public key with algorithm &quot; + publicKey.getAlgorithm() + &quot;, format &quot; + publicKey.getFormat() + &quot;, implementation &quot;</span>
<span class="nc" id="L649">                    + publicKey.getClass().getName());</span>
        }
<span class="pc bpc" id="L651" title="2 of 4 branches missed.">        if (!AlgorithmConstants.KEYALGORITHM_RSA.equals(publicKey.getAlgorithm()) || !(publicKey instanceof RSAPublicKey)) {</span>
<span class="nc" id="L652">            final String message = &quot;Invalid: Public key algorithm is not RSA or could not be parsed: &quot; + publicKey.getAlgorithm() + &quot;, format &quot;</span>
<span class="nc" id="L653">                    + publicKey.getFormat();</span>
<span class="nc" id="L654">            messages.add(message);</span>
            // Make sure this ends up in the server log
<span class="nc" id="L656">            log.info(message+&quot;, &quot;+publicKey.getClass().getName());</span>
<span class="nc" id="L657">            throw new ValidatorNotApplicableException(message);</span>
        }
<span class="fc" id="L659">        final RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;</span>
<span class="fc" id="L660">        final BigInteger publicKeyExponent = rsaPublicKey.getPublicExponent();</span>
<span class="fc" id="L661">        final BigInteger publicKeyModulus = rsaPublicKey.getModulus();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L663">            log.debug(&quot;Validate RSA public key with exponent &quot; + publicKeyExponent + &quot; and modulus &quot; + publicKeyModulus);</span>
        }
<span class="fc" id="L665">        final int settingsOption = getSettingsTemplate();</span>
<span class="fc" id="L666">        final int keyLength = KeyTools.getKeyLength(publicKey);</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (KeyValidatorSettingsTemplate.USE_CERTIFICATE_PROFILE_SETTINGS.getOption() == settingsOption) {</span>
<span class="nc" id="L668">            final List&lt;Integer&gt; bitLengths = certificateProfile.getAvailableBitLengthsAsList();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (!bitLengths.contains(Integer.valueOf(keyLength))) {</span>
                // Invalid Key in request: Illegal key length, not authorized by certificate profile: 2048.. Please supply a correct request.
<span class="nc" id="L671">                messages.add(&quot;Invalid: RSA key size/strength: Use one of the following &quot; + bitLengths + &quot;.&quot;);</span>
            }
<span class="nc" id="L673">        } else {</span>
<span class="fc" id="L674">            final List&lt;String&gt; bitLengths = getBitLengths();</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">            if (!bitLengths.contains(Integer.toString(keyLength))) {</span>
<span class="nc" id="L676">                messages.add(&quot;Invalid: RSA key size/strength: Use one of the following &quot; + bitLengths + &quot;.&quot;);</span>
            }
        }
<span class="fc bfc" id="L679" title="All 2 branches covered.">        if (isPublicKeyExponentOnlyAllowOdd()) {</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (publicKeyExponent.mod(BigInteger.valueOf(2L)).compareTo(BigInteger.ZERO) == 0) {</span>
<span class="fc" id="L681">                messages.add(&quot;Invalid: RSA public key exponent is odd.&quot;);</span>
            } else {
<span class="fc" id="L683">                log.trace(&quot;isPublicKeyExponentOnlyAllowOdd passed&quot;);</span>
            }
        }
<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (null != getPublicKeyExponentMin()) {</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">            if (publicKeyExponent.compareTo(getPublicKeyExponentMin()) == -1) {</span>
<span class="fc" id="L688">                messages.add(&quot;Invalid: RSA public key exponent is smaller than &quot; + getPublicKeyExponentMin());</span>
            } else {
<span class="fc" id="L690">                log.trace(&quot;getPublicKeyExponentMin passed&quot;);</span>
            }
        }
<span class="fc bfc" id="L693" title="All 2 branches covered.">        if (null != getPublicKeyExponentMax()) {</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">            if (publicKeyExponent.compareTo(getPublicKeyExponentMax()) == 1) {</span>
<span class="fc" id="L695">                messages.add(&quot;Invalid: RSA public key exponent is greater than &quot; + getPublicKeyExponentMax());</span>
            }
        }
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (isPublicKeyModulusOnlyAllowOdd()) {</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">            if (publicKeyModulus.mod(BigInteger.valueOf(2L)).compareTo(BigInteger.ZERO) == 0) {</span>
<span class="fc" id="L700">                messages.add(&quot;Invalid: RSA public key modulus is odd.&quot;);</span>
            } else {
<span class="fc" id="L702">                log.trace(&quot;isPublicKeyModulusOnlyAllowOdd passed&quot;);</span>
            }
        }
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (isPublicKeyModulusDontAllowPowerOfPrime()) {</span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">            if (isPowerOfPrime(publicKeyModulus)) {</span>
<span class="fc" id="L707">                messages.add(&quot;Invalid: RSA public key modulus is not allowed to be the power of a prime.&quot;);</span>
            } else {
<span class="nc" id="L709">                log.trace(&quot;isPublicKeyModulusDontAllowPowerOfPrime passed&quot;);</span>
            }
        }
<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (isPublicKeyModulusDontAllowRocaWeakKeys()) {</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">            if (RocaBrokenKey.isAffected(publicKeyModulus)) {</span>
<span class="fc" id="L714">                messages.add(&quot;Invalid: RSA public key modulus is a weak key according to CVE-2017-15361.&quot;);</span>
            } else {
<span class="fc" id="L716">                log.trace(&quot;isPublicKeyModulusDontAllowRocaWeakKeys passed&quot;);</span>
            }
        }
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (null != getPublicKeyModulusMinFactor()) {</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">            if (hasSmallerFactorThan(publicKeyModulus, getPublicKeyModulusMinFactor() + 1)) {</span>
<span class="fc" id="L721">                messages.add(&quot;Invalid: RSA public key modulus smallest factor is less than &quot; + getPublicKeyModulusMinFactor());</span>
            } else {
<span class="fc" id="L723">                log.trace(&quot;getPublicKeyModulusMinFactor passed&quot;);</span>
            }
        }
<span class="fc bfc" id="L726" title="All 2 branches covered.">        if (null != getPublicKeyModulusMin()) {</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">            if (publicKeyModulus.compareTo(getPublicKeyModulusMin()) == -1) {</span>
<span class="fc" id="L728">                messages.add(&quot;Invalid: RSA public key modulus is smaller than &quot; + getPublicKeyModulusMin());</span>
            } else {
<span class="nc" id="L730">                log.trace(&quot;getPublicKeyModulusMin passed&quot;);</span>
            }
        }
<span class="fc bfc" id="L733" title="All 2 branches covered.">        if (null != getPublicKeyModulusMax()) {</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">            if (publicKeyModulus.compareTo(getPublicKeyModulusMax()) == 1) {</span>
<span class="fc" id="L735">                messages.add(&quot;Invalid: RSA public key modulus is greater than &quot; + getPublicKeyModulusMax());</span>
            } else {
<span class="fc" id="L737">                log.trace(&quot;getPublicKeyModulusMax passed&quot;);</span>
            }
        }

<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            for (String message : messages) {</span>
<span class="nc" id="L743">                log.debug(message);</span>
<span class="nc" id="L744">            }</span>
        }
<span class="fc" id="L746">        return messages;</span>
    }

    /**
     * Gets the available bit lengths to choose.
     * @return the list of available bit lengths.
     */
    public List&lt;String&gt; getAvailableBitLengths() {
<span class="nc" id="L754">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">        for (int length : CertificateProfile.DEFAULTBITLENGTHS) {</span>
<span class="nc" id="L756">            result.add(Integer.toString(length));</span>
        }
<span class="nc" id="L758">        return result;</span>
    }

    /**
     * Gets the available bit lengths to choose.
     * @param minLength minimum length
     * @return the list of available bit lengths.
     */
    public static List&lt;String&gt; getAvailableBitLengths(final int minLength) {
<span class="nc" id="L767">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">        for (int length : CertificateProfile.DEFAULTBITLENGTHS) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (length &gt;= minLength) {</span>
<span class="nc" id="L770">                result.add(Integer.toString(length));</span>
            }
        }
<span class="nc" id="L773">        return result;</span>
    }

    /**
     * Gets the available bit lengths to choose as map ( key = value).
     * @param minLength minimum length
     * @return the map of available bit lengths.
     */
    public static Map&lt;String,String&gt; getAvailableBitLengthsAsMap(final int minLength) {
<span class="nc" id="L782">        final Map&lt;String,String&gt; result = new LinkedHashMap&lt;String,String&gt;();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        for (int length : CertificateProfile.DEFAULTBITLENGTHS) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">            if (length &gt;= minLength) {</span>
<span class="nc" id="L785">                result.put(Integer.toString(length), Integer.toString(length));</span>
            }
        }
<span class="nc" id="L788">        return result;</span>
    }

    @Override
    public String getLabel() {
<span class="nc" id="L793">        return intres.getLocalizedMessage(&quot;validator.implementation.key.rsa&quot;);</span>
    }

    @Override
    public String getValidatorTypeIdentifier() {
<span class="nc" id="L798">        return TYPE_IDENTIFIER;</span>
    }

    @Override
    protected Class&lt;? extends Profile&gt; getImplementationClass() {
<span class="fc" id="L803">        return RsaKeyValidator.class;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>