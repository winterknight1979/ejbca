<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CertTools.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-entity</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util</a> &gt; <span class="el_source">CertTools.java</span></div><h1>CertTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.util;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.cert.CRL;
import java.security.cert.CRLException;
import java.security.cert.CertPath;
import java.security.cert.CertPathValidator;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertPathValidatorResult;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.CertificateParsingException;
import java.security.cert.PKIXCertPathChecker;
import java.security.cert.PKIXCertPathValidatorResult;
import java.security.cert.PKIXParameters;
import java.security.cert.TrustAnchor;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.ECPublicKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.CharUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.math.NumberUtils;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Encoding;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.ASN1TaggedObject;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DERGeneralString;
import org.bouncycastle.asn1.DERGeneralizedTime;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.DERTaggedObject;
import org.bouncycastle.asn1.DERUTF8String;
import org.bouncycastle.asn1.pkcs.Attribute;
import org.bouncycastle.asn1.pkcs.CertificationRequest;
import org.bouncycastle.asn1.pkcs.CertificationRequestInfo;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x500.AttributeTypeAndValue;
import org.bouncycastle.asn1.x500.RDN;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x500.X500NameBuilder;
import org.bouncycastle.asn1.x500.X500NameStyle;
import org.bouncycastle.asn1.x500.style.IETFUtils;
import org.bouncycastle.asn1.x509.AccessDescription;
import org.bouncycastle.asn1.x509.AuthorityInformationAccess;
import org.bouncycastle.asn1.x509.AuthorityKeyIdentifier;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.bouncycastle.asn1.x509.GeneralSubtree;
import org.bouncycastle.asn1.x509.KeyPurposeId;
import org.bouncycastle.asn1.x509.NameConstraints;
import org.bouncycastle.asn1.x509.PolicyInformation;
import org.bouncycastle.asn1.x509.PrivateKeyUsagePeriod;
import org.bouncycastle.asn1.x509.ReasonFlags;
import org.bouncycastle.asn1.x509.SubjectKeyIdentifier;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
import org.bouncycastle.cert.CertIOException;
import org.bouncycastle.cert.X509CRLHolder;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CRLConverter;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;
import org.bouncycastle.cert.jcajce.JcaX509ExtensionUtils;
import org.bouncycastle.cms.CMSAbsentContent;
import org.bouncycastle.cms.CMSException;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import org.bouncycastle.jce.X509KeyUsage;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.provider.PKIXNameConstraintValidator;
import org.bouncycastle.jce.provider.PKIXNameConstraintValidatorException;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.operator.BufferingContentSigner;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder;
import org.bouncycastle.pkcs.PKCS10CertificationRequest;
import org.bouncycastle.util.CollectionStore;
import org.bouncycastle.util.encoders.DecoderException;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.certificates.ca.IllegalNameException;
import org.cesecore.certificates.certificate.CertificateWrapper;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.certificates.ocsp.SHA1DigestCalculator;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.DnComponents;
import org.cesecore.config.OcspConfiguration;
import org.cesecore.internal.InternalResources;
import org.ejbca.cvc.AuthorizationRole;
import org.ejbca.cvc.CVCAuthorizationTemplate;
import org.ejbca.cvc.CVCObject;
import org.ejbca.cvc.CVCertificate;
import org.ejbca.cvc.CardVerifiableCertificate;
import org.ejbca.cvc.CertificateParser;
import org.ejbca.cvc.ReferenceField;
import org.ejbca.cvc.exception.ConstructionException;
import org.ejbca.cvc.exception.ParseException;

import com.novell.ldap.LDAPDN;

/**
 * Tools to handle common certificate operations.
 * 
 * @version $Id: CertTools.java 30344 2018-11-01 13:10:21Z samuellb $
 */
<span class="nc" id="L176">public abstract class CertTools {</span>
<span class="fc" id="L177">    private static final Logger log = Logger.getLogger(CertTools.class);</span>

<span class="fc" id="L179">    private static final InternalResources intres = InternalResources.getInstance();</span>

    // Initialize dnComponents
    static {
<span class="fc" id="L183">        DnComponents.getDnObjects(true);</span>
    }
    public static final String EMAIL = &quot;rfc822name&quot;;
    public static final String EMAIL1 = &quot;email&quot;;
    public static final String EMAIL2 = &quot;EmailAddress&quot;;
    public static final String EMAIL3 = &quot;E&quot;;
    public static final String DNS = &quot;dNSName&quot;;
    public static final String URI = &quot;uniformResourceIdentifier&quot;;
    public static final String URI1 = &quot;uri&quot;;
    public static final String URI2 = &quot;uniformResourceId&quot;;
    public static final String IPADDR = &quot;iPAddress&quot;;
    public static final String DIRECTORYNAME = &quot;directoryName&quot;;
    public static final String REGISTEREDID = &quot;registeredID&quot;;
    public static final String XMPPADDR = &quot;xmppAddr&quot;;
    public static final String SRVNAME = &quot;srvName&quot;;
    public static final String FASCN = &quot;fascN&quot;;

    /** Kerberos altName for smart card logon */
    public static final String KRB5PRINCIPAL = &quot;krb5principal&quot;;
    /** OID for Kerberos altName for smart card logon */
    public static final String KRB5PRINCIPAL_OBJECTID = &quot;1.3.6.1.5.2.2&quot;;
    /** Microsoft altName for windows smart card logon */
    public static final String UPN = &quot;upn&quot;;
    /** ObjectID for upn altName for windows smart card logon */
    public static final String UPN_OBJECTID = &quot;1.3.6.1.4.1.311.20.2.3&quot;;
    /** ObjectID for XmppAddr, rfc6120#section-13.7.1.4 */
    public static final String XMPPADDR_OBJECTID = &quot;1.3.6.1.5.5.7.8.5&quot;;
    /** ObjectID for srvName, rfc4985 */
    public static final String SRVNAME_OBJECTID =  &quot;1.3.6.1.5.5.7.8.7&quot;;
    public static final String PERMANENTIDENTIFIER = &quot;permanentIdentifier&quot;;
    public static final String PERMANENTIDENTIFIER_OBJECTID = &quot;1.3.6.1.5.5.7.8.3&quot;;
    public static final String PERMANENTIDENTIFIER_SEP = &quot;/&quot;;
    public static final String FASCN_OBJECTID =  &quot;2.16.840.1.101.3.6.6&quot;;

    /** Microsoft altName for windows domain controller guid */
    public static final String GUID = &quot;guid&quot;;
    /** ObjectID for upn altName for windows domain controller guid */
    public static final String GUID_OBJECTID = &quot;1.3.6.1.4.1.311.25.1&quot;;
    /** ObjectID for Microsoft Encrypted File System Certificates extended key usage */
    public static final String EFS_OBJECTID = &quot;1.3.6.1.4.1.311.10.3.4&quot;;
    /** ObjectID for Microsoft Encrypted File System Recovery Certificates extended key usage */
    public static final String EFSR_OBJECTID = &quot;1.3.6.1.4.1.311.10.3.4.1&quot;;
    /** ObjectID for Microsoft Signer of documents extended key usage */
    public static final String MS_DOCUMENT_SIGNING_OBJECTID = &quot;1.3.6.1.4.1.311.10.3.12&quot;;
    /** Object id id-pkix */
    public static final String id_pkix = &quot;1.3.6.1.5.5.7&quot;;
    /** Object id id-kp */
    public static final String id_kp = id_pkix + &quot;.3&quot;;
    /** Object id id-pda */
    public static final String id_pda = id_pkix + &quot;.9&quot;;
    /**
     * Object id id-pda-dateOfBirth DateOfBirth ::= GeneralizedTime
     */
    public static final String id_pda_dateOfBirth = id_pda + &quot;.1&quot;;
    /**
     * Object id id-pda-placeOfBirth PlaceOfBirth ::= DirectoryString
     */
    public static final String id_pda_placeOfBirth = id_pda + &quot;.2&quot;;
    /**
     * Object id id-pda-gender Gender ::= PrintableString (SIZE(1)) -- &quot;M&quot;, &quot;F&quot;, &quot;m&quot; or &quot;f&quot;
     */
    public static final String id_pda_gender = id_pda + &quot;.3&quot;;
    /**
     * Object id id-pda-countryOfCitizenship CountryOfCitizenship ::= PrintableString (SIZE (2)) -- ISO 3166 Country Code
     */
    public static final String id_pda_countryOfCitizenship = id_pda + &quot;.4&quot;;
    /**
     * Object id id-pda-countryOfResidence CountryOfResidence ::= PrintableString (SIZE (2)) -- ISO 3166 Country Code
     */
    public static final String id_pda_countryOfResidence = id_pda + &quot;.5&quot;;
    /** OID used for creating MS Templates certificate extension */
    public static final String OID_MSTEMPLATE = &quot;1.3.6.1.4.1.311.20.2&quot;;
    /** extended key usage OID Intel AMT (out of band) network management */
    public static final String Intel_amt = &quot;2.16.840.1.113741.1.2.3&quot;;
    
    /** Object ID for CT (Certificate Transparency) specific extensions */
    public static final String id_ct_redacted_domains = &quot;1.3.6.1.4.1.11129.2.4.6&quot;;
    
<span class="fc" id="L261">    private static final String[] EMAILIDS = { EMAIL, EMAIL1, EMAIL2, EMAIL3 };</span>
    
<span class="fc" id="L263">    private static final Pattern UNESCAPE_FIELD_REGEX = Pattern.compile(&quot;\\\\([,+\&quot;\\\\&lt;&gt;; ])&quot;);</span>

    public static final String BEGIN_CERTIFICATE_REQUEST = &quot;-----BEGIN CERTIFICATE REQUEST-----&quot;;
    public static final String END_CERTIFICATE_REQUEST = &quot;-----END CERTIFICATE REQUEST-----&quot;;
    public static final String BEGIN_KEYTOOL_CERTIFICATE_REQUEST = &quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;;
    public static final String END_KEYTOOL_CERTIFICATE_REQUEST = &quot;-----END NEW CERTIFICATE REQUEST-----&quot;;
    public static final String BEGIN_CERTIFICATE = &quot;-----BEGIN CERTIFICATE-----&quot;;
    public static final String END_CERTIFICATE = &quot;-----END CERTIFICATE-----&quot;;
    public static final  String BEGIN_CERTIFICATE_WITH_NL = &quot;-----BEGIN CERTIFICATE-----\n&quot;;
    public static final  String END_CERTIFICATE_WITH_NL    = &quot;\n-----END CERTIFICATE-----\n&quot;;
    public static final String BEGIN_PUBLIC_KEY = &quot;-----BEGIN PUBLIC KEY-----&quot;;
    public static final String END_PUBLIC_KEY = &quot;-----END PUBLIC KEY-----&quot;;
    public static final String BEGIN_PRIVATE_KEY = &quot;-----BEGIN PRIVATE KEY-----&quot;;
    public static final String END_PRIVATE_KEY = &quot;-----END PRIVATE KEY-----&quot;;
    public static final String BEGIN_X509_CRL_KEY = &quot;-----BEGIN X509 CRL-----&quot;;
    public static final String END_X509_CRL_KEY = &quot;-----END X509 CRL-----&quot;;
    public static final  String BEGIN_PKCS7  = &quot;-----BEGIN PKCS7-----&quot;;
    public static final  String END_PKCS7     = &quot;-----END PKCS7-----&quot;;

    /**
     * See stringToBcX500Name(String, X500NameStyle, boolean), this method uses the default name style (CeSecoreNameStyle) and ldap
     * order
     * 
     * @see #stringToBcX500Name(String, X500NameStyle, boolean)
     * @param dn String containing DN that will be transformed into X500Name, The DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in
     *            the string will be added to the end positions of OID array.
     * 
     * @return X500Name, which can be empty if dn does not contain any real DN components, or null if input is null
     */
    public static X500Name stringToBcX500Name(final String dn) {
<span class="fc" id="L293">        final X500NameStyle nameStyle = CeSecoreNameStyle.INSTANCE;</span>
<span class="fc" id="L294">        return stringToBcX500Name(dn, nameStyle, true);</span>
    }

    /**
     * See stringToBcX500Name(String, X500NameStyle, boolean), this method uses the default name style (CeSecoreNameStyle) and ldap
     * order
     * 
     * @see #stringToBcX500Name(String, X500NameStyle, boolean)
     * @param dn String containing DN that will be transformed into X500Name, The DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in
     *            the string will be added to the end positions of OID array.
     * @param ldapOrder true if X500Name should be in Ldap Order
     * @return X500Name, which can be empty if dn does not contain any real DN components, or null if input is null
     */
    public static X500Name stringToBcX500Name(final String dn, boolean ldapOrder) {
<span class="fc" id="L308">        final X500NameStyle nameStyle = CeSecoreNameStyle.INSTANCE;</span>
<span class="fc" id="L309">        return stringToBcX500Name(dn, nameStyle, ldapOrder);</span>
    }

    /**
     * Creates a (Bouncycastle) X500Name object from a string with a DN. Known OID (with order) are:
     * &lt;code&gt; EmailAddress, UID, CN, SN (SerialNumber), GivenName, Initials, SurName, T, OU,
     * O, L, ST, DC, C &lt;/code&gt; To change order edit 'dnObjects' in this source file. Important NOT to mess with the ordering within this class, since
     * cert vierification on some clients (IE :-() might depend on order.
     * 
     * @param dn String containing DN that will be transformed into X500Name, The DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in
     *            the string will be added to the end positions of OID array.
     * @param nameStyle Controls how the name is encoded. Usually it should be a CeSecoreNameStyle.
     * @param ldaporder true if LDAP ordering of DN should be used (default in EJBCA), false for X.500 order, ldap order is CN=A,OU=B,O=C,C=SE, x.500
     *            order is the reverse
     * @return X500Name, which can be empty if dn does not contain any real DN components, or null if input is null
     * @throws IllegalArgumentException if DN is not valid
     */
    public static X500Name stringToBcX500Name(String dn, final X500NameStyle nameStyle, final boolean ldaporder) {
<span class="fc" id="L327">        return stringToBcX500Name(dn, nameStyle, ldaporder, null);</span>
    }
    /** Same as @see {@link CertTools#stringToBcX500Name(String, X500NameStyle, boolean)} but with the possibility of 
     * specifying a custom order. 
     * ONLY to be used when creating names that are transient, never for storing in the database.
     * 
     * @param dn String containing DN that will be transformed into X500Name, The DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in
     *            the string will be added to the end positions of OID array.
     * @param nameStyle Controls how the name is encoded. Usually it should be a CeSecoreNameStyle.
     * @param ldaporder true if LDAP ordering of DN should be used (default in EJBCA), false for X.500 order, ldap order is CN=A,OU=B,O=C,C=SE, x.500
     *            order is the reverse
     * @param order specified order, which overrides 'ldaporder', care must be taken constructing this String array, ignored if null or empty
     * @return X500Name, which can be empty if dn does not contain any real DN components, or null if input is null
     */
    public static X500Name stringToBcX500Name(String dn, final X500NameStyle nameStyle, final boolean ldaporder, final String[] order) {
<span class="fc" id="L342">        return stringToBcX500Name(dn, nameStyle, ldaporder, order, true);</span>
    }
    
    public static X500Name stringToBcX500Name(String dn, final X500NameStyle nameStyle, final boolean ldaporder, final String[] order, final boolean applyLdapToCustomOrder) {
<span class="fc" id="L346">        final X500Name x500Name = stringToUnorderedX500Name(dn, nameStyle);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (x500Name==null) {</span>
<span class="fc" id="L348">            return null;</span>
        }
        // -- Reorder fields
<span class="fc" id="L351">        final X500Name orderedX500Name = getOrderedX500Name(x500Name, ldaporder, order, applyLdapToCustomOrder, nameStyle);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L353">            log.trace(&quot;&gt;stringToBcX500Name: x500Name=&quot; + x500Name.toString() + &quot; orderedX500Name=&quot; + orderedX500Name.toString());</span>
        }
<span class="fc" id="L355">        return orderedX500Name;</span>
    }

    public static X500Name stringToUnorderedX500Name(String dn, final X500NameStyle nameStyle) {
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L360">            log.trace(&quot;&gt;stringToUnorderedX500Name: &quot; + dn);</span>
        }
<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (dn == null) {</span>
<span class="fc" id="L363">            return null;</span>
        }
        // If the entire DN is quoted (which is strange but legacy), we just remove these quotes and carry on
<span class="pc bpc" id="L366" title="3 of 6 branches missed.">        if (dn.length() &gt; 2 &amp;&amp; dn.charAt(0) == '&quot;' &amp;&amp; dn.charAt(dn.length() - 1) == '&quot;') {</span>
<span class="nc" id="L367">            dn = dn.substring(1, dn.length() - 1);</span>
        }
<span class="fc" id="L369">        final X500NameBuilder nameBuilder = new X500NameBuilder(nameStyle);</span>
<span class="fc" id="L370">        boolean quoted = false;</span>
<span class="fc" id="L371">        boolean escapeNext = false;</span>
<span class="fc" id="L372">        int currentStartPosition = -1;</span>
<span class="fc" id="L373">        String currentPartName = null;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        for (int i = 0; i &lt; dn.length(); i++) {</span>
<span class="fc" id="L375">            final char current = dn.charAt(i);</span>
            // Toggle quoting for every non-escaped &quot;-char
<span class="fc bfc" id="L377" title="All 4 branches covered.">            if (!escapeNext &amp;&amp; current == '&quot;') {</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                quoted = !quoted;</span>
            }
            // If there is an unescaped and unquoted =-char the proceeding chars is a part name
<span class="pc bpc" id="L381" title="3 of 10 branches missed.">            if (currentStartPosition == -1 &amp;&amp; !quoted &amp;&amp; !escapeNext &amp;&amp; current == '=' &amp;&amp; 1 &lt;= i) {</span>
                // Trim spaces (e.g. &quot;O =value&quot;)
<span class="fc" id="L383">                int endIndexOfPartName = i;</span>
<span class="pc bpc" id="L384" title="1 of 4 branches missed.">                while (endIndexOfPartName &gt; 0 &amp;&amp; dn.charAt(endIndexOfPartName - 1) == ' ') {</span>
<span class="fc" id="L385">                    endIndexOfPartName--;</span>
                }
<span class="fc" id="L387">                int startIndexOfPartName = endIndexOfPartName - 1;</span>
<span class="fc" id="L388">                final String endOfPartNameSearchChars = &quot;, +&quot;;</span>
<span class="fc bfc" id="L389" title="All 4 branches covered.">                while (startIndexOfPartName &gt; 0 &amp;&amp; (endOfPartNameSearchChars.indexOf(dn.charAt(startIndexOfPartName - 1)) == -1)) {</span>
<span class="fc" id="L390">                    startIndexOfPartName--;</span>
                }
<span class="fc" id="L392">                currentPartName = dn.substring(startIndexOfPartName, endIndexOfPartName);</span>
<span class="fc" id="L393">                currentStartPosition = i + 1;</span>
            }
            // When we have found a start marker, we need to be on the lookout for the ending marker
<span class="pc bpc" id="L396" title="1 of 12 branches missed.">            if (currentStartPosition != -1 &amp;&amp; ((!quoted &amp;&amp; !escapeNext &amp;&amp; (current == ',' || current == '+')) || i == dn.length() - 1)) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                int endPosition = (i == dn.length() - 1) ? dn.length() - 1 : i - 1;</span>
                // Remove white spaces from the end of the value
<span class="fc bfc" id="L399" title="All 4 branches covered.">                while (endPosition &gt; currentStartPosition &amp;&amp; dn.charAt(endPosition) == ' ') {</span>
<span class="fc" id="L400">                    endPosition--;</span>
                }
                // Remove white spaces from the beginning of the value
<span class="fc bfc" id="L403" title="All 4 branches covered.">                while (endPosition &gt; currentStartPosition &amp;&amp; dn.charAt(currentStartPosition) == ' ') {</span>
<span class="fc" id="L404">                    currentStartPosition++;</span>
                }
                // Only return the inner value if the part is quoted
<span class="pc bpc" id="L407" title="1 of 6 branches missed.">                if (currentStartPosition &lt; dn.length() &amp;&amp; dn.charAt(currentStartPosition) == '&quot;' &amp;&amp; dn.charAt(endPosition) == '&quot;') {</span>
<span class="fc" id="L408">                    currentStartPosition++;</span>
<span class="fc" id="L409">                    endPosition--;</span>
                }
<span class="fc" id="L411">                String currentValue = dn.substring(currentStartPosition, endPosition + 1);</span>
                // Unescape value (except escaped #) since the nameBuilder will double each escape
<span class="fc" id="L413">                currentValue = unescapeValue(new StringBuilder(currentValue)).toString();</span>
                try {
                    // -- First search the OID by name in declared OID's
<span class="fc" id="L416">                    ASN1ObjectIdentifier oid = DnComponents.getOid(currentPartName);</span>
                    // -- If isn't declared, we try to create it
<span class="fc bfc" id="L418" title="All 2 branches covered.">                    if (oid == null) {</span>
<span class="fc" id="L419">                        oid = new ASN1ObjectIdentifier(currentPartName);</span>
                    }
<span class="fc" id="L421">                    nameBuilder.addRDN(oid, currentValue);</span>
<span class="fc" id="L422">                } catch (IllegalArgumentException e) {</span>
                    // If it is not an OID we will ignore it
<span class="fc" id="L424">                    log.warn(&quot;Unknown DN component ignored and silently dropped: &quot; + currentPartName);</span>
<span class="fc" id="L425">                }</span>
                // Reset markers
<span class="fc" id="L427">                currentStartPosition = -1;</span>
<span class="fc" id="L428">                currentPartName = null;</span>
            }
<span class="fc bfc" id="L430" title="All 2 branches covered.">            if (escapeNext) {</span>
                // This character was escaped, so don't escape the next one
<span class="fc" id="L432">                escapeNext = false;</span>
            } else {
<span class="fc bfc" id="L434" title="All 4 branches covered.">                if (!quoted &amp;&amp; current == '\\') {</span>
                    // This escape character is not escaped itself, so the next one should be
<span class="fc" id="L436">                    escapeNext = true;</span>
                }
            }
        }
<span class="fc" id="L440">        final X500Name x500Name = nameBuilder.build();</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L442">            log.trace(&quot;&lt;stringToUnorderedX500Name: x500Name=&quot; + x500Name.toString());</span>
        }
<span class="fc" id="L444">        return x500Name;</span>
    }

    /** Removes any unescaped '\' character from the provided StringBuilder. Assumes that escaping quotes have been stripped. 
     * Special treatment of the # sign, which if not escaped will be treated as hex encoded DER value by BC. 
     * @param sb unescaped StringBuilder
     * @return escaped StringBuilder*/
    private static StringBuilder unescapeValue(final StringBuilder sb) {
<span class="fc" id="L452">        boolean esq = false;</span>
<span class="fc" id="L453">        int index = 0;</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        while (index &lt; (sb.length()-1)) {</span>
<span class="fc bfc" id="L455" title="All 6 branches covered.">            if (!esq &amp;&amp; sb.charAt(index) == '\\' &amp;&amp; sb.charAt(index+1) != '#') {</span>
<span class="fc" id="L456">                esq = true;</span>
<span class="fc" id="L457">                sb.deleteCharAt(index);</span>
            } else {
<span class="fc" id="L459">                esq = false;</span>
<span class="fc" id="L460">                index++;</span>
            }
        }
<span class="fc" id="L463">        return sb;</span>
    }

    // Remove extra '+' character escaping
    public static String getUnescapedPlus(final String value) {
<span class="nc" id="L468">        StringBuilder buf = new StringBuilder(value);</span>
<span class="nc" id="L469">        int index = 0;</span>
<span class="nc" id="L470">        int end = buf.length();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        while (index &lt; end) {</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">            if (buf.charAt(index) == '\\' &amp;&amp; index + 1 != end) {</span>
<span class="nc" id="L473">                char c = buf.charAt(index + 1);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">                if (c == '+') {</span>
<span class="nc" id="L475">                    buf.deleteCharAt(index);</span>
<span class="nc" id="L476">                    end--;</span>
                }
            }
<span class="nc" id="L479">            index++;</span>
        }
<span class="nc" id="L481">        return buf.toString();</span>
    }

    /**
     * Check if the String contains any unescaped '+'. RFC 2253, section 2.2 states that '+' is used for multi-valued RelativeDistinguishedName.
     * BC (version 1.45) did not support multi-valued RelativeDistinguishedName, and automatically escaped them instead.
     * Even though it is now (BC 1.49b15) supported, we want to keep ecaping '+' chars and warn that this might not be supported in the future.
     * @param dn DN
     * @return escaped DN
     */
    public static String handleUnescapedPlus(final String dn) {
<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (dn == null) {</span>
<span class="fc" id="L493">            return dn;</span>
        }
<span class="fc" id="L495">        final StringBuilder buf = new StringBuilder(dn);</span>
<span class="fc" id="L496">        int index = 0;</span>
<span class="fc" id="L497">        final int end = buf.length();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        while (index &lt; end) {</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">            if (buf.charAt(index) == '+') {</span>
                // Found an unescaped '+' character.
<span class="fc" id="L501">                log.warn(&quot;DN \&quot;&quot; + dn + &quot;\&quot; contains an unescaped '+'-character that will be automatically escaped. RFC 2253 reservs this &quot;</span>
                        + &quot;for multi-valued RelativeDistinguishedNames. Encourage clients to use '\\+' instead, since future behaviour might change.&quot;);
<span class="fc" id="L503">                buf.insert(index, '\\');</span>
<span class="fc" id="L504">                index++;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            } else if (buf.charAt(index) == '\\') {</span>
                // Found an escape character.
<span class="fc" id="L507">                index++;</span>
            }
<span class="fc" id="L509">            index++;</span>
        }
<span class="fc" id="L511">        return buf.toString();</span>
    }

    /**
     * Every DN-string should look the same. Creates a name string ordered and looking like we want it...
     * 
     * @param dn String containing DN
     * 
     * @return String containing DN, or empty string if dn does not contain any real DN components, or null if input is null
     */
    public static String stringToBCDNString(String dn) {
        // BC now seem to handle multi-valued RDNs, but we keep escaping this for now to keep the behavior until support is required
<span class="fc" id="L523">        dn = handleUnescapedPlus(dn); // Log warning if dn contains unescaped '+'</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (isDNReversed(dn)) {</span>
<span class="fc" id="L525">            dn = reverseDN(dn);</span>
        }
<span class="fc" id="L527">        String ret = null;</span>
<span class="fc" id="L528">        final X500Name name = stringToBcX500Name(dn);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (name != null) {</span>
<span class="fc" id="L530">            ret = name.toString();</span>
        }
        /*
         * For some databases (MySQL for instance) the database column holding subjectDN is only 250 chars long. There have been strange error
         * reported (clipping DN naturally) that is hard to debug if DN is more than 250 chars and we don't have a good message
         */
<span class="pc bpc" id="L536" title="1 of 4 branches missed.">        if ((ret != null) &amp;&amp; (ret.length() &gt; 250)) {</span>
<span class="nc" id="L537">            log.info(&quot;Warning! DN is more than 250 characters long. Some databases have only 250 characters in the database for SubjectDN. Clipping may occur! DN (&quot;</span>
<span class="nc" id="L538">                    + ret.length() + &quot; chars): &quot; + ret);</span>
        }
<span class="fc" id="L540">        return ret;</span>
    }

    /**
     * Convenience method for getting an email addresses from a DN. Uses {@link #getPartsFromDN(String,String)} internally, and searches for
     * {@link #EMAIL}, {@link #EMAIL1}, {@link #EMAIL2}, {@link #EMAIL3} and returns the first one found.
     * 
     * @param dn the DN
     * 
     * @return ArrayList containing email or empty list if email is not present
     */
    public static ArrayList&lt;String&gt; getEmailFromDN(String dn) {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L553">            log.trace(&quot;&gt;getEmailFromDN(&quot; + dn + &quot;)&quot;);</span>
        }
<span class="fc" id="L555">        ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">        for (int i = 0; i &lt; EMAILIDS.length; i++) {</span>
<span class="fc" id="L557">            List&lt;String&gt; emails = getPartsFromDN(dn, EMAILIDS[i]);</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (!emails.isEmpty()) {</span>
<span class="fc" id="L559">                ret.addAll(emails);</span>
            }

        }
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L564">            log.trace(&quot;&lt;getEmailFromDN(&quot; + dn + &quot;): &quot; + ret.size());</span>
        }
<span class="fc" id="L566">        return ret;</span>
    }

    /**
     * Search for e-mail address, first in SubjectAltName (as in PKIX recommendation) then in subject DN. Original author: Marco Ferrante, (c) 2005
     * CSITA - University of Genoa (Italy)
     * 
     * @param certificate certificate
     * @return subject email or null if not present in certificate
     */
    public static String getEMailAddress(Certificate certificate) {
<span class="fc" id="L577">        log.debug(&quot;Searching for EMail Address in SubjectAltName&quot;);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        if (certificate == null) {</span>
<span class="fc" id="L579">            return null;</span>
        }
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">        if (certificate instanceof X509Certificate) {</span>
<span class="fc" id="L582">            X509Certificate x509cert = (X509Certificate) certificate;</span>
            try {
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                if (x509cert.getSubjectAlternativeNames() != null) {</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">                    for (List&lt;?&gt; item : x509cert.getSubjectAlternativeNames()) {</span>
<span class="fc" id="L586">                        Integer type = (Integer) item.get(0);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                        if (type.intValue() == 1) {</span>
<span class="fc" id="L588">                            return (String) item.get(1);</span>
                        }
<span class="fc" id="L590">                    }</span>
                }
<span class="nc" id="L592">            } catch (CertificateParsingException e) {</span>
<span class="nc" id="L593">                log.error(&quot;Error parsing certificate: &quot;, e);</span>
<span class="fc" id="L594">            }</span>
<span class="fc" id="L595">            log.debug(&quot;Searching for EMail Address in Subject DN&quot;);</span>
<span class="fc" id="L596">            ArrayList&lt;String&gt; emails = CertTools.getEmailFromDN(x509cert.getSubjectDN().getName());</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">            if (!emails.isEmpty()) {</span>
<span class="nc" id="L598">                return emails.get(0);</span>
            }
        }
<span class="fc" id="L601">        return null;</span>
    }

    /**
     * Takes a DN and reverses it completely so the first attribute ends up last. C=SE,O=Foo,CN=Bar becomes CN=Bar,O=Foo,C=SE.
     * 
     * @param dn String containing DN to be reversed, The DN string has the format &quot;C=SE, O=xx, OU=yy, CN=zz&quot;.
     * 
     * @return String containing reversed DN
     */
    public static String reverseDN(String dn) {
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L613">            log.trace(&quot;&gt;reverseDN: dn: &quot; + dn);</span>
        }
<span class="fc" id="L615">        String ret = null;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (dn != null) {</span>
            String o;
<span class="fc" id="L618">            final BasicX509NameTokenizer xt = new BasicX509NameTokenizer(dn);</span>
<span class="fc" id="L619">            StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L620">            boolean first = true;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            while (xt.hasMoreTokens()) {</span>
<span class="fc" id="L622">                o = xt.nextToken();</span>
                // log.debug(&quot;token: &quot;+o);
<span class="fc bfc" id="L624" title="All 2 branches covered.">                if (!first) {</span>
<span class="fc" id="L625">                    buf.insert(0, &quot;,&quot;);</span>
                } else {
<span class="fc" id="L627">                    first = false;</span>
                }
<span class="fc" id="L629">                buf.insert(0, o);</span>
            }
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            if (buf.length() &gt; 0) {</span>
<span class="fc" id="L632">                ret = buf.toString();</span>
            }
        }
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L636">            log.trace(&quot;&lt;reverseDN: resulting dn: &quot; + ret);</span>
        }
<span class="fc" id="L638">        return ret;</span>
    }

    /**
     * Tries to determine if a DN is in reversed form. It does this by taking the last attribute and the first attribute. If the last attribute comes
     * before the first in the dNObjects array the DN is assumed to be in reversed order.
     * 
     * The default ordering is: &quot;CN=Tomas, O=PrimeKey, C=SE&quot; (dNObjectsForward ordering in EJBCA) a dn or form &quot;C=SE, O=PrimeKey, CN=Tomas&quot; is
     * reversed.
     * 
     * If the string has only one component (e.g. &quot;CN=example.com&quot;) then this method returns false.
     * If the string does not contain any real DN components, it returns false. 
     * 
     * @param dn String containing DN to be checked, The DN string has the format &quot;C=SE, O=xx, OU=yy, CN=zz&quot;.
     * @return true if the DN is believed to be in reversed order, false otherwise
     */
    public static boolean isDNReversed(String dn) {
        /*
         * if (log.isTraceEnabled()) { log.trace(&quot;&gt;isDNReversed: dn: &quot; + dn); }
         */
<span class="fc" id="L658">        boolean ret = false;</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">        if (dn != null) {</span>
<span class="fc" id="L660">            String first = null;</span>
<span class="fc" id="L661">            String last = null;</span>
<span class="fc" id="L662">            X509NameTokenizer xt = new X509NameTokenizer(dn);</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">            if (xt.hasMoreTokens()) {</span>
<span class="fc" id="L664">                first = xt.nextToken().trim();</span>
            }
<span class="fc bfc" id="L666" title="All 2 branches covered.">            while (xt.hasMoreTokens()) {</span>
<span class="fc" id="L667">                last = xt.nextToken().trim();</span>
            }
<span class="fc" id="L669">            String[] dNObjects = DnComponents.getDnObjects(true);</span>
<span class="pc bpc" id="L670" title="1 of 4 branches missed.">            if ((first != null) &amp;&amp; (last != null)) {</span>
                // Be careful for bad input, that may not have any = sign in it
<span class="fc" id="L672">                final int fi = first.indexOf('=');</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">                first = first.substring(0, (fi != -1 ? fi : (first.length()-1)));</span>
<span class="fc" id="L674">                final int li = last.indexOf('=');</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">                last = last.substring(0, (li != -1 ? li : (last.length()-1)));</span>
<span class="fc" id="L676">                int firsti = 0, lasti = 0;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">                for (int i = 0; i &lt; dNObjects.length; i++) {</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">                    if (first.equalsIgnoreCase(dNObjects[i])) {</span>
<span class="fc" id="L679">                        firsti = i;</span>
                    }
<span class="fc bfc" id="L681" title="All 2 branches covered.">                    if (last.equalsIgnoreCase(dNObjects[i])) {</span>
<span class="fc" id="L682">                        lasti = i;</span>
                    }
                }
<span class="fc bfc" id="L685" title="All 2 branches covered.">                if (lasti &lt; firsti) {</span>
<span class="fc" id="L686">                    ret = true;</span>
                }

            }
        }
        /*
         * if (log.isTraceEnabled()) { log.trace(&quot;&lt;isDNReversed: &quot; + ret); }
         */
<span class="fc" id="L694">        return ret;</span>
    } // isDNReversed
    
    /**
     * Checks if a DN has at least two components. Then the DN can be in either LDAP or X500 order.
     * Otherwise it's not possible to determine the order.
     * @param dn DN
     * @return boolean
     */
    public static boolean dnHasMultipleComponents(String dn) {
<span class="fc" id="L704">        final X509NameTokenizer xt = new X509NameTokenizer(dn);</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (xt.hasMoreTokens()) {</span>
<span class="fc" id="L706">            xt.nextToken();</span>
<span class="fc" id="L707">            return xt.hasMoreTokens();</span>
        }
<span class="nc" id="L709">        return false;</span>
    }

    /**
     * Gets a specified part of a DN. Specifically the first occurrence it the DN contains several instances of a part (i.e. cn=x, cn=y returns x).
     * 
     * @param dn String containing DN, The DN string has the format &quot;C=SE, O=xx, OU=yy, CN=zz&quot;.
     * @param dnpart String specifying which part of the DN to get, should be &quot;CN&quot; or &quot;OU&quot; etc.
     * 
     * @return String containing dnpart or null if dnpart is not present
     */
    public static String getPartFromDN(String dn, String dnpart) {
<span class="fc" id="L721">        String part = null;</span>
<span class="fc" id="L722">        final List&lt;String&gt; dnParts = getPartsFromDNInternal(dn, dnpart, true);</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        if (!dnParts.isEmpty()) {</span>
<span class="fc" id="L724">            part = dnParts.get(0);</span>
        }
<span class="fc" id="L726">        return part;</span>
    }

    /**
     * Gets a specified parts of a DN. Returns all occurrences as an ArrayList, also works if DN contains several
     * instances of a part (i.e. cn=x, cn=y returns {x, y, null}).
     * 
     * @param dn String containing DN, The DN string has the format &quot;C=SE, O=xx, OU=yy, CN=zz&quot;.
     * @param dnpart String specifying which part of the DN to get, should be &quot;CN&quot; or &quot;OU&quot; etc.
     * 
     * @return ArrayList containing dnparts or empty list if dnpart is not present
     */
    public static List&lt;String&gt; getPartsFromDN(String dn, String dnpart) {
<span class="fc" id="L739">        return getPartsFromDNInternal(dn, dnpart, false);</span>
    }

    public static List&lt;String&gt; getPartsFromDNInternal(final String dn, final String dnPart, final boolean onlyReturnFirstMatch) {
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L744">            log.trace(&quot;&gt;getPartsFromDNInternal: dn:'&quot; + dn + &quot;', dnpart=&quot; + dnPart + &quot;, onlyReturnFirstMatch=&quot; + onlyReturnFirstMatch);</span>
        }
<span class="fc" id="L746">        final List&lt;String&gt; parts = new ArrayList&lt;String&gt;();</span>
<span class="pc bpc" id="L747" title="1 of 4 branches missed.">        if (dn != null &amp;&amp; dnPart != null) {</span>
<span class="fc" id="L748">            final String dnPartLowerCase = dnPart.toLowerCase();</span>
<span class="fc" id="L749">            final int dnPartLenght = dnPart.length();</span>
<span class="fc" id="L750">            boolean quoted = false;</span>
<span class="fc" id="L751">            boolean escapeNext = false;</span>
<span class="fc" id="L752">            int currentStartPosition = -1;</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">            for (int i = 0; i &lt; dn.length(); i++) {</span>
<span class="fc" id="L754">                final char current = dn.charAt(i);</span>
                // Toggle quoting for every non-escaped &quot;-char
<span class="fc bfc" id="L756" title="All 4 branches covered.">                if (!escapeNext &amp;&amp; current == '&quot;') {</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                    quoted = !quoted;</span>
                }
                // If there is an unescaped and unquoted =-char we need to investigate if it is a match for the sought after part
<span class="fc bfc" id="L760" title="All 8 branches covered.">                if (!quoted &amp;&amp; !escapeNext &amp;&amp; current == '=' &amp;&amp; dnPartLenght &lt;= i) {</span>
                    // Check that the character before our expected partName isn't a letter (e.g. dnsName=.. should not match E=..)
<span class="fc bfc" id="L762" title="All 4 branches covered.">                    if (i - dnPartLenght - 1 &lt; 0 || !Character.isLetter(dn.charAt(i - dnPartLenght - 1))) {</span>
<span class="fc" id="L763">                        boolean match = true;</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">                        for (int j = 0; j &lt; dnPartLenght; j++) {</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">                            if (Character.toLowerCase(dn.charAt(i - dnPartLenght + j)) != dnPartLowerCase.charAt(j)) {</span>
<span class="fc" id="L766">                                match = false;</span>
<span class="fc" id="L767">                                break;</span>
                            }
                        }
<span class="fc bfc" id="L770" title="All 2 branches covered.">                        if (match) {</span>
<span class="fc" id="L771">                            currentStartPosition = i + 1;</span>
                        }
                    }
                }
                // When we have found a start marker, we need to be on the lookout for the ending marker
<span class="pc bpc" id="L776" title="1 of 12 branches missed.">                if (currentStartPosition != -1 &amp;&amp; ((!quoted &amp;&amp; !escapeNext &amp;&amp; (current == ',' || current == '+')) || i == dn.length() - 1)) {</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">                    int endPosition = (i == dn.length() - 1) ? dn.length() - 1 : i - 1;</span>
                    // Remove white spaces from the end of the value
<span class="pc bpc" id="L779" title="1 of 4 branches missed.">                    while (endPosition &gt; currentStartPosition &amp;&amp; dn.charAt(endPosition) == ' ') {</span>
<span class="nc" id="L780">                        endPosition--;</span>
                    }
                    // Remove white spaces from the beginning of the value
<span class="pc bpc" id="L783" title="1 of 4 branches missed.">                    while (endPosition &gt; currentStartPosition &amp;&amp; dn.charAt(currentStartPosition) == ' ') {</span>
<span class="nc" id="L784">                        currentStartPosition++;</span>
                    }
                    // Only return the inner value if the part is quoted
<span class="pc bpc" id="L787" title="1 of 6 branches missed.">                    if (currentStartPosition != dn.length() &amp;&amp; dn.charAt(currentStartPosition) == '&quot;' &amp;&amp; dn.charAt(endPosition) == '&quot;') {</span>
<span class="fc" id="L788">                        currentStartPosition++;</span>
<span class="fc" id="L789">                        endPosition--;</span>
                    }
<span class="fc" id="L791">                    parts.add(unescapeFieldValue(dn.substring(currentStartPosition, endPosition + 1)));</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">                    if (onlyReturnFirstMatch) {</span>
<span class="fc" id="L793">                        break;</span>
                    }
<span class="fc" id="L795">                    currentStartPosition = -1;</span>
                }
<span class="fc bfc" id="L797" title="All 2 branches covered.">                if (escapeNext) {</span>
                    // This character was escaped, so don't escape the next one
<span class="fc" id="L799">                    escapeNext = false;</span>
                } else {
<span class="fc bfc" id="L801" title="All 4 branches covered.">                    if (!quoted &amp;&amp; current == '\\') {</span>
                        // This escape character is not escaped itself, so the next one should be
<span class="fc" id="L803">                        escapeNext = true;</span>
                    }
                }
            }
        }
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L809">            log.trace(&quot;&lt;getPartsFromDNInternal: resulting DN part=&quot; + parts.toString());</span>
        }
<span class="fc" id="L811">        return parts;</span>
    }

    /**
     * Gets a list of all custom OIDs defined in the string. A custom OID is defined as an OID, simply as that. Otherwise, if it is not a custom oid,
     * the DNpart is defined by a name such as CN och rfc822Name. This method only returns a oid once, so if the input string has multiple of the same
     * oid, only one value is returned.
     * 
     * @param dn String containing DN, The DN string has the format &quot;C=SE, O=xx, OU=yy, CN=zz&quot;, or &quot;rfc822Name=foo@bar.com&quot;, etc.
     * @return ArrayList containing unique oids or empty list if no custom OIDs are present
     */
    public static ArrayList&lt;String&gt; getCustomOids(String dn) {
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L824">            log.trace(&quot;&gt;getCustomOids: dn:'&quot; + dn);</span>
        }
<span class="fc" id="L826">        ArrayList&lt;String&gt; parts = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">        if (dn != null) {</span>
            String o;
<span class="fc" id="L829">            X509NameTokenizer xt = new X509NameTokenizer(dn);</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">            while (xt.hasMoreTokens()) {</span>
<span class="fc" id="L831">                o = xt.nextToken().trim();</span>
                // Try to see if it is a valid OID
                try {
<span class="fc" id="L834">                    int i = o.indexOf('=');</span>
                    // An oid is never shorter than 3 chars and must start with 1.
<span class="fc bfc" id="L836" title="All 4 branches covered.">                    if ((i &gt; 2) &amp;&amp; (o.charAt(1) == '.')) {</span>
<span class="fc" id="L837">                        String oid = o.substring(0, i);</span>
                        // If we have multiple of the same custom oid, don't claim that we have more
                        // This method will only return &quot;unique&quot; custom oids.
<span class="fc bfc" id="L840" title="All 2 branches covered.">                        if (!parts.contains(oid)) {</span>
                            // Check if it is a real oid, if it is not we will ignore it (IllegalArgumentException will be thrown)
<span class="fc" id="L842">                            new ASN1ObjectIdentifier(oid);</span>
<span class="fc" id="L843">                            parts.add(oid);</span>
                        }
                    }
<span class="nc" id="L846">                } catch (IllegalArgumentException e) {</span>
                    // Not a valid oid
<span class="pc" id="L848">                }</span>
            }
        }
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L852">            log.trace(&quot;&lt;getCustomOids: resulting DN part=&quot; + parts.toString());</span>
        }
<span class="fc" id="L854">        return parts;</span>
    }

    /**
     * Gets subject DN in the format we are sure about (BouncyCastle),supporting UTF8.
     * 
     * @param cert Certificate
     * 
     * @return String containing the subjects DN.
     */
    public static String getSubjectDN(final Certificate cert) {
<span class="fc" id="L865">        return getDN(cert, 1);</span>
    }

    /**
     * @param value String to enescape
     * @return value in unescaped RDN format
     */
    public static String getUnescapedRdnValue(final String value){
<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (StringUtils.isNotEmpty(value)) {</span>
<span class="nc" id="L874">            return org.ietf.ldap.LDAPDN.unescapeRDN(value);</span>
        } else {
<span class="nc" id="L876">            return value;</span>
        }
    }

    /**
     * Gets issuer DN in the format we are sure about (BouncyCastle),supporting UTF8.
     * 
     * @param cert Certificate
     * 
     * @return String containing the issuers DN.
     */
    public static String getIssuerDN(final Certificate cert) {
<span class="fc" id="L888">        return getDN(cert, 2);</span>
    }

    /**
     * Gets subject or issuer DN in the format we are sure about (BouncyCastle),supporting UTF8.
     * 
     * @param cert X509Certificate
     * @param which 1 = subjectDN, anything else = issuerDN
     * 
     * @return String containing the DN.
     */
    private static String getDN(final Certificate cert, final int which) {
<span class="fc" id="L900">        String ret = null;</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L902">            return null;</span>
        }
<span class="fc bfc" id="L904" title="All 2 branches covered.">        if (cert instanceof X509Certificate) {</span>
            // cert.getType=X.509
            try {
<span class="fc" id="L907">                final String clazz = cert.getClass().getName();</span>
                // The purpose of the below generateCertificate is to create a BC certificate object, because there we know how DN components
                // are handled. If we already have a BC certificate however, we can save a lot of time to not have to encode/decode it.
                final X509Certificate x509cert;
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">                if (clazz.contains(&quot;org.bouncycastle&quot;)) {</span>
<span class="fc" id="L912">                    x509cert = (X509Certificate)cert;</span>
                } else {
<span class="nc" id="L914">                    final CertificateFactory cf = CertTools.getCertificateFactory();</span>
<span class="nc" id="L915">                    x509cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(cert.getEncoded()));                    </span>
                }
<span class="fc" id="L917">                String dn = null;</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">                if (which == 1) {</span>
<span class="fc" id="L919">                    dn = x509cert.getSubjectDN().toString();</span>
                } else {
<span class="fc" id="L921">                    dn = x509cert.getIssuerDN().toString();</span>
                }
<span class="fc" id="L923">                ret = stringToBCDNString(dn);</span>
<span class="nc" id="L924">            } catch (CertificateException ce) {</span>
<span class="nc" id="L925">                log.info(&quot;Could not get DN from X509Certificate. &quot; + ce.getMessage());</span>
<span class="nc" id="L926">                log.debug(&quot;&quot;, ce);</span>
<span class="nc" id="L927">                return null;</span>
<span class="fc" id="L928">            }</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">        } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L930">            final CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
            try {
<span class="fc" id="L932">                ReferenceField rf = null;</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">                if (which == 1) {</span>
<span class="fc" id="L934">                    rf = cvccert.getCVCertificate().getCertificateBody().getHolderReference();</span>
                } else {
<span class="fc" id="L936">                    rf = cvccert.getCVCertificate().getCertificateBody().getAuthorityReference();</span>
                }
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">                if (rf != null) {</span>
                    // Construct a &quot;fake&quot; DN which can be used in EJBCA
                    // Use only mnemonic and country, since sequence is more of a serialnumber than a DN part
<span class="fc" id="L941">                    String dn = &quot;&quot;;</span>
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">                    if (rf.getMnemonic() != null) {</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">                        if (StringUtils.isNotEmpty(dn)) {</span>
<span class="nc" id="L944">                            dn += &quot;, &quot;;</span>
                        }
<span class="fc" id="L946">                        dn += &quot;CN=&quot; + rf.getMnemonic();</span>
                    }
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">                    if (rf.getCountry() != null) {</span>
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">                        if (StringUtils.isNotEmpty(dn)) {</span>
<span class="fc" id="L950">                            dn += &quot;, &quot;;</span>
                        }
<span class="fc" id="L952">                        dn += &quot;C=&quot; + rf.getCountry();</span>
                    }
<span class="fc" id="L954">                    ret = stringToBCDNString(dn);</span>
                }
<span class="nc" id="L956">            } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L957">                log.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L958">                return null;</span>
<span class="fc" id="L959">            }</span>
        }
<span class="fc" id="L961">        return ret;</span>
    }

    /**
     * Gets Serial number of the certificate.
     * 
     * @param cert Certificate
     * 
     * @return BigInteger containing the certificate serial number. Can be 0 for CVC certificates with alphanumeric serial numbers if the sequence
     *         does not contain any number characters at all.
     * @throws IllegalArgumentException if null input of certificate type is not handled
     */
    public static BigInteger getSerialNumber(Certificate cert) {
<span class="fc bfc" id="L974" title="All 2 branches covered.">        if (cert == null) {</span>
<span class="fc" id="L975">            throw new IllegalArgumentException(&quot;Null input&quot;);</span>
        }
<span class="fc" id="L977">        BigInteger ret = null;</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L979">            X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L980">            ret = xcert.getSerialNumber();</span>
<span class="pc bpc" id="L981" title="1 of 2 branches missed.">        } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
            // For CVC certificates the sequence field of the HolderReference is kind of a serial number,
            // but if can be alphanumeric which means it can not be made into a BigInteger
<span class="fc" id="L984">            CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
            try {
<span class="fc" id="L986">                String sequence = cvccert.getCVCertificate().getCertificateBody().getHolderReference().getSequence();</span>
<span class="fc" id="L987">                ret = getSerialNumberFromString(sequence);</span>
<span class="nc" id="L988">            } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L989">                log.error(&quot;getSerialNumber: NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L990">                ret = BigInteger.valueOf(0);</span>
<span class="fc" id="L991">            }</span>
<span class="fc" id="L992">        } else {</span>
<span class="nc" id="L993">            throw new IllegalArgumentException(&quot;getSerialNumber: Certificate of type &quot; + cert.getType() + &quot; is not implemented&quot;);</span>
        }
<span class="fc" id="L995">        return ret;</span>
    }

    /**
     * Gets a serial number in numeric form, it takes - either a hex encoded integer with length != 5 (x.509 certificate) - 5 letter numeric string
     * (cvc), will convert the number to an int - 5 letter alfanumeric string vi some numbers in it (cvc), will convert the numbers in it to a numeric
     * string (remove the letters) and convert to int - 5 letter alfanumeric string with only letters (cvc), will convert to integer from string with
     * radix 36
     * 
     * @param sernoString serial
     * @return BigInteger
     */
    public static BigInteger getSerialNumberFromString(String sernoString) {
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        if (sernoString == null) {</span>
<span class="fc" id="L1009">            throw new IllegalArgumentException(&quot;getSerialNumberFromString: cert is null&quot;);</span>
        }
        BigInteger ret;
        try {
<span class="fc bfc" id="L1013" title="All 2 branches covered.">            if (sernoString.length() != 5) {</span>
                // This can not be a CVC certificate sequence, so it must be a hex encoded regular certificate serial number
<span class="fc" id="L1015">                ret = new BigInteger(sernoString, 16);</span>
            } else {
                // We try to handle the different cases of CVC certificate sequences, see StringTools.KEY_SEQUENCE_FORMAT
<span class="fc bfc" id="L1018" title="All 2 branches covered.">                if (NumberUtils.isNumber(sernoString)) {</span>
<span class="fc" id="L1019">                    ret = NumberUtils.createBigInteger(sernoString);</span>
                } else {
                    // check if input is hexadecimal
<span class="fc" id="L1022">                    log.info(&quot;getSerialNumber: Sequence is not a numeric string, trying to extract numerical sequence part.&quot;);</span>
<span class="fc" id="L1023">                    StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">                    for (int i = 0; i &lt; sernoString.length(); i++) {</span>
<span class="fc" id="L1025">                        char c = sernoString.charAt(i);</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">                        if (CharUtils.isAsciiNumeric(c)) {</span>
<span class="fc" id="L1027">                            buf.append(c);</span>
                        }
                    }
<span class="fc bfc" id="L1030" title="All 2 branches covered.">                    if (buf.length() &gt; 0) {</span>
<span class="fc" id="L1031">                        ret = NumberUtils.createBigInteger(buf.toString());</span>
                    } else {
<span class="fc" id="L1033">                        log.info(&quot;getSerialNumber: can not extract numeric sequence part, trying alfanumeric value (radix 36).&quot;);</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">                        if (sernoString.matches(&quot;[0-9A-Z]{1,5}&quot;)) {</span>
<span class="fc" id="L1035">                            int numSeq = Integer.parseInt(sernoString, 36);</span>
<span class="fc" id="L1036">                            ret = BigInteger.valueOf(numSeq);</span>
<span class="fc" id="L1037">                        } else {</span>
<span class="nc" id="L1038">                            log.info(&quot;getSerialNumber: Sequence does not contain any numeric parts, returning 0.&quot;);</span>
<span class="nc" id="L1039">                            ret = BigInteger.valueOf(0);</span>
                        }
                    }
                }
            }
<span class="nc" id="L1044">        } catch (NumberFormatException e) {</span>
            // If we can't make the sequence into a serial number big integer, set it to 0
<span class="nc" id="L1046">            log.debug(&quot;getSerialNumber: NumberFormatException for sequence: &quot; + sernoString);</span>
<span class="nc" id="L1047">            ret = BigInteger.valueOf(0);</span>
<span class="fc" id="L1048">        }</span>
<span class="fc" id="L1049">        return ret;</span>
    }

    /**
     * Gets Serial number of the certificate as a string. For X509 Certificate this means a HEX encoded BigInteger, and for CVC certificate is means
     * the sequence field of the holder reference.
     * &lt;p&gt;
     * For X509 certificates, the value is normalized (uppercase without leading zeros), so there's no need to normalize the returned value.
     * 
     * @param cert Certificate
     * 
     * @return String to be displayed, or used in RoleMember objects
     */
    public static String getSerialNumberAsString(Certificate cert) {
<span class="fc" id="L1063">        String ret = null;</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">        if (cert == null) {</span>
<span class="fc" id="L1065">            throw new IllegalArgumentException(&quot;getSerialNumber: cert is null&quot;);</span>
        }
<span class="fc bfc" id="L1067" title="All 2 branches covered.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1068">            X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1069">            ret = xcert.getSerialNumber().toString(16).toUpperCase();</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">        } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
            // For CVC certificates the sequence field of the HolderReference is kind of a serial number,
            // but if can be alphanumeric which means it can not be made into a BigInteger
<span class="fc" id="L1073">            CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
            try {
<span class="fc" id="L1075">                ret = cvccert.getCVCertificate().getCertificateBody().getHolderReference().getSequence();</span>
<span class="nc" id="L1076">            } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L1077">                log.error(&quot;getSerialNumber: NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L1078">                ret = &quot;N/A&quot;;</span>
<span class="fc" id="L1079">            }</span>
<span class="fc" id="L1080">        } else {</span>
<span class="nc" id="L1081">            throw new IllegalArgumentException(&quot;getSerialNumber: Certificate of type &quot; + cert.getType() + &quot; is not implemented&quot;);</span>
        }
<span class="fc" id="L1083">        return ret;</span>
    }

    /**
     * Gets the signature value (the raw signature bits) from the certificate. For an X509 certificate this is the ASN.1 definition which is:
     * signature BIT STRING
     * 
     * @param cert Certificate
     * 
     * @return byte[] containing the certificate signature bits, if cert is null a byte[] of size 0 is returned.
     */
    public static byte[] getSignature(Certificate cert) {
<span class="fc" id="L1095">        byte[] ret = null;</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L1097">            ret = new byte[0];</span>
        } else {
<span class="fc bfc" id="L1099" title="All 2 branches covered.">            if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1100">                X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1101">                ret = xcert.getSignature();</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">            } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1103">                CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
                try {
<span class="fc" id="L1105">                    ret = cvccert.getCVCertificate().getSignature();</span>
<span class="nc" id="L1106">                } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L1107">                    log.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L1108">                    return null;</span>
<span class="fc" id="L1109">                }</span>
            }
        }
<span class="fc" id="L1112">        return ret;</span>
    }

    /**
     * Gets issuer DN for CRL in the format we are sure about (BouncyCastle),supporting UTF8.
     * 
     * @param crl X509RL
     * 
     * @return String containing the DN.
     */
    public static String getIssuerDN(X509CRL crl) {
<span class="fc" id="L1123">        String dn = null;</span>
        try {
<span class="fc" id="L1125">            CertificateFactory cf = CertTools.getCertificateFactory();</span>
<span class="fc" id="L1126">            X509CRL x509crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(crl.getEncoded()));</span>
            // log.debug(&quot;Created certificate of class: &quot; + x509crl.getClass().getName());
<span class="fc" id="L1128">            dn = x509crl.getIssuerDN().toString();</span>
<span class="nc" id="L1129">        } catch (CRLException ce) {</span>
<span class="nc" id="L1130">            log.error(&quot;CRLException: &quot;, ce);</span>
<span class="nc" id="L1131">            return null;</span>
<span class="fc" id="L1132">        }</span>
<span class="fc" id="L1133">        return stringToBCDNString(dn);</span>
    }

    public static Date getNotBefore(Certificate cert) {
<span class="fc" id="L1137">        Date ret = null;</span>
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L1139">            throw new IllegalArgumentException(&quot;getNotBefore: cert is null&quot;);</span>
        }
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1142">            X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1143">            ret = xcert.getNotBefore();</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">        } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1145">            CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
            try {
<span class="fc" id="L1147">                ret = cvccert.getCVCertificate().getCertificateBody().getValidFrom();</span>
<span class="nc" id="L1148">            } catch (NoSuchFieldException e) {</span>
                // it is not uncommon that this field is missing in CVC certificate requests (it's not in the EAC standard so)
<span class="nc" id="L1150">                log.debug(&quot;NoSuchFieldException: &quot; + e.getMessage());</span>
<span class="nc" id="L1151">                return null;</span>
<span class="fc" id="L1152">            }</span>
        }
<span class="fc" id="L1154">        return ret;</span>
    }

    public static Date getNotAfter(Certificate cert) {
<span class="fc" id="L1158">        Date ret = null;</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L1160">            throw new IllegalArgumentException(&quot;getNotAfter: cert is null&quot;);</span>
        }
<span class="fc bfc" id="L1162" title="All 2 branches covered.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1163">            final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1164">            ret = xcert.getNotAfter();</span>
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">        } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1166">            final CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
            try {
<span class="fc" id="L1168">                ret = cvccert.getCVCertificate().getCertificateBody().getValidTo();</span>
<span class="nc" id="L1169">            } catch (NoSuchFieldException e) {</span>
                // it is not uncommon that this field is missing in CVC certificate requests (it's not in the EAC standard so)
<span class="nc bnc" id="L1171" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1172">                    log.debug(&quot;NoSuchFieldException: &quot; + e.getMessage());</span>
                }
<span class="nc" id="L1174">                return null;</span>
<span class="fc" id="L1175">            }</span>
        }
<span class="fc" id="L1177">        return ret;</span>
    }

    /** Returns a CertificateFactory that can be used to create certificates from byte arrays and such.
     * @param provider Security provider that should be used to create certificates, default BC is null is passed.
     * @return CertificateFactory
     */
    public static CertificateFactory getCertificateFactory(final String provider) {
        final String prov;
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L1187">            prov = BouncyCastleProvider.PROVIDER_NAME;</span>
        } else {
<span class="fc" id="L1189">            prov = provider;</span>
        }
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">        if (BouncyCastleProvider.PROVIDER_NAME.equals(prov)) {</span>
<span class="fc" id="L1192">            CryptoProviderTools.installBCProviderIfNotAvailable();</span>
        }
        try {
<span class="fc" id="L1195">            return CertificateFactory.getInstance(&quot;X.509&quot;, prov);</span>
<span class="nc" id="L1196">        } catch (NoSuchProviderException nspe) {</span>
<span class="nc" id="L1197">            log.error(&quot;NoSuchProvider: &quot;, nspe);</span>
<span class="nc" id="L1198">        } catch (CertificateException ce) {</span>
<span class="nc" id="L1199">            log.error(&quot;CertificateException: &quot;, ce);</span>
<span class="nc" id="L1200">        }</span>
<span class="nc" id="L1201">        return null;</span>
    }

    public static CertificateFactory getCertificateFactory() {
<span class="fc" id="L1205">        return getCertificateFactory(BouncyCastleProvider.PROVIDER_NAME);</span>
    }

   /**
    * Reads certificates in PEM-format from a filename.
    * The stream may contain other things between the different certificates.
    * 
    * @param certFilename filename of the file containing the certificates in PEM-format
    * @return Ordered List of Certificates, first certificate first, or empty List
    * @throws FileNotFoundException if certFile was not found
    * @throws CertificateParsingException if the file contains an incorrect certificate.
    * 
    * @deprecated Use org.cesecore.util.CertTools.getCertsFromPEM(String, Class&amp;lt;T&amp;gt;) instead
    */
    @Deprecated
   public static List&lt;Certificate&gt; getCertsFromPEM(String certFilename) throws FileNotFoundException, CertificateParsingException {
<span class="nc" id="L1221">        return getCertsFromPEM(certFilename, Certificate.class);</span>
    }
    
    /**
     * Reads certificates in PEM-format from a filename.
     * The stream may contain other things between the different certificates.
     * 
     * @param certFilename filename of the file containing the certificates in PEM-format
     * @param returnType a Class specifying the desired return type. Certificate can be used if return type is unknown.
     * @param &lt;T&gt; type
     * @return Ordered List of Certificates, first certificate first, or empty List
     * @throws FileNotFoundException if certFile was not found
     * @throws CertificateParsingException if the file contains an incorrect certificate.
     */
    public static &lt;T extends Certificate&gt; List&lt;T&gt; getCertsFromPEM(String certFilename, Class&lt;T&gt; returnType) throws FileNotFoundException, CertificateParsingException {
<span class="nc bnc" id="L1236" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1237">            log.trace(&quot;&gt;getCertfromPEM: certFilename=&quot; + certFilename);</span>
        }
<span class="nc" id="L1239">        InputStream inStrm = null;</span>
        final List&lt;T&gt; certs;
        try {
<span class="nc" id="L1242">            inStrm = new FileInputStream(certFilename);</span>
<span class="nc" id="L1243">            certs = getCertsFromPEM(inStrm, returnType);</span>
        } finally {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">            if (inStrm != null) {</span>
                try {
<span class="nc" id="L1247">                    inStrm.close();</span>
<span class="nc" id="L1248">                } catch (IOException e) {</span>
<span class="nc" id="L1249">                    throw new IllegalStateException(&quot;Could not clode input stream&quot;, e);</span>
<span class="nc" id="L1250">                }</span>
            }
        }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1254">            log.trace(&quot;&lt;getCertfromPEM: certFile=&quot; + certFilename);</span>
        }
<span class="nc" id="L1256">        return certs;</span>
    }
    
    /**
     * Reads a CA certificate and its certificate chain by a file. If it is a chain it is a file with multiple PEM encoded certificates.
     * A single certificate is either in PEM or binary format.
     *  
     * @param file the full path of the file.
     * @return a byte array containing one PEM or binary certificate, or all certificates in the chain in PEM format. First is the CA certificate, followed by its certificate chain.
     * @throws FileNotFoundException if the file cannot be found.
     * @throws IOException on IO error
     * @throws CertificateParsingException if a certificate could not be parsed.
     * @throws CertificateEncodingException if a certificate cannot be encoded.
     */
    public static final byte[] readCertificateChainAsArrayOrThrow(final String file)
            throws FileNotFoundException, IOException, CertificateParsingException, CertificateEncodingException {
        
<span class="nc" id="L1273">        final List&lt;byte[]&gt; cachain = new ArrayList&lt;byte[]&gt;();</span>
<span class="nc" id="L1274">        try (FileInputStream fis = new FileInputStream(file)) {</span>
<span class="nc" id="L1275">            Collection&lt;Certificate&gt; certs = CertTools.getCertsFromPEM(fis, Certificate.class);</span>
<span class="nc" id="L1276">            Iterator&lt;Certificate&gt; iter = certs.iterator();</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L1278">                Certificate cert = iter.next();</span>
<span class="nc" id="L1279">                cachain.add(cert.getEncoded());</span>
<span class="nc" id="L1280">            }</span>
<span class="nc" id="L1281">        } catch (CertificateParsingException e) {</span>
            // It was perhaps not a PEM chain...see if it was a single binary certificate
<span class="nc" id="L1283">            byte[] certbytes = FileTools.readFiletoBuffer(file);</span>
<span class="nc" id="L1284">            Certificate cert = CertTools.getCertfromByteArray(certbytes, Certificate.class); // check if it is a good cert, decode PEM if it is PEM, etc</span>
<span class="nc" id="L1285">            cachain.add(cert.getEncoded());</span>
<span class="nc" id="L1286">        }</span>
        
<span class="nc" id="L1288">        try (final ByteArrayOutputStream bos = new ByteArrayOutputStream()) {</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">            for (byte[] bytes : cachain) {</span>
<span class="nc" id="L1290">                bos.write(bytes);</span>
<span class="nc" id="L1291">            }</span>
<span class="nc" id="L1292">            final byte[] result = bos.toByteArray();</span>
<span class="nc" id="L1293">            return result;</span>
        }
    }
    
    public static final List&lt;CertificateWrapper&gt; bytesToListOfCertificateWrapperOrThrow(final byte[] bytes) throws CertificateParsingException {
<span class="nc" id="L1298">        Collection&lt;java.security.cert.Certificate&gt; certs = null;</span>
        try {
<span class="nc" id="L1300">            certs = CertTools.getCertsFromPEM(new ByteArrayInputStream(bytes), java.security.cert.Certificate.class);</span>
<span class="nc" id="L1301">        } catch (CertificateException e) {</span>
<span class="nc" id="L1302">            log.debug(&quot;Input stream is not PEM certificate(s): &quot;+e.getMessage());</span>
            // See if it is a single binary certificate
<span class="nc" id="L1304">            java.security.cert.Certificate cert = CertTools.getCertfromByteArray(bytes, java.security.cert.Certificate.class);</span>
<span class="nc" id="L1305">            certs = new ArrayList&lt;java.security.cert.Certificate&gt;();</span>
<span class="nc" id="L1306">            certs.add(cert);</span>
<span class="nc" id="L1307">        }</span>
<span class="nc" id="L1308">        return EJBTools.wrapCertCollection(certs);</span>
    }

    /**
     * Reads certificates in PEM-format from an InputStream. 
     * The stream may contain other things between the different certificates.
     * 
     * @param certstream the input stream containing the certificates in PEM-format
     * @return Ordered List of Certificates, first certificate first, or empty List
     *
     * @throws CertificateParsingException if the stream contains an incorrect certificate.
     * 
     * @deprecated Use org.cesecore.util.CertTools.getCertsFromPEM(InputStream, Class&amp;lt;T&amp;gt;) instead. 
     */
    @Deprecated
    public static List&lt;Certificate&gt; getCertsFromPEM(InputStream certstream) throws CertificateParsingException {
<span class="nc" id="L1324">        return getCertsFromPEM(certstream, Certificate.class);</span>
    }
    
    /**
     * Reads certificates in PEM-format from an InputStream. 
     * The stream may contain other things between the different certificates.
     * 
     * @param certstream the input stream containing the certificates in PEM-format
     * @param returnType specifies the desired certificate type. Certificate can be used if certificate type is unknown.
     * @param &lt;T&gt; type
     * @return Ordered List of Certificates, first certificate first, or empty List
     * @exception CertificateParsingException if the stream contains an incorrect certificate.
     */
    public static &lt;T extends Certificate&gt; List&lt;T&gt; getCertsFromPEM(InputStream certstream, Class&lt;T&gt; returnType) throws CertificateParsingException {
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1339">            log.trace(&quot;&gt;getCertfromPEM&quot;);</span>
        }
<span class="fc" id="L1341">        ArrayList&lt;T&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1342">        String beginKeyTrust = &quot;-----BEGIN TRUSTED CERTIFICATE-----&quot;;</span>
<span class="fc" id="L1343">        String endKeyTrust = &quot;-----END TRUSTED CERTIFICATE-----&quot;;</span>
<span class="fc" id="L1344">        BufferedReader bufRdr = null;</span>
<span class="fc" id="L1345">        ByteArrayOutputStream ostr = null;</span>
<span class="fc" id="L1346">        PrintStream opstr = null;</span>
        try {
            try {
<span class="fc" id="L1349">                bufRdr = new BufferedReader(new InputStreamReader(new SecurityFilterInputStream(certstream)));</span>
<span class="fc bfc" id="L1350" title="All 2 branches covered.">                while (bufRdr.ready()) {</span>
<span class="fc" id="L1351">                    ostr = new ByteArrayOutputStream();</span>
<span class="fc" id="L1352">                    opstr = new PrintStream(ostr);</span>
                    String temp;
<span class="pc bpc" id="L1354" title="4 of 6 branches missed.">                    while ((temp = bufRdr.readLine()) != null &amp;&amp; !(temp.equals(CertTools.BEGIN_CERTIFICATE) || temp.equals(beginKeyTrust))) {</span>
<span class="nc" id="L1355">                        continue;</span>
                    }
<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">                    if (temp == null) {</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">                        if (ret.isEmpty()) {</span>
                            // There was no certificate in the file
<span class="nc" id="L1360">                            throw new CertificateParsingException(&quot;Error in &quot; + certstream.toString() + &quot;, missing &quot; + CertTools.BEGIN_CERTIFICATE</span>
                                    + &quot; boundary&quot;);
                        } else {
                            // There were certificates, but some blank lines or something in the end
                            // anyhow, the file has ended so we can break here.
                            break;
                        }
                    }
<span class="pc bpc" id="L1368" title="2 of 6 branches missed.">                    while ((temp = bufRdr.readLine()) != null &amp;&amp; !(temp.equals(CertTools.END_CERTIFICATE) || temp.equals(endKeyTrust))) {</span>
<span class="fc" id="L1369">                        opstr.print(temp);</span>
                    }
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">                    if (temp == null) {</span>
<span class="nc" id="L1372">                        throw new IllegalArgumentException(&quot;Error in &quot; + certstream.toString() + &quot;, missing &quot; + CertTools.END_CERTIFICATE</span>
                                + &quot; boundary&quot;);
                    }
<span class="fc" id="L1375">                    opstr.close();</span>

<span class="fc" id="L1377">                    byte[] certbuf = Base64.decode(ostr.toByteArray());</span>
<span class="fc" id="L1378">                    ostr.close();</span>
                    // Phweeew, were done, now decode the cert from file back to Certificate object
<span class="fc" id="L1380">                    T cert = getCertfromByteArray(certbuf, returnType);</span>
<span class="fc" id="L1381">                    ret.add(cert);</span>
<span class="fc" id="L1382">                }</span>

            } finally {
<span class="pc bpc" id="L1385" title="1 of 2 branches missed.">                if (bufRdr != null) {</span>
<span class="fc" id="L1386">                    bufRdr.close();</span>
                }
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">                if (opstr != null) {</span>
<span class="fc" id="L1389">                    opstr.close();</span>
                }
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">                if (ostr != null) {</span>
<span class="fc" id="L1392">                    ostr.close();</span>
                }
            }
<span class="nc" id="L1395">        } catch (IOException e) {</span>
<span class="nc" id="L1396">            throw new IllegalStateException(&quot;Exception caught when attempting to read stream, see underlying IOException&quot;, e);</span>
<span class="fc" id="L1397">        }</span>
<span class="pc bpc" id="L1398" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1399">            log.trace(&quot;&lt;getcertfromPEM:&quot; + ret.size());</span>
        }
<span class="fc" id="L1401">        return ret;</span>
    }

    /**
     * Converts a regular array of certificates into an ArrayList, using the provided provided.
     * 
     * @param certs Certificate[] of certificates to convert
     * @param provider provider for example &quot;SUN&quot; or &quot;BC&quot;, use null for the default provider (BC)
     * @return An ArrayList of certificates in the same order as the passed in array
     * @throws NoSuchProviderException if provider not found
     * @throws CertificateException if certifiate cannot be parsed
     */
    public static List&lt;Certificate&gt; getCertCollectionFromArray(Certificate[] certs, String provider) throws CertificateException,
            NoSuchProviderException {
<span class="pc bpc" id="L1415" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1416">            log.trace(&quot;&gt;getCertCollectionFromArray: &quot; + provider);</span>
        }
<span class="fc" id="L1418">        ArrayList&lt;Certificate&gt; ret = new ArrayList&lt;Certificate&gt;();</span>
<span class="fc" id="L1419">        String prov = provider;</span>
<span class="pc bpc" id="L1420" title="1 of 2 branches missed.">        if (prov == null) {</span>
<span class="nc" id="L1421">            prov = &quot;BC&quot;;</span>
        }
<span class="fc bfc" id="L1423" title="All 2 branches covered.">        for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="fc" id="L1424">            Certificate cert = certs[i];</span>
<span class="fc" id="L1425">            Certificate newcert = getCertfromByteArray(cert.getEncoded(), prov);</span>
<span class="fc" id="L1426">            ret.add(newcert);</span>
        }
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1429">            log.trace(&quot;&lt;getCertCollectionFromArray: &quot; + ret.size());</span>
        }
<span class="fc" id="L1431">        return ret;</span>
    }

    /**
     * Returns a certificate in PEM-format.
     * 
     * @param certs Collection of Certificate to convert to PEM
     * @return byte array containing PEM certificate
     * @exception CertificateException if the stream does not contain a correct certificate.
     * 
     * @deprecated Since 6.0.0, use org.cesecore.util.CertTools.getPemFromCertificateChain(Collection&amp;lt;Certificate&amp;gt;) instead
     */
    @Deprecated
    public static byte[] getPEMFromCerts(Collection&lt;Certificate&gt; certs) throws CertificateException {
<span class="nc" id="L1445">        return getPemFromCertificateChain(certs);</span>
    }

    /**
     * Returns a certificate in PEM-format.
     * 
     * @param certs Collection of Certificate to convert to PEM
     * @return byte array containing PEM certificate
     * @throws CertificateEncodingException if an encoding error occurred
     */
    public static byte[] getPemFromCertificateChain(Collection&lt;Certificate&gt; certs) throws CertificateEncodingException  {
<span class="fc" id="L1456">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L1457">        try ( final PrintStream printStream = new PrintStream(baos) ) {</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">            for (final Certificate certificate : certs) {</span>
<span class="pc bpc" id="L1459" title="1 of 2 branches missed.">                if (certificate != null) {</span>
<span class="fc" id="L1460">                    printStream.println(&quot;Subject: &quot; + CertTools.getSubjectDN(certificate));</span>
<span class="fc" id="L1461">                    printStream.println(&quot;Issuer: &quot; + CertTools.getIssuerDN(certificate));</span>
<span class="fc" id="L1462">                    writeAsPemEncoded(printStream, certificate.getEncoded(), BEGIN_CERTIFICATE, END_CERTIFICATE);                    </span>
                }
<span class="fc" id="L1464">            }</span>
        }
<span class="fc" id="L1466">        return baos.toByteArray();</span>
    }
    /**
     * Returns a certificate in PEM-format.
     *
     * @param cacert a Certificate to convert to PEM
     * @return byte array containing PEM certificate
     * @throws CertificateEncodingException if an encoding error occurred
     */
    public static String getPemFromCertificate(Certificate cacert) throws CertificateEncodingException {
<span class="nc" id="L1476">        byte[] enccert = cacert.getEncoded();</span>
<span class="nc" id="L1477">        byte[] b64cert = Base64.encode(enccert);</span>
<span class="nc" id="L1478">        String out = BEGIN_CERTIFICATE_WITH_NL;</span>
<span class="nc" id="L1479">        out += new String(b64cert);</span>
<span class="nc" id="L1480">        out += END_CERTIFICATE_WITH_NL;</span>
<span class="nc" id="L1481">        return out;</span>
    }

    /** @param crlBytes CRL
     * @return a CRL in PEM-format as a byte array. */
    public static byte[] getPEMFromCrl(byte[] crlBytes) {
<span class="fc" id="L1487">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L1488">        try ( final PrintStream printStream = new PrintStream(baos) ) {</span>
<span class="fc" id="L1489">            writeAsPemEncoded(printStream, crlBytes, BEGIN_X509_CRL_KEY, END_X509_CRL_KEY);</span>
        }
<span class="fc" id="L1491">        return baos.toByteArray();</span>
    }

    /** @param publicKeyBytes key
     * @return a PublicKey in PEM-format as a byte array. */
    public static byte[] getPEMFromPublicKey(final byte[] publicKeyBytes) {
<span class="fc" id="L1497">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L1498">        try ( final PrintStream printStream = new PrintStream(baos) ) {</span>
<span class="fc" id="L1499">            writeAsPemEncoded(printStream, publicKeyBytes, BEGIN_PUBLIC_KEY, END_PUBLIC_KEY);</span>
        }
<span class="fc" id="L1501">        return baos.toByteArray();</span>
    }

    public static byte[] getPEMFromPrivateKey(final byte[] privateKeyBytes) {
<span class="nc" id="L1505">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1506">        try ( final PrintStream printStream = new PrintStream(baos) ) {</span>
<span class="nc" id="L1507">            writeAsPemEncoded(printStream, privateKeyBytes, BEGIN_PRIVATE_KEY, END_PRIVATE_KEY);</span>
        }
<span class="nc" id="L1509">        return baos.toByteArray();</span>
    }

    /** @param certificateRequestBytes key
     * @return a PublicKey in PEM-format as a byte array. */
    public static byte[] getPEMFromCertificateRequest(final byte[] certificateRequestBytes) {
<span class="nc" id="L1515">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1516">        try ( final PrintStream printStream = new PrintStream(baos) ) {</span>
<span class="nc" id="L1517">            writeAsPemEncoded(printStream, certificateRequestBytes, BEGIN_CERTIFICATE_REQUEST, END_CERTIFICATE_REQUEST);</span>
        }
<span class="nc" id="L1519">        return baos.toByteArray();</span>
    }
    
    /** 
     * Generates PEM from binary pkcs#7 data.
     * @param pkcs7Binary pkcs#7 binary data
     * @return a pkcs#7 PEM encoded */
    public static byte[] getPemFromPkcs7(final byte[] pkcs7Binary) {
<span class="nc" id="L1527">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1528">        try ( final PrintStream printStream = new PrintStream(baos) ) {</span>
<span class="nc" id="L1529">            writeAsPemEncoded(printStream, pkcs7Binary, BEGIN_PKCS7, END_PKCS7);</span>
        }
<span class="nc" id="L1531">        return baos.toByteArray();</span>
    }

    /** Write the supplied bytes to the printstream as Base64 using beginKey and endKey around it. 
     * @param printStream stream
     * @param unencodedData data
     * @param beginKey key start
     * @param endKey key end */
    private static void writeAsPemEncoded(PrintStream printStream, byte[] unencodedData, String beginKey, String endKey) {
<span class="fc" id="L1540">        printStream.println(beginKey);</span>
<span class="fc" id="L1541">        printStream.println(new String(Base64.encode(unencodedData)));</span>
<span class="fc" id="L1542">        printStream.println(endKey);</span>
<span class="fc" id="L1543">    }</span>


    /**
     * Creates Certificate from byte[], can be either an X509 certificate or a CVCCertificate
     * 
     * @param cert byte array containing certificate in binary (DER) format, or PEM encoded X.509 certificate
     * @param provider provider for example &quot;SUN&quot; or &quot;BC&quot;, use null for the default provider (BC)
     * 
     * @return a Certificate 
     * @throws CertificateParsingException if certificate couldn't be parsed from cert
     * 
     * @deprecated Use org.cesecore.util.CertTools.getCertfromByteArray(byte[], String, Class&amp;lt;Y&amp;gt;) instead. 
     */
    @Deprecated
    public static Certificate getCertfromByteArray(byte[] cert, String provider) throws CertificateParsingException {
<span class="fc" id="L1559">        return getCertfromByteArray(cert, provider, Certificate.class);</span>
    }
    
    /**
     * Creates Certificate from byte[], can be either an X509 certificate or a CVCCertificate
     * 
     * @param cert byte array containing certificate in binary (DER) format, or PEM encoded X.509 certificate
     * @param provider provider for example &quot;SUN&quot; or &quot;BC&quot;, use null for the default provider (BC)
     * @param returnType the type of Certificate to be returned. Certificate can be used if certificate type is unknown.
     * @param &lt;T&gt; type
     * @return a Certificate 
     * @throws CertificateParsingException if certificate couldn't be parsed from cert, or if the incorrect return type was specified.
     * 
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Certificate&gt; T getCertfromByteArray(byte[] cert, String provider, Class&lt;T&gt; returnType) throws CertificateParsingException {
<span class="fc" id="L1575">        T ret = null;</span>
<span class="fc" id="L1576">        String prov = provider;</span>
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L1578">            prov = BouncyCastleProvider.PROVIDER_NAME;</span>
        }
        
<span class="fc bfc" id="L1581" title="All 2 branches covered.">        if(returnType.equals(X509Certificate.class)) {</span>
<span class="fc" id="L1582">            ret = (T) parseX509Certificate(prov, cert);</span>
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">        } else if(returnType.equals(CardVerifiableCertificate.class)) {</span>
<span class="nc" id="L1584">            ret = (T) parseCardVerifiableCertificate(prov, cert);</span>
        } else {
            //Let's guess...
            try {
<span class="fc" id="L1588">                ret = (T) parseX509Certificate(prov, cert);</span>
<span class="fc" id="L1589">            } catch (CertificateParsingException e) {</span>
                try {
<span class="fc" id="L1591">                    ret = (T) parseCardVerifiableCertificate(prov, cert);</span>
<span class="nc" id="L1592">                } catch (CertificateParsingException e1) {</span>
<span class="nc" id="L1593">                    throw new CertificateParsingException(&quot;No certificate could be parsed from byte array. See debug logs for details.&quot;);</span>
<span class="fc" id="L1594">                }</span>
<span class="fc" id="L1595">            }</span>
        }
        
<span class="fc" id="L1598">        return ret;</span>
    }
    
    /**
     * 
     * @param provider a provider name 
     * @param cert a byte array containing an encoded certificate
     * @return a decoded X509Certificate
     * @throws CertificateParsingException if the byte array wasn't valid, or contained a certificate other than an X509 Certificate. 
     */
    private static X509Certificate parseX509Certificate(String provider, byte[] cert) throws CertificateParsingException {
<span class="fc" id="L1609">        final CertificateFactory cf = CertTools.getCertificateFactory(provider);</span>
        X509Certificate result;
        try {
<span class="fc" id="L1612">           result = (X509Certificate) cf.generateCertificate(new SecurityFilterInputStream(new ByteArrayInputStream(cert)));      </span>
<span class="fc" id="L1613">        } catch (CertificateException e) {</span>
<span class="fc" id="L1614">            throw new CertificateParsingException(&quot;Could not parse byte array as X509Certificate.&quot; + e.getCause().getMessage(), e);</span>
<span class="fc" id="L1615">        }</span>
<span class="fc bfc" id="L1616" title="All 2 branches covered.">        if(result != null) {</span>
<span class="fc" id="L1617">            return result;</span>
        } else {
<span class="fc" id="L1619">            throw new CertificateParsingException(&quot;Could not parse byte array as X509Certificate.&quot;);</span>
        }
    }
    
    private static CardVerifiableCertificate parseCardVerifiableCertificate(String provider, byte[] cert) throws CertificateParsingException {
        // We could not create an X509Certificate, see if it is a CVC certificate instead
        try {
<span class="fc" id="L1626">            final CVCertificate parsedObject = CertificateParser.parseCertificate(cert);</span>
<span class="fc" id="L1627">            return new CardVerifiableCertificate(parsedObject);</span>
<span class="nc" id="L1628">        } catch (ParseException e) {</span>
<span class="nc" id="L1629">            throw new CertificateParsingException(&quot;ParseException trying to read CVCCertificate.&quot;, e);</span>
<span class="nc" id="L1630">        } catch (ConstructionException e) {</span>
<span class="nc" id="L1631">            throw new CertificateParsingException(&quot;ConstructionException trying to read CVCCertificate.&quot;, e);</span>
        } 
    }

   
    
    /**
     * 
     * @param cert vertificate
     * @return certificate
     * @throws CertificateParsingException if the byte array does not contain a proper certificate.
     * 
     * @deprecated Use org.cesecore.util.CertTools.getCertfromByteArray(byte[], Class&amp;lt;T&amp;gt;) to specify return type instead.
     */
    @Deprecated
    public static Certificate getCertfromByteArray(byte[] cert) throws CertificateParsingException {
<span class="fc" id="L1647">        return getCertfromByteArray(cert, Certificate.class);</span>
    }
    
    /**
     * @param cert certificate as byte array
     * @param &lt;T&gt; type
     * @param returnType the type of Certificate to be returned, for example X509Certificate.class. Certificate.class can be used if certificate type is unknown.
     * @return Certificate
     * 
     * @throws CertificateParsingException if the byte array does not contain a proper certificate.
     */
    public static &lt;T extends Certificate&gt; T getCertfromByteArray(byte[] cert, Class&lt;T&gt; returnType) throws CertificateParsingException {
<span class="fc" id="L1659">        return getCertfromByteArray(cert, BouncyCastleProvider.PROVIDER_NAME, returnType);</span>
    }

    /**
     * Creates X509CRL from byte[].
     * 
     * @param crl byte array containing CRL in DER-format
     * 
     * @return X509CRL
     * 
     * @throws CRLException if the byte array does not contain a correct CRL.
     */
    public static X509CRL getCRLfromByteArray(byte[] crl) throws CRLException {
<span class="fc" id="L1672">        log.trace(&quot;&gt;getCRLfromByteArray&quot;);</span>
<span class="pc bpc" id="L1673" title="1 of 2 branches missed.">        if(crl == null) {</span>
<span class="nc" id="L1674">            throw new CRLException(&quot;No content in crl byte array&quot;);</span>
        }
<span class="fc" id="L1676">        CertificateFactory cf = CertTools.getCertificateFactory();</span>
<span class="fc" id="L1677">        X509CRL x509crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(crl));</span>
<span class="fc" id="L1678">        log.trace(&quot;&lt;getCRLfromByteArray&quot;);</span>

<span class="fc" id="L1680">        return x509crl;</span>
    } // getCRLfromByteArray

    /**
     * Checks if a certificate is self signed by verifying if subject and issuer are the same.
     * 
     * @param cert the certificate that shall be checked.
     * 
     * @return boolean true if the certificate has the same issuer and subject, false otherwise.
     */
    public static boolean isSelfSigned(Certificate cert) {
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1692">            log.trace(&quot;&gt;isSelfSigned: cert: &quot; + CertTools.getIssuerDN(cert) + &quot;\n&quot; + CertTools.getSubjectDN(cert));</span>
        }
<span class="fc" id="L1694">        boolean ret = CertTools.getSubjectDN(cert).equals(CertTools.getIssuerDN(cert));</span>
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1696">            log.trace(&quot;&lt;isSelfSigned:&quot; + ret);</span>
        }
<span class="fc" id="L1698">        return ret;</span>
    } // isSelfSigned

    /**
     * Checks if a certificate is valid.
     * @param warnIfAboutToExpire Also print a WARN log message if the certificate is about to expire. If false, it is still printed at DEBUG level. 
     * 
     * @param signerCert the certificate to be tested
     * @return true if the certificate is valid
     */
    public static boolean isCertificateValid(final X509Certificate signerCert, final boolean warnIfAboutToExpire) {
        try {
<span class="nc" id="L1710">            signerCert.checkValidity();</span>
<span class="nc" id="L1711">        } catch (CertificateExpiredException e) {</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1713">                log.debug(intres.getLocalizedMessage(&quot;ocsp.errorcerthasexpired&quot;, signerCert.getSerialNumber().toString(16), signerCert.getIssuerDN()));</span>
            }
<span class="nc" id="L1715">            return false;</span>
<span class="nc" id="L1716">        } catch (CertificateNotYetValidException e) {</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1718">                log.debug(intres.getLocalizedMessage(&quot;ocsp.errornotyetvalid&quot;, signerCert.getSerialNumber().toString(16), signerCert.getIssuerDN()));</span>
            }
<span class="nc" id="L1720">            return false;</span>
<span class="nc" id="L1721">        }</span>
<span class="nc" id="L1722">        final long warnBeforeExpirationTime = OcspConfiguration.getWarningBeforeExpirationTime();</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">        if (warnBeforeExpirationTime &lt; 1) {</span>
<span class="nc" id="L1724">            return true;</span>
        }
<span class="nc" id="L1726">        final Date warnDate = new Date(new Date().getTime() + warnBeforeExpirationTime);</span>
        try {
<span class="nc" id="L1728">            signerCert.checkValidity(warnDate);</span>
<span class="nc" id="L1729">        } catch (CertificateExpiredException e) {</span>
<span class="nc bnc" id="L1730" title="All 4 branches missed.">            if (warnIfAboutToExpire || log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                final Level logLevel = warnIfAboutToExpire ? Level.WARN : Level.DEBUG;</span>
<span class="nc" id="L1732">                log.log(logLevel, intres.getLocalizedMessage(&quot;ocsp.warncertwillexpire&quot;, signerCert.getSerialNumber().toString(16), signerCert.getIssuerDN(),</span>
<span class="nc" id="L1733">                        signerCert.getNotAfter()));</span>
            }
<span class="nc" id="L1735">        } catch (CertificateNotYetValidException e) {</span>
<span class="nc" id="L1736">            throw new IllegalStateException(&quot;This should never happen.&quot;, e);</span>
<span class="nc" id="L1737">        }</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1739">            log.debug(&quot;Time for \&quot;certificate will soon expire\&quot; not yet reached. You will be warned after: &quot;</span>
<span class="nc" id="L1740">                    + new Date(signerCert.getNotAfter().getTime() - warnBeforeExpirationTime));</span>
        }
<span class="nc" id="L1742">        return true;</span>
    }

    /**
     * Checks if a certificate is a CA certificate according to BasicConstraints (X.509), or role (CVC). If there is no basic constraints extension on
     * a X.509 certificate, false is returned.
     * 
     * @param cert the certificate that shall be checked.
     * 
     * @return boolean true if the certificate belongs to a CA.
     */
    public static boolean isCA(Certificate cert) {
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1755">            log.trace(&quot;&gt;isCA&quot;);</span>
        }
<span class="fc" id="L1757">        boolean ret = false;</span>
<span class="fc bfc" id="L1758" title="All 2 branches covered.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1759">            X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc bfc" id="L1760" title="All 2 branches covered.">            if (x509cert.getBasicConstraints() &gt; -1) {</span>
<span class="fc" id="L1761">                ret = true;</span>
            }
<span class="pc bpc" id="L1763" title="1 of 2 branches missed.">        } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1764">            CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
            try {
<span class="fc" id="L1766">                CVCAuthorizationTemplate templ = cvccert.getCVCertificate().getCertificateBody().getAuthorizationTemplate();</span>
<span class="fc" id="L1767">                AuthorizationRole role = templ.getAuthorizationField().getAuthRole();</span>
<span class="fc bfc" id="L1768" title="All 4 branches covered.">                if (role.isCVCA() || role.isDV()) {</span>
<span class="fc" id="L1769">                    ret = true;</span>
                }
<span class="nc" id="L1771">            } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L1772">                log.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="fc" id="L1773">            }</span>
        }
<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1776">            log.trace(&quot;&lt;isCA:&quot; + ret);</span>
        }
<span class="fc" id="L1778">        return ret;</span>
    }

    /**
     * Is OCSP extended key usage set for a certificate?
     * 
     * @param cert to check.
     * @return true if the extended key usage for OCSP is check
     */
    public static boolean isOCSPCert(X509Certificate cert) {
        final List&lt;String&gt; keyUsages;
        try {
<span class="nc" id="L1790">            keyUsages = cert.getExtendedKeyUsage();</span>
<span class="nc" id="L1791">        } catch (CertificateParsingException e) {</span>
<span class="nc" id="L1792">            return false;</span>
<span class="nc" id="L1793">        }</span>
<span class="nc bnc" id="L1794" title="All 4 branches missed.">        return keyUsages != null &amp;&amp; keyUsages.contains(KeyPurposeId.id_kp_OCSPSigning.getId());</span>
    }

    /**
     * Generate a selfsigned certificate.
     * 
     * @param dn subject and issuer DN
     * @param validity in days
     * @param policyId policy string ('2.5.29.32.0') or null
     * @param privKey private key
     * @param pubKey public key
     * @param sigAlg signature algorithm, you can use one of the contants AlgorithmConstants.SIGALG_XXX
     * @param isCA boolean true or false
     * 
     * @return X509Certificate, self signed
     * 
     * @throws CertificateException  If cert cannot be parsed
     * @throws OperatorCreationException if creation fails
     */
    public static X509Certificate genSelfCert(String dn, long validity, String policyId, PrivateKey privKey, PublicKey pubKey, String sigAlg,
            boolean isCA) throws OperatorCreationException, CertificateException  {
<span class="fc" id="L1815">        return genSelfCert(dn, validity, policyId, privKey, pubKey, sigAlg, isCA, BouncyCastleProvider.PROVIDER_NAME);</span>
    }

    /** Generates a self signed certificate with keyUsage X509KeyUsage.keyCertSign + X509KeyUsage.cRLSign, i.e. a CA certificate
     *  @param dn subject and issuer DN
     * @param validity in days
     * @param policyId policy string ('2.5.29.32.0') or null
     * @param privKey private key
     * @param pubKey public key
     * @param sigAlg signature algorithm, you can use one of the contants AlgorithmConstants.SIGALG_XXX
     * @param isCA boolean true or false
     * @param provider jce provider
     * @param ldapOrder true to sort
     * 
     * @return X509Certificate, self signed
      * @throws CertificateParsingException  If cert cannot be parsed
     * @throws OperatorCreationException if creation fails
     * 
     */
    public static X509Certificate genSelfCert(String dn, long validity, String policyId, PrivateKey privKey, PublicKey pubKey, String sigAlg,
            boolean isCA, String provider, boolean ldapOrder) throws CertificateParsingException, OperatorCreationException {
        final int keyUsage;
<span class="fc bfc" id="L1837" title="All 2 branches covered.">        if (isCA) {</span>
<span class="fc" id="L1838">            keyUsage = X509KeyUsage.keyCertSign + X509KeyUsage.cRLSign;</span>
        } else {
<span class="fc" id="L1840">            keyUsage = 0;</span>
        }
<span class="fc" id="L1842">        return genSelfCertForPurpose(dn, validity, policyId, privKey, pubKey, sigAlg, isCA, keyUsage, null, null, provider, ldapOrder);</span>
    } // genselfCert

    /** Generates a self signed certificate with keyUsage X509KeyUsage.keyCertSign + X509KeyUsage.cRLSign, i.e. a CA certificate
     * @param dn subject and issuer DN
     * @param validity in days
     * @param policyId policy string ('2.5.29.32.0') or null
     * @param privKey private key
     * @param pubKey public key
     * @param sigAlg signature algorithm, you can use one of the contants AlgorithmConstants.SIGALG_XXX
     * @param isCA boolean true or false
     * @param provider JCE provider
     * 
     * @return X509Certificate, self signed
     * 
     * @throws CertificateException  If cert cannot be parsed
     * @throws OperatorCreationException if creation fails
     */
    public static X509Certificate genSelfCert(String dn, long validity, String policyId, PrivateKey privKey, PublicKey pubKey, String sigAlg,
            boolean isCA, String provider) throws OperatorCreationException, CertificateException {
<span class="fc" id="L1862">        return genSelfCert(dn, validity, policyId, privKey, pubKey, sigAlg, isCA, provider, true);</span>
    } // genselfCert

    /**
     * Generate a selfsigned certiicate with possibility to specify key usage.
     * 
     * @param dn subject and issuer DN
     * @param validity in days
     * @param policyId policy string ('2.5.29.32.0') or null
     * @param privKey private key
     * @param pubKey public key
     * @param sigAlg signature algorithm, you can use one of the contants AlgorithmConstants.SIGALG_XXX
     * @param isCA boolean true or false
     * @param keyusage as defined by constants in X509KeyUsage
     * @param ldapOrder set true to sort
     * 
     *   @return X509Certificate, self signed
      * @throws CertificateParsingException  If cert cannot be parsed
     * @throws OperatorCreationException if creation fails
     */
    public static X509Certificate genSelfCertForPurpose(String dn, long validity, String policyId, PrivateKey privKey, PublicKey pubKey,
            String sigAlg, boolean isCA, int keyusage, boolean ldapOrder) throws CertificateParsingException, OperatorCreationException {
<span class="fc" id="L1884">        return genSelfCertForPurpose(dn, validity, policyId, privKey, pubKey, sigAlg, isCA, keyusage, null, null, BouncyCastleProvider.PROVIDER_NAME, ldapOrder);</span>
    }

    public static X509Certificate genSelfCertForPurpose(String dn, long validity, String policyId, PrivateKey privKey, PublicKey pubKey,
            String sigAlg, boolean isCA, int keyusage, Date privateKeyNotBefore, Date privateKeyNotAfter, String provider)
            throws CertificateParsingException, OperatorCreationException {
<span class="fc" id="L1890">        return genSelfCertForPurpose(dn, validity, policyId, privKey, pubKey, sigAlg, isCA, keyusage, privateKeyNotBefore, privateKeyNotAfter,</span>
                provider, true);
    }

    public static X509Certificate genSelfCertForPurpose(String dn, long validity, String policyId, PrivateKey privKey, PublicKey pubKey,
            String sigAlg, boolean isCA, int keyusage, Date privateKeyNotBefore, Date privateKeyNotAfter, String provider, boolean ldapOrder)
            throws CertificateParsingException, OperatorCreationException {
        try {
<span class="fc" id="L1898">            return genSelfCertForPurpose(dn, validity, policyId, privKey, pubKey, sigAlg, isCA, keyusage, privateKeyNotBefore, privateKeyNotAfter,</span>
                    provider, ldapOrder, null);
<span class="nc" id="L1900">        } catch (CertIOException e) {</span>
<span class="nc" id="L1901">          throw new IllegalStateException(&quot;CertIOException was thrown due to an invalid extension, but no extensions were provided.&quot;, e);</span>
        }
    }

    public static X509Certificate genSelfCertForPurpose(String dn, long validity, String policyId, PrivateKey privKey, PublicKey pubKey,
            String sigAlg, boolean isCA, int keyusage, Date privateKeyNotBefore, Date privateKeyNotAfter, String provider, boolean ldapOrder,
            List&lt;Extension&gt; additionalExtensions) throws CertificateParsingException, OperatorCreationException, CertIOException {
        // Create self signed certificate
<span class="fc" id="L1909">        Date firstDate = new Date();</span>

        // Set back startdate ten minutes to avoid some problems with wrongly set clocks.
<span class="fc" id="L1912">        firstDate.setTime(firstDate.getTime() - (10 * 60 * 1000));</span>

<span class="fc" id="L1914">        Date lastDate = new Date();</span>

        // validity in days = validity*24*60*60*1000 milliseconds
<span class="fc" id="L1917">        lastDate.setTime(lastDate.getTime() + (validity * (24 * 60 * 60 * 1000)));</span>

<span class="fc" id="L1919">        return genSelfCertForPurpose(dn, firstDate, lastDate, policyId, privKey, pubKey, sigAlg, isCA, keyusage, privateKeyNotBefore, privateKeyNotAfter, provider, ldapOrder, additionalExtensions);</span>
    }
    
    public static X509Certificate genSelfCertForPurpose(String dn, Date firstDate, Date lastDate, String policyId, PrivateKey privKey, PublicKey pubKey,
            String sigAlg, boolean isCA, int keyusage, Date privateKeyNotBefore, Date privateKeyNotAfter, String provider, boolean ldapOrder,
            List&lt;Extension&gt; additionalExtensions) throws CertificateParsingException, OperatorCreationException, CertIOException {
        // Transform the PublicKey to be sure we have it in a format that the X509 certificate generator handles, it might be
        // a CVC public key that is passed as parameter
<span class="fc" id="L1927">        PublicKey publicKey = null;</span>
<span class="fc bfc" id="L1928" title="All 2 branches covered.">        if (pubKey instanceof RSAPublicKey) {</span>
<span class="fc" id="L1929">            RSAPublicKey rsapk = (RSAPublicKey) pubKey;</span>
<span class="fc" id="L1930">            RSAPublicKeySpec rSAPublicKeySpec = new RSAPublicKeySpec(rsapk.getModulus(), rsapk.getPublicExponent());</span>
            try {
<span class="fc" id="L1932">                publicKey = KeyFactory.getInstance(&quot;RSA&quot;).generatePublic(rSAPublicKeySpec);</span>
<span class="nc" id="L1933">            } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L1934">                log.error(&quot;Error creating RSAPublicKey from spec: &quot;, e);</span>
<span class="nc" id="L1935">                publicKey = pubKey;</span>
<span class="nc" id="L1936">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1937">                throw new IllegalStateException(&quot;RSA was not a known algorithm&quot;, e);</span>
<span class="pc" id="L1938">            }</span>
<span class="fc bfc" id="L1939" title="All 2 branches covered.">        } else if (pubKey instanceof ECPublicKey) {</span>
<span class="fc" id="L1940">            ECPublicKey ecpk = (ECPublicKey) pubKey;</span>
            try {
<span class="fc" id="L1942">                ECPublicKeySpec ecspec = new ECPublicKeySpec(ecpk.getW(), ecpk.getParams()); // will throw NPE if key is &quot;implicitlyCA&quot;</span>
<span class="fc" id="L1943">                final String algo = ecpk.getAlgorithm();</span>
<span class="pc bpc" id="L1944" title="1 of 2 branches missed.">                if (algo.equals(AlgorithmConstants.KEYALGORITHM_ECGOST3410)) {</span>
                    try {
<span class="nc" id="L1946">                        publicKey = KeyFactory.getInstance(&quot;ECGOST3410&quot;).generatePublic(ecspec);</span>
<span class="nc" id="L1947">                    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1948">                        throw new IllegalStateException(&quot;ECGOST3410 was not a known algorithm&quot;, e);</span>
<span class="nc" id="L1949">                    }</span>
<span class="pc bpc" id="L1950" title="1 of 2 branches missed.">                } else if (algo.equals(AlgorithmConstants.KEYALGORITHM_DSTU4145)) {</span>
                    try {
<span class="nc" id="L1952">                        publicKey = KeyFactory.getInstance(&quot;DSTU4145&quot;).generatePublic(ecspec);</span>
<span class="nc" id="L1953">                    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1954">                        throw new IllegalStateException(&quot;DSTU4145 was not a known algorithm&quot;, e);</span>
<span class="nc" id="L1955">                    }</span>
                } else {
                    try {
<span class="fc" id="L1958">                        publicKey = KeyFactory.getInstance(&quot;EC&quot;).generatePublic(ecspec);</span>
<span class="nc" id="L1959">                    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1960">                        throw new IllegalStateException(&quot;EC was not a known algorithm&quot;, e);</span>
<span class="fc" id="L1961">                    }</span>
                }
<span class="nc" id="L1963">            } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L1964">                log.error(&quot;Error creating ECPublicKey from spec: &quot;, e);</span>
<span class="nc" id="L1965">                publicKey = pubKey;</span>
<span class="fc" id="L1966">            } catch (NullPointerException e) {</span>
<span class="fc" id="L1967">                log.debug(&quot;NullPointerException, probably it is implicitlyCA generated keys: &quot; + e.getMessage());</span>
<span class="fc" id="L1968">                publicKey = pubKey;</span>
<span class="pc" id="L1969">            }</span>
<span class="fc" id="L1970">        } else {</span>
<span class="fc" id="L1971">            log.debug(&quot;Not converting key of class. &quot; + pubKey.getClass().getName());</span>
<span class="fc" id="L1972">            publicKey = pubKey;</span>
        }

        // Serialnumber is random bits, where random generator is initialized with Date.getTime() when this
        // bean is created.
<span class="fc" id="L1977">        byte[] serno = new byte[8];</span>
        SecureRandom random;
        try {
<span class="fc" id="L1980">            random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span>
<span class="nc" id="L1981">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1982">            throw new IllegalStateException(&quot;SHA1PRNG was not a known algorithm&quot;, e);</span>
<span class="fc" id="L1983">        }</span>
<span class="fc" id="L1984">        random.setSeed(new Date().getTime());</span>
<span class="fc" id="L1985">        random.nextBytes(serno);</span>

<span class="fc" id="L1987">        final SubjectPublicKeyInfo pkinfo = SubjectPublicKeyInfo.getInstance(publicKey.getEncoded());</span>
<span class="fc" id="L1988">        X509v3CertificateBuilder certbuilder = new X509v3CertificateBuilder(CertTools.stringToBcX500Name(dn, ldapOrder), new BigInteger(serno).abs(),</span>
<span class="fc" id="L1989">                firstDate, lastDate, CertTools.stringToBcX500Name(dn, ldapOrder), pkinfo);</span>

        // Basic constranits is always critical and MUST be present at-least in CA-certificates.
<span class="fc" id="L1992">        BasicConstraints bc = new BasicConstraints(isCA);</span>
<span class="fc" id="L1993">        certbuilder.addExtension(Extension.basicConstraints, true, bc);</span>

        // Put critical KeyUsage in CA-certificates
<span class="fc bfc" id="L1996" title="All 4 branches covered.">        if (isCA || keyusage != 0) {</span>
<span class="fc" id="L1997">            X509KeyUsage ku = new X509KeyUsage(keyusage);</span>
<span class="fc" id="L1998">            certbuilder.addExtension(Extension.keyUsage, true, ku);</span>
        }

<span class="fc bfc" id="L2001" title="All 4 branches covered.">        if ((privateKeyNotBefore != null) || (privateKeyNotAfter != null)) {</span>
<span class="fc" id="L2002">            final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L2003" title="All 2 branches covered.">            if (privateKeyNotBefore != null) {</span>
<span class="fc" id="L2004">                v.add(new DERTaggedObject(false, 0, new DERGeneralizedTime(privateKeyNotBefore)));</span>
            }
<span class="fc bfc" id="L2006" title="All 2 branches covered.">            if (privateKeyNotAfter != null) {</span>
<span class="fc" id="L2007">                v.add(new DERTaggedObject(false, 1, new DERGeneralizedTime(privateKeyNotAfter)));</span>
            }
<span class="fc" id="L2009">            certbuilder.addExtension(Extension.privateKeyUsagePeriod, false, new DERSequence(v));</span>
        }

        // Subject and Authority key identifier is always non-critical and MUST be present for certificates to verify in Firefox.
        try {
<span class="fc bfc" id="L2014" title="All 2 branches covered.">            if (isCA) {</span>
<span class="fc" id="L2015">                JcaX509ExtensionUtils extensionUtils = new JcaX509ExtensionUtils(SHA1DigestCalculator.buildSha1Instance());</span>
<span class="fc" id="L2016">                SubjectKeyIdentifier ski = extensionUtils.createSubjectKeyIdentifier(publicKey);</span>
<span class="fc" id="L2017">                AuthorityKeyIdentifier aki = extensionUtils.createAuthorityKeyIdentifier(publicKey);</span>
<span class="fc" id="L2018">                certbuilder.addExtension(Extension.subjectKeyIdentifier, false, ski);</span>
<span class="fc" id="L2019">                certbuilder.addExtension(Extension.authorityKeyIdentifier, false, aki);</span>
            }
<span class="nc" id="L2021">        } catch (IOException e) { // do nothing</span>
<span class="fc" id="L2022">        }</span>

        // CertificatePolicies extension if supplied policy ID, always non-critical
<span class="pc bpc" id="L2025" title="1 of 2 branches missed.">        if (policyId != null) {</span>
<span class="nc" id="L2026">            PolicyInformation pi = new PolicyInformation(new ASN1ObjectIdentifier(policyId));</span>
<span class="nc" id="L2027">            DERSequence seq = new DERSequence(pi);</span>
<span class="nc" id="L2028">            certbuilder.addExtension(Extension.certificatePolicies, false, seq);</span>
        }
        // Add any additional
<span class="fc bfc" id="L2031" title="All 2 branches covered.">        if (additionalExtensions != null) {</span>
<span class="fc bfc" id="L2032" title="All 2 branches covered.">            for (final Extension extension : additionalExtensions) {</span>
<span class="fc" id="L2033">                certbuilder.addExtension(extension.getExtnId(), extension.isCritical(), extension.getParsedValue());</span>
<span class="fc" id="L2034">            }</span>
        }
<span class="fc" id="L2036">        final ContentSigner signer = new BufferingContentSigner(new JcaContentSignerBuilder(sigAlg).setProvider(provider).build(privKey), 20480);</span>
<span class="fc" id="L2037">        final X509CertificateHolder certHolder = certbuilder.build(signer);</span>
        X509Certificate selfcert;
        try {
<span class="fc" id="L2040">            selfcert = (X509Certificate) CertTools.getCertfromByteArray(certHolder.getEncoded());</span>
<span class="nc" id="L2041">        } catch (IOException e) {</span>
<span class="nc" id="L2042">            throw new IllegalStateException(&quot;Unexpected IOException was caught.&quot;, e);</span>
<span class="fc" id="L2043">        }</span>

<span class="fc" id="L2045">        return selfcert;</span>
    } // genselfCertForPurpose

    /**
     * Get the authority key identifier from a certificate extensions
     * 
     * @param certificate certificate containing the extension
     * @return byte[] containing the authority key identifier, or null if it does not exist
     */
    public static byte[] getAuthorityKeyId(final Certificate certificate) {
<span class="pc bpc" id="L2055" title="2 of 4 branches missed.">        if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2056">            final ASN1Primitive asn1Sequence = getExtensionValue((X509Certificate) certificate, Extension.authorityKeyIdentifier.getId()); // &quot;2.5.29.35&quot;</span>
<span class="pc bpc" id="L2057" title="1 of 2 branches missed.">            if (asn1Sequence != null) {</span>
<span class="fc" id="L2058">                return AuthorityKeyIdentifier.getInstance(asn1Sequence).getKeyIdentifier();</span>
            }
        }
<span class="nc" id="L2061">        return null;</span>
    }

    /**
     * Get the subject key identifier from a certificate extensions
     * 
     * @param certificate certificate containing the extension
     * @return byte[] containing the subject key identifier, or null if it does not exist
     */
    public static byte[] getSubjectKeyId(final Certificate certificate) {
<span class="pc bpc" id="L2071" title="2 of 4 branches missed.">        if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2072">            final ASN1Primitive asn1Sequence = getExtensionValue((X509Certificate) certificate, Extension.subjectKeyIdentifier.getId()); // &quot;2.5.29.14&quot;</span>
<span class="pc bpc" id="L2073" title="1 of 2 branches missed.">            if (asn1Sequence != null) {</span>
<span class="fc" id="L2074">                return SubjectKeyIdentifier.getInstance(asn1Sequence).getKeyIdentifier();</span>
            }
        }
<span class="nc" id="L2077">        return null;</span>
    }

    /**
     * Get a certificate policy ID from a certificate policies extension
     * 
     * @param certificate certificate containing the extension
     * @param pos position of the policy id, if several exist, the first is as pos 0
     * @return String with the certificate policy OID, or null if an id at the given position does not exist
     * @throws IOException if extension can not be parsed
     */
    public static String getCertificatePolicyId(Certificate certificate, int pos) throws IOException {
<span class="pc bpc" id="L2089" title="2 of 4 branches missed.">        if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2090">            final ASN1Sequence asn1Sequence = (ASN1Sequence) getExtensionValue((X509Certificate) certificate, Extension.certificatePolicies.getId());</span>
<span class="pc bpc" id="L2091" title="1 of 2 branches missed.">            if (asn1Sequence != null) {</span>
                // Check the size so we don't ArrayIndexOutOfBounds
<span class="fc bfc" id="L2093" title="All 2 branches covered.">                if (asn1Sequence.size() &gt;= pos + 1) {</span>
<span class="fc" id="L2094">                    return PolicyInformation.getInstance(asn1Sequence.getObjectAt(pos)).getPolicyIdentifier().getId();</span>
                }
            }
        }
<span class="fc" id="L2098">        return null;</span>
    }

    /**
     * Get a list of certificate policy IDs from a certificate policies extension
     * 
     * @param certificate certificate containing the extension
     * @return List of ObjectIdentifiers, or empty list if no policies exist
     * @throws IOException if extension can not be parsed
     */
    public static List&lt;ASN1ObjectIdentifier&gt; getCertificatePolicyIds(Certificate certificate) throws IOException {
<span class="fc" id="L2109">        List&lt;ASN1ObjectIdentifier&gt; ret = new ArrayList&lt;ASN1ObjectIdentifier&gt;();</span>
<span class="pc bpc" id="L2110" title="2 of 4 branches missed.">        if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2111">            final ASN1Sequence asn1Sequence = (ASN1Sequence) getExtensionValue((X509Certificate) certificate, Extension.certificatePolicies.getId());</span>
<span class="fc bfc" id="L2112" title="All 2 branches covered.">            if (asn1Sequence != null) {</span>
<span class="fc bfc" id="L2113" title="All 2 branches covered.">                for (ASN1Encodable asn1Encodable : asn1Sequence) {</span>
<span class="fc" id="L2114">                    PolicyInformation pi = PolicyInformation.getInstance(asn1Encodable);</span>
<span class="fc" id="L2115">                    ret.add(pi.getPolicyIdentifier());</span>
<span class="fc" id="L2116">                }</span>
            }
        }
<span class="fc" id="L2119">        return ret;</span>
    }

    /**
     * Get a list of certificate policy information from a certificate policies extension
     * 
     * @param certificate certificate containing the extension
     * @return List of PolicyInformation, or empty list if no policies exist
     * @throws IOException if extension can not be parsed
     */
    public static List&lt;PolicyInformation&gt; getCertificatePolicies(Certificate certificate) throws IOException {
<span class="fc" id="L2130">        List&lt;PolicyInformation&gt; ret = new ArrayList&lt;PolicyInformation&gt;();</span>
<span class="pc bpc" id="L2131" title="2 of 4 branches missed.">        if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2132">            final ASN1Sequence asn1Sequence = (ASN1Sequence) getExtensionValue((X509Certificate) certificate, Extension.certificatePolicies.getId());</span>
<span class="pc bpc" id="L2133" title="1 of 2 branches missed.">            if (asn1Sequence != null) {</span>
<span class="fc bfc" id="L2134" title="All 2 branches covered.">                for (ASN1Encodable asn1Encodable : asn1Sequence) {</span>
<span class="fc" id="L2135">                    PolicyInformation pi = PolicyInformation.getInstance(asn1Encodable);</span>
<span class="fc" id="L2136">                    ret.add(pi);</span>
<span class="fc" id="L2137">                }</span>
            }
        }
<span class="fc" id="L2140">        return ret;</span>
    }

    /**
     * Gets the Microsoft specific UPN altName (altName, OtherName).
     * 
     * UPN is an OtherName Subject Alternative Name:
     * 
     * OtherName ::= SEQUENCE { type-id OBJECT IDENTIFIER, value [0] EXPLICIT ANY DEFINED BY type-id }
     * 
     * UPN ::= UTF8String
     * 
     * @param cert certificate containing the extension
     * @return String with the UPN name or null if the altName does not exist
     * @throws IOException On disk error
     * @throws CertificateParsingException if cert parse fails 
     */
    public static String getUPNAltName(Certificate cert) throws IOException, CertificateParsingException {
<span class="fc" id="L2158">        return getUTF8AltNameOtherName(cert, CertTools.UPN_OBJECTID);</span>
    }

    /**
     * Gets a UTF8 OtherName altName (altName, OtherName).
     * 
     * Like UPN and XmpAddr
     * 
     * An OtherName Subject Alternative Name:
     * 
     * OtherName ::= SEQUENCE { type-id OBJECT IDENTIFIER, value [0] EXPLICIT ANY DEFINED BY type-id }
     * 
     * UPN ::= UTF8String
     * (subjectAltName=otherName:1.3.6.1.4.1.311.20.2.3;UTF8:username@some.domain)
     * XmppAddr ::= UTF8String
     * (subjectAltName=otherName:1.3.6.1.5.5.7.8.5;UTF8:username@some.domain)
     * 
     * CertTools.UPN_OBJECTID = &quot;1.3.6.1.4.1.311.20.2.3&quot;;
     * CertTools.XMPPADDR_OBJECTID = &quot;1.3.6.1.5.5.7.8.5&quot;;
     * CertTools.SRVNAME_OBJECTID = &quot;1.3.6.1.5.5.7.8.7&quot;;
     * 
     * @param cert certificate containing the extension
     * @param oid the OID of the OtherName
     * @return String with the UTF8 name or null if the altName does not exist
     * @throws IOException On disk error
     * @throws CertificateParsingException if cert parse fails 
     */
    public static String getUTF8AltNameOtherName(final Certificate cert, final String oid) throws IOException, CertificateParsingException {
<span class="fc" id="L2186">        String ret = null;</span>
<span class="pc bpc" id="L2187" title="1 of 2 branches missed.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L2188">            X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L2189">            Collection&lt;List&lt;?&gt;&gt; altNames = x509cert.getSubjectAlternativeNames();</span>
<span class="pc bpc" id="L2190" title="1 of 2 branches missed.">            if (altNames != null) {</span>
<span class="pc bpc" id="L2191" title="1 of 2 branches missed.">                for (final List&lt;?&gt; next : altNames) {</span>
<span class="fc" id="L2192">                    ret = getUTF8StringFromSequence(getAltnameSequence(next), oid);</span>
<span class="fc bfc" id="L2193" title="All 2 branches covered.">                    if (ret != null) {</span>
<span class="fc" id="L2194">                        break;</span>
                    }
<span class="fc" id="L2196">                }</span>
            }
        }
<span class="fc" id="L2199">        return ret;</span>
    }

    /**
     * Helper method for the above method.
     * 
     * @param seq the OtherName sequence
     * @param oid OID
     * @return String which is the decoded ASN.1 UTF8 String of the (simple) OtherName
     */
    private static String getUTF8StringFromSequence(final ASN1Sequence seq, final String oid) {
<span class="fc bfc" id="L2210" title="All 2 branches covered.">        if (seq != null) {</span>
            // First in sequence is the object identifier, that we must check
<span class="fc" id="L2212">            ASN1ObjectIdentifier id = ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L2213" title="1 of 2 branches missed.">            if (id.getId().equals(oid)) {</span>
<span class="fc" id="L2214">                ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
                // Due to bug in java cert.getSubjectAltName regarding OtherName, it can be tagged an extra time...
<span class="fc" id="L2216">                ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L2217" title="1 of 2 branches missed.">                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L2218">                    obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                }
<span class="fc" id="L2220">                DERUTF8String str = DERUTF8String.getInstance(obj);</span>
<span class="fc" id="L2221">                return str.getString();</span>
            }
        }
<span class="fc" id="L2224">        return null;</span>
    }

    /**
     * Helper method.
     * 
     * @param seq the OtherName sequence
     * @param oid OID
     * @return String which is the decoded ASN.1 IA5String of the (simple) OtherName
     */
    private static String getIA5StringFromSequence(final ASN1Sequence seq, final String oid) {
<span class="pc bpc" id="L2235" title="1 of 2 branches missed.">        if (seq != null) {</span>
            // First in sequence is the object identifier, that we must check
<span class="fc" id="L2237">            ASN1ObjectIdentifier id = ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L2238" title="1 of 2 branches missed.">            if (id.getId().equals(oid)) {</span>
<span class="fc" id="L2239">                ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
                // Due to bug in java cert.getSubjectAltName regarding OtherName, it can be tagged an extra time...
<span class="fc" id="L2241">                ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L2242" title="1 of 2 branches missed.">                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L2243">                    obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                }
<span class="fc" id="L2245">                DERIA5String str = DERIA5String.getInstance(obj);</span>
<span class="fc" id="L2246">                return str.getString();</span>
            }
        }
<span class="nc" id="L2249">        return null;</span>
    }

    /**
     * Helper method.
     * 
     * @param seq the OtherName sequence
     * @param oid OID
     * @return bytes which is the decoded ASN.1 Octet String of the (simple) OtherName
     */
    private static byte[] getOctetStringFromSequence(final ASN1Sequence seq, final String oid) {
<span class="pc bpc" id="L2260" title="1 of 2 branches missed.">        if (seq != null) {</span>
            // First in sequence is the object identifier, that we must check
<span class="fc" id="L2262">            ASN1ObjectIdentifier id = ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L2263" title="1 of 2 branches missed.">            if (id.getId().equals(oid)) {</span>
<span class="fc" id="L2264">                ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
                // Due to bug in java cert.getSubjectAltName regarding OtherName, it can be tagged an extra time...
<span class="fc" id="L2266">                ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L2268">                    obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                }
<span class="fc" id="L2270">                ASN1OctetString str = ASN1OctetString.getInstance(obj);</span>
<span class="fc" id="L2271">                return str.getOctets();</span>
            }
        }
<span class="nc" id="L2274">        return null;</span>
    }

    /**
     * Gets the Permanent Identifier (altName, OtherName).
     * 
     * permanentIdentifier is an OtherName Subject Alternative Name:
     * 
     * OtherName ::= SEQUENCE { type-id OBJECT IDENTIFIER, value [0] EXPLICIT ANY DEFINED BY type-id }
     * 
     * -- Permanent Identifier
     *
     *   permanentIdentifier OTHER-NAME ::=
     * { PermanentIdentifier IDENTIFIED BY id-on-permanentIdentifier }
     *
     * PermanentIdentifier ::= SEQUENCE {
     *  identifierValue    UTF8String             OPTIONAL,
     *                  -- if absent, use the serialNumber attribute
     *                  -- if there is a single such attribute present
     *                  -- in the subject DN
     *  assigner           OBJECT IDENTIFIER      OPTIONAL
     *                  -- if absent, the assigner is
     *                  -- the certificate issuer
     * }
     * 
     * @param cert certificate containing the extension
     * @return String with the permanentIdentifier name or null if the altName does not exist
     * @throws IOException On disk error
     * @throws CertificateParsingException if cert parse fails 
     */
    public static String getPermanentIdentifierAltName(Certificate cert) throws IOException, CertificateParsingException {
<span class="fc" id="L2305">        String ret = null;</span>
<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L2307">            X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L2308">            Collection&lt;List&lt;?&gt;&gt; altNames = x509cert.getSubjectAlternativeNames();</span>
<span class="pc bpc" id="L2309" title="1 of 2 branches missed.">            if (altNames != null) {</span>
<span class="fc" id="L2310">                Iterator&lt;List&lt;?&gt;&gt; i = altNames.iterator();</span>
<span class="pc bpc" id="L2311" title="1 of 2 branches missed.">                while (i.hasNext()) {</span>
<span class="fc" id="L2312">                    ASN1Sequence seq = getAltnameSequence(i.next());</span>
<span class="fc" id="L2313">                    ret = getPermanentIdentifierStringFromSequence(seq);</span>
<span class="fc bfc" id="L2314" title="All 2 branches covered.">                    if (ret != null) {</span>
<span class="fc" id="L2315">                        break;</span>
                    }
<span class="fc" id="L2317">                }</span>
            }
        }
<span class="fc" id="L2320">        return ret;</span>
    } // getPermanentIdentifierAltName

    /**
     * (This method intentionally has package level visibility to be able to be invoked from JUnit tests.)
     * @param seq asn.1 sequence
     * @return The extension values encoded as an permanentIdentifierString
     */
    static String getPermanentIdentifierStringFromSequence(ASN1Sequence seq) {
<span class="pc bpc" id="L2329" title="1 of 2 branches missed.">        if (seq != null) {</span>
            // First in sequence is the object identifier, that we must check
<span class="fc" id="L2331">            ASN1ObjectIdentifier id = ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="fc bfc" id="L2332" title="All 2 branches covered.">            if (id.getId().equals(CertTools.PERMANENTIDENTIFIER_OBJECTID)) {</span>
<span class="fc" id="L2333">                String identifierValue = null;</span>
<span class="fc" id="L2334">                String assigner = null;</span>

                // Get the PermanentIdentifier sequence
<span class="fc" id="L2337">                ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
                // Due to bug in java cert.getSubjectAltName regarding OtherName, it can be tagged an extra time...
<span class="fc" id="L2339">                ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L2340" title="1 of 2 branches missed.">                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L2341">                    obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                }
<span class="fc" id="L2343">                ASN1Sequence piSeq = ASN1Sequence.getInstance(obj);</span>

<span class="fc" id="L2345">                Enumeration&lt;?&gt; e = piSeq.getObjects();</span>
<span class="fc bfc" id="L2346" title="All 2 branches covered.">                if (e.hasMoreElements()) {</span>
<span class="fc" id="L2347">                    Object element = e.nextElement();</span>
<span class="fc bfc" id="L2348" title="All 2 branches covered.">                    if (element instanceof DERUTF8String) {</span>
<span class="fc" id="L2349">                        identifierValue = ((DERUTF8String) element).getString();</span>
<span class="fc bfc" id="L2350" title="All 2 branches covered.">                        if (e.hasMoreElements()) {</span>
<span class="fc" id="L2351">                            element = e.nextElement();</span>
                        }
                    }
<span class="fc bfc" id="L2354" title="All 2 branches covered.">                    if (element instanceof ASN1ObjectIdentifier) {</span>
<span class="fc" id="L2355">                        assigner = ((ASN1ObjectIdentifier) element).getId();</span>
                    }
                }

<span class="fc" id="L2359">                StringBuilder buff = new StringBuilder();</span>
<span class="fc bfc" id="L2360" title="All 2 branches covered.">                if (identifierValue != null) {</span>
<span class="fc" id="L2361">                    buff.append(escapePermanentIdentifierValue(identifierValue));</span>
                }
<span class="fc" id="L2363">                buff.append(PERMANENTIDENTIFIER_SEP);</span>
<span class="fc bfc" id="L2364" title="All 2 branches covered.">                if (assigner != null) {</span>
<span class="fc" id="L2365">                    buff.append(assigner);</span>
                }
<span class="fc" id="L2367">                return buff.toString();</span>
            }
        }
<span class="fc" id="L2370">        return null;</span>
    }

    private static String escapePermanentIdentifierValue(String realValue) {
<span class="fc" id="L2374">        return realValue.replace(PERMANENTIDENTIFIER_SEP, &quot;\\&quot; + PERMANENTIDENTIFIER_SEP);</span>
    }

    private static String unescapePermanentIdentifierValue(String escapedValue) {
<span class="fc" id="L2378">        return escapedValue.replace(&quot;\\&quot; + PERMANENTIDENTIFIER, PERMANENTIDENTIFIER);</span>
    }

    /**
     * (This method intentionally has package level visibility to be able to be invoked from JUnit tests.)
     * @param permanentIdentifierString filter
     * @return A two elements String array with the extension values
     */
    static String[] getPermanentIdentifierValues(String permanentIdentifierString) {
<span class="fc" id="L2387">        String[] result = new String[2];</span>
<span class="fc" id="L2388">        int sepPos = permanentIdentifierString.lastIndexOf(PERMANENTIDENTIFIER_SEP);</span>
<span class="fc bfc" id="L2389" title="All 2 branches covered.">        if (sepPos == -1) {</span>
<span class="fc bfc" id="L2390" title="All 2 branches covered.">            if (!permanentIdentifierString.isEmpty()) {</span>
<span class="fc" id="L2391">                result[0] = unescapePermanentIdentifierValue(permanentIdentifierString);</span>
            }
<span class="fc bfc" id="L2393" title="All 2 branches covered.">        } else if (sepPos == 0) {</span>
<span class="fc bfc" id="L2394" title="All 2 branches covered.">            if (permanentIdentifierString.length() &gt; 1) {</span>
<span class="fc" id="L2395">                result[1] = permanentIdentifierString.substring(1);</span>
            }
<span class="pc bpc" id="L2397" title="1 of 2 branches missed.">        } else if (permanentIdentifierString.charAt(sepPos - PERMANENTIDENTIFIER_SEP.length()) != '\\') {</span>
<span class="fc" id="L2398">            result[0] = unescapePermanentIdentifierValue(permanentIdentifierString.substring(0, sepPos));</span>
<span class="fc bfc" id="L2399" title="All 2 branches covered.">            if (permanentIdentifierString.length() &gt; sepPos + PERMANENTIDENTIFIER_SEP.length()) {</span>
<span class="fc" id="L2400">                result[1] = permanentIdentifierString.substring(sepPos + 1);</span>
            }
        }
<span class="fc" id="L2403">        return result;</span>
    }
    
    /**
     * Helper method to get MS GUID from GeneralName otherName sequence
     * 
     * @param seq the OtherName sequence
     * @return GUID
     */
    private static String getGUIDStringFromSequence(ASN1Sequence seq) {
<span class="fc" id="L2413">        String ret = null;</span>
<span class="pc bpc" id="L2414" title="1 of 2 branches missed.">        if (seq != null) {</span>
            // First in sequence is the object identifier, that we must check
<span class="fc" id="L2416">            ASN1ObjectIdentifier id = ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="fc bfc" id="L2417" title="All 2 branches covered.">            if (id.getId().equals(CertTools.GUID_OBJECTID)) {</span>
<span class="fc" id="L2418">                ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
                // Due to bug in java cert.getSubjectAltName regarding OtherName, it can be tagged an extra time...
<span class="fc" id="L2420">                ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L2421" title="1 of 2 branches missed.">                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L2422">                    obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                }
<span class="fc" id="L2424">                ASN1OctetString str = ASN1OctetString.getInstance(obj);</span>
<span class="fc" id="L2425">                ret = new String(Hex.encode(str.getOctets()));</span>
            }
        }
<span class="fc" id="L2428">        return ret;</span>
    }

    /**
     * Helper method for getting kerberos 5 principal name (altName, OtherName)
     * 
     * Krb5PrincipalName is an OtherName Subject Alternative Name
     * 
     * String representation is in form &quot;principalname1/principalname2@realm&quot;
     * 
     * KRB5PrincipalName ::= SEQUENCE { realm [0] Realm, principalName [1] PrincipalName }
     * 
     * Realm ::= KerberosString
     * 
     * PrincipalName ::= SEQUENCE { name-type [0] Int32, name-string [1] SEQUENCE OF KerberosString }
     * 
     * The new (post-RFC 1510) type KerberosString, defined below, is a GeneralString that is constrained to contain only characters in IA5String.
     * 
     * KerberosString ::= GeneralString (IA5String)
     * 
     * Int32 ::= INTEGER (-2147483648..2147483647) -- signed values representable in 32 bits
     * 
     * @param seq the OtherName sequence
     * @return String with the krb5 name in the form of &quot;principal1/principal2@realm&quot; or null if the altName does not exist
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    protected static String getKrb5PrincipalNameFromSequence(ASN1Sequence seq) {
<span class="fc" id="L2455">        String ret = null;</span>
<span class="pc bpc" id="L2456" title="1 of 2 branches missed.">        if (seq != null) {</span>
            // First in sequence is the object identifier, that we must check
<span class="fc" id="L2458">            ASN1ObjectIdentifier id = ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L2459" title="1 of 2 branches missed.">            if (id.getId().equals(CertTools.KRB5PRINCIPAL_OBJECTID)) {</span>
                // Get the KRB5PrincipalName sequence
<span class="fc" id="L2461">                ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
                // Due to bug in java cert.getSubjectAltName regarding OtherName, it can be tagged an extra time...
<span class="fc" id="L2463">                ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L2464" title="1 of 2 branches missed.">                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L2465">                    obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                }
<span class="fc" id="L2467">                ASN1Sequence krb5Seq = ASN1Sequence.getInstance(obj);</span>
                // Get the Realm tagged as 0
<span class="fc" id="L2469">                ASN1TaggedObject robj = (ASN1TaggedObject) krb5Seq.getObjectAt(0);</span>
<span class="fc" id="L2470">                DERGeneralString realmObj = DERGeneralString.getInstance(robj.getObject());</span>
<span class="fc" id="L2471">                String realm = realmObj.getString();</span>
                // Get the PrincipalName tagged as 1
<span class="fc" id="L2473">                ASN1TaggedObject pobj = (ASN1TaggedObject) krb5Seq.getObjectAt(1);</span>
                // This is another sequence of type and name
<span class="fc" id="L2475">                ASN1Sequence nseq = ASN1Sequence.getInstance(pobj.getObject());</span>
                // Get the name tagged as 1
<span class="fc" id="L2477">                ASN1TaggedObject nobj = (ASN1TaggedObject) nseq.getObjectAt(1);</span>
                // The name is yet another sequence of GeneralString
<span class="fc" id="L2479">                ASN1Sequence sseq = ASN1Sequence.getInstance(nobj.getObject());</span>
<span class="fc" id="L2480">                Enumeration&lt;ASN1Object&gt; en = sseq.getObjects();</span>
<span class="fc bfc" id="L2481" title="All 2 branches covered.">                while (en.hasMoreElements()) {</span>
<span class="fc" id="L2482">                    ASN1Primitive o = (ASN1Primitive) en.nextElement();</span>
<span class="fc" id="L2483">                    DERGeneralString str = DERGeneralString.getInstance(o);</span>
<span class="fc bfc" id="L2484" title="All 2 branches covered.">                    if (ret != null) {</span>
<span class="fc" id="L2485">                        ret += &quot;/&quot; + str.getString();</span>
                    } else {
<span class="fc" id="L2487">                        ret = str.getString();</span>
                    }
<span class="fc" id="L2489">                }</span>
                // Add the realm in the end so we have &quot;principal@realm&quot;
<span class="fc" id="L2491">                ret += &quot;@&quot; + realm;</span>
            }
        }
<span class="fc" id="L2494">        return ret;</span>
    }

    /**
     * Gets the Microsoft specific GUID altName, that is encoded as an octect string.
     * 
     * @param cert certificate containing the extension
     * @return String with the hex-encoded GUID byte array or null if the altName does not exist
     * @throws IOException On disk error
     * @throws CertificateParsingException if cert parse fails 
     */
    public static String getGuidAltName(Certificate cert) throws IOException, CertificateParsingException {
<span class="pc bpc" id="L2506" title="1 of 2 branches missed.">        if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L2507">            X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L2508">            Collection&lt;List&lt;?&gt;&gt; altNames = x509cert.getSubjectAlternativeNames();</span>
<span class="pc bpc" id="L2509" title="1 of 2 branches missed.">            if (altNames != null) {</span>
<span class="fc" id="L2510">                Iterator&lt;List&lt;?&gt;&gt; i = altNames.iterator();</span>
<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">                while (i.hasNext()) {</span>
<span class="fc" id="L2512">                    ASN1Sequence seq = getAltnameSequence(i.next());</span>
<span class="fc bfc" id="L2513" title="All 2 branches covered.">                    if (seq != null) {</span>
<span class="fc" id="L2514">                        String guid = CertTools.getGUIDStringFromSequence(seq);</span>
<span class="fc bfc" id="L2515" title="All 2 branches covered.">                        if (guid != null) {</span>
<span class="fc" id="L2516">                            return guid;</span>
                        }
                    }
<span class="fc" id="L2519">                }</span>
            }
        }
<span class="nc" id="L2522">        return null;</span>
    } // getGuidAltName

    /**
     * Helper for the above methods
     * @param listitem item
     * @return asn.1
     */
    private static ASN1Sequence getAltnameSequence(List&lt;?&gt; listitem) {
<span class="fc" id="L2531">        Integer no = (Integer) listitem.get(0);</span>
<span class="fc bfc" id="L2532" title="All 2 branches covered.">        if (no.intValue() == 0) {</span>
<span class="fc" id="L2533">            byte[] altName = (byte[]) listitem.get(1);</span>
<span class="fc" id="L2534">            return getAltnameSequence(altName);</span>
        }
<span class="fc" id="L2536">        return null;</span>
    }

    private static ASN1Sequence getAltnameSequence(byte[] value) {
<span class="fc" id="L2540">        ASN1Primitive oct = null;</span>
        try {
<span class="fc" id="L2542">            oct = ASN1Primitive.fromByteArray(value);</span>
<span class="nc" id="L2543">        } catch (IOException e) {</span>
<span class="nc" id="L2544">            throw new RuntimeException(&quot;Could not read ASN1InputStream&quot;, e);</span>
<span class="fc" id="L2545">        }</span>
<span class="fc bfc" id="L2546" title="All 2 branches covered.">        if (oct instanceof ASN1TaggedObject) {</span>
<span class="fc" id="L2547">            oct = ((ASN1TaggedObject) oct).getObject();</span>
        }
<span class="fc" id="L2549">        ASN1Sequence seq = ASN1Sequence.getInstance(oct);</span>
<span class="fc" id="L2550">        return seq;</span>
    }

    /**
     * Gets an altName string from an X509Extension
     * 
     * @param ext X509Extension with AlternativeNames
     * @return String as defined in method getSubjectAlternativeName
     */
    public static String getAltNameStringFromExtension(Extension ext) {
<span class="fc" id="L2560">        String altName = null;</span>
        // GeneralNames, the actual encoded name
<span class="fc" id="L2562">        GeneralNames names = getGeneralNamesFromExtension(ext);</span>
<span class="pc bpc" id="L2563" title="1 of 2 branches missed.">        if (names != null) {</span>
            try {
<span class="fc" id="L2565">                GeneralName[] gns = names.getNames();</span>
<span class="fc bfc" id="L2566" title="All 2 branches covered.">                for (GeneralName gn : gns) {</span>
<span class="fc" id="L2567">                    int tag = gn.getTagNo();</span>
<span class="fc" id="L2568">                    ASN1Encodable name = gn.getName();</span>
<span class="fc" id="L2569">                    String str = CertTools.getGeneralNameString(tag, name);</span>
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">                    if (str == null) {</span>
<span class="nc" id="L2571">                        continue;</span>
                    }
<span class="fc bfc" id="L2573" title="All 2 branches covered.">                    if (altName == null) {</span>
<span class="fc" id="L2574">                        altName = escapeFieldValue(str);</span>
                    } else {
<span class="fc" id="L2576">                        altName += &quot;, &quot; + escapeFieldValue(str);</span>
                    }
                }
<span class="nc" id="L2579">            } catch (IOException e) {</span>
<span class="nc" id="L2580">                log.error(&quot;IOException parsing altNames: &quot;, e);</span>
<span class="nc" id="L2581">                return null;</span>
<span class="fc" id="L2582">            }</span>
        }
<span class="fc" id="L2584">        return altName;</span>
    }

    /**
     * Gets GeneralNames from an X509Extension
     * 
     * @param ext X509Extension with AlternativeNames
     * @return GeneralNames with all Alternative Names
     */
    public static GeneralNames getGeneralNamesFromExtension(Extension ext) {
<span class="fc" id="L2594">        ASN1Encodable gnames = ext.getParsedValue();</span>
<span class="pc bpc" id="L2595" title="1 of 2 branches missed.">        if (gnames != null) {</span>
<span class="fc" id="L2596">                GeneralNames names = GeneralNames.getInstance(gnames);</span>
<span class="fc" id="L2597">                return names;</span>
        }
<span class="nc" id="L2599">        return null;</span>
    }
    
    /**
     * Escapes a value of a field in a DN, SAN or directory attributes.
     * Unlike LDAPDN.escapeRDN, this method allows empty values (e.g. DNSNAME=)
     * @param value Value to escape, with or without the XX=
     * @return Escaped string
     */
    protected static String escapeFieldValue(final String value) {
<span class="fc bfc" id="L2609" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L2610">            return null;</span>
<span class="fc bfc" id="L2611" title="All 2 branches covered.">        } else if (value.indexOf('=') == value.length()-1) {</span>
<span class="fc" id="L2612">            return value;</span>
        } else {
<span class="fc" id="L2614">            return LDAPDN.escapeRDN(value);</span>
        }
    }
    
    /**
     * Unescapes a value of a field in a DN, SAN or directory attributes.
     * Unlike LDAPDN.unescapeRDN, this method handles value without the field name (e.g. example.com) and empty values (e.g. DNSNAME=)
     * @param value Value to unescape
     * @return Unescaped string
     */
    protected static String unescapeFieldValue(final String value) {
<span class="fc bfc" id="L2625" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L2626">            return null;</span>
        } else {
<span class="fc" id="L2628">            return UNESCAPE_FIELD_REGEX.matcher(value).replaceAll(&quot;$1&quot;);</span>
        }
    }

    
    /**
     * SubjectAltName ::= GeneralNames
     * 
     * GeneralNames :: = SEQUENCE SIZE (1..MAX) OF GeneralName
     * 
     * GeneralName ::= CHOICE { otherName [0] OtherName, rfc822Name [1] IA5String, dNSName [2] IA5String, x400Address [3] ORAddress, directoryName [4]
     * Name, ediPartyName [5] EDIPartyName, uniformResourceIdentifier [6] IA5String, iPAddress [7] OCTET STRING, registeredID [8] OBJECT IDENTIFIER}
     * 
     * SubjectAltName is of form \&quot;rfc822Name=&amp;lt;email&amp;gt;, dNSName=&amp;lt;host name&amp;gt;, uniformResourceIdentifier=&amp;lt;http://host.com/&amp;gt;, iPAddress=&amp;lt;address&amp;gt;,
     * guid=&amp;lt;globally unique id&amp;gt;, directoryName=&amp;lt;CN=testDirName|dir|name&amp;gt;, permanentIdentifier=&amp;lt;identifierValue/assigner|identifierValue|/assigner|/&amp;gt;
     * 
     * Supported altNames are upn, krb5principal, rfc822Name, uniformResourceIdentifier, dNSName, iPAddress, directoryName, permanentIdentifier
     * 
     * @author Marco Ferrante, (c) 2005 CSITA - University of Genoa (Italy)
     * @author Tomas Gustavsson
     * @param certificate containing alt names
     * @return String containing altNames of form
     *         &quot;rfc822Name=email, dNSName=hostname, uniformResourceIdentifier=uri, iPAddress=ip, upn=upn, directoryName=CN=testDirName|dir|name&quot;, permanentIdentifier=identifierValue/assigner or
     *         empty string if no altNames exist. Values in returned String is from CertTools constants. AltNames not supported are simply not shown
     *         in the resulting string.
     */
    public static String getSubjectAlternativeName(Certificate certificate) {
<span class="pc bpc" id="L2655" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2656">            log.trace(&quot;&gt;getSubjectAlternativeName&quot;);</span>
        }
<span class="fc" id="L2658">        String result = &quot;&quot;;</span>
<span class="pc bpc" id="L2659" title="1 of 2 branches missed.">        if (certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2660">            X509Certificate x509cert = (X509Certificate) certificate;</span>

<span class="fc" id="L2662">            Collection&lt;List&lt;?&gt;&gt; altNames = null;</span>

            try {
<span class="fc" id="L2665">                altNames = x509cert.getSubjectAlternativeNames();</span>
<span class="nc" id="L2666">            } catch (CertificateParsingException e) {</span>
<span class="nc" id="L2667">                throw new RuntimeException(&quot;Could not parse certificate&quot;, e);</span>
<span class="fc" id="L2668">            }</span>

<span class="pc bpc" id="L2670" title="1 of 2 branches missed.">            if (altNames == null) {</span>
<span class="nc" id="L2671">                return null;</span>
            }
<span class="fc" id="L2673">            final Iterator&lt;List&lt;?&gt;&gt; iter = altNames.iterator();</span>
<span class="fc" id="L2674">            String append = new String();</span>
<span class="fc" id="L2675">            List&lt;?&gt; item = null;</span>
<span class="fc" id="L2676">            Integer type = null;</span>
<span class="fc" id="L2677">            Object value = null;</span>
<span class="fc bfc" id="L2678" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L2679">                item = iter.next();</span>
<span class="fc" id="L2680">                type = (Integer) item.get(0);</span>
<span class="fc" id="L2681">                value = item.get(1);</span>
<span class="fc bfc" id="L2682" title="All 2 branches covered.">                if (!StringUtils.isEmpty(result)) {</span>
                    // Result already contains one altname, so we have to add comma if there are more altNames
<span class="fc" id="L2684">                    append = &quot;, &quot;;</span>
                }
<span class="fc" id="L2686">                String rdn = null;</span>
<span class="pc bpc" id="L2687" title="3 of 10 branches missed.">                switch (type.intValue()) {</span>
                case 0:
                    // OtherName, can be a lot of different things
<span class="fc" id="L2690">                    final ASN1Sequence sequence = getAltnameSequence(item);</span>
<span class="fc" id="L2691">                    final ASN1ObjectIdentifier oid = ASN1ObjectIdentifier.getInstance(sequence.getObjectAt(0));</span>
<span class="pc bpc" id="L2692" title="2 of 9 branches missed.">                    switch(oid.getId()) {</span>
                        case CertTools.UPN_OBJECTID:
<span class="fc" id="L2694">                            rdn = CertTools.UPN + &quot;=&quot; + getUTF8StringFromSequence(sequence, CertTools.UPN_OBJECTID);</span>
<span class="fc" id="L2695">                            break;</span>
                        case CertTools.PERMANENTIDENTIFIER_OBJECTID:
<span class="fc" id="L2697">                            rdn = CertTools.PERMANENTIDENTIFIER + &quot;=&quot; + getPermanentIdentifierStringFromSequence(sequence);</span>
<span class="fc" id="L2698">                            break;</span>
                        case CertTools.KRB5PRINCIPAL_OBJECTID:
<span class="fc" id="L2700">                            rdn = CertTools.KRB5PRINCIPAL + &quot;=&quot; + getKrb5PrincipalNameFromSequence(sequence);</span>
<span class="fc" id="L2701">                            break;</span>
                        case RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD_OBJECTID:
<span class="nc" id="L2703">                            final String sim = RFC4683Tools.getSimStringSequence(sequence);</span>
<span class="nc" id="L2704">                            rdn = RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD + &quot;=&quot; + sim;</span>
<span class="nc" id="L2705">                            break;</span>
                        case CertTools.GUID_OBJECTID:
<span class="fc" id="L2707">                            rdn = CertTools.GUID + &quot;=&quot; + getGUIDStringFromSequence(sequence);</span>
<span class="fc" id="L2708">                            break;</span>
                        case CertTools.XMPPADDR_OBJECTID:
<span class="fc" id="L2710">                            rdn = CertTools.XMPPADDR + &quot;=&quot; + getUTF8StringFromSequence(sequence, CertTools.XMPPADDR_OBJECTID);</span>
<span class="fc" id="L2711">                            break;</span>
                        case CertTools.SRVNAME_OBJECTID:
<span class="fc" id="L2713">                            rdn = CertTools.SRVNAME + &quot;=&quot; + getIA5StringFromSequence(sequence, CertTools.SRVNAME_OBJECTID);</span>
<span class="fc" id="L2714">                            break;</span>
                        case CertTools.FASCN_OBJECTID:
                            // PIV FASC-N (FIPS 201-2) is an OCTET STRING, we'll return if as a hex encoded String
<span class="fc" id="L2717">                            rdn = CertTools.FASCN + &quot;=&quot; + new String(Hex.encode(getOctetStringFromSequence(sequence, CertTools.FASCN_OBJECTID)));</span>
                            break;
                    };
<span class="fc" id="L2720">                    break;</span>
                case 1:
<span class="fc" id="L2722">                    rdn = CertTools.EMAIL + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L2723">                    break;</span>
                case 2:
<span class="fc" id="L2725">                    rdn = CertTools.DNS + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L2726">                    break;</span>
                case 3: // SubjectAltName of type x400Address not supported
<span class="nc" id="L2728">                    break;</span>
                case 4:
<span class="fc" id="L2730">                    rdn = CertTools.DIRECTORYNAME + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L2731">                    break;</span>
                case 5: // SubjectAltName of type ediPartyName not supported
<span class="nc" id="L2733">                    break;</span>
                case 6:
<span class="fc" id="L2735">                    rdn = CertTools.URI + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L2736">                    break;</span>
                case 7:
<span class="fc" id="L2738">                    rdn = CertTools.IPADDR + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L2739">                    break;</span>
                case 8:
                    // OID names are returned as Strings according to the JDK X509Certificate javadoc
<span class="fc" id="L2742">                    rdn = CertTools.REGISTEREDID + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L2743">                    break;</span>
                default: // SubjectAltName of unknown type
                    break;
                }
<span class="pc bpc" id="L2747" title="1 of 2 branches missed.">                if (rdn != null) {</span>
                    // The rdn might contain commas, so escape it.
<span class="fc" id="L2749">                    result += append + escapeFieldValue(rdn);</span>
                }
<span class="fc" id="L2751">            }</span>
<span class="pc bpc" id="L2752" title="1 of 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2753">                log.trace(&quot;&lt;getSubjectAlternativeName: &quot; + result);</span>
            }
<span class="pc bpc" id="L2755" title="1 of 2 branches missed.">            if (StringUtils.isEmpty(result)) {</span>
<span class="nc" id="L2756">                return null;</span>
            }
        }
<span class="fc" id="L2759">        return result;</span>
    }

    /**
     * From an altName string as defined in getSubjectAlternativeName
     * 
     * @param altName name
     * @return ASN.1 GeneralNames
     * @see #getSubjectAlternativeName
     */
    public static GeneralNames getGeneralNamesFromAltName(final String altName) {
<span class="pc bpc" id="L2770" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2771">            log.trace(&quot;&gt;getGeneralNamesFromAltName: &quot; + altName);</span>
        }
<span class="fc" id="L2773">        final ASN1EncodableVector vec = new ASN1EncodableVector();</span>

<span class="fc bfc" id="L2775" title="All 2 branches covered.">        for (final String email : CertTools.getEmailFromDN(altName)) {</span>
<span class="fc" id="L2776">            vec.add(new GeneralName(1, /*new DERIA5String(iter.next())*/email));</span>
<span class="fc" id="L2777">        }</span>

<span class="fc bfc" id="L2779" title="All 2 branches covered.">        for (final String dns : CertTools.getPartsFromDN(altName, CertTools.DNS)) {</span>
<span class="fc" id="L2780">            vec.add(new GeneralName(2, new DERIA5String(dns)));</span>
<span class="fc" id="L2781">        }</span>

<span class="fc" id="L2783">        final String directoryName = getDirectoryStringFromAltName(altName);</span>
<span class="fc bfc" id="L2784" title="All 2 branches covered.">        if (directoryName != null) {</span>
<span class="fc" id="L2785">            final X500Name x500DirectoryName = new X500Name(CeSecoreNameStyle.INSTANCE, directoryName);</span>
<span class="fc" id="L2786">            final GeneralName gn = new GeneralName(4, x500DirectoryName);</span>
<span class="fc" id="L2787">            vec.add(gn);</span>
        }

<span class="fc bfc" id="L2790" title="All 2 branches covered.">        for (final String uri : CertTools.getPartsFromDN(altName, CertTools.URI)) {</span>
<span class="fc" id="L2791">            vec.add(new GeneralName(6, new DERIA5String(uri)));</span>
<span class="fc" id="L2792">        }</span>
<span class="fc bfc" id="L2793" title="All 2 branches covered.">        for (final String uri : CertTools.getPartsFromDN(altName, CertTools.URI1)) {</span>
<span class="fc" id="L2794">            vec.add(new GeneralName(6, new DERIA5String(uri)));</span>
<span class="fc" id="L2795">        }</span>
<span class="pc bpc" id="L2796" title="1 of 2 branches missed.">        for (final String uri : CertTools.getPartsFromDN(altName, CertTools.URI2)) {</span>
<span class="nc" id="L2797">            vec.add(new GeneralName(6, new DERIA5String(uri)));</span>
<span class="nc" id="L2798">        }</span>

<span class="fc bfc" id="L2800" title="All 2 branches covered.">        for (final String addr : CertTools.getPartsFromDN(altName, CertTools.IPADDR)) {</span>
<span class="fc" id="L2801">            final byte[] ipoctets = StringTools.ipStringToOctets(addr);</span>
<span class="pc bpc" id="L2802" title="1 of 2 branches missed.">            if (ipoctets.length &gt; 0) {</span>
<span class="fc" id="L2803">                final GeneralName gn = new GeneralName(7, new DEROctetString(ipoctets));</span>
<span class="fc" id="L2804">                vec.add(gn);</span>
<span class="fc" id="L2805">            } else {</span>
<span class="nc" id="L2806">                log.error(&quot;Cannot parse/encode ip address, ignoring: &quot; + addr);</span>
            }
<span class="fc" id="L2808">        }</span>
<span class="pc bpc" id="L2809" title="1 of 2 branches missed.">        for (final String oid : CertTools.getPartsFromDN(altName, CertTools.REGISTEREDID)) {</span>
<span class="nc" id="L2810">            vec.add(new GeneralName(GeneralName.registeredID, oid));</span>
<span class="nc" id="L2811">        }</span>

        // UPN is an OtherName see method getUpn... for asn.1 definition
<span class="fc bfc" id="L2814" title="All 2 branches covered.">        for (final String upn : CertTools.getPartsFromDN(altName, CertTools.UPN)) {</span>
<span class="fc" id="L2815">            final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="fc" id="L2816">            v.add(new ASN1ObjectIdentifier(CertTools.UPN_OBJECTID));</span>
<span class="fc" id="L2817">            v.add(new DERTaggedObject(true, 0, new DERUTF8String(upn)));</span>
<span class="fc" id="L2818">            vec.add(GeneralName.getInstance(new DERTaggedObject(false, 0, new DERSequence(v))));</span>
<span class="fc" id="L2819">        }</span>

        // XmpAddr is an OtherName see method getUTF8String...... for asn.1 definition
<span class="pc bpc" id="L2822" title="1 of 2 branches missed.">        for (final String xmppAddr : CertTools.getPartsFromDN(altName, CertTools.XMPPADDR)) {</span>
<span class="nc" id="L2823">            final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L2824">            v.add(new ASN1ObjectIdentifier(CertTools.XMPPADDR_OBJECTID));</span>
<span class="nc" id="L2825">            v.add(new DERTaggedObject(true, 0, new DERUTF8String(xmppAddr)));</span>
<span class="nc" id="L2826">            vec.add(GeneralName.getInstance(new DERTaggedObject(false, 0, new DERSequence(v))));</span>
<span class="nc" id="L2827">        }</span>

        // srvName is an OtherName see method getIA5String...... for asn.1 definition
<span class="pc bpc" id="L2830" title="1 of 2 branches missed.">        for (final String srvName : CertTools.getPartsFromDN(altName, CertTools.SRVNAME)) {</span>
<span class="nc" id="L2831">            final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L2832">            v.add(new ASN1ObjectIdentifier(CertTools.SRVNAME_OBJECTID));</span>
<span class="nc" id="L2833">            v.add(new DERTaggedObject(true, 0, new DERIA5String(srvName)));</span>
<span class="nc" id="L2834">            vec.add(GeneralName.getInstance(new DERTaggedObject(false, 0, new DERSequence(v))));</span>
<span class="nc" id="L2835">        }</span>

        // FASC-N is an OtherName see method getOctetString...... for asn.1 definition (PIV FIPS 201-2)
        // We take the input as being a hex encoded octet string
<span class="pc bpc" id="L2839" title="1 of 2 branches missed.">        for (final String fascN : CertTools.getPartsFromDN(altName, CertTools.FASCN)) {</span>
<span class="nc" id="L2840">            final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L2841">            v.add(new ASN1ObjectIdentifier(CertTools.FASCN_OBJECTID));</span>
<span class="nc" id="L2842">            v.add(new DERTaggedObject(true, 0, new DEROctetString(Hex.decode(fascN))));</span>
<span class="nc" id="L2843">            vec.add(GeneralName.getInstance(new DERTaggedObject(false, 0, new DERSequence(v))));</span>
<span class="nc" id="L2844">        }</span>

        // PermanentIdentifier is an OtherName see method getPermananentIdentifier... for asn.1 definition
<span class="fc bfc" id="L2847" title="All 2 branches covered.">        for (final String permanentIdentifier : CertTools.getPartsFromDN(altName, CertTools.PERMANENTIDENTIFIER)) {</span>
<span class="fc" id="L2848">            final String[] values = getPermanentIdentifierValues(permanentIdentifier);</span>
<span class="fc" id="L2849">            final ASN1EncodableVector v = new ASN1EncodableVector(); // this is the OtherName</span>
<span class="fc" id="L2850">            v.add(new ASN1ObjectIdentifier(CertTools.PERMANENTIDENTIFIER_OBJECTID));</span>
            // First the PermanentIdentifier sequence
<span class="fc" id="L2852">            final ASN1EncodableVector piSeq = new ASN1EncodableVector();</span>
<span class="pc bpc" id="L2853" title="1 of 2 branches missed.">            if (values[0] != null) {</span>
<span class="fc" id="L2854">                piSeq.add(new DERUTF8String(values[0]));</span>
            }
<span class="pc bpc" id="L2856" title="1 of 2 branches missed.">            if (values[1] != null) {</span>
<span class="fc" id="L2857">                piSeq.add(new ASN1ObjectIdentifier(values[1]));</span>
            }
<span class="fc" id="L2859">            v.add(new DERTaggedObject(true, 0, new DERSequence(piSeq)));</span>
            // GeneralName gn = new GeneralName(new DERSequence(v), 0);
<span class="fc" id="L2861">            final ASN1Primitive gn = new DERTaggedObject(false, 0, new DERSequence(v));</span>
<span class="fc" id="L2862">            vec.add(gn);</span>
<span class="fc" id="L2863">        }</span>

<span class="fc bfc" id="L2865" title="All 2 branches covered.">        for (final String guid : CertTools.getPartsFromDN(altName, CertTools.GUID)) {</span>
<span class="fc" id="L2866">            final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="fc" id="L2867">            byte[] guidbytes = Hex.decode(guid);</span>
<span class="pc bpc" id="L2868" title="1 of 2 branches missed.">            if (guidbytes != null) {</span>
<span class="fc" id="L2869">                v.add(new ASN1ObjectIdentifier(CertTools.GUID_OBJECTID));</span>
<span class="fc" id="L2870">                v.add(new DERTaggedObject(true, 0, new DEROctetString(guidbytes)));</span>
<span class="fc" id="L2871">                final ASN1Primitive gn = new DERTaggedObject(false, 0, new DERSequence(v));</span>
<span class="fc" id="L2872">                vec.add(gn);</span>
<span class="fc" id="L2873">            } else {</span>
<span class="nc" id="L2874">                log.error(&quot;Cannot decode hexadecimal guid, ignoring: &quot; + guid);</span>
            }
<span class="fc" id="L2876">        }</span>

        // Krb5PrincipalName is an OtherName, see method getKrb5Principal...for ASN.1 definition
<span class="fc bfc" id="L2879" title="All 2 branches covered.">        for (final String principalString : CertTools.getPartsFromDN(altName, CertTools.KRB5PRINCIPAL)) {</span>
            // Start by parsing the input string to separate it in different parts
<span class="pc bpc" id="L2881" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L2882">                log.debug(&quot;principalString: &quot; + principalString);</span>
            }
            // The realm is the last part moving back until an @
<span class="fc" id="L2885">            final int index = principalString.lastIndexOf('@');</span>
<span class="fc" id="L2886">            String realm = &quot;&quot;;</span>
<span class="pc bpc" id="L2887" title="1 of 2 branches missed.">            if (index &gt; 0) {</span>
<span class="fc" id="L2888">                realm = principalString.substring(index + 1);</span>
            }
<span class="pc bpc" id="L2890" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L2891">                log.debug(&quot;realm: &quot; + realm);</span>
            }
            // Now we can have several principals separated by /
<span class="fc" id="L2894">            final ArrayList&lt;String&gt; principalarr = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L2895">            int jndex = 0;</span>
<span class="fc" id="L2896">            int bindex = 0;</span>
<span class="fc bfc" id="L2897" title="All 2 branches covered.">            while (jndex &lt; index) {</span>
                // Loop and add all strings separated by /
<span class="fc" id="L2899">                jndex = principalString.indexOf('/', bindex);</span>
<span class="fc bfc" id="L2900" title="All 2 branches covered.">                if (jndex == -1) {</span>
<span class="fc" id="L2901">                    jndex = index;</span>
                }
<span class="fc" id="L2903">                String s = principalString.substring(bindex, jndex);</span>
<span class="pc bpc" id="L2904" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L2905">                    log.debug(&quot;adding principal name: &quot; + s);</span>
                }
<span class="fc" id="L2907">                principalarr.add(s);</span>
<span class="fc" id="L2908">                bindex = jndex + 1;</span>
<span class="fc" id="L2909">            }</span>

            // Now we must construct the rather complex asn.1...
<span class="fc" id="L2912">            final ASN1EncodableVector v = new ASN1EncodableVector(); // this is the OtherName</span>
<span class="fc" id="L2913">            v.add(new ASN1ObjectIdentifier(CertTools.KRB5PRINCIPAL_OBJECTID));</span>

            // First the Krb5PrincipalName sequence
<span class="fc" id="L2916">            final ASN1EncodableVector krb5p = new ASN1EncodableVector();</span>
            // The realm is the first tagged GeneralString
<span class="fc" id="L2918">            krb5p.add(new DERTaggedObject(true, 0, new DERGeneralString(realm)));</span>
            // Second is the sequence of principal names, which is at tagged position 1 in the krb5p
<span class="fc" id="L2920">            final ASN1EncodableVector principals = new ASN1EncodableVector();</span>
            // According to rfc4210 the type NT-UNKNOWN is 0, and according to some other rfc this type should be used...
<span class="fc" id="L2922">            principals.add(new DERTaggedObject(true, 0, new ASN1Integer(0)));</span>
            // The names themselves are yet another sequence
<span class="fc" id="L2924">            final ASN1EncodableVector names = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L2925" title="All 2 branches covered.">            for (final String principalName : principalarr) {</span>
<span class="fc" id="L2926">                names.add(new DERGeneralString(principalName));</span>
<span class="fc" id="L2927">            }</span>
<span class="fc" id="L2928">            principals.add(new DERTaggedObject(true, 1, new DERSequence(names)));</span>
<span class="fc" id="L2929">            krb5p.add(new DERTaggedObject(true, 1, new DERSequence(principals)));</span>

<span class="fc" id="L2931">            v.add(new DERTaggedObject(true, 0, new DERSequence(krb5p)));</span>
<span class="fc" id="L2932">            final ASN1Primitive gn = new DERTaggedObject(false, 0, new DERSequence(v));</span>
<span class="fc" id="L2933">            vec.add(gn);</span>
<span class="fc" id="L2934">        }</span>

        // SIM is an OtherName. See RFC-4683
<span class="fc bfc" id="L2937" title="All 2 branches covered.">        for (final String internalSimString : CertTools.getPartsFromDN(altName, RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD)) {</span>
<span class="pc bpc" id="L2938" title="1 of 2 branches missed.">            if (StringUtils.isNotBlank(internalSimString)) {</span>
<span class="fc" id="L2939">                final String[] tokens = internalSimString.split(RFC4683Tools.LIST_SEPARATOR); </span>
<span class="pc bpc" id="L2940" title="1 of 2 branches missed.">                if (tokens.length==3) {</span>
<span class="fc" id="L2941">                    ASN1Primitive gn = RFC4683Tools.createSimGeneralName(tokens[0], tokens[1], tokens[2]);</span>
<span class="fc" id="L2942">                    vec.add(gn);</span>
<span class="pc bpc" id="L2943" title="1 of 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L2944">                        log.debug(&quot;SIM GeneralName added: &quot; + gn.toString());</span>
                    }
                }
            }            
<span class="fc" id="L2948">        }</span>
        
        // To support custom OIDs in altNames, they must be added as an OtherName of plain type UTF8String
<span class="pc bpc" id="L2951" title="1 of 2 branches missed.">        for (final String oid : CertTools.getCustomOids(altName)) {</span>
<span class="nc bnc" id="L2952" title="All 2 branches missed.">            for (final String oidValue : CertTools.getPartsFromDN(altName, oid)) {</span>
<span class="nc" id="L2953">                final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L2954">                v.add(new ASN1ObjectIdentifier(oid));</span>
<span class="nc" id="L2955">                v.add(new DERTaggedObject(true, 0, new DERUTF8String(oidValue)));</span>
<span class="nc" id="L2956">                final ASN1Primitive gn = new DERTaggedObject(false, 0, new DERSequence(v));</span>
<span class="nc" id="L2957">                vec.add(gn);</span>
<span class="nc" id="L2958">            }</span>
<span class="nc" id="L2959">        }</span>

<span class="fc bfc" id="L2961" title="All 2 branches covered.">        if (vec.size() &gt; 0) {</span>
<span class="fc" id="L2962">            return GeneralNames.getInstance(new DERSequence(vec));</span>
        }
<span class="fc" id="L2964">        return null;</span>
    }

    /**
     * GeneralName ::= CHOICE { otherName [0] OtherName, rfc822Name [1] IA5String, dNSName [2] IA5String, x400Address [3] ORAddress, directoryName [4]
     * Name, ediPartyName [5] EDIPartyName, uniformResourceIdentifier [6] IA5String, iPAddress [7] OCTET STRING, registeredID [8] OBJECT IDENTIFIER}
     * 
     * @param tag the no tag 0-8
     * @param value the ASN1Encodable value as returned by GeneralName.getName()
     * @return String in form rfc822Name=&amp;lt;email&amp;gt; or uri=&amp;lt;uri&amp;gt; etc
     * @throws IOException on disk error
     * @see #getSubjectAlternativeName
     */
    public static String getGeneralNameString(int tag, ASN1Encodable value) throws IOException {
<span class="fc" id="L2978">        String ret = null;</span>
<span class="pc bpc" id="L2979" title="5 of 10 branches missed.">        switch (tag) {</span>
        case 0:
        {
<span class="fc" id="L2982">            final ASN1Sequence sequence = getAltnameSequence(value.toASN1Primitive().getEncoded());</span>
<span class="fc" id="L2983">            final ASN1ObjectIdentifier oid = ASN1ObjectIdentifier.getInstance(sequence.getObjectAt(0));</span>
<span class="pc bpc" id="L2984" title="4 of 8 branches missed.">            switch(oid.getId()) {</span>
                case CertTools.UPN_OBJECTID:
<span class="fc" id="L2986">                    ret = CertTools.UPN + &quot;=&quot; + getUTF8StringFromSequence(sequence, CertTools.UPN_OBJECTID);</span>
<span class="fc" id="L2987">                    break;</span>
                case CertTools.PERMANENTIDENTIFIER_OBJECTID:
<span class="fc" id="L2989">                    ret = CertTools.PERMANENTIDENTIFIER + &quot;=&quot; + getPermanentIdentifierStringFromSequence(sequence);</span>
<span class="fc" id="L2990">                    break;</span>
                case CertTools.KRB5PRINCIPAL_OBJECTID:
<span class="fc" id="L2992">                    ret = CertTools.KRB5PRINCIPAL + &quot;=&quot; + getKrb5PrincipalNameFromSequence(sequence);</span>
<span class="fc" id="L2993">                    break;</span>
                case RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD_OBJECTID:
<span class="fc" id="L2995">                    ret = RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD + &quot;=&quot; + RFC4683Tools.getSimStringSequence(sequence);</span>
<span class="fc" id="L2996">                    break;</span>
                case CertTools.XMPPADDR_OBJECTID:
<span class="nc" id="L2998">                    ret = CertTools.XMPPADDR + &quot;=&quot; + getUTF8StringFromSequence(sequence, CertTools.XMPPADDR_OBJECTID);</span>
<span class="nc" id="L2999">                    break;</span>
                case CertTools.SRVNAME_OBJECTID:
<span class="nc" id="L3001">                    ret = CertTools.SRVNAME + &quot;=&quot; + getIA5StringFromSequence(sequence, CertTools.SRVNAME_OBJECTID);</span>
<span class="nc" id="L3002">                    break;</span>
                case CertTools.FASCN_OBJECTID:
<span class="nc" id="L3004">                    ret = CertTools.FASCN + &quot;=&quot; + new String(Hex.encode(getOctetStringFromSequence(sequence, CertTools.FASCN_OBJECTID)));</span>
                    break;
            };
<span class="fc" id="L3007">            break;</span>
        }
        case 1:
<span class="fc" id="L3010">            ret = CertTools.EMAIL + &quot;=&quot; + DERIA5String.getInstance(value).getString();</span>
<span class="fc" id="L3011">            break;</span>
        case 2:
<span class="fc" id="L3013">            ret = CertTools.DNS + &quot;=&quot; + DERIA5String.getInstance(value).getString();</span>
<span class="fc" id="L3014">            break;</span>
        case 3: // SubjectAltName of type x400Address not supported
<span class="nc" id="L3016">            break;</span>
        case 4:
<span class="fc" id="L3018">            final X500Name name = X500Name.getInstance(value);</span>
<span class="fc" id="L3019">            ret = CertTools.DIRECTORYNAME + &quot;=&quot; + name.toString();</span>
<span class="fc" id="L3020">            break;</span>
        case 5: // SubjectAltName of type ediPartyName not supported
<span class="nc" id="L3022">            break;</span>
        case 6:
<span class="nc" id="L3024">            ret = CertTools.URI + &quot;=&quot; + DERIA5String.getInstance(value).getString();</span>
<span class="nc" id="L3025">            break;</span>
        case 7:
<span class="fc" id="L3027">            ASN1OctetString oct = ASN1OctetString.getInstance(value);</span>
<span class="fc" id="L3028">            ret = CertTools.IPADDR + &quot;=&quot; + StringTools.ipOctetsToString(oct.getOctets());</span>
<span class="fc" id="L3029">            break;</span>
        case 8:
            // BC GeneralName stores the actual object value, which is an OID
<span class="nc" id="L3032">            ASN1ObjectIdentifier oid = ASN1ObjectIdentifier.getInstance(value);</span>
<span class="nc" id="L3033">            ret = CertTools.REGISTEREDID+ &quot;=&quot; + oid.getId();</span>
<span class="nc" id="L3034">            break;            </span>
        default: // SubjectAltName of unknown type
            break;
        }
<span class="fc" id="L3038">        return ret;</span>
    }

    /**
     * Check the certificate with CA certificate.
     * 
     * @param certificate certificate to verify
     * @param caCertChain collection of X509Certificates
     * @param date Date to verify at, or null to use current time.
     * @param pkixCertPathCheckers optional PKIXCertPathChecker implementations to use during cert path validation
     * @return true if verified OK
     * @throws CertPathValidatorException if certificate could not be validated
     */
    public static boolean verify(X509Certificate certificate, Collection&lt;X509Certificate&gt; caCertChain, Date date, PKIXCertPathChecker... pkixCertPathCheckers)
            throws CertPathValidatorException {
        try {
<span class="fc" id="L3054">            ArrayList&lt;X509Certificate&gt; certlist = new ArrayList&lt;&gt;();</span>
            // Create CertPath
<span class="fc" id="L3056">            certlist.add(certificate);</span>
            // Add other certs...
<span class="fc" id="L3058">            CertPath cp = CertificateFactory.getInstance(&quot;X.509&quot;, BouncyCastleProvider.PROVIDER_NAME).generateCertPath(certlist);</span>
            
            // Create TrustAnchor. Since EJBCA use BouncyCastle provider, we assume
            // certificate already in correct order
<span class="fc" id="L3062">            X509Certificate[] cac = caCertChain.toArray(new X509Certificate[caCertChain.size()]);</span>
<span class="fc" id="L3063">            TrustAnchor anchor = new TrustAnchor(cac[0], null);</span>
            // Set the PKIX parameters
<span class="fc" id="L3065">            PKIXParameters params = new PKIXParameters(Collections.singleton(anchor));</span>
<span class="fc bfc" id="L3066" title="All 2 branches covered.">            for (final PKIXCertPathChecker pkixCertPathChecker : pkixCertPathCheckers) {</span>
<span class="fc" id="L3067">                params.addCertPathChecker(pkixCertPathChecker);</span>
            }
<span class="fc" id="L3069">            params.setRevocationEnabled(false);</span>
<span class="fc" id="L3070">            params.setDate(date);</span>
<span class="fc" id="L3071">            CertPathValidator cpv = CertPathValidator.getInstance(&quot;PKIX&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="fc" id="L3072">            PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) cpv.validate(cp, params);</span>
<span class="pc bpc" id="L3073" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L3074">                log.debug(&quot;Certificate verify result: &quot; + result.toString());</span>
            }
<span class="fc" id="L3076">        } catch (CertPathValidatorException cpve) {</span>
<span class="fc" id="L3077">            throw new CertPathValidatorException(&quot;Invalid certificate or certificate not issued by specified CA: &quot; + cpve.getMessage());</span>
<span class="nc" id="L3078">        } catch (CertificateException e) {</span>
<span class="nc" id="L3079">            throw new IllegalArgumentException(&quot;Something was wrong with the supplied certificate&quot;, e);</span>
<span class="nc" id="L3080">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L3081">            throw new IllegalStateException(&quot;BouncyCastle provider not found.&quot;, e);</span>
<span class="nc" id="L3082">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L3083">            throw new IllegalStateException(&quot;Algorithm PKIX was not found.&quot;, e);</span>
<span class="nc" id="L3084">        } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L3085">            throw new IllegalArgumentException(&quot;Either ca certificate chain was empty, or the certificate was on an inappropraite type for a PKIX path checker.&quot;, e);</span>
<span class="fc" id="L3086">        }</span>
<span class="fc" id="L3087">        return true;</span>
    }
    
    /**
     * Check the certificate with CA certificate.
     * 
     * @param certificate certificate to verify
     * @param caCertChain collection of X509Certificates
     * @return true if verified OK
     * @throws CertPathValidatorException if verification failed
     */
    public static boolean verify(X509Certificate certificate, Collection&lt;X509Certificate&gt; caCertChain) throws CertPathValidatorException {
<span class="nc" id="L3099">        return verify(certificate, caCertChain, null);</span>
    }
    
    /**
     * Check the certificate with a list of trusted certificates.
     * The trusted certificates list can either be end entity certificates, in this case, only this certificate by this issuer 
     * is trusted; or it could be CA certificates, in this case, all certificates issued by this CA are trusted.
     * 
     * @param certificate certificate to verify
     * @param trustedCertificates collection of trusted X509Certificates
     * @param pkixCertPathCheckers optional PKIXCertPathChecker implementations to use during cert path validation
     * @return true if verified OK
     */
    public static boolean verifyWithTrustedCertificates(X509Certificate certificate, List&lt; Collection&lt;X509Certificate&gt;&gt; trustedCertificates, PKIXCertPathChecker...pkixCertPathCheckers) {
        
<span class="pc bpc" id="L3114" title="1 of 2 branches missed.">        if(trustedCertificates == null) {</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">            if(log.isDebugEnabled()) {</span>
<span class="nc" id="L3116">                log.debug(&quot;Input of trustedCertificates was null. Trusting nothing.&quot;);</span>
            }
<span class="nc" id="L3118">            return false;</span>
        }
        
<span class="pc bpc" id="L3121" title="1 of 2 branches missed.">        if(trustedCertificates.size() == 0) {</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">            if(log.isDebugEnabled()) {</span>
<span class="nc" id="L3123">                log.debug(&quot;Input of trustedCertificates was empty. Trusting everything.&quot;);</span>
            }
<span class="nc" id="L3125">            return true;</span>
        }
        
<span class="fc" id="L3128">        BigInteger certSN = getSerialNumber(certificate);</span>
<span class="fc bfc" id="L3129" title="All 2 branches covered.">        for(Collection&lt;X509Certificate&gt; trustedCertChain : trustedCertificates) {</span>
<span class="fc" id="L3130">            X509Certificate trustedCert = trustedCertChain.iterator().next();</span>
<span class="fc" id="L3131">            BigInteger trustedCertSN = getSerialNumber(trustedCert);</span>
<span class="fc bfc" id="L3132" title="All 2 branches covered.">            if(certSN.equals(trustedCertSN)) {</span>
                // If the serial number of the certificate matches the serial number of a certificate in the list, make sure that it in 
                // fact is the same certificate by verifying that they were issued by the same issuer.
                // Removing this trusted certificate from the trustedCertChain will leave only the CA's certificate chain, which will be 
                // used to verify the issuer.
<span class="pc bpc" id="L3137" title="1 of 2 branches missed.">                if(trustedCertChain.size() &gt; 1) {</span>
<span class="nc" id="L3138">                    trustedCertChain.remove(trustedCert);</span>
                }
            }
            try {
<span class="fc" id="L3142">                verify(certificate, trustedCertChain, null, pkixCertPathCheckers);</span>
<span class="pc bpc" id="L3143" title="1 of 2 branches missed.">                if(log.isDebugEnabled()) {</span>
<span class="nc" id="L3144">                    log.debug(&quot;Trusting certificate with SubjectDN '&quot; + getSubjectDN(certificate) + &quot;' and issuerDN '&quot; + getIssuerDN(certificate) + &quot;'.&quot;);</span>
                }
<span class="fc" id="L3146">                return true;</span>
<span class="fc" id="L3147">            } catch (CertPathValidatorException e) {</span>
                //Do nothing. Just try the next trusted certificate chain in the list
            }
            
<span class="fc" id="L3151">        }</span>
<span class="fc" id="L3152">        return false;</span>
    }

    /**
     * Checks that the given date is within the certificate's validity period. In other words, this determines whether the certificate would be valid
     * at the given date/time.
     * 
     * This utility class is only a helper to get the same behavior as the standard java.security.cert API regardless if using X.509 or CV
     * Certificate.
     * 
     * @param cert certificate to verify, if null the method returns immediately, null does not have a validity to check.
     * @param date the Date to check against to see if this certificate is valid at that date/time.
     * @throws CertificateExpiredException - if the certificate has expired with respect to the date supplied.
     * @throws CertificateNotYetValidException - if the certificate is not yet valid with respect to the date supplied.
     * @see java.security.cert.X509Certificate#checkValidity(Date)
     */
    public static void checkValidity(final Certificate cert, final Date date) throws CertificateExpiredException, CertificateNotYetValidException {
<span class="pc bpc" id="L3169" title="1 of 2 branches missed.">        if (cert != null) {</span>
<span class="fc bfc" id="L3170" title="All 2 branches covered.">            if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L3171">                final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L3172">                xcert.checkValidity(date);</span>
<span class="pc bpc" id="L3173" title="1 of 2 branches missed.">            } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L3174">                final CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
                try {
<span class="fc" id="L3176">                    final Date start = cvccert.getCVCertificate().getCertificateBody().getValidFrom();</span>
<span class="fc" id="L3177">                    final Date end = cvccert.getCVCertificate().getCertificateBody().getValidTo();</span>
<span class="fc bfc" id="L3178" title="All 2 branches covered.">                    if (start.after(date)) {</span>
<span class="fc" id="L3179">                        String msg = &quot;CV Certificate startDate '&quot; + start + &quot;' is after check date '&quot; + date + &quot;'. Subject: &quot;+CertTools.getSubjectDN(cert);</span>
<span class="pc bpc" id="L3180" title="1 of 2 branches missed.">                        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L3181">                            log.trace(msg);</span>
                        }
<span class="fc" id="L3183">                        throw new CertificateNotYetValidException(msg);</span>
                    }
<span class="fc bfc" id="L3185" title="All 2 branches covered.">                    if (end.before(date)) {</span>
<span class="fc" id="L3186">                        final String msg = &quot;CV Certificate endDate '&quot; + end + &quot;' is before check date '&quot; + date + &quot;'. Subject: &quot;+CertTools.getSubjectDN(cert);</span>
<span class="pc bpc" id="L3187" title="1 of 2 branches missed.">                        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L3188">                            log.trace(msg);</span>
                        }
<span class="fc" id="L3190">                        throw new CertificateExpiredException(msg);</span>
                    }
<span class="nc" id="L3192">                } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L3193">                    log.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="fc" id="L3194">                }</span>
            }
        }
<span class="fc" id="L3197">    }</span>

    /**
     * Return the first CRL distribution points. The CRL distributions points are URL specified in the certificate extension 
     * CRLDistributionPoints with OID 2.5.29.31.
     * 
     * The CRLDistributionPoints extension contains a sequece of DistributionPoint, which has the following structure:
     * 
     *              DistributionPoint ::= SEQUENCE {
     *                   distributionPoint  [0] DistributionPointName OPTIONAL,
     *                   reasons            [1] ReasonFlags OPTIONAL,
     *                   cRLIssuer          [2] GeneralNames OPTIONAL
     *               }
     *               
     * This method extracts &quot;distributionPoint&quot; (tag 0) from the first DistributionPoint included in the extension. No other 
     * tags are read.
     * 
     * @param certificate certificate
     * @return A URL, or null if no CRL distribution points were found
     */
    public static URL getCrlDistributionPoint(final Certificate certificate) {
<span class="pc bpc" id="L3218" title="1 of 2 branches missed.">        if(certificate instanceof X509Certificate) {</span>
<span class="fc" id="L3219">            final X509Certificate x509cert = (X509Certificate) certificate;</span>
<span class="fc" id="L3220">            final Collection&lt;URL&gt; cdps = getCrlDistributionPoints(x509cert, true);</span>
<span class="fc bfc" id="L3221" title="All 2 branches covered.">            if(!cdps.isEmpty()) {</span>
<span class="fc" id="L3222">                return cdps.iterator().next();</span>
            }
        }
<span class="fc" id="L3225">        return null;</span>
    }
    
    /**
     * Return a list of CRL distribution points. The CRL distributions points are URL specified in the certificate extension 
     * CRLDistributionPoints with OID 2.5.29.31.
     * 
     * The CRLDistributionPoints extension contains a sequece of DistributionPoint, which has the following structure:
     * 
     *              DistributionPoint ::= SEQUENCE {
     *                   distributionPoint  [0] DistributionPointName OPTIONAL,
     *                   reasons            [1] ReasonFlags OPTIONAL,
     *                   cRLIssuer          [2] GeneralNames OPTIONAL
     *               }
     *               
     * This method extracts &quot;distributionPoint&quot; (tag 0) from every DistributionPoint included in the extension. No other 
     * tags are read.
     * 
     * @param x509cert X.509 cert
     * @return A list of URLs
     */
    public static Collection&lt;URL&gt; getCrlDistributionPoints(final X509Certificate x509cert) {
<span class="nc" id="L3247">        return getCrlDistributionPoints(x509cert, false);</span>
    }
    
    private static Collection&lt;URL&gt; getCrlDistributionPoints(final X509Certificate x509cert, final boolean onlyfirst) {
<span class="fc" id="L3251">        ArrayList&lt;URL&gt; cdps = new ArrayList&lt;URL&gt;();</span>
<span class="fc" id="L3252">        final ASN1Primitive obj = getExtensionValue(x509cert, Extension.cRLDistributionPoints.getId());</span>
<span class="pc bpc" id="L3253" title="1 of 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L3254">            return cdps;</span>
        }
            
<span class="fc" id="L3257">        final ASN1Sequence crlDistributionPoints = (ASN1Sequence) obj;</span>
<span class="pc bpc" id="L3258" title="1 of 2 branches missed.">        for (int i = 0; i &lt; crlDistributionPoints.size(); i++) {</span>
<span class="fc" id="L3259">            ASN1Sequence distributionPoint = (ASN1Sequence) crlDistributionPoints.getObjectAt(i);</span>
<span class="pc bpc" id="L3260" title="1 of 2 branches missed.">            for (int j = 0; j &lt; distributionPoint.size(); j++) {</span>
<span class="fc" id="L3261">                ASN1TaggedObject tagged = (ASN1TaggedObject) distributionPoint.getObjectAt(j);</span>
<span class="pc bpc" id="L3262" title="1 of 2 branches missed.">                if (tagged.getTagNo() == 0) {</span>
<span class="fc" id="L3263">                    String url = getStringFromGeneralNames(tagged.getObject());</span>
<span class="fc bfc" id="L3264" title="All 2 branches covered.">                    if(url!=null) {</span>
                        try {
<span class="fc" id="L3266">                            cdps.add(new URL(url));</span>
<span class="nc" id="L3267">                        } catch (MalformedURLException e) {</span>
<span class="nc bnc" id="L3268" title="All 2 branches missed.">                            if(log.isDebugEnabled()) {</span>
<span class="nc" id="L3269">                                log.debug(&quot;Error parsing '&quot; + url + &quot;' as a URL. &quot; + e.getLocalizedMessage());</span>
                            }
<span class="fc" id="L3271">                        }</span>
                    }
<span class="pc bpc" id="L3273" title="1 of 2 branches missed.">                    if(onlyfirst) {</span>
<span class="fc" id="L3274">                        return cdps; // returning only the first URL</span>
                    }
                }
            }
        }
<span class="nc" id="L3279">        return cdps;</span>
    }

    

    /**
     * This utility method extracts the Authority Information Access Extention's URLs
     * 
     * @param crl a CRL to parse
     * @return the Authority Information Access Extention's URLs, or an empty Collection if none were found
     */
    public static Collection&lt;String&gt; getAuthorityInformationAccess(CRL crl) {
<span class="nc" id="L3291">        Collection&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L3292" title="All 2 branches missed.">        if (crl instanceof X509CRL) {</span>
<span class="nc" id="L3293">            X509CRL x509crl = (X509CRL) crl;</span>
<span class="nc" id="L3294">            ASN1Primitive derObject = getExtensionValue(x509crl, Extension.authorityInfoAccess.getId());</span>
<span class="nc bnc" id="L3295" title="All 2 branches missed.">            if (derObject != null) {</span>
<span class="nc" id="L3296">                AuthorityInformationAccess authorityInformationAccess = AuthorityInformationAccess.getInstance(derObject);</span>
<span class="nc" id="L3297">                AccessDescription[] accessDescriptions = authorityInformationAccess.getAccessDescriptions();</span>
<span class="nc bnc" id="L3298" title="All 4 branches missed.">                if ((accessDescriptions != null) &amp;&amp; (accessDescriptions.length &gt; 0)) {</span>
<span class="nc bnc" id="L3299" title="All 2 branches missed.">                    for (AccessDescription accessDescription : accessDescriptions) {</span>
<span class="nc bnc" id="L3300" title="All 2 branches missed.">                        if (accessDescription.getAccessMethod().equals(X509ObjectIdentifiers.id_ad_caIssuers)) {</span>
<span class="nc" id="L3301">                            GeneralName generalName = accessDescription.getAccessLocation();</span>
<span class="nc bnc" id="L3302" title="All 2 branches missed.">                            if (generalName.getTagNo() == GeneralName.uniformResourceIdentifier) {</span>
                                // Due to bug in java getting some ASN.1 objects, it can be tagged an extra time...
<span class="nc" id="L3304">                                ASN1Primitive obj = generalName.toASN1Primitive();</span>
<span class="nc bnc" id="L3305" title="All 2 branches missed.">                                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L3306">                                    obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                                }
<span class="nc" id="L3308">                                final DERIA5String deria5String = DERIA5String.getInstance(obj);</span>
<span class="nc" id="L3309">                                result.add(deria5String.getString());</span>
                            }
                        }
                    }
                }
            }
        }
<span class="nc" id="L3316">        return result;</span>
    }

    /**
     * @param cert cert
     * @return all CA issuer URI that are inside AuthorityInformationAccess extension or an empty list
     */
    public static List&lt;String&gt; getAuthorityInformationAccessCAIssuerUris(Certificate cert) {
<span class="fc" id="L3324">        return getAuthorityInformationAccessCaIssuerUris(cert, false);</span>
    }
    
    
    /**
     * @return the first OCSP URL that is inside AuthorityInformationAccess extension, or null.
     * 
     * @param cert is the certificate to parse
     */
    public static String getAuthorityInformationAccessOcspUrl(Certificate cert) {
<span class="fc" id="L3334">        Collection&lt;String&gt; urls = getAuthorityInformationAccessOcspUrls(cert);</span>
<span class="pc bpc" id="L3335" title="1 of 2 branches missed.">        if(!urls.isEmpty()) {</span>
<span class="fc" id="L3336">            return urls.iterator().next();</span>
        }
<span class="nc" id="L3338">        return null;</span>
    }
    
    /**
     * @param cert cert
     * @return all OCSP URL that is inside AuthorityInformationAccess extension or an empty list
     */
    public static List&lt;String&gt; getAuthorityInformationAccessOcspUrls(Certificate cert) {
<span class="fc" id="L3346">        return getAuthorityInformationAccessOcspUrls(cert, false);</span>
    }
    
    /**
     * @param cert cert
     * @param onlyfirst only return first result if true 
     * @return all CA issuer URI that are inside AuthorityInformationAccess extension or an empty list.
     */
    private static List&lt;String&gt; getAuthorityInformationAccessCaIssuerUris(Certificate cert, final boolean onlyfirst) {
<span class="fc" id="L3355">        final List&lt;String&gt; urls = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L3356" title="1 of 2 branches missed.">        if(cert instanceof X509Certificate) {</span>
<span class="fc" id="L3357">            X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L3358">            final ASN1Primitive obj = getExtensionValue(x509cert, Extension.authorityInfoAccess.getId());</span>
<span class="pc bpc" id="L3359" title="1 of 2 branches missed.">            if (obj != null) {</span>
<span class="fc" id="L3360">                final AccessDescription[] accessDescriptions = AuthorityInformationAccess.getInstance(obj).getAccessDescriptions();</span>
<span class="pc bpc" id="L3361" title="1 of 2 branches missed.">                if (accessDescriptions != null) {</span>
<span class="fc bfc" id="L3362" title="All 2 branches covered.">                    for (final AccessDescription accessDescription : accessDescriptions) {</span>
                        // OID 1.3.6.1.5.5.7.48.2: 2 times in Bouncy Castle X509ObjectIdentifiers class.
                        // X509ObjectIdentifiers.id_ad_caIssuers = X509ObjectIdentifiers.crlAccessMethod
<span class="fc bfc" id="L3365" title="All 2 branches covered.">                        if (accessDescription.getAccessMethod().equals(X509ObjectIdentifiers.id_ad_caIssuers)) {</span>
<span class="fc" id="L3366">                            final GeneralName generalName = accessDescription.getAccessLocation();</span>
<span class="pc bpc" id="L3367" title="1 of 2 branches missed.">                            if (generalName.getTagNo() == GeneralName.uniformResourceIdentifier) {</span>
                                // After encoding in a cert, it is tagged an extra time...
<span class="fc" id="L3369">                                ASN1Primitive gnobj = generalName.toASN1Primitive();</span>
<span class="pc bpc" id="L3370" title="1 of 2 branches missed.">                                if (gnobj instanceof ASN1TaggedObject) {</span>
<span class="fc" id="L3371">                                    gnobj = ASN1TaggedObject.getInstance(gnobj).getObject();</span>
                                }
<span class="fc" id="L3373">                                final DERIA5String str = DERIA5String.getInstance(gnobj);</span>
<span class="pc bpc" id="L3374" title="1 of 2 branches missed.">                                if(str != null) {</span>
<span class="fc" id="L3375">                                    urls.add(str.getString());</span>
                                }
<span class="pc bpc" id="L3377" title="1 of 2 branches missed.">                                if(onlyfirst) {</span>
<span class="nc" id="L3378">                                    return urls; // returning only the first URL</span>
                                }
                            }
                        }
                    }
                }
            }
        }
<span class="fc" id="L3386">        return urls;</span>
    }
    
    /**
     *  @param cert cert
     * @param onlyfirst only return first result if true 
     * @return all OCSP URL that is inside AuthorityInformationAccess extension or an empty list
     */
    private static List&lt;String&gt; getAuthorityInformationAccessOcspUrls(Certificate cert, final boolean onlyfirst) {
<span class="fc" id="L3395">        final List&lt;String&gt; urls = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L3396" title="1 of 2 branches missed.">        if(cert instanceof X509Certificate) {</span>
<span class="fc" id="L3397">            X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L3398">            final ASN1Primitive obj = getExtensionValue(x509cert, Extension.authorityInfoAccess.getId());</span>
<span class="pc bpc" id="L3399" title="1 of 2 branches missed.">            if (obj != null) {</span>
<span class="fc" id="L3400">                final AccessDescription[] accessDescriptions = AuthorityInformationAccess.getInstance(obj).getAccessDescriptions();</span>
<span class="pc bpc" id="L3401" title="1 of 2 branches missed.">                if (accessDescriptions != null) {</span>
<span class="fc bfc" id="L3402" title="All 2 branches covered.">                    for (final AccessDescription accessDescription : accessDescriptions) {</span>
                        // OID 1.3.6.1.5.5.7.48.1: 2 times in Bouncy Castle X509ObjectIdentifiers class.
                        // X509ObjectIdentifiers.id_ad_ocsp = X509ObjectIdentifiers.ocspAccessMethod
<span class="fc bfc" id="L3405" title="All 2 branches covered.">                        if (accessDescription.getAccessMethod().equals(X509ObjectIdentifiers.ocspAccessMethod)) {</span>
<span class="fc" id="L3406">                            final GeneralName generalName = accessDescription.getAccessLocation();</span>
<span class="pc bpc" id="L3407" title="1 of 2 branches missed.">                            if (generalName.getTagNo() == GeneralName.uniformResourceIdentifier) {</span>
                                // After encoding in a cert, it is tagged an extra time...
<span class="fc" id="L3409">                                ASN1Primitive gnobj = generalName.toASN1Primitive();</span>
<span class="pc bpc" id="L3410" title="1 of 2 branches missed.">                                if (gnobj instanceof ASN1TaggedObject) {</span>
<span class="fc" id="L3411">                                    gnobj = ASN1TaggedObject.getInstance(gnobj).getObject();</span>
                                }
<span class="fc" id="L3413">                                final DERIA5String str = DERIA5String.getInstance(gnobj);</span>
<span class="pc bpc" id="L3414" title="1 of 2 branches missed.">                                if(str != null) {</span>
<span class="fc" id="L3415">                                    urls.add(str.getString());</span>
                                }
<span class="pc bpc" id="L3417" title="1 of 2 branches missed.">                                if(onlyfirst) {</span>
<span class="nc" id="L3418">                                    return urls; // returning only the first URL</span>
                                }
                            }
                        }
                    }
                }
            }
        }
<span class="fc" id="L3426">        return urls;</span>
    }
    
    
    /** @param cert cert
     * @return PrivateKeyUsagePeriod extension from a certificate */
    public static PrivateKeyUsagePeriod getPrivateKeyUsagePeriod(final X509Certificate cert) {
<span class="fc" id="L3433">        PrivateKeyUsagePeriod res = null;</span>
<span class="fc" id="L3434">        final byte[] extvalue = cert.getExtensionValue(Extension.privateKeyUsagePeriod.getId());</span>
<span class="pc bpc" id="L3435" title="1 of 4 branches missed.">        if (extvalue != null &amp;&amp; extvalue.length &gt; 0) {</span>
<span class="pc bpc" id="L3436" title="1 of 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L3437">                log.trace(&quot;Found a PrivateKeyUsagePeriod in the certificate with subject: &quot; + cert.getSubjectDN().toString());</span>
            }
<span class="fc" id="L3439">            res = PrivateKeyUsagePeriod.getInstance(DEROctetString.getInstance(extvalue).getOctets());</span>
        }
<span class="fc" id="L3441">        return res;</span>
    }

    /**
     * 
     * @param cert An X509Certificate
     * @param oid An OID for an extension 
     * @return an Extension ASN1Primitive from a certificate, or null
     */
    protected static ASN1Primitive getExtensionValue(X509Certificate cert, String oid) {
<span class="pc bpc" id="L3451" title="1 of 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L3452">            return null;</span>
        }
<span class="fc" id="L3454">        return getDerObjectFromByteArray(cert.getExtensionValue(oid));</span>
    }

    /**
     * 
     * @param crl an X509CRL
     * @param oid An OID for an extension 
     * @return an Extension ASN1Primitive from a CRL
     */
    protected static ASN1Primitive getExtensionValue(X509CRL crl, String oid) {
<span class="nc bnc" id="L3464" title="All 4 branches missed.">        if (crl == null || oid == null) {</span>
<span class="nc" id="L3465">            return null;</span>
        }
<span class="nc" id="L3467">        return getDerObjectFromByteArray(crl.getExtensionValue(oid));</span>
    }

    /** @param pkcs10CertificateRequest PKCS10 Request
     * @param oid OID
     * @return the PKCS#10's extension of the specified OID or null if no such extension exists */
    public static Extension getExtension(final PKCS10CertificationRequest pkcs10CertificateRequest, String oid) {
<span class="nc bnc" id="L3474" title="All 4 branches missed.">        if (pkcs10CertificateRequest != null &amp;&amp; oid != null) {</span>
<span class="nc" id="L3475">            final Extensions extensions = getPKCS10Extensions(pkcs10CertificateRequest);</span>
<span class="nc bnc" id="L3476" title="All 2 branches missed.">            if (extensions!=null) {</span>
<span class="nc" id="L3477">                return extensions.getExtension(new ASN1ObjectIdentifier(oid));</span>
            }
        }
<span class="nc" id="L3480">        return null;</span>
    }

    /** @param pkcs10CertificateRequest PKCS10 request
     * @return the first found extensions or null if PKCSObjectIdentifiers.pkcs_9_at_extensionRequest was not present in the PKCS#10 */
    private static Extensions getPKCS10Extensions(final PKCS10CertificationRequest pkcs10CertificateRequest) {
<span class="nc" id="L3486">        final Attribute[] attributes = pkcs10CertificateRequest.getAttributes(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest);</span>
<span class="nc bnc" id="L3487" title="All 2 branches missed.">        for (final Attribute attribute : attributes) {</span>
<span class="nc" id="L3488">            final ASN1Set attributeValues = attribute.getAttrValues();</span>
<span class="nc bnc" id="L3489" title="All 2 branches missed.">            if (attributeValues.size()&gt;0) {</span>
<span class="nc" id="L3490">                return Extensions.getInstance(attributeValues.getObjectAt(0));</span>
            }
        }
<span class="nc" id="L3493">        return null;</span>
    }

    private static ASN1Primitive getDerObjectFromByteArray(byte[] bytes) {
<span class="fc bfc" id="L3497" title="All 2 branches covered.">        if (bytes == null) {</span>
<span class="fc" id="L3498">            return null;</span>
        }
        try {
<span class="fc" id="L3501">            return ASN1Primitive.fromByteArray(ASN1OctetString.getInstance(bytes).getOctets());</span>
<span class="nc" id="L3502">        } catch (IOException e) {</span>
<span class="nc" id="L3503">            throw new RuntimeException(&quot;Caught an unexected IOException&quot;, e);</span>
        }
    }

    /**
     * Gets a URI string from a GeneralNames structure.
     * 
     * @param names DER GeneralNames object, that is a sequence of DERTaggedObject
     * @return String with URI if tagNo is 6 (uniformResourceIdentifier), null otherwise
     */
    private static String getStringFromGeneralNames(ASN1Primitive names) {
<span class="fc" id="L3514">        ASN1Sequence namesSequence = ASN1Sequence.getInstance((ASN1TaggedObject) names, false);</span>
<span class="pc bpc" id="L3515" title="1 of 2 branches missed.">        if (namesSequence.size() == 0) {</span>
<span class="nc" id="L3516">            return null;</span>
        }
<span class="fc" id="L3518">        DERTaggedObject taggedObject = (DERTaggedObject) namesSequence.getObjectAt(0);</span>
<span class="fc bfc" id="L3519" title="All 2 branches covered.">        if (taggedObject.getTagNo() != GeneralName.uniformResourceIdentifier) { // uniformResourceIdentifier [6] IA5String,</span>
<span class="fc" id="L3520">            return null;</span>
        }
<span class="fc" id="L3522">        return new String(ASN1OctetString.getInstance(taggedObject, false).getOctets());</span>
    } // getStringFromGeneralNames

    /**
     * Generate SHA1 fingerprint of certificate in string representation.
     * 
     * @param cert Certificate.
     * 
     * @return String containing hex format of SHA1 fingerprint (lower case), or null if input is null.
     */
    public static String getFingerprintAsString(Certificate cert) {
<span class="pc bpc" id="L3533" title="1 of 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L3534">            return null;</span>
        }
        try {
<span class="fc" id="L3537">            byte[] res = generateSHA1Fingerprint(cert.getEncoded());</span>

<span class="fc" id="L3539">            return new String(Hex.encode(res));</span>
<span class="nc" id="L3540">        } catch (CertificateEncodingException cee) {</span>
<span class="nc" id="L3541">            log.error(&quot;Error encoding certificate.&quot;, cee);</span>
        }

<span class="nc" id="L3544">        return null;</span>
    }

    /**
     * Generate SHA1 fingerprint of CRL in string representation.
     * 
     * @param crl X509CRL.
     * 
     * @return String containing hex format of SHA1 fingerprint.
     */
    public static String getFingerprintAsString(X509CRL crl) {
        try {
<span class="nc" id="L3556">            byte[] res = generateSHA1Fingerprint(crl.getEncoded());</span>

<span class="nc" id="L3558">            return new String(Hex.encode(res));</span>
<span class="nc" id="L3559">        } catch (CRLException ce) {</span>
<span class="nc" id="L3560">            log.error(&quot;Error encoding CRL.&quot;, ce);</span>
        }

<span class="nc" id="L3563">        return null;</span>
    }

    /**
     * Generate SHA1 fingerprint of byte array in string representation.
     * 
     * @param in byte array to fingerprint.
     * 
     * @return String containing hex format of SHA1 fingerprint.
     */
    public static String getFingerprintAsString(byte[] in) {
<span class="fc" id="L3574">        byte[] res = generateSHA1Fingerprint(in);</span>
<span class="fc" id="L3575">        return new String(Hex.encode(res));</span>
    }

    /**
     * Generate SHA256 fingerprint of byte array in string representation.
     * 
     * @param in byte array to fingerprint.
     * 
     * @return String containing hex format of SHA256 fingerprint.
     */
    public static String getSHA256FingerprintAsString(byte[] in) {
<span class="nc" id="L3586">        byte[] res = generateSHA256Fingerprint(in);</span>
<span class="nc" id="L3587">        return new String(Hex.encode(res));</span>
    }

    /**
     * Generate a SHA1 fingerprint from a byte array containing a certificate
     * 
     * @param ba Byte array containing DER encoded Certificate or CRL.
     * 
     * @return Byte array containing SHA1 hash of DER encoded certificate.
     */
    public static byte[] generateSHA1Fingerprint(byte[] ba) {
        // log.trace(&quot;&gt;generateSHA1Fingerprint&quot;);
        try {
<span class="fc" id="L3600">            MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;);</span>
<span class="fc" id="L3601">            return md.digest(ba);</span>
<span class="nc" id="L3602">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L3603">            log.error(&quot;SHA1 algorithm not supported&quot;, nsae);</span>
        }
        // log.trace(&quot;&lt;generateSHA1Fingerprint&quot;);
<span class="nc" id="L3606">        return null;</span>
    } // generateSHA1Fingerprint

    /**
     * Generate a SHA256 fingerprint from a byte array containing a certificate
     * 
     * @param ba Byte array containing DER encoded Certificate or CRL.
     * 
     * @return Byte array containing SHA256 hash of DER encoded certificate.
     */
    public static byte[] generateSHA256Fingerprint(byte[] ba) {
        try {
<span class="nc" id="L3618">            MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="nc" id="L3619">            return md.digest(ba);</span>
<span class="nc" id="L3620">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L3621">            log.error(&quot;SHA-256 algorithm not supported&quot;, nsae);</span>
        }
<span class="nc" id="L3623">        return null;</span>
    } // generateSHA256Fingerprint

    /**
     * Generate a MD5 fingerprint from a byte array containing a certificate
     * 
     * @param ba Byte array containing DER encoded Certificate.
     * 
     * @return Byte array containing MD5 hash of DER encoded certificate (raw binary hash).
     */
    public static byte[] generateMD5Fingerprint(byte[] ba) {
        try {
<span class="fc" id="L3635">            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="fc" id="L3636">            return md.digest(ba);</span>
<span class="nc" id="L3637">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L3638">            log.error(&quot;MD5 algorithm not supported&quot;, nsae);</span>
        }

<span class="nc" id="L3641">        return null;</span>
    } // generateMD5Fingerprint

    /**
     * Converts Sun Key usage bits to Bouncy castle key usage kits
     * 
     * @param sku key usage bit fields according to java.security.cert.X509Certificate#getKeyUsage, must be a boolean aray of size 9.
     * @return key usage int according to org.bouncycastle.jce.X509KeyUsage#X509KeyUsage, or -1 if input is null.
     * @see java.security.cert.X509Certificate#getKeyUsage
     * @see org.bouncycastle.jce.X509KeyUsage#X509KeyUsage
     */
    public static int sunKeyUsageToBC(boolean[] sku) {
<span class="nc bnc" id="L3653" title="All 2 branches missed.">        if (sku == null) {</span>
<span class="nc" id="L3654">            return -1;</span>
        }
<span class="nc" id="L3656">        int bcku = 0;</span>
<span class="nc bnc" id="L3657" title="All 2 branches missed.">        if (sku[0]) {</span>
<span class="nc" id="L3658">            bcku = bcku | X509KeyUsage.digitalSignature;</span>
        }
<span class="nc bnc" id="L3660" title="All 2 branches missed.">        if (sku[1]) {</span>
<span class="nc" id="L3661">            bcku = bcku | X509KeyUsage.nonRepudiation;</span>
        }
<span class="nc bnc" id="L3663" title="All 2 branches missed.">        if (sku[2]) {</span>
<span class="nc" id="L3664">            bcku = bcku | X509KeyUsage.keyEncipherment;</span>
        }
<span class="nc bnc" id="L3666" title="All 2 branches missed.">        if (sku[3]) {</span>
<span class="nc" id="L3667">            bcku = bcku | X509KeyUsage.dataEncipherment;</span>
        }
<span class="nc bnc" id="L3669" title="All 2 branches missed.">        if (sku[4]) {</span>
<span class="nc" id="L3670">            bcku = bcku | X509KeyUsage.keyAgreement;</span>
        }
<span class="nc bnc" id="L3672" title="All 2 branches missed.">        if (sku[5]) {</span>
<span class="nc" id="L3673">            bcku = bcku | X509KeyUsage.keyCertSign;</span>
        }
<span class="nc bnc" id="L3675" title="All 2 branches missed.">        if (sku[6]) {</span>
<span class="nc" id="L3676">            bcku = bcku | X509KeyUsage.cRLSign;</span>
        }
<span class="nc bnc" id="L3678" title="All 2 branches missed.">        if (sku[7]) {</span>
<span class="nc" id="L3679">            bcku = bcku | X509KeyUsage.encipherOnly;</span>
        }
<span class="nc bnc" id="L3681" title="All 2 branches missed.">        if (sku[8]) {</span>
<span class="nc" id="L3682">            bcku = bcku | X509KeyUsage.decipherOnly;</span>
        }
<span class="nc" id="L3684">        return bcku;</span>
    }

    /**
     * Converts DERBitString ResonFlags to a RevokedCertInfo constant
     * 
     * @param reasonFlags DERBITString received from org.bouncycastle.asn1.x509.ReasonFlags.
     * @return int according to org.cesecore.certificates.crl.RevokedCertInfo
     */
    public static int bitStringToRevokedCertInfo(DERBitString reasonFlags) {
<span class="nc" id="L3694">        int ret = RevokedCertInfo.REVOCATION_REASON_UNSPECIFIED;</span>
<span class="nc bnc" id="L3695" title="All 2 branches missed.">        if (reasonFlags == null) {</span>
<span class="nc" id="L3696">            return ret;</span>
        }
<span class="nc" id="L3698">        int val = reasonFlags.intValue();</span>
<span class="nc bnc" id="L3699" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L3700">            log.debug(&quot;Int value of bitString revocation reason: &quot; + val);</span>
        }
<span class="nc bnc" id="L3702" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.aACompromise) != 0) {</span>
<span class="nc" id="L3703">            ret = RevokedCertInfo.REVOCATION_REASON_AACOMPROMISE;</span>
        }
<span class="nc bnc" id="L3705" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.affiliationChanged) != 0) {</span>
<span class="nc" id="L3706">            ret = RevokedCertInfo.REVOCATION_REASON_AFFILIATIONCHANGED;</span>
        }
<span class="nc bnc" id="L3708" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.cACompromise) != 0) {</span>
<span class="nc" id="L3709">            ret = RevokedCertInfo.REVOCATION_REASON_CACOMPROMISE;</span>
        }
<span class="nc bnc" id="L3711" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.certificateHold) != 0) {</span>
<span class="nc" id="L3712">            ret = RevokedCertInfo.REVOCATION_REASON_CERTIFICATEHOLD;</span>
        }
<span class="nc bnc" id="L3714" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.cessationOfOperation) != 0) {</span>
<span class="nc" id="L3715">            ret = RevokedCertInfo.REVOCATION_REASON_CESSATIONOFOPERATION;</span>
        }
<span class="nc bnc" id="L3717" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.keyCompromise) != 0) {</span>
<span class="nc" id="L3718">            ret = RevokedCertInfo.REVOCATION_REASON_KEYCOMPROMISE;</span>
        }
<span class="nc bnc" id="L3720" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.privilegeWithdrawn) != 0) {</span>
<span class="nc" id="L3721">            ret = RevokedCertInfo.REVOCATION_REASON_PRIVILEGESWITHDRAWN;</span>
        }
<span class="nc bnc" id="L3723" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.superseded) != 0) {</span>
<span class="nc" id="L3724">            ret = RevokedCertInfo.REVOCATION_REASON_SUPERSEDED;</span>
        }
<span class="nc bnc" id="L3726" title="All 2 branches missed.">        if ((val &amp; ReasonFlags.unused) != 0) {</span>
<span class="nc" id="L3727">            ret = RevokedCertInfo.REVOCATION_REASON_UNSPECIFIED;</span>
        }
<span class="nc" id="L3729">        return ret;</span>
    }

    /**
     * Method used to insert a CN postfix into DN by extracting the first found CN appending cnpostfix and then replacing the original CN with the new
     * one in DN.
     * 
     * If no CN could be found in DN then should the given DN be returned untouched
     * 
     * @param dn the DN to manipulate, cannot be null
     * @param cnpostfix the postfix to insert, cannot be null
     * @param nameStyle Controls how the name is encoded. Usually it should be a CeSecoreNameStyle.
     * @return the new DN
     */
    public static String insertCNPostfix(String dn, String cnpostfix, X500NameStyle nameStyle) {
<span class="pc bpc" id="L3744" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L3745">            log.trace(&quot;&gt;insertCNPostfix: dn=&quot; + dn + &quot;, cnpostfix=&quot; + cnpostfix);</span>
        }
<span class="pc bpc" id="L3747" title="1 of 2 branches missed.">        if (dn == null) {</span>
<span class="nc" id="L3748">            return null;</span>
        }
<span class="fc" id="L3750">        final RDN[] rdns = IETFUtils.rDNsFromString(dn, nameStyle);</span>
<span class="fc" id="L3751">        final X500NameBuilder nameBuilder = new X500NameBuilder(nameStyle);</span>
<span class="fc" id="L3752">        boolean replaced = false;</span>
<span class="fc bfc" id="L3753" title="All 2 branches covered.">        for (final RDN rdn : rdns) {</span>
<span class="fc" id="L3754">            final AttributeTypeAndValue[] attributeTypeAndValues = rdn.getTypesAndValues();</span>
<span class="fc bfc" id="L3755" title="All 2 branches covered.">            for (final AttributeTypeAndValue atav : attributeTypeAndValues) {</span>
<span class="pc bpc" id="L3756" title="1 of 2 branches missed.">                if (atav.getType() != null) {</span>
<span class="fc" id="L3757">                    final String currentSymbol = CeSecoreNameStyle.DefaultSymbols.get(atav.getType());</span>
<span class="fc bfc" id="L3758" title="All 4 branches covered.">                    if (!replaced &amp;&amp; &quot;CN&quot;.equals(currentSymbol)) {</span>
<span class="fc" id="L3759">                        nameBuilder.addRDN(atav.getType(), IETFUtils.valueToString(atav.getValue()) + cnpostfix);</span>
<span class="fc" id="L3760">                        replaced = true;</span>
                    } else {
<span class="fc" id="L3762">                        nameBuilder.addRDN(atav);</span>
                    }
                }
            }
        }
<span class="fc" id="L3767">        final String ret = nameBuilder.build().toString();</span>
<span class="pc bpc" id="L3768" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L3769">            log.trace(&quot;&lt;reverseDN: &quot; + ret);</span>
        }
<span class="fc" id="L3771">        return ret;</span>
    }

    /**
     * Splits a DN into components.
     * @param dn DN
     * @return DN components
     * @see X509NameTokenizer
     */
    public static List&lt;String&gt; getX500NameComponents(String dn) {
<span class="nc" id="L3781">        List&lt;String&gt; ret = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L3782">        X509NameTokenizer tokenizer = new X509NameTokenizer(dn);</span>
<span class="nc bnc" id="L3783" title="All 2 branches missed.">        while (tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L3784">            ret.add(tokenizer.nextToken());</span>
        }
<span class="nc" id="L3786">        return ret;</span>
    }

    /**
     * Returns the parent DN of a DN string, e.g. if the input is
     * &quot;cn=User,dc=example,dc=com&quot; then it would return &quot;dc=example,dc=com&quot;.
     * Returns an empty string if there is no parent DN.
     * @param dn DN
     * @return Parent DN
     */
    public static String getParentDN(String dn) {
<span class="nc" id="L3797">        final X509NameTokenizer tokenizer = new X509NameTokenizer(dn);</span>
<span class="nc" id="L3798">        tokenizer.nextToken();</span>
<span class="nc" id="L3799">        return tokenizer.getRemainingString();</span>
    }

    /**
     * class for breaking up an X500 Name into it's component tokens, ala java.util.StringTokenizer. 
     */
    private static class X509NameTokenizer {
        private String value;
        private int index;
        private char separator;
<span class="fc" id="L3809">        private StringBuffer buf = new StringBuffer();</span>

        /** Creates the object, using the default comma (,) as separator for tokenization 
         * @param oid OID */
        public X509NameTokenizer(String oid) {
<span class="fc" id="L3814">            this(oid, ',');</span>
<span class="fc" id="L3815">        }</span>

<span class="fc" id="L3817">        public X509NameTokenizer(String oid, char separator) {</span>
<span class="fc" id="L3818">            this.value = oid;</span>
<span class="fc" id="L3819">            this.index = -1;</span>
<span class="fc" id="L3820">            this.separator = separator;</span>
<span class="fc" id="L3821">        }</span>

        public boolean hasMoreTokens() {
<span class="fc bfc" id="L3824" title="All 2 branches covered.">            return (index != value.length());</span>
        }

        public String nextToken() {
<span class="pc bpc" id="L3828" title="1 of 2 branches missed.">            if (index == value.length()) {</span>
<span class="nc" id="L3829">                return null;</span>
            }

<span class="fc" id="L3832">            int end = index + 1;</span>
<span class="fc" id="L3833">            boolean quoted = false;</span>
<span class="fc" id="L3834">            boolean escaped = false;</span>

<span class="fc" id="L3836">            buf.setLength(0);</span>

<span class="fc bfc" id="L3838" title="All 2 branches covered.">            while (end != value.length()) {</span>
<span class="fc" id="L3839">                char c = value.charAt(end);</span>

<span class="fc bfc" id="L3841" title="All 2 branches covered.">                if (c == '&quot;') {</span>
<span class="fc bfc" id="L3842" title="All 2 branches covered.">                    if (!escaped) {</span>
<span class="fc bfc" id="L3843" title="All 2 branches covered.">                        quoted = !quoted;</span>
                    } else {
<span class="pc bpc" id="L3845" title="3 of 4 branches missed.">                        if (c == '#' &amp;&amp; buf.charAt(buf.length() - 1) == '=') {</span>
<span class="nc" id="L3846">                            buf.append('\\');</span>
<span class="pc bpc" id="L3847" title="3 of 4 branches missed.">                        } else if (c == '+' &amp;&amp; separator != '+') {</span>
<span class="nc" id="L3848">                            buf.append('\\');</span>
                        }
<span class="fc" id="L3850">                        buf.append(c);</span>
                    }
<span class="fc" id="L3852">                    escaped = false;</span>
                } else {
<span class="fc bfc" id="L3854" title="All 4 branches covered.">                    if (escaped || quoted) {</span>
<span class="pc bpc" id="L3855" title="1 of 4 branches missed.">                        if (c == '#' &amp;&amp; buf.charAt(buf.length() - 1) == '=') {</span>
<span class="fc" id="L3856">                            buf.append('\\');</span>
<span class="pc bpc" id="L3857" title="1 of 4 branches missed.">                        } else if (c == '+' &amp;&amp; separator != '+') {</span>
<span class="fc" id="L3858">                            buf.append('\\');</span>
                        }
<span class="fc" id="L3860">                        buf.append(c);</span>
<span class="fc" id="L3861">                        escaped = false;</span>
<span class="fc bfc" id="L3862" title="All 2 branches covered.">                    } else if (c == '\\') {</span>
<span class="fc" id="L3863">                        escaped = true;</span>
<span class="fc bfc" id="L3864" title="All 2 branches covered.">                    } else if (c == separator) {</span>
<span class="fc" id="L3865">                        break;</span>
                    } else {
<span class="fc" id="L3867">                        buf.append(c);</span>
                    }
                }
<span class="fc" id="L3870">                end++;</span>
<span class="fc" id="L3871">            }</span>

<span class="fc" id="L3873">            index = end;</span>
<span class="fc" id="L3874">            return buf.toString().trim();</span>
        }

        /**
         * @return the remaining (not yet tokenized) part of the DN.
         */
        String getRemainingString() {
<span class="nc bnc" id="L3881" title="All 2 branches missed.">            return index + 1 &lt; value.length() ? value.substring(index + 1) : &quot;&quot;;</span>
        }
    }

    /**
     * class for breaking up an X500 Name into it's component tokens, ala java.util.StringTokenizer. Taken from BouncyCastle, but does NOT use or
     * consider escaped characters. Used for reversing DNs without unescaping.
     */
    private static class BasicX509NameTokenizer {
        final private String oid;
<span class="fc" id="L3891">        private int index = -1;</span>
        /* 
         * Since this class isn't thread safe anyway, we can use the slightly faster StringBuilder instead of StringBuffer 
         */
<span class="fc" id="L3895">        private StringBuilder buf = new StringBuilder();</span>

<span class="fc" id="L3897">        public BasicX509NameTokenizer(String oid) {</span>
<span class="fc" id="L3898">            this.oid = oid;</span>
<span class="fc" id="L3899">        }</span>

        public boolean hasMoreTokens() {
<span class="fc bfc" id="L3902" title="All 2 branches covered.">            return (index != oid.length());</span>
        }

        public String nextToken() {
<span class="pc bpc" id="L3906" title="1 of 2 branches missed.">            if (index == oid.length()) {</span>
<span class="nc" id="L3907">                return null;</span>
            }

<span class="fc" id="L3910">            int end = index + 1;</span>
<span class="fc" id="L3911">            boolean quoted = false;</span>
<span class="fc" id="L3912">            boolean escaped = false;</span>

<span class="fc" id="L3914">            buf.setLength(0);</span>

<span class="fc bfc" id="L3916" title="All 2 branches covered.">            while (end != oid.length()) {</span>
<span class="fc" id="L3917">                char c = oid.charAt(end);</span>

<span class="fc bfc" id="L3919" title="All 2 branches covered.">                if (c == '&quot;') {</span>
<span class="pc bpc" id="L3920" title="1 of 2 branches missed.">                    if (!escaped) {</span>
<span class="fc" id="L3921">                        buf.append(c);</span>
<span class="fc" id="L3922">                        quoted ^= true; // Faster than &quot;quoted = !quoted;&quot;</span>
                    } else {
<span class="nc" id="L3924">                        buf.append(c);</span>
                    }
<span class="fc" id="L3926">                    escaped = false;</span>
                } else {
<span class="fc bfc" id="L3928" title="All 4 branches covered.">                    if (escaped || quoted) {</span>
<span class="fc" id="L3929">                        buf.append(c);</span>
<span class="fc" id="L3930">                        escaped = false;</span>
<span class="fc bfc" id="L3931" title="All 2 branches covered.">                    } else if (c == '\\') {</span>
<span class="fc" id="L3932">                        buf.append(c);</span>
<span class="fc" id="L3933">                        escaped = true;</span>
<span class="pc bpc" id="L3934" title="1 of 4 branches missed.">                    } else if ((c == ',') &amp;&amp; (!escaped)) {</span>
<span class="fc" id="L3935">                        break;</span>
                    } else {
<span class="fc" id="L3937">                        buf.append(c);</span>
                    }
                }
<span class="fc" id="L3940">                end++;</span>
<span class="fc" id="L3941">            }</span>

<span class="fc" id="L3943">            index = end;</span>
<span class="fc" id="L3944">            return buf.toString().trim();</span>
        }
    } // BasicX509NameTokenizer

    /**
     * Obtains a List with the ASN1ObjectIdentifiers for dNObjects names, in the specified order
     * 
     * @param order an array of DN objects.
     * @return a List with ASN1ObjectIdentifiers defining the known order we require
     * @see org.cesecore.certificates.util.DnComponents#getDnObjects(boolean) for definition of the contents of the input array
     */
    private static List&lt;ASN1ObjectIdentifier&gt; getX509FieldOrder(String[] order) {
<span class="fc" id="L3956">        List&lt;ASN1ObjectIdentifier&gt; fieldOrder = new ArrayList&lt;ASN1ObjectIdentifier&gt;();</span>
<span class="fc bfc" id="L3957" title="All 2 branches covered.">        for (final String dNObject : order) {</span>
<span class="fc" id="L3958">            fieldOrder.add(DnComponents.getOid(dNObject));</span>
        }
<span class="fc" id="L3960">        return fieldOrder;</span>
    }
    /**
     * Obtains a List with the ASN1ObjectIdentifiers for dNObjects names, in the specified pre-defined order
     * 
     * @param ldaporder if true the returned order are as defined in LDAP RFC (CN=foo,O=bar,C=SE), otherwise the order is a defined in X.500
     *            (C=SE,O=bar,CN=foo).
     * @return a List with ASN1ObjectIdentifiers defining the known order we require
     * @see org.cesecore.certificates.util.DnComponents#getDnObjects(boolean)
     */
    public static List&lt;ASN1ObjectIdentifier&gt; getX509FieldOrder(boolean ldaporder) {
<span class="fc" id="L3971">        return getX509FieldOrder(DnComponents.getDnObjects(ldaporder));</span>
    }

    /**
     * EJBCA accepts extension OIDs on different formats, e.g. &quot;1.2.3.4&quot; and &quot;1.2.3.4.value&quot;.
     * Method returns the OID only given any OID string
     * @param oidString to parse
     * @return String containing OID only
     */
    public static String getOidFromString(final String oidString) {
<span class="fc" id="L3981">        String retval = oidString;</span>
        // Matches anything but numerical and dots
<span class="fc" id="L3983">        final Pattern pattern = Pattern.compile(&quot;[^0-9.]&quot;);</span>
<span class="fc" id="L3984">        final Matcher matcher = pattern.matcher(oidString);</span>
<span class="pc bpc" id="L3985" title="1 of 2 branches missed.">        if (matcher.find()) {</span>
<span class="fc" id="L3986">            int endIndex = matcher.start();</span>
<span class="fc" id="L3987">            retval = oidString.substring(0, endIndex-1);</span>
        }
<span class="fc" id="L3989">        return retval;</span>
    }
    
    /**
     * Returns the regex match pattern given an OID wildcard.
     * @param oidWildcard wildcard. E.g. 1.2.*.3
     * @return regex match pattern
     */
    public static String getOidWildcardPattern(final String oidWildcard) {
        // First escape all '.' which are interpreted as regex wildcards themselves.
        // Secondly, generate the pattern where '*' is the wildcard character
<span class="fc" id="L4000">        final String wildcardMatchPattern = oidWildcard.replaceAll(&quot;\\.&quot;, &quot;\\\\.&quot;).replaceAll(&quot;\\*&quot;, &quot;([0-9.]*)&quot;);</span>
<span class="fc" id="L4001">        return wildcardMatchPattern;</span>
    }
    
    /**
     * Obtain a X500Name reordered, if some fields from original X500Name doesn't appear in &quot;ordering&quot; parameter, they will be added at end in the
     * original order.
     * 
     * @param x500Name the X500Name that is unordered
     * @param ldaporder true if LDAP ordering of DN should be used (default in EJBCA), false for X.500 order, ldap order is CN=A,OU=B,O=C,C=SE, x.500
     *            order is the reverse
     * @param order specified order, which overrides 'ldaporder', care must be taken constructing this String array, ignored if null or empty
     * @param applyLdapToCustomOrder specifies if the ldaporder setting should apply to an order (custom order) if this is not empty
     * @param nameStyle Controls how the name is encoded. Usually it should be a CeSecoreNameStyle.
     * @return X500Name with ordered conmponents according to the orcering vector
     */
    private static X500Name getOrderedX500Name(final X500Name x500Name, boolean ldaporder, String[] order, final boolean applyLdapToCustomOrder, final X500NameStyle nameStyle) {
        // -- New order for the X509 Fields
<span class="fc" id="L4018">        final List&lt;ASN1ObjectIdentifier&gt; newOrdering = new ArrayList&lt;ASN1ObjectIdentifier&gt;();</span>
<span class="fc" id="L4019">        final List&lt;ASN1Encodable&gt; newValues = new ArrayList&lt;ASN1Encodable&gt;();</span>
        // -- Add ordered fields
<span class="fc" id="L4021">        final ASN1ObjectIdentifier[] allOids = x500Name.getAttributeTypes();</span>
        
        // Guess order of the input name
<span class="fc bfc" id="L4024" title="All 2 branches covered.">        final boolean isLdapOrder = !isDNReversed(x500Name.toString());</span>
        // If we think the DN is in LDAP order, first order it as a LDAP DN, if we don't think it's LDAP order
        // order it as a X.500 DN. If we haven't specified our own ordering
        final List&lt;ASN1ObjectIdentifier&gt; ordering;
<span class="pc bpc" id="L4028" title="1 of 4 branches missed.">        final boolean useCustomOrder = (order != null) &amp;&amp; (order.length &gt; 0);  </span>
<span class="fc bfc" id="L4029" title="All 2 branches covered.">        if (useCustomOrder) {</span>
<span class="fc" id="L4030">            log.debug(&quot;Using custom DN order&quot;);</span>
<span class="fc" id="L4031">            ordering = getX509FieldOrder(order);            </span>
        } else {
<span class="fc" id="L4033">            ordering = getX509FieldOrder(isLdapOrder);</span>
        }
        
<span class="fc" id="L4036">        final HashSet&lt;ASN1ObjectIdentifier&gt; hs = new HashSet&lt;ASN1ObjectIdentifier&gt;(allOids.length + ordering.size());</span>
<span class="fc bfc" id="L4037" title="All 2 branches covered.">        for (final ASN1ObjectIdentifier oid : ordering) {</span>
<span class="fc bfc" id="L4038" title="All 2 branches covered.">            if (!hs.contains(oid)) {</span>
<span class="fc" id="L4039">                hs.add(oid);</span>
<span class="fc" id="L4040">                final RDN[] valueList = x500Name.getRDNs(oid);</span>
                // -- Only add the OID if has not null value
<span class="fc bfc" id="L4042" title="All 2 branches covered.">                for (final RDN value : valueList) {</span>
<span class="fc" id="L4043">                    newOrdering.add(oid);</span>
<span class="fc" id="L4044">                    newValues.add(value.getFirst().getValue());</span>
                }
            }
<span class="fc" id="L4047">        }</span>
        // -- Add unexpected fields to the end
<span class="fc bfc" id="L4049" title="All 2 branches covered.">        for (final ASN1ObjectIdentifier oid : allOids) {</span>
<span class="fc bfc" id="L4050" title="All 2 branches covered.">            if (!hs.contains(oid)) {</span>
<span class="fc" id="L4051">                hs.add(oid);</span>
<span class="fc" id="L4052">                final RDN[] valueList = x500Name.getRDNs(oid);</span>
                // -- Only add the OID if has not null value
<span class="fc bfc" id="L4054" title="All 2 branches covered.">                for (final RDN value : valueList) {</span>
<span class="fc" id="L4055">                    newOrdering.add(oid);</span>
<span class="fc" id="L4056">                    newValues.add(value.getFirst().getValue());</span>
<span class="pc bpc" id="L4057" title="1 of 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L4058">                        log.debug(&quot;added --&gt; &quot; + oid + &quot; val: &quot; + value);</span>
                    }
                }
            }
        }
        // If the requested ordering was the reverse of the ordering the input string was in (by our guess in the beginning)
        // we have to reverse the vectors.
        // Unless we have specified a custom order, and choose to not apply LDAP Order to this custom order, in which case we will not change the order from the custom
<span class="fc bfc" id="L4066" title="All 6 branches covered.">        if ( (useCustomOrder &amp;&amp; applyLdapToCustomOrder) || !useCustomOrder) {</span>
<span class="fc bfc" id="L4067" title="All 2 branches covered.">            if (ldaporder != isLdapOrder) {</span>
<span class="pc bpc" id="L4068" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L4069">                    log.debug(&quot;Reversing order of DN, ldaporder=&quot; + ldaporder + &quot;, isLdapOrder=&quot; + isLdapOrder);</span>
                }
<span class="fc" id="L4071">                Collections.reverse(newOrdering);</span>
<span class="fc" id="L4072">                Collections.reverse(newValues);</span>
            }
        }

<span class="fc" id="L4076">        X500NameBuilder nameBuilder = new X500NameBuilder(nameStyle);</span>
<span class="fc bfc" id="L4077" title="All 2 branches covered.">        for (int i = 0; i &lt; newOrdering.size(); i++) {</span>
<span class="fc" id="L4078">            nameBuilder.addRDN(newOrdering.get(i), newValues.get(i));</span>
        }
        // -- Return X500Name with the ordered fields
<span class="fc" id="L4081">        return nameBuilder.build();</span>
    } //

    /**
     * Obtain the directory string for the directoryName generation form the Subject Alternative Name String.
     * 
     * @param altName name
     * @return directory
     */
    private static String getDirectoryStringFromAltName(String altName) {
<span class="fc" id="L4091">        String directoryName = CertTools.getPartFromDN(altName, CertTools.DIRECTORYNAME);</span>
        // DNFieldExtractor dnfe = new DNFieldExtractor(altName, DNFieldExtractor.TYPE_SUBJECTALTNAME);
        // String directoryName = dnfe.getField(DNFieldExtractor.DIRECTORYNAME, 0);
        /** TODO: Validate or restrict the directoryName Fields? */
<span class="pc bpc" id="L4095" title="1 of 2 branches missed.">        return (&quot;&quot;.equals(directoryName) ? null : directoryName);</span>
    } // getDirectoryStringFromAltName

    /**
     * Method to create certificate path and to check it's validity from a list of certificates. The list of certificates should only contain one root
     * certificate. The created certificate chain is checked to be valid at the current date and time.
     * 
     * @param certlistin List of certificates to create certificate chain from.
     * @return the certificatepath with the root CA at the end
     * @throws CertPathValidatorException if the certificate chain can not be constructed or validated
     * @throws InvalidAlgorithmParameterException If params are invalid
     * @throws NoSuchProviderException If provider not found
     * @throws NoSuchAlgorithmException If algorithm not found
     * @throws CertificateException If certificate cannot be parsed
     */
    public static List&lt;Certificate&gt; createCertChain(Collection&lt;?&gt; certlistin) throws CertPathValidatorException, InvalidAlgorithmParameterException,
            NoSuchAlgorithmException, NoSuchProviderException, CertificateException {
<span class="fc" id="L4112">        return createCertChain(certlistin, new Date());</span>
    }

    /**
     * Method to create certificate path and to check it's validity from a list of certificates. The list of certificates should only contain one root
     * certificate.
     * 
     * @param certlistin List of certificates (X.509, CVC, or other supported) to create certificate chain from.
     * @param now Date to use when checking if the CAs chain is valid.
     * @return the certificate path with the root CA at the end
     * @throws CertPathValidatorException if the certificate chain can not be constructed
     * @throws InvalidAlgorithmParameterException If params are invalid
     * @throws NoSuchProviderException If provider not found
     * @throws NoSuchAlgorithmException If algorithm not found
     * @throws CertificateException If certificate cannot be parsed
     */
    public static List&lt;Certificate&gt; createCertChain(Collection&lt;?&gt; certlistin, Date now) throws CertPathValidatorException, InvalidAlgorithmParameterException,
            NoSuchAlgorithmException, NoSuchProviderException, CertificateException {
<span class="fc" id="L4130">        final List&lt;Certificate&gt; returnval = new ArrayList&lt;Certificate&gt;();</span>

<span class="fc" id="L4132">        Collection&lt;Certificate&gt; certlist = orderCertificateChain(certlistin);</span>
        // Verify that the chain contains a Root CA certificate
<span class="fc" id="L4134">        Certificate rootca = null;</span>
<span class="fc bfc" id="L4135" title="All 2 branches covered.">        for(Certificate crt : certlist) {</span>
<span class="fc bfc" id="L4136" title="All 2 branches covered.">            if (CertTools.isSelfSigned(crt)) {</span>
<span class="fc" id="L4137">                rootca = crt;</span>
            }
<span class="fc" id="L4139">        }</span>
<span class="pc bpc" id="L4140" title="1 of 2 branches missed.">        if (rootca == null) {</span>
<span class="nc" id="L4141">            throw new CertPathValidatorException(&quot;No root CA certificate found in certificate list&quot;);</span>
        }

        // set certificate chain
<span class="fc" id="L4145">        Certificate rootcert = null;</span>
<span class="fc" id="L4146">        ArrayList&lt;Certificate&gt; calist = new ArrayList&lt;Certificate&gt;();</span>
<span class="fc bfc" id="L4147" title="All 2 branches covered.">        for (Certificate next : certlist) {</span>
<span class="fc bfc" id="L4148" title="All 2 branches covered.">            if (CertTools.isSelfSigned(next)) {</span>
<span class="fc" id="L4149">                rootcert = next;</span>
            } else {
<span class="fc" id="L4151">                calist.add(next);</span>
            }
<span class="fc" id="L4153">        }</span>

<span class="pc bpc" id="L4155" title="1 of 2 branches missed.">        if (calist.isEmpty()) {</span>
            // only one root cert, no certchain
<span class="nc" id="L4157">            returnval.add(rootcert);</span>
        } else {
            // We need a bit special handling for CV certificates because those can not be handled using a PKIX CertPathValidator
<span class="fc" id="L4160">            Certificate test = calist.get(0);</span>
<span class="fc bfc" id="L4161" title="All 2 branches covered.">            if (test.getType().equals(&quot;CVC&quot;)) {</span>
<span class="pc bpc" id="L4162" title="1 of 2 branches missed.">                if (calist.size() == 1) {</span>
<span class="fc" id="L4163">                    returnval.add(test);</span>
<span class="fc" id="L4164">                    returnval.add(rootcert);</span>
                } else {
<span class="nc" id="L4166">                    throw new CertPathValidatorException(&quot;CVC certificate chain can not be of length longer than two.&quot;);</span>
                }
            } else {
                // Normal X509 certificates
<span class="fc" id="L4170">                HashSet&lt;TrustAnchor&gt; trustancors = new HashSet&lt;TrustAnchor&gt;();</span>
<span class="fc" id="L4171">                TrustAnchor trustanchor = null;</span>
<span class="fc" id="L4172">                trustanchor = new TrustAnchor((X509Certificate) rootcert, null);</span>
<span class="fc" id="L4173">                trustancors.add(trustanchor);</span>

                // Create the parameters for the validator
<span class="fc" id="L4176">                PKIXParameters params = new PKIXParameters(trustancors);</span>

                // Disable CRL checking since we are not supplying any CRLs
<span class="fc" id="L4179">                params.setRevocationEnabled(false);</span>
<span class="fc" id="L4180">                params.setDate(now);</span>

                // Create the validator and validate the path
<span class="fc" id="L4183">                CertPathValidator certPathValidator = CertPathValidator.getInstance(CertPathValidator.getDefaultType(), &quot;BC&quot;);</span>
<span class="fc" id="L4184">                CertificateFactory fact = CertTools.getCertificateFactory();</span>
<span class="fc" id="L4185">                CertPath certpath = fact.generateCertPath(calist);</span>

<span class="fc" id="L4187">                CertPathValidatorResult result = certPathValidator.validate(certpath, params);</span>

                // Get the certificates validate in the path
<span class="fc" id="L4190">                PKIXCertPathValidatorResult pkixResult = (PKIXCertPathValidatorResult) result;</span>
<span class="fc" id="L4191">                returnval.addAll(certpath.getCertificates());</span>

                // Get the CA used to validate this path
<span class="fc" id="L4194">                TrustAnchor ta = pkixResult.getTrustAnchor();</span>
<span class="fc" id="L4195">                X509Certificate cert = ta.getTrustedCert();</span>
<span class="fc" id="L4196">                returnval.add(cert);</span>
            }
        }
<span class="fc" id="L4199">        return returnval;</span>
    } // createCertChain

    /**
     * Method ordering a list of certificate (X.509, CVC, or other supported type) into a certificate path with the root CA at the end. Does not check validity or verification of any kind,
     * just ordering by issuerdn.
     * 
     * @param certlist list of certificates to order can be collection of Certificate or byte[] (der encoded certs), must contain a full chain.
     * @return List with certificatechain, Root CA last.
     * @throws CertPathValidatorException  if validation fails
     */
    private static List&lt;Certificate&gt; orderCertificateChain(Collection&lt;?&gt; certlist) throws CertPathValidatorException {
<span class="fc" id="L4211">        ArrayList&lt;Certificate&gt; returnval = new ArrayList&lt;Certificate&gt;();</span>
<span class="fc" id="L4212">        Certificate rootca = null;</span>
<span class="fc" id="L4213">        HashMap&lt;String, Certificate&gt; cacertmap = new HashMap&lt;String, Certificate&gt;();</span>
<span class="fc bfc" id="L4214" title="All 2 branches covered.">        for(Object possibleCertificate : certlist) {</span>
<span class="fc" id="L4215">            Certificate cert = null;</span>
            try {
<span class="fc" id="L4217">                cert = (Certificate) possibleCertificate;</span>
<span class="nc" id="L4218">            } catch (ClassCastException e) {</span>
                // This was not a certificate, is it byte encoded?
<span class="nc" id="L4220">                byte[] certBytes = (byte[]) possibleCertificate;</span>
                try {
<span class="nc" id="L4222">                    cert = CertTools.getCertfromByteArray(certBytes);</span>
<span class="nc" id="L4223">                } catch (CertificateParsingException e1) {</span>
<span class="nc" id="L4224">                    throw new CertPathValidatorException(e1);</span>
<span class="nc" id="L4225">                }</span>
<span class="fc" id="L4226">            }</span>
<span class="fc bfc" id="L4227" title="All 2 branches covered.">            if (CertTools.isSelfSigned(cert)) {</span>
<span class="fc" id="L4228">                rootca = cert;</span>
            } else {
<span class="fc" id="L4230">                log.debug(&quot;Adding to cacertmap with index '&quot; + CertTools.getIssuerDN(cert) + &quot;'&quot;);</span>
<span class="fc" id="L4231">                cacertmap.put(CertTools.getIssuerDN(cert), cert);</span>
            }
<span class="fc" id="L4233">        }</span>

<span class="pc bpc" id="L4235" title="1 of 2 branches missed.">        if (rootca == null) {</span>
<span class="nc" id="L4236">            throw new CertPathValidatorException(&quot;No root CA certificate found in certificatelist&quot;);</span>
        }
<span class="fc" id="L4238">        returnval.add(0, rootca);</span>
<span class="fc" id="L4239">        Certificate currentcert = rootca;</span>
<span class="fc" id="L4240">        int i = 0;</span>
<span class="pc bpc" id="L4241" title="1 of 4 branches missed.">        while (certlist.size() != returnval.size() &amp;&amp; i &lt;= certlist.size()) {</span>
<span class="pc bpc" id="L4242" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L4243">                log.debug(&quot;Looking in cacertmap for '&quot; + CertTools.getSubjectDN(currentcert) + &quot;'&quot;);</span>
            }
<span class="fc" id="L4245">            Certificate nextcert = cacertmap.get(CertTools.getSubjectDN(currentcert));</span>
<span class="pc bpc" id="L4246" title="1 of 2 branches missed.">            if (nextcert == null) {</span>
<span class="nc bnc" id="L4247" title="All 2 branches missed.">                if(log.isDebugEnabled()) {</span>
<span class="nc" id="L4248">                    log.debug(&quot;Dumping keys of CA certificate map:&quot;);</span>
<span class="nc bnc" id="L4249" title="All 2 branches missed.">                    for(String issuerDn : cacertmap.keySet()) {</span>
<span class="nc" id="L4250">                        log.debug(issuerDn);</span>
<span class="nc" id="L4251">                    }</span>
                }
<span class="nc" id="L4253">                throw new CertPathValidatorException(&quot;Error building certificate path. Could find certificate with SubjectDN &quot; </span>
<span class="nc" id="L4254">                        + CertTools.getSubjectDN(currentcert) + &quot; in certificate map. See debug log for details.&quot;);</span>
            }
<span class="fc" id="L4256">            returnval.add(0, nextcert);</span>
<span class="fc" id="L4257">            currentcert = nextcert;</span>
<span class="fc" id="L4258">            i++;</span>
<span class="fc" id="L4259">        }</span>

<span class="pc bpc" id="L4261" title="1 of 2 branches missed.">        if (i &gt; certlist.size()) {</span>
<span class="nc" id="L4262">            throw new CertPathValidatorException(&quot;Error building certificate path&quot;);</span>
        }

<span class="fc" id="L4265">        return returnval;</span>
    } // orderCertificateChain

    /**
     * Method ordering a list of X509 certificate into a certificate path with the root CA, or topmost Sub CA at the end. Does not check validity or verification of any kind,
     * just ordering by issuerdn/keyId. This is mostly a wrapper around CertPath.generateCertPath, but we do regression test this ordering.
     * 
     * @param certlist list of certificates to order can be collection of Certificate or byte[] (der encoded certs).
     * @return List with certificate chain with leaf certificate first, and root CA, or last sub CA, in the end, does not have to contain a Root CA is input does not.
     * @throws CertPathValidatorException if validation fails
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static List&lt;X509Certificate&gt; orderX509CertificateChain(List&lt;X509Certificate&gt; certlist) throws CertPathValidatorException {
        CertPath cp;
        try {
<span class="fc" id="L4280">            cp = CertificateFactory.getInstance(&quot;X.509&quot;, BouncyCastleProvider.PROVIDER_NAME).generateCertPath(certlist);</span>
<span class="nc" id="L4281">        } catch (CertificateException e) {</span>
            // Wasn't a certificate after all?
<span class="nc" id="L4283">            throw new CertPathValidatorException(e);</span>
<span class="nc" id="L4284">        } catch (NoSuchProviderException e) {</span>
            // This is really bad
<span class="nc" id="L4286">            throw new IllegalStateException(&quot;BouncyCastle was not found as a provider.&quot;, e);</span>
<span class="fc" id="L4287">        }</span>
<span class="fc" id="L4288">        return (List&lt;X509Certificate&gt;)cp.getCertificates();</span>
    } // orderX509CertificateChain

    /**
     * @param chainA first chain
     * @param chainB second chain
     * @return true if the chains are nonempty, contain the same certificates in the same order
     */
    public static boolean compareCertificateChains(Certificate[] chainA, Certificate[] chainB) {
<span class="nc bnc" id="L4297" title="All 4 branches missed.">        if (chainA == null || chainB == null) {</span>
<span class="nc" id="L4298">            return false;</span>
        }
<span class="nc bnc" id="L4300" title="All 2 branches missed.">        if (chainA.length != chainB.length) {</span>
<span class="nc" id="L4301">            return false;</span>
        }
<span class="nc bnc" id="L4303" title="All 2 branches missed.">        for (int i = 0; i &lt; chainA.length; i++) {</span>
<span class="nc bnc" id="L4304" title="All 4 branches missed.">            if (chainA[i] == null || !chainA[i].equals(chainB[i])) {</span>
<span class="nc" id="L4305">                return false;</span>
            }
        }
<span class="nc" id="L4308">        return true;</span>
    }

    /**
     * Dumps a certificate (cvc or x.509) to string format, suitable for manual inspection/debugging.
     * 
     * @param cert Certificate
     * 
     * @return String with cvc or asn.1 dump.
     */
    public static String dumpCertificateAsString(final Certificate cert) {
<span class="nc" id="L4319">        String ret = null;</span>
<span class="nc bnc" id="L4320" title="All 2 branches missed.">        if (cert instanceof X509Certificate) {</span>
            try {
<span class="nc" id="L4322">                final Certificate c = getCertfromByteArray(cert.getEncoded());</span>
<span class="nc" id="L4323">                ret = c.toString();</span>
                // ASN1InputStream ais = new ASN1InputStream(new ByteArrayInputStream(cert.getEncoded()));
                // ASN1Primitive obj = ais.readObject();
                // ret = ASN1Dump.dumpAsString(obj);
<span class="nc" id="L4327">            } catch (CertificateException e) {</span>
<span class="nc" id="L4328">                ret = e.getMessage();</span>
<span class="nc" id="L4329">            }</span>
<span class="nc bnc" id="L4330" title="All 2 branches missed.">        } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="nc" id="L4331">            final CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cert;</span>
<span class="nc" id="L4332">            final CVCObject obj = cvccert.getCVCertificate();</span>
<span class="nc" id="L4333">            ret = obj.getAsText(&quot;&quot;);</span>
<span class="nc" id="L4334">        } else {</span>
<span class="nc" id="L4335">            throw new IllegalArgumentException(&quot;dumpCertificateAsString: Certificate of type &quot; + cert.getType() + &quot; is not implemented&quot;);</span>
        }
<span class="nc" id="L4337">        return ret;</span>
    }
    
    /**
     * Creates PKCS10CertificateRequest object from PEM encoded certificate request
     * @param pemEncodedCsr PEM encoded CSR
     * @return PKCS10CertificateRequest object
     */
    public static PKCS10CertificationRequest getCertificateRequestFromPem(final String pemEncodedCsr){
<span class="nc bnc" id="L4346" title="All 2 branches missed.">        if(pemEncodedCsr == null){</span>
<span class="nc" id="L4347">            return null;</span>
        }
<span class="nc" id="L4349">        PKCS10CertificationRequest csr = null;</span>
<span class="nc" id="L4350">        final ByteArrayInputStream pemStream = new ByteArrayInputStream(pemEncodedCsr.getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L4351">        try (PEMParser pemParser = new PEMParser(new BufferedReader(new InputStreamReader(pemStream)));) {</span>
<span class="nc" id="L4352">            final Object parsedObj = pemParser.readObject();</span>
<span class="nc bnc" id="L4353" title="All 2 branches missed.">            if (parsedObj instanceof PKCS10CertificationRequest) {</span>
<span class="nc" id="L4354">                csr = (PKCS10CertificationRequest) parsedObj;</span>
            }
<span class="nc" id="L4356">        } catch (IOException | DecoderException e) {//IOException that will be wrapped as (runtime) DecoderException</span>
<span class="nc" id="L4357">            log.info(&quot;IOException while decoding certificate request from PEM: &quot; + e.getMessage());</span>
<span class="nc" id="L4358">            log.debug(&quot;IOException while decoding certificate request from PEM.&quot;, e);</span>
<span class="nc" id="L4359">        }</span>
<span class="nc" id="L4360">        return csr;</span>
    }

    /**
     * Generates a PKCS10CertificationRequest
     * 
     * Code Example:
     * -------------
     * An example of putting AltName and a password challenge in an 'attributes' set (taken from RequestMessageTest.test01Pkcs10RequestMessage() ):
     *       
     *      {@code
     *      // Create a P10 with extensions, in this case altNames with a DNS name
     *      ASN1EncodableVector altnameattr = new ASN1EncodableVector();
     *      altnameattr.add(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest);
     *      // AltNames
     *      GeneralNames san = CertTools.getGeneralNamesFromAltName(&quot;dNSName=foo1.bar.com&quot;);
     *      ExtensionsGenerator extgen = new ExtensionsGenerator();
     *      extgen.addExtension(Extension.subjectAlternativeName, false, san );
     *      Extensions exts = extgen.generate();
     *      altnameattr.add(new DERSet(exts));
     *    
     *      // Add a challenge password as well
     *      ASN1EncodableVector pwdattr = new ASN1EncodableVector();
     *      pwdattr.add(PKCSObjectIdentifiers.pkcs_9_at_challengePassword); 
     *      ASN1EncodableVector pwdvalues = new ASN1EncodableVector();
     *      pwdvalues.add(new DERUTF8String(&quot;foo123&quot;));
     *      pwdattr.add(new DERSet(pwdvalues));
     *    
     *      // Complete the Attribute section of the request, the set (Attributes)
     *      // contains one sequence (Attribute)
     *      ASN1EncodableVector v = new ASN1EncodableVector();
     *      v.add(new DERSequence(altnameattr));
     *      v.add(new DERSequence(pwdattr));
     *      DERSet attributes = new DERSet(v);
     *      }
     * 
     * @param signatureAlgorithm the signature algorithm to sign the CSR.
     * @param subject the request's subject DN.
     * @param publickey the public key of the CSR.
     * @param attributes a set of attributes, for example, extensions, challenge password, etc.
     * @param privateKey the private key used to sign the CSR.
     * @param provider the JCA/JCE provider to use.
     * @return a PKCS10CertificateRequest based on the input parameters.
     * 
     * @throws OperatorCreationException if an error occurred while creating the signing key
     */
    // Should sign with. other private as well!
    public static PKCS10CertificationRequest genPKCS10CertificationRequest(String signatureAlgorithm, X500Name subject, PublicKey publickey,
            ASN1Set attributes, PrivateKey privateKey, String provider) throws OperatorCreationException {

        ContentSigner signer;
        CertificationRequestInfo reqInfo;
        try {
<span class="fc" id="L4413">            SubjectPublicKeyInfo pkinfo = SubjectPublicKeyInfo.getInstance(publickey.getEncoded());</span>
<span class="fc" id="L4414">            reqInfo = new CertificationRequestInfo(subject, pkinfo, attributes);</span>

<span class="pc bpc" id="L4416" title="1 of 2 branches missed.">            if (provider == null) {</span>
<span class="fc" id="L4417">                provider = BouncyCastleProvider.PROVIDER_NAME;</span>
            }
<span class="fc" id="L4419">            signer = new BufferingContentSigner(new JcaContentSignerBuilder(signatureAlgorithm).setProvider(provider).build(privateKey), 20480);</span>
<span class="fc" id="L4420">            signer.getOutputStream().write(reqInfo.getEncoded(ASN1Encoding.DER));</span>
<span class="fc" id="L4421">            signer.getOutputStream().flush();</span>
<span class="nc" id="L4422">        } catch (IOException e) {</span>
<span class="nc" id="L4423">            throw new IllegalStateException(&quot;Unexpected IOException was caught.&quot;, e);</span>
<span class="fc" id="L4424">        }</span>
<span class="fc" id="L4425">        byte[] sig = signer.getSignature();</span>
<span class="fc" id="L4426">        DERBitString sigBits = new DERBitString(sig);</span>

<span class="fc" id="L4428">        CertificationRequest req = new CertificationRequest(reqInfo, signer.getAlgorithmIdentifier(), sigBits);</span>
<span class="fc" id="L4429">        return new PKCS10CertificationRequest(req);</span>
    }

    /**
     * Create a &quot;certs-only&quot; PKCS#7 / CMS from the provided chain.
     * 
     * @param x509CertificateChain chain of certificates with the leaf in the first position and root in the last or just a leaf certificate.
     * @return a byte array containing the CMS
     * @throws CertificateEncodingException if the provided list of certificates could not be parsed correctly
     * @throws CMSException if there was a problem creating the certs-only CMS message
     */
    public static byte[] createCertsOnlyCMS(final List&lt;X509Certificate&gt; x509CertificateChain) throws CertificateEncodingException, CMSException {
<span class="nc bnc" id="L4441" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L4442" title="All 4 branches missed.">            final String subjectdn = ( (x509CertificateChain != null &amp;&amp; x509CertificateChain.size() &gt; 0) ? x509CertificateChain.get(0).getSubjectDN().toString() : &quot;null&quot;);  </span>
<span class="nc" id="L4443">            log.debug(&quot;Creating a certs-only CMS for &quot; + subjectdn);</span>
        }
<span class="nc" id="L4445">        final List&lt;JcaX509CertificateHolder&gt; certList = CertTools.convertToX509CertificateHolder(x509CertificateChain);</span>
<span class="nc" id="L4446">        final CMSSignedDataGenerator cmsSignedDataGenerator = new CMSSignedDataGenerator();</span>
<span class="nc" id="L4447">        cmsSignedDataGenerator.addCertificates(new CollectionStore&lt;JcaX509CertificateHolder&gt;(certList));</span>
<span class="nc" id="L4448">        final CMSSignedData cmsSignedData = cmsSignedDataGenerator.generate(new CMSAbsentContent(), true);</span>
        try {
<span class="nc" id="L4450">            return cmsSignedData.getEncoded();</span>
<span class="nc" id="L4451">        } catch (IOException e) {</span>
<span class="nc" id="L4452">            throw new CMSException(e.getMessage());</span>
        }
    }

    /**
     * Generated Generates a ContentVerifierProvider.
     * 
     * @param pubkey Key
     * @return a JcaContentVerifierProvider. Useful for verifying the signiture in a PKCS10CertificationRequest
     * @throws OperatorCreationException On fail
     */
    public static ContentVerifierProvider genContentVerifierProvider(PublicKey pubkey) throws OperatorCreationException {
<span class="fc" id="L4464">        return new JcaContentVerifierProviderBuilder().setProvider(BouncyCastleProvider.PROVIDER_NAME).build(pubkey);</span>
    }

    /**
     * @param chain cert chain
     * @return a Certificate Collection as a X509Certificate list
     * @throws ClassCastException if one of the Certificates in the collection is not an X509Certificate
     */
    public static final List&lt;X509Certificate&gt; convertCertificateChainToX509Chain(final Collection&lt;Certificate&gt; chain) throws ClassCastException {
<span class="nc" id="L4473">        final List&lt;X509Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4474" title="All 2 branches missed.">        for (final Certificate certificate : chain) {</span>
<span class="nc" id="L4475">            ret.add((X509Certificate) certificate);</span>
<span class="nc" id="L4476">        }</span>
<span class="nc" id="L4477">        return ret;</span>
    }
    
    /** @param chain cert chain
     * @return a X509Certificate Collection as a Certificate list */
    public static final List&lt;Certificate&gt; convertCertificateChainToGenericChain(final Collection&lt;X509Certificate&gt; chain) {
<span class="nc" id="L4483">        final List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4484" title="All 2 branches missed.">        for (final Certificate certificate : chain) {</span>
<span class="nc" id="L4485">            ret.add(certificate);</span>
<span class="nc" id="L4486">        }</span>
<span class="nc" id="L4487">        return ret;</span>
    }
    
    /**
     * Converts a X509Certificate chain into a JcaX509CertificateHolder chain.
     * 
     * @param certificateChain input chain to be converted
     * @return the result
     * @throws CertificateEncodingException if there is a problem extracting the certificate information.
     */
    public static final JcaX509CertificateHolder[] convertToX509CertificateHolder(X509Certificate[] certificateChain)
            throws CertificateEncodingException {
<span class="nc" id="L4499">        final JcaX509CertificateHolder[] certificateHolderChain = new JcaX509CertificateHolder[certificateChain.length];</span>
<span class="nc bnc" id="L4500" title="All 2 branches missed.">        for (int i = 0; i &lt; certificateChain.length; ++i) {</span>
<span class="nc" id="L4501">            certificateHolderChain[i] = new JcaX509CertificateHolder(certificateChain[i]);</span>
        }
<span class="nc" id="L4503">        return certificateHolderChain;</span>
    }
    
    /**
     * Converts a X509Certificate chain into a JcaX509CertificateHolder chain.
     * 
     * @param certificateChain input chain to be converted
     * @return the result
     * @throws CertificateEncodingException if there is a problem extracting the certificate information.
     */
    public static final List&lt;JcaX509CertificateHolder&gt; convertToX509CertificateHolder(List&lt;X509Certificate&gt; certificateChain)
            throws CertificateEncodingException {
<span class="nc" id="L4515">        final List&lt;JcaX509CertificateHolder&gt; certificateHolderChain = new ArrayList&lt;JcaX509CertificateHolder&gt;();</span>
<span class="nc bnc" id="L4516" title="All 2 branches missed.">        for (X509Certificate certificate : certificateChain) {</span>
<span class="nc" id="L4517">            certificateHolderChain.add( new JcaX509CertificateHolder(certificate));</span>
<span class="nc" id="L4518">        }</span>
<span class="nc" id="L4519">        return certificateHolderChain;</span>
    }

    /**
     * Converts a X509CertificateHolder chain into a X509Certificate chain.
     * 
     * @param certificateHolderChain input chain to be converted
     * @return the result
     * @throws CertificateException if there is a problem extracting the certificate information.
     */
    public static final List&lt;X509Certificate&gt; convertToX509CertificateList(Collection&lt;X509CertificateHolder&gt; certificateHolderChain) throws CertificateException {
<span class="nc" id="L4530">        final List&lt;X509Certificate&gt; ret = new ArrayList&lt;X509Certificate&gt;();</span>
<span class="nc" id="L4531">        final JcaX509CertificateConverter jcaX509CertificateConverter = new JcaX509CertificateConverter();</span>
<span class="nc bnc" id="L4532" title="All 2 branches missed.">        for (final X509CertificateHolder certificateHolder : certificateHolderChain) {</span>
<span class="nc" id="L4533">            ret.add(jcaX509CertificateConverter.getCertificate(certificateHolder));</span>
<span class="nc" id="L4534">        }</span>
<span class="nc" id="L4535">        return ret;</span>
    }

    /**
     * Converts a X509CertificateHolder chain into a X509Certificate chain.
     * 
     * @param certificateHolderChain input chain to be converted
     * @return the result
     * @throws CertificateException if there is a problem extracting the certificate information.
     */
    public static final X509Certificate[] convertToX509CertificateArray(Collection&lt;X509CertificateHolder&gt; certificateHolderChain) throws CertificateException {
<span class="nc" id="L4546">        return convertToX509CertificateList(certificateHolderChain).toArray(new X509Certificate[0]);</span>
    }

    /**
     * Converts a X509CertificateHolder chain into a X509Certificate chain.
     * 
     * @param crlHolders input chain to be converted
     * @return the result
     * @throws CRLException if there is a problem extracting the CRL information.
     */
    public static final List&lt;X509CRL&gt; convertToX509CRLList(Collection&lt;X509CRLHolder&gt; crlHolders) throws CRLException {
<span class="nc" id="L4557">        final List&lt;X509CRL&gt; ret = new ArrayList&lt;X509CRL&gt;();</span>
<span class="nc" id="L4558">        final JcaX509CRLConverter jcaX509CRLConverter = new JcaX509CRLConverter();</span>
<span class="nc bnc" id="L4559" title="All 2 branches missed.">        for (final X509CRLHolder crlHolder : crlHolders) {</span>
<span class="nc" id="L4560">            ret.add(jcaX509CRLConverter.getCRL(crlHolder));</span>
<span class="nc" id="L4561">        }</span>
<span class="nc" id="L4562">        return ret;</span>
    }

    /**
     * Checks that the given SubjectDN / SAN satisfies the Name Constraints of the given issuer (if there are any).
     * This method checks the Name Constraints in the given issuer only. A complete implementation of
     * name constraints should check the whole certificate chain.
     * 
     * @param issuer Issuing CA.
     * @param subjectDNName Subject DN to check. Optional.
     * @param subjectAltName Subject Alternative Name to check. Optional.
     * @throws IllegalNameException if the name(s) didn't pass naming constraints 
     */
    public static void checkNameConstraints(X509Certificate issuer, X500Name subjectDNName, GeneralNames subjectAltName) throws IllegalNameException {
<span class="fc" id="L4576">        final byte[] ncbytes = issuer.getExtensionValue(Extension.nameConstraints.getId());</span>
<span class="pc bpc" id="L4577" title="1 of 2 branches missed.">        final ASN1OctetString ncstr = (ncbytes != null ? DEROctetString.getInstance(ncbytes) : null);</span>
<span class="pc bpc" id="L4578" title="1 of 2 branches missed.">        final ASN1Sequence ncseq = (ncbytes != null ? DERSequence.getInstance(ncstr.getOctets()) : null);</span>
<span class="pc bpc" id="L4579" title="1 of 2 branches missed.">        final NameConstraints nc = (ncseq != null ? NameConstraints.getInstance(ncseq) : null);</span>
        
<span class="pc bpc" id="L4581" title="1 of 2 branches missed.">        if (nc != null) {</span>
<span class="pc bpc" id="L4582" title="1 of 2 branches missed.">            if (subjectDNName != null) {</span>
                // Skip check for root CAs
<span class="fc" id="L4584">                final X500Name issuerDNName = X500Name.getInstance(issuer.getSubjectX500Principal().getEncoded());</span>
<span class="pc bpc" id="L4585" title="1 of 2 branches missed.">                if (issuerDNName.equals(subjectDNName)) {</span>
<span class="nc" id="L4586">                    return;</span>
                }
            }
            
<span class="fc" id="L4590">            final PKIXNameConstraintValidator validator = new PKIXNameConstraintValidator();</span>
            
<span class="fc" id="L4592">            GeneralSubtree[] permitted = nc.getPermittedSubtrees();</span>
<span class="fc" id="L4593">            GeneralSubtree[] excluded = nc.getExcludedSubtrees();</span>
            
<span class="pc bpc" id="L4595" title="1 of 2 branches missed.">            if (permitted != null) {</span>
<span class="fc" id="L4596">                validator.intersectPermittedSubtree(permitted);</span>
            }
<span class="pc bpc" id="L4598" title="1 of 2 branches missed.">            if (excluded != null) {</span>
<span class="fc bfc" id="L4599" title="All 2 branches covered.">                for (GeneralSubtree subtree : excluded) {</span>
<span class="fc" id="L4600">                    validator.addExcludedSubtree(subtree);</span>
                }
            }

<span class="pc bpc" id="L4604" title="1 of 2 branches missed.">            if (subjectDNName != null) {</span>
<span class="fc" id="L4605">                GeneralName dngn = new GeneralName(subjectDNName);</span>
                try {
<span class="fc" id="L4607">                    validator.checkPermitted(dngn);</span>
<span class="fc" id="L4608">                    validator.checkExcluded(dngn);</span>
<span class="fc" id="L4609">                } catch (PKIXNameConstraintValidatorException e) {</span>
<span class="fc" id="L4610">                    final String dnStr = subjectDNName.toString();</span>
<span class="pc bpc" id="L4611" title="1 of 4 branches missed.">                    final boolean isLdapOrder = dnHasMultipleComponents(dnStr) &amp;&amp; !isDNReversed(dnStr);</span>
<span class="fc bfc" id="L4612" title="All 2 branches covered.">                    if (isLdapOrder) {</span>
<span class="fc" id="L4613">                        final String msg = intres.getLocalizedMessage(&quot;nameconstraints.x500dnorderrequired&quot;);</span>
<span class="fc" id="L4614">                        throw new IllegalNameException(msg);</span>
                    } else {
<span class="fc" id="L4616">                        final String msg = intres.getLocalizedMessage(&quot;nameconstraints.forbiddensubjectdn&quot;, subjectDNName);</span>
<span class="fc" id="L4617">                        throw new IllegalNameException(msg, e);</span>
                    }
<span class="fc" id="L4619">                }</span>
            }
            
<span class="fc bfc" id="L4622" title="All 2 branches covered.">            if (subjectAltName != null) {</span>
<span class="fc bfc" id="L4623" title="All 2 branches covered.">                for (GeneralName sangn : subjectAltName.getNames()) {</span>
                    try {
<span class="fc" id="L4625">                        validator.checkPermitted(sangn);</span>
<span class="fc" id="L4626">                        validator.checkExcluded(sangn);</span>
<span class="fc" id="L4627">                    } catch (PKIXNameConstraintValidatorException e) {</span>
<span class="fc" id="L4628">                        final String msg = intres.getLocalizedMessage(&quot;nameconstraints.forbiddensubjectaltname&quot;, sangn);</span>
<span class="fc" id="L4629">                        throw new IllegalNameException(msg, e);</span>
<span class="fc" id="L4630">                    }</span>
                }
            }
        }
<span class="fc" id="L4634">    }</span>
    
    /**
     * Creates a public key fingerprint with the given digest algorithm. 
     * 
     * @param publicKey the public key.
     * @param algorithm the digest algorithm (i.e. MD-5, SHA-1, SHA-256, etc.)
     * @return the public key fingerprint or null.
     */
    public static final String createPublicKeyFingerprint(final PublicKey publicKey, final String algorithm) {
        try {
<span class="nc" id="L4645">            final MessageDigest digest = MessageDigest.getInstance(algorithm);</span>
<span class="nc" id="L4646">            digest.reset();</span>
<span class="nc" id="L4647">            digest.update(publicKey.getEncoded());</span>
<span class="nc" id="L4648">            final String result = Hex.toHexString(digest.digest());</span>
<span class="nc bnc" id="L4649" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L4650">                log.debug(&quot;Fingerprint &quot; + result + &quot; created for public key: &quot; + new String(Base64.encode(publicKey.getEncoded())));</span>
            }
<span class="nc" id="L4652">            return result;</span>
<span class="nc" id="L4653">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L4654">            log.warn(&quot;Could not create fingerprint for public key &quot;, e);</span>
<span class="nc" id="L4655">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>