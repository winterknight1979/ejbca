<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ExternalProcessTools.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-entity</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util</a> &gt; <span class="el_source">ExternalProcessTools.java</span></div><h1>ExternalProcessTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateParsingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;
import org.apache.log4j.Logger;
import org.cesecore.internal.InternalResources;

/**
 * Tools to handle calls with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html&quot;&gt;Java Process API&lt;/a&gt;
 *
 * @version $Id: ExternalProcessTools.java 27126 2017-12-16 09:28:54Z anjakobs $
 */
public final class ExternalProcessTools {

    /** Class logger. */
<span class="nc" id="L43">    private static final Logger log = Logger.getLogger(ExternalProcessTools.class);</span>

    /** Internal localization of logs and errors. */
<span class="nc" id="L46">    private static final InternalResources intres = InternalResources.getInstance();</span>

    /** Literal for the (platform dependent) line separator. */
<span class="nc" id="L49">    private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);</span>

    /** Literal for place holder for the certificate issued */
    public static final String PLACE_HOLDER_CERTIFICATE = &quot;%cert%&quot;;

    /** Literal for default MS Windows shell. */
    public static final String WINDOWS_SHELL = &quot;cmd.exe&quot;;

    /** Literal for default MS Windows shell options. */
    public static final String WINDOWS_SHELL_OPTIONS = &quot;/c&quot;;

    /** Literal for default Unix shell. */
    public static final String UNIX_SHELL = &quot;/bin/sh&quot;;

    /** Literal for default Unix shell options. */
    public static final String UNIX_SHELL_OPTIONS = &quot;-c&quot;;

    /** Literal for exit code label / prefix. */
    public static final String EXIT_CODE_PREFIX = &quot;Exit code: &quot;;

    /** Literal for STDOUT label to log the external out streams . */
    public static final String STDOUT_PREFIX = &quot;STDOUT: &quot;;

    /** Literal for ERROUT label to log the external out streams . */
    public static final String ERROUT_PREFIX = &quot;ERROUT: &quot;;

    /**
     * Builds the platform dependent external command array:
     * - field at index 0 is the interpreter,
     * - field at index 1 is the one and only parameter of the interpreter,
     * - field at index 2 must contain the complete external command, including pipes, chains, sub-shells, etc. and is appended later.
     * 
     * @param cmd the external command or script
     * @return the command array as list.
     */
    protected static final List&lt;String&gt; buildShellCommand(final String cmd) {
<span class="nc" id="L85">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc" id="L87">            result.add(WINDOWS_SHELL);</span>
<span class="nc" id="L88">            result.add(WINDOWS_SHELL_OPTIONS);</span>
        } else {
<span class="nc" id="L90">            result.add(UNIX_SHELL);</span>
<span class="nc" id="L91">            result.add(UNIX_SHELL_OPTIONS);</span>
        }
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L94">            log.debug(&quot;Use platform shell command for &quot; + SystemUtils.OS_NAME + &quot; : &quot; + result);</span>
        }
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (result.size() == 2) {</span>
<span class="nc" id="L97">            result.add(cmd);</span>
        }
<span class="nc" id="L99">        return result;</span>
    }

    /**
     * Writes the byte-array to a temporary file or pipes the PEM certificate into the command, and launches the given external command, 
     * see {@link ExternalProcessTools#launchExternalCommand(String, byte[], boolean, boolean, boolean, boolean, List, String)}.
     * 
     * @param cmd The command to run.
     * @param bytes The buffer with content to write to the file.
     * @param failOnCode Determines if the method should fail on a non-zero exit code.
     * @param failOnOutput Determines if the method should fail on output to standard error.
     * @param args Added to the command after the temporary files name
     * @param filePrefix  prefix
     * @return output
     * @throws ExternalProcessException if the temporary file could not be written or the external process fails.
     */
    public static final List&lt;String&gt; launchExternalCommand(final String cmd, final byte[] bytes, final boolean failOnCode, final boolean failOnOutput,
            final List&lt;String&gt; args, final String filePrefix) throws ExternalProcessException {
<span class="nc" id="L117">        return launchExternalCommand(cmd, bytes, failOnCode, failOnOutput, false, false, args, filePrefix);</span>
    }

    /**
     * Writes the byte-array to a temporary file and launches the given external command with the file as argument at 
     * index positional parameter index 1 or the pipes the PEM certificate into the command. The function will, depending on 
     * its parameters, fail if output to standard error from the command was detected or the command returns with an non-zero exit code.
     * 
     * @param cmd The command to run. If the parameter place holder {@link #PLACE_HOLDER_CERTIFICATE} is used, the PEM certificate is piped into the STDIN of the command (i.e. 'openssl x509 -text -noout %cert%').
     * @param bytes The buffer with content to write to the file.
     * @param failOnCode Determines if the method should fail on a non-zero exit code.
     * @param failOnOutput Determines if the method should fail on output to standard error.
     * @param logStdOut if the scripts STDOUT should be logged as info.
     * @param logErrOut if the scripts ERROUT should be logged as info.
     * @param arguments Added to the command after the temporary files name
     * @param filePrefix prefix
     * @return output
     * @throws ExternalProcessException if the temporary file could not be written or the external process fails.
     */
    public static final List&lt;String&gt; launchExternalCommand(final String cmd, final byte[] bytes, final boolean failOnCode, final boolean failOnOutput,
            final boolean logStdOut, final boolean logErrOut, final List&lt;String&gt; arguments, final String filePrefix) throws ExternalProcessException {
<span class="nc" id="L138">        final long startTime = System.currentTimeMillis();</span>
<span class="nc" id="L139">        int exitStatus = -1;</span>
<span class="nc" id="L140">        final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        final boolean writeFileToDisk = !arguments.contains(PLACE_HOLDER_CERTIFICATE);</span>
<span class="nc" id="L142">        File file = null;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (writeFileToDisk) {</span>
<span class="nc" id="L144">            file = writeTemporaryFileToDisk(bytes, filePrefix, &quot;.tmp&quot;);</span>
        }
        // Execute external script or command with PEM in STDIN or full path of temporary file as first argument.
<span class="nc" id="L147">        String filename = null;</span>
        try {
<span class="nc" id="L149">            final List&lt;String&gt; cmdTokens = Arrays.asList(cmd.split(&quot;\\s&quot;));</span>
            // Write file to disk or process place holder with PEM certificates and build shell command.
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (writeFileToDisk) {</span>
<span class="nc" id="L152">                filename = file.getCanonicalPath();</span>
<span class="nc" id="L153">                arguments.add(0, filename);</span>
            } else {
                // Only works with PEM X.509 certificates at the time as used in ExternalCommandCertificateValidator (not by CRL publishers).
<span class="nc" id="L156">                final List&lt;Certificate&gt; certificates = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L157">                certificates.add(CertTools.getCertfromByteArray(bytes, Certificate.class));</span>
<span class="nc" id="L158">                final byte[] testPemBytes = CertTools.getPemFromCertificateChain(certificates);</span>
<span class="nc" id="L159">                String pemString = new String(testPemBytes);</span>
<span class="nc" id="L160">                pemString = pemString.substring(pemString.indexOf(LINE_SEPARATOR) + 1, pemString.length());</span>
<span class="nc" id="L161">                pemString = pemString.substring(pemString.indexOf(LINE_SEPARATOR) + 1, pemString.length());</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L163">                    log.debug(&quot;Using certificates:\n&quot; + pemString);</span>
                }
<span class="nc" id="L165">                arguments.remove(arguments.indexOf(PLACE_HOLDER_CERTIFICATE));</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">                if (SystemUtils.IS_OS_WINDOWS) {</span>
                    // Broken. Command cannot be executed.
<span class="nc" id="L169">                    cmdTokens.set(0, &quot;echo \&quot;&quot; + pemString + &quot;\&quot; | &quot; + cmdTokens.get(0));</span>
                    /*
                     * Hack needed for Windows, where Runtime.exec won't consistently encapsulate arguments, leading to arguments
                     * containing spaces (such as Subject DNs) sometimes being parsed as multiple arguments. Bash, on the other hand,
                     * won't parse quote surrounded arguments. 
                     */
<span class="nc" id="L175">                    qouteArguments(arguments);</span>
                } else {
<span class="nc" id="L177">                    cmdTokens.set(0, &quot;echo -n \&quot;&quot; + pemString + &quot;\&quot; | &quot; + cmdTokens.get(0));</span>
                }
            }
<span class="nc" id="L180">            List&lt;String&gt; cmdArray = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L181">            cmdArray.addAll(cmdTokens);</span>
<span class="nc" id="L182">            cmdArray.addAll(arguments);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (!writeFileToDisk) {</span>
<span class="nc" id="L184">                cmdArray = buildShellCommand(StringUtils.join(cmdArray, &quot; &quot;));</span>
            }
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L187">                log.debug(&quot;Process external command for &quot; + getPlatformString() + &quot;: &quot; + cmdArray);</span>
            }
            // Launch external process.
<span class="nc" id="L190">            final Process externalProcess = Runtime.getRuntime().exec(cmdArray.toArray(new String[] {}), null, null);</span>
<span class="nc" id="L191">            externalProcess.getOutputStream().close(); // prevent process from trying to wait for user input (e.g. prompt for overwrite, or similar)</span>
<span class="nc" id="L192">            final BufferedReader stdError = new BufferedReader(new InputStreamReader(externalProcess.getErrorStream()));</span>
<span class="nc" id="L193">            final BufferedReader stdOut = new BufferedReader(new InputStreamReader(externalProcess.getInputStream()));</span>
<span class="nc" id="L194">            String line = null;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">            while ((line = stdOut.readLine()) != null) { // NOPMD: Required under win32 to avoid lock</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if (logStdOut) {</span>
<span class="nc" id="L197">                    result.add(STDOUT_PREFIX + line);</span>
                }
            }
<span class="nc" id="L200">            String stdErrorOutput = null;</span>
            // Check error code and the external applications output to STDERR.
<span class="nc" id="L202">            exitStatus = externalProcess.waitFor();</span>
<span class="nc" id="L203">            result.add(0, EXIT_CODE_PREFIX + exitStatus);</span>
<span class="nc bnc" id="L204" title="All 8 branches missed.">            if (((exitStatus != 0) &amp;&amp; failOnCode) || (stdError.ready() &amp;&amp; failOnOutput)) {</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">                if (writeFileToDisk &amp;&amp; file.exists()) {</span>
<span class="nc" id="L206">                    file.delete();</span>
                }
<span class="nc" id="L208">                String errTemp = null;</span>
<span class="nc bnc" id="L209" title="All 4 branches missed.">                while (stdError.ready() &amp;&amp; (errTemp = stdError.readLine()) != null) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                    if (logErrOut) {</span>
<span class="nc" id="L211">                        result.add(ERROUT_PREFIX + errTemp);</span>
                    }
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    if (stdErrorOutput == null) {</span>
<span class="nc" id="L214">                        stdErrorOutput = errTemp;</span>
                    } else {
<span class="nc" id="L216">                        stdErrorOutput += &quot;\n&quot; + errTemp;</span>
                    }
                }
<span class="nc" id="L219">                String msg = intres.getLocalizedMessage(&quot;process.errorexternalapp&quot;, cmd);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                if (stdErrorOutput != null) {</span>
<span class="nc" id="L221">                    msg += &quot; - &quot; + stdErrorOutput + &quot; - &quot; + filename;</span>
                }
<span class="nc" id="L223">                throw new ExternalProcessException(msg, result);</span>
            }
<span class="nc" id="L225">        } catch (CertificateParsingException | CertificateEncodingException e) { // Should never happen (is only used for certificates not for CRL.)</span>
<span class="nc" id="L226">            throw new ExternalProcessException(&quot;Certificate could not parsed or encoded.&quot; + cmd, e, result);</span>
<span class="nc" id="L227">        } catch (IOException e) { // if the command could not be found</span>
<span class="nc" id="L228">            result.add(0, EXIT_CODE_PREFIX + exitStatus);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (logErrOut) {</span>
<span class="nc" id="L230">                result.add(ERROUT_PREFIX + e.getMessage());</span>
            }
<span class="nc" id="L232">            throw new ExternalProcessException(intres.getLocalizedMessage(&quot;process.errorexternalapp&quot;, cmd), e, result);</span>
<span class="nc" id="L233">        } catch (InterruptedException e) {</span>
<span class="nc" id="L234">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L235">            throw new ExternalProcessException(intres.getLocalizedMessage(&quot;process.errorexternalapp&quot;, cmd), e, result);</span>
        } finally {
<span class="nc bnc" id="L237" title="All 8 branches missed.">            if (writeFileToDisk &amp;&amp; file != null &amp;&amp; file.exists() &amp;&amp; !file.delete()) {</span>
                // Remove temporary file or schedule for delete if delete fails.
<span class="nc" id="L239">                file.deleteOnExit();</span>
<span class="nc" id="L240">                log.info(intres.getLocalizedMessage(&quot;process.errordeletetempfile&quot;, filename));</span>
            }
        }
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L244">            log.trace(&quot;Time spent to execute external command (writeFileToDisk=&quot; + writeFileToDisk + &quot;): &quot; + (System.currentTimeMillis() - startTime)</span>
                    + &quot;ms.&quot;);
        }
<span class="nc" id="L247">        return result;</span>
    }

    public static final String getPlatformString() {
<span class="nc" id="L251">        return SystemUtils.OS_NAME + &quot; / &quot; + SystemUtils.OS_VERSION + &quot; - &quot; + SystemUtils.OS_ARCH;</span>
    }

    /**
     * Writes the byte array into a temporary file with the prefix + &quot;-&quot; + System.currentTimeMillies + suffix into the user directory and returns it, or null.
     * 
     * @param bytes the bytes to write.
     * @param filePrefix the file prefix.
     * @param fileSuffix the file suffix.
     * @return the file or null.
     * @throws ExternalProcessException any exception.
     */
    public static final File writeTemporaryFileToDisk(final byte[] bytes, final String filePrefix, final String fileSuffix)
            throws ExternalProcessException {
<span class="nc" id="L265">        File file = null;</span>
        try {
<span class="nc" id="L267">            file = File.createTempFile(filePrefix + &quot;-&quot; + System.currentTimeMillis(), fileSuffix);</span>
<span class="nc" id="L268">        } catch (IOException e) {</span>
<span class="nc" id="L269">            final String msg = intres.getLocalizedMessage(&quot;process.errortempfile&quot;);</span>
<span class="nc" id="L270">            log.error(msg, e);</span>
<span class="nc" id="L271">        }</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (file != null) {</span>
<span class="nc" id="L273">            try (FileOutputStream fos = new FileOutputStream(file)) {</span>
<span class="nc" id="L274">                fos.write(bytes);</span>
<span class="nc" id="L275">            } catch (FileNotFoundException e) {</span>
<span class="nc" id="L276">                final String msg = intres.getLocalizedMessage(&quot;process.errortempfile&quot;);</span>
<span class="nc" id="L277">                log.error(msg, e);</span>
<span class="nc" id="L278">                throw new ExternalProcessException(msg);</span>
<span class="nc" id="L279">            } catch (IOException e) {</span>
                try {
<span class="nc" id="L281">                    file.delete();</span>
<span class="nc" id="L282">                } catch (Exception e1) {</span>
                    // NOOP
<span class="nc" id="L284">                }</span>
<span class="nc" id="L285">                final String msg = intres.getLocalizedMessage(&quot;process.errortempfile&quot;);</span>
<span class="nc" id="L286">                log.error(msg, e);</span>
<span class="nc" id="L287">                throw new ExternalProcessException(msg);</span>
<span class="nc" id="L288">            }</span>
        }
        // Delete temp file on JVM exit. 
<span class="nc" id="L291">        file.deleteOnExit();</span>
<span class="nc" id="L292">        return file;</span>
    }
    
    /**
     * Extracts the exit code in the list (at index 0 prefixed with #EXIT_CODE_PREFIX).
     * @param out the output of the external process.
     * 
     * @return the exit code.
     */
    public static final Integer extractExitCode(final List&lt;String&gt; out) {
<span class="nc" id="L302">        Integer result = null;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (CollectionUtils.isNotEmpty(out)) {</span>
<span class="nc" id="L304">            result = Integer.parseInt(out.get(0).replaceFirst(ExternalProcessTools.EXIT_CODE_PREFIX, StringUtils.EMPTY));</span>
        }
<span class="nc" id="L306">        return result;</span>
    }

    /**
     * Checks if the list contains logging to ERROUT.
     * @param out the output of the external process.
     * @return true if the list contains logging to ERROUT.
     */
    public static final boolean containsErrout(final List&lt;String&gt; out) {
<span class="nc bnc" id="L315" title="All 4 branches missed.">        if (CollectionUtils.isNotEmpty(out) &amp;&amp; out.size() &gt; 1) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            for (int i= 1,j=out.size();i&lt;j;i++) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                if (out.get(i).startsWith(ERROUT_PREFIX)) {</span>
<span class="nc" id="L318">                    return true;</span>
                }
            }
        }
<span class="nc" id="L322">        return false;</span>
    }
    
    /**
     * Quotes the arguments list.
     * @param arguments the arguments list.
     */
    private static final void qouteArguments(final List&lt;String&gt; arguments) {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (int i = 0; i &lt; arguments.size(); i++) {</span>
<span class="nc" id="L331">            String argument = arguments.get(i);</span>
            //Add quotes to encapsulate argument. 
<span class="nc bnc" id="L333" title="All 4 branches missed.">            if (!argument.startsWith(&quot;\&quot;&quot;) &amp;&amp; !argument.endsWith(&quot;\&quot;&quot;)) {</span>
<span class="nc" id="L334">                arguments.set(i, &quot;\&quot;&quot; + argument + &quot;\&quot;&quot;);</span>
            }
        }
<span class="nc" id="L337">    }</span>

    /**
     * Avoid instantiation.
     */
    private ExternalProcessTools() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>