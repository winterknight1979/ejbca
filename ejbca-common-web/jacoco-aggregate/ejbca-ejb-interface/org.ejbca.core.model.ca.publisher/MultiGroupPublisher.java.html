<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MultiGroupPublisher.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">ejbca-common-web</a> &gt; <a href="../index.html" class="el_bundle">ejbca-ejb-interface</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.model.ca.publisher</a> &gt; <span class="el_source">MultiGroupPublisher.java</span></div><h1>MultiGroupPublisher.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.ejbca.core.model.ca.publisher;

import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.TreeSet;
import java.util.concurrent.ThreadLocalRandom;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.certificates.certificate.Base64CertData;
import org.cesecore.certificates.certificate.CertificateData;
import org.cesecore.certificates.certificate.CertificateDataWrapper;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.ejbca.core.ejb.ca.publisher.PublisherSessionLocal;
import org.ejbca.core.model.util.EjbLocalHelper;

/**
 * Publishes to multiple groups of publishers. For each group it publishes to one random publisher.
 * &lt;p&gt;
 * Useful when you have a lot of publishers, and you want to manage them in a single place.
 * @version $Id: MultiGroupPublisher.java 34192 2020-01-07 15:10:21Z aminkh $
 */
public class MultiGroupPublisher extends BasePublisher {

<span class="nc" id="L41">    private static final Logger log = Logger.getLogger(MultiGroupPublisher.class);</span>

    private static final long serialVersionUID = 1L;

    private static final float LATEST_VERSION = 1.0F;
    private static final String PROPERTYKEY_PUBLISHERGROUPS = &quot;publishergroups&quot;;

    private transient PublisherSessionLocal cachedPublisherSession;

    public MultiGroupPublisher() {
<span class="nc" id="L51">        super();</span>
<span class="nc" id="L52">        data.put(TYPE, Integer.valueOf(PublisherConst.TYPE_MULTIGROUPPUBLISHER));</span>
<span class="nc" id="L53">        data.put(PROPERTYKEY_PUBLISHERGROUPS, new ArrayList&lt;&gt;());</span>
<span class="nc" id="L54">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;TreeSet&lt;Integer&gt;&gt; getPublisherGroups() {
<span class="nc" id="L58">        final Object value = data.get(PROPERTYKEY_PUBLISHERGROUPS);</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        return value != null ? (List&lt;TreeSet&lt;Integer&gt;&gt;) value : new ArrayList&lt;TreeSet&lt;Integer&gt;&gt;();</span>
    }

    public void setPublisherGroups(final List&lt;TreeSet&lt;Integer&gt;&gt; publisherGroups) {
<span class="nc" id="L63">        data.put(PROPERTYKEY_PUBLISHERGROUPS, new ArrayList&lt;&gt;(publisherGroups));</span>
<span class="nc" id="L64">    }</span>


    private PublisherSessionLocal getPublisherSession() {
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (cachedPublisherSession == null) {</span>
<span class="nc" id="L69">            cachedPublisherSession = new EjbLocalHelper().getPublisherSession();</span>
        }
<span class="nc" id="L71">        return cachedPublisherSession;</span>
    }

    private BasePublisher getPublisher(int publisherId) {
<span class="nc" id="L75">        return getPublisherSession().getPublisher(publisherId);</span>
    }

    /**
     * Returns a list of publishers to use for some certificate or CRL.
     * The result is randomized, so it will return a different result each time.
     * This method uses the PublisherCache for better performance.
     * @param getAll Return ALL publishers in each group, instead of only a random one.
     * @return List of publishers to use.
     */
    private List&lt;BasePublisher&gt; getPublishersToUse(final boolean getAll) {
<span class="nc" id="L86">        final List&lt;BasePublisher&gt; publishers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        for (final TreeSet&lt;Integer&gt; group : getPublisherGroups()) {</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            if (getAll) {</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                for (int publisherId : group) {</span>
<span class="nc" id="L90">                    final BasePublisher publisher = getPublisher(publisherId);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                    if (publisher != null) {</span>
<span class="nc" id="L92">                        publishers.add(publisher);</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                    } else if (log.isDebugEnabled()) {</span>
<span class="nc" id="L94">                        log.debug(&quot;Ignoring non-existent publisher: &quot; + publisherId);</span>
                    }
<span class="nc" id="L96">                }</span>
            } else {
<span class="nc" id="L98">                final List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(group);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">                while (!ids.isEmpty()) {</span>
                    // Grab a random publisher
<span class="nc" id="L101">                    final int index = ThreadLocalRandom.current().nextInt(ids.size());</span>
<span class="nc" id="L102">                    final int publisherId = ids.get(index);</span>
<span class="nc" id="L103">                    final BasePublisher publisher = getPublisher(publisherId);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                    if (publisher != null) {</span>
<span class="nc" id="L105">                        publishers.add(publisher);</span>
<span class="nc" id="L106">                        break;</span>
                    } else {
                        // This happens when clicking &quot;Test Connection&quot;, so it won't spam the logs
<span class="nc" id="L109">                        log.warn(&quot;Ignoring non-existent publisher &quot; + publisherId + &quot; in publisher &quot; + getName());</span>
                    }
<span class="nc" id="L111">                    ids.remove(index);</span>
<span class="nc" id="L112">                }</span>
            }
<span class="nc" id="L114">        }</span>
<span class="nc" id="L115">        return publishers;</span>
    }


    @Override
    public boolean willPublishCertificate(int status, int revocationReason) {
<span class="nc" id="L121">        log.trace(&quot;&gt;willPublishCertificate&quot;);</span>
        // We don't know exactly which publishers storeCertificate will use,
        // so we just check the &quot;first&quot; one in each group. (&quot;first&quot; means lowest ID)
<span class="nc bnc" id="L124" title="All 2 branches missed.">        for (final TreeSet&lt;Integer&gt; group : getPublisherGroups()) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (group.isEmpty()) {</span>
<span class="nc" id="L126">                log.debug(&quot;An empty group was found in publisher '&quot; + getName() + &quot;'&quot;);</span>
            }
<span class="nc" id="L128">            final int publisherId = group.first();</span>
<span class="nc" id="L129">            final BasePublisher publisher = getPublisher(publisherId);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (publisher.willPublishCertificate(status, revocationReason)) {</span>
<span class="nc" id="L131">                log.trace(&quot;&lt;willPublishCertificate: true&quot;);</span>
<span class="nc" id="L132">                return true;</span>
            }
<span class="nc" id="L134">        }</span>
<span class="nc" id="L135">        log.trace(&quot;&lt;willPublishCertificate: false&quot;);</span>
<span class="nc" id="L136">        return false;</span>
    }

    @Override
    public boolean storeCertificate(AuthenticationToken admin, Certificate incert, String username, String password, String userDN, String cafp,
            int status, int type, long revocationDate, int revocationReason, String tag, int certificateProfileId, long lastUpdate,
            ExtendedInformation extendedinformation) throws PublisherException {
<span class="nc" id="L143">        throw new UnsupportedOperationException(&quot;Legacy storeCertificate method should never have been invoked for this publisher.&quot;);</span>
    }

    @Override
    public boolean storeCertificate(final AuthenticationToken authenticationToken, final CertificateData certificateData, final Base64CertData base64CertData) throws PublisherException {
<span class="nc" id="L148">        throw new UnsupportedOperationException(&quot;Internal error. Wrong storeCertificate method was called.&quot;);</span>
    }

    @Override
    public boolean storeCertificate(final AuthenticationToken authenticationToken, final CertificateData certificateData, final Base64CertData base64CertData, final String password, final String userDN, final ExtendedInformation extendedinformation) throws PublisherException {
<span class="nc" id="L153">        log.trace(&quot;&gt;storeCertificate&quot;);</span>
<span class="nc" id="L154">        final List&lt;Integer&gt; publisherIdsToUse = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        for (final BasePublisher publisher : getPublishersToUse(false)) {</span>
<span class="nc" id="L156">            final boolean willPublish = publisher.willPublishCertificate(certificateData.getStatus(), certificateData.getRevocationReason());</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (willPublish) {</span>
<span class="nc" id="L158">                publisherIdsToUse.add(publisher.getPublisherId());</span>
            }
<span class="nc bnc" id="L160" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                log.debug(&quot;Will &quot; + (willPublish ? &quot;&quot; : &quot;NOT &quot;) +&quot;publish certificate &quot; + certificateData.getSerialNumberHex() + &quot; to publisher '&quot; + publisher.getName() + &quot;'&quot;);</span>
            }
<span class="nc" id="L163">        }</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (!publisherIdsToUse.isEmpty()) {</span>
            try {
<span class="nc" id="L166">                getPublisherSession().storeCertificate(authenticationToken, publisherIdsToUse, new CertificateDataWrapper(null, certificateData, base64CertData), password, userDN, extendedinformation);</span>
<span class="nc" id="L167">            } catch (AuthorizationDeniedException e) {</span>
<span class="nc" id="L168">                throw new PublisherException(&quot;Authorization was denied: &quot; + e.getMessage());</span>
<span class="nc" id="L169">            }</span>
        }
<span class="nc" id="L171">        log.trace(&quot;&lt;storeCertificate&quot;);</span>
<span class="nc" id="L172">        return true;</span>
    }

    @Override
    public boolean isFullEntityPublishingSupported() {
<span class="nc" id="L177">        return true;</span>
    }

    @Override
    public boolean storeCRL(AuthenticationToken admin, byte[] incrl, String cafp, int number, String userDN) throws PublisherException {
<span class="nc" id="L182">        final List&lt;Integer&gt; publisherIdsToUse = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L183">        log.trace(&quot;&gt;storeCRL&quot;);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        for (final BasePublisher publisher : getPublishersToUse(false)) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L186">                log.debug(&quot;Will publish CRL &quot; + number + &quot; for CA &quot; + cafp + &quot; to publisher '&quot; + publisher.getName() + &quot;'&quot;);</span>
            }
<span class="nc" id="L188">            publisherIdsToUse.add(publisher.getPublisherId());</span>
<span class="nc" id="L189">        }</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (publisherIdsToUse.isEmpty()) {</span>
<span class="nc" id="L191">            log.info(&quot;No publishers available in multi group publisher '&quot; + getName() + &quot;'. Can't publish CRL &quot; + number + &quot; for CA &quot; + cafp);</span>
<span class="nc" id="L192">            return false;</span>
        }
        try {
<span class="nc" id="L195">            getPublisherSession().storeCRL(admin, publisherIdsToUse, incrl, cafp, number, userDN);</span>
<span class="nc" id="L196">        } catch (AuthorizationDeniedException e) {</span>
<span class="nc" id="L197">            throw new PublisherException(&quot;Authorization was denied: &quot; + e.getMessage());</span>
<span class="nc" id="L198">        }</span>
<span class="nc" id="L199">        log.trace(&quot;&lt;storeCRL&quot;);</span>
<span class="nc" id="L200">        return true;</span>
    }

    @Override
    public void testConnection() throws PublisherConnectionException {
<span class="nc" id="L205">        Exception publisherException = null;</span>
<span class="nc" id="L206">        List&lt;String&gt; failedNames = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L207">        log.debug(&quot;Testing all publishers in multi group publisher.&quot;);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        for (final BasePublisher publisher : getPublishersToUse(true)) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L210">                log.debug(&quot;Testing publisher: &quot; + publisher.getName());</span>
            }
            try {
<span class="nc" id="L213">                publisher.testConnection();</span>
<span class="nc" id="L214">            } catch (PublisherConnectionException | RuntimeException e) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L216">                    log.debug(&quot;Publisher '&quot; + publisher.getName() + &quot;' failed: &quot; + e.getMessage(), e);</span>
                }
<span class="nc" id="L218">                failedNames.add(publisher.getName());</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                if (publisherException == null) {</span>
<span class="nc" id="L220">                    publisherException = e;</span>
                }
<span class="nc" id="L222">            }</span>
<span class="nc" id="L223">        }</span>
<span class="nc" id="L224">        log.debug(&quot;Done testing publishers in multi group publisher.&quot;);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (publisherException != null) {</span>
<span class="nc" id="L226">            final String msg = &quot;Publishers [&quot; + StringUtils.join(failedNames, &quot;, &quot;) + &quot;] failed. First failure: &quot; +publisherException.getMessage();</span>
<span class="nc" id="L227">            log.info(msg, publisherException);</span>
<span class="nc" id="L228">            throw new PublisherConnectionException(msg, publisherException);</span>
        }
<span class="nc" id="L230">    }</span>

    @Override
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L234">        final MultiGroupPublisher clone = new MultiGroupPublisher();</span>
<span class="nc" id="L235">        final LinkedHashMap&lt;Object, Object&gt; clonedata = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L236">        clonedata.putAll(data);</span>
<span class="nc" id="L237">        final List&lt;TreeSet&lt;Integer&gt;&gt; publisherGroupsClone = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (final TreeSet&lt;Integer&gt; publisherGroup : getPublisherGroups()) {</span>
<span class="nc" id="L239">            publisherGroupsClone.add(new TreeSet&lt;&gt;(publisherGroup));</span>
<span class="nc" id="L240">        }</span>
<span class="nc" id="L241">        clonedata.put(PROPERTYKEY_PUBLISHERGROUPS, publisherGroupsClone);</span>
<span class="nc" id="L242">        clone.loadData(clonedata);</span>
<span class="nc" id="L243">        return clone;</span>
    }

    @Override
    public float getLatestVersion() {
<span class="nc" id="L248">        return LATEST_VERSION;</span>
    }

    /** 
     * Implemtation of UpgradableDataHashMap function upgrade. 
     */
    @Override
    public void upgrade() {
<span class="nc" id="L256">        log.trace(&quot;&gt;upgrade&quot;);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (Float.compare(LATEST_VERSION, getVersion()) != 0) {</span>
            // Does nothing currently
<span class="nc" id="L259">            data.put(VERSION,  Float.valueOf(LATEST_VERSION));</span>
        }
<span class="nc" id="L261">        log.trace(&quot;&lt;upgrade&quot;);</span>
<span class="nc" id="L262">    }</span>

    @Override
    public void validateDataSource(String dataSource) throws PublisherException {
        // Method not applicable for this publisher type!
<span class="nc" id="L267">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>