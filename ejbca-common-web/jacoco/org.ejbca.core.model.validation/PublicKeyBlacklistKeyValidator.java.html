<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PublicKeyBlacklistKeyValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">EJBCA Common Web code</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.model.validation</a> &gt; <span class="el_source">PublicKeyBlacklistKeyValidator.java</span></div><h1>PublicKeyBlacklistKeyValidator.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.ejbca.core.model.validation;

import java.security.PublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;
import org.bouncycastle.jcajce.provider.asymmetric.rsa.BCRSAPublicKey;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.keys.validation.KeyValidatorBase;
import org.cesecore.keys.validation.ValidationException;
import org.cesecore.profiles.Profile;
import org.cesecore.util.ui.DynamicUiModel;
import org.cesecore.util.ui.DynamicUiProperty;
import org.ejbca.core.model.util.EjbLocalHelper;

/**
 * Public key blacklist key validator using the Bouncy Castle BCRSAPublicKey implementation 
 * (see org.bouncycastle.jcajce.provider.asymmetric.rsa.BCRSAPublicKey). 
 * 
 * The key validator is used to filter out weak debian keys or other blacklisted public keys 
 * generated by 'openssl', 'ssh-keygen', or 'openvpn --keygen', @see &quot;https://wiki.debian.org/SSLkeys#Identifying_Weak_Keys&quot;
 * 
 * @version $Id: PublicKeyBlacklistKeyValidator.java 29467 2018-07-05 16:23:04Z mikekushner $
 */
public class PublicKeyBlacklistKeyValidator extends KeyValidatorBase {

    private static final long serialVersionUID = 215729318959311916L;

    /** Class logger. */
<span class="fc" id="L53">    private static final Logger log = Logger.getLogger(PublicKeyBlacklistKeyValidator.class);</span>

    /** The key validator type. */
    private static final String TYPE_IDENTIFIER = &quot;BLACKLIST_KEY_VALIDATOR&quot;;

    protected static final String KEY_ALGORITHMS = &quot;keyAlgorithms&quot;;
    
<span class="fc" id="L60">    protected static final ArrayList&lt;String&gt; AVAILABLE_KEY_ALGORITHMS = new ArrayList&lt;String&gt;();</span>
    
    static {
<span class="fc" id="L63">        AVAILABLE_KEY_ALGORITHMS.add(&quot;DSA&quot;);</span>
<span class="fc" id="L64">        AVAILABLE_KEY_ALGORITHMS.add(&quot;RSA&quot;);</span>
<span class="fc" id="L65">        AVAILABLE_KEY_ALGORITHMS.add(&quot;ECDSA&quot;);</span>
<span class="fc" id="L66">    }</span>
    
    /** field used for JUnit testing, avoiding lookups so we can control the cache */
<span class="pc" id="L69">    private boolean useOnlyCache = false;</span>
    
    /**
     * Public constructor needed for deserialization.
     */
    public PublicKeyBlacklistKeyValidator() {
<span class="nc" id="L75">        super();</span>
<span class="nc" id="L76">    }</span>
    
    /**
     * Creates a new instance.
     * @param name Name
     */
    public PublicKeyBlacklistKeyValidator(final String name) {
<span class="fc" id="L83">        super(name);</span>
<span class="fc" id="L84">    }</span>

    /**
     * Initializes uninitialized data fields.
     */
    public void init() {
<span class="fc" id="L90">        super.init();</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (data.get(KEY_ALGORITHMS) == null) {</span>
<span class="fc" id="L92">            setKeyAlgorithms(AVAILABLE_KEY_ALGORITHMS);</span>
        }
<span class="fc" id="L94">    }</span>
    
    @Override
    public void initDynamicUiModel() {
<span class="nc" id="L98">        uiModel = new DynamicUiModel(data);</span>
<span class="nc" id="L99">        uiModel.add(new DynamicUiProperty&lt;String&gt;(&quot;settings&quot;));</span>
<span class="nc" id="L100">        final LinkedHashMap&lt;String,String&gt; labels = new LinkedHashMap&lt;String,String&gt;();</span>
<span class="nc" id="L101">        labels.put(&quot;-1&quot;, &quot;ALL&quot;);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        for (final String algorithm : AlgorithmTools.getAvailableKeyAlgorithms()) {</span>
<span class="nc" id="L103">            labels.put(algorithm, algorithm);</span>
<span class="nc" id="L104">        }</span>
<span class="nc" id="L105">        final DynamicUiProperty&lt;String&gt; keyAlgorithms = new DynamicUiProperty&lt;String&gt;(String.class, KEY_ALGORITHMS, getKeyAlgorithmsAsString(), labels.keySet());</span>
<span class="nc" id="L106">        keyAlgorithms.setRenderingHint(DynamicUiProperty.RENDER_SELECT_MANY);</span>
<span class="nc" id="L107">        keyAlgorithms.setLabels(labels);</span>
<span class="nc" id="L108">        keyAlgorithms.setHasMultipleValues(true);</span>
        // Temp. because it is stored as String.
<span class="nc" id="L110">        keyAlgorithms.setSaveListAsString(true);</span>
<span class="nc" id="L111">        keyAlgorithms.setRequired(true);</span>
<span class="nc" id="L112">        uiModel.add(keyAlgorithms);</span>
<span class="nc" id="L113">    }</span>

    /** Gets a list of key algorithms.
     * @return a list.
     */
    public String getKeyAlgorithmsAsString() {
<span class="nc" id="L119">        return (String) data.get(KEY_ALGORITHMS);</span>
    }
    
    /** Gets a list of key algorithms.
     * @return a list.
     */
    public List&lt;String&gt; getKeyAlgorithms() {
<span class="fc" id="L126">        List&lt;String&gt; list = Arrays.asList( StringUtils.split((String) data.get(KEY_ALGORITHMS), LIST_SEPARATOR));</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (list == null) {</span>
<span class="nc" id="L128">            list = new ArrayList&lt;String&gt;();</span>
        }
<span class="fc" id="L130">        return list;</span>
    }

    /** Sets the key algorithms, RSA, ECDSA, ....
     * 
     * @param algorithms list of key algorithms.
     */
    public void setKeyAlgorithms(List&lt;String&gt; algorithms) {
<span class="fc" id="L138">        data.put(KEY_ALGORITHMS, StringUtils.join(algorithms, LIST_SEPARATOR));</span>
<span class="fc" id="L139">    }</span>
    
    @Override
    public void upgrade() {
<span class="nc" id="L143">        super.upgrade();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L145">            log.trace(&quot;&gt;upgrade: &quot; + getLatestVersion() + &quot;, &quot; + getVersion());</span>
        }
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (Float.compare(LATEST_VERSION, getVersion()) != 0) {</span>
            // New version of the class, upgrade.
<span class="nc" id="L149">            log.info(INTRES.getLocalizedMessage(&quot;blacklistkeyvalidator.upgrade&quot;, Float.valueOf(getVersion())));</span>
<span class="nc" id="L150">            init();</span>
        }
<span class="nc" id="L152">    }</span>

    @Override
    public List&lt;String&gt; validate(final PublicKey publicKey, final CertificateProfile certificateProfile) throws ValidationException {
<span class="fc" id="L156">        List&lt;String&gt; messages = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L157">        final int keyLength = KeyTools.getKeyLength(publicKey);</span>
<span class="fc" id="L158">        final String keyAlgorithm = publicKey.getAlgorithm(); // AlgorithmTools.getKeyAlgorithm(publicKey);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L160">            log.debug(&quot;Validating public key with algorithm &quot; + keyAlgorithm + &quot;, length &quot; + keyLength + &quot;, format &quot; + publicKey.getFormat()</span>
<span class="nc" id="L161">                    + &quot;, implementation &quot; + publicKey.getClass().getName() + &quot; against public key blacklist.&quot;);</span>
        }
        // Use the entry class to create a correct fingerprint
<span class="fc" id="L164">        final String fingerprint = PublicKeyBlacklistEntry.createFingerprint(publicKey);</span>
<span class="fc" id="L165">        log.info(&quot;Matching public key with blacklist fingerprint &quot; + fingerprint + &quot; with public key blacklist.&quot;);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (!useOnlyCache) {</span>
            // A bit hackish, make a call to blacklist session to ensure that blacklist cache has this entry loaded
            // TODO: if the key is not in the cache (which it hopefully is not) this is a database lookup for each key. Huuge performance hit
            // should better be implemented as a full in memory cache with a state so we know if it's loaded or not, with background updates. See ECA-5951
            // We could simply add a call to load the whole map into cache, when the cache needs updating
            // See BlacklistSessionBean.getBlacklistEntryIdToFingerprintMap (and add cache there)
<span class="nc" id="L172">            new EjbLocalHelper().getBlacklistSession().getBlacklistEntryId(PublicKeyBlacklistEntry.TYPE, fingerprint);</span>
        }
<span class="fc" id="L174">        Integer idValue = PublicKeyBlacklistEntryCache.INSTANCE.getNameToIdMap().get(fingerprint);</span>
<span class="fc" id="L175">        final PublicKeyBlacklistEntry entry = PublicKeyBlacklistEntryCache.INSTANCE.getEntry(idValue);</span>
<span class="fc" id="L176">        boolean keyAlgMatched = false;</span>

<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (null != entry) {</span>
            // Filter for key specifications.
<span class="fc" id="L180">            final Set&lt;String&gt; keyAlgs = new HashSet&lt;&gt;(getKeyAlgorithms());</span>
<span class="fc bfc" id="L181" title="All 4 branches covered.">            if (keyAlgs.contains(AlgorithmConstants.KEYALGORITHM_EC) || keyAlgs.contains(AlgorithmConstants.KEYALGORITHM_ECDSA)) {</span>
<span class="fc" id="L182">                keyAlgs.add(AlgorithmConstants.KEYALGORITHM_EC);</span>
<span class="fc" id="L183">                keyAlgs.add(AlgorithmConstants.KEYALGORITHM_ECDSA);</span>
            }
<span class="fc bfc" id="L185" title="All 4 branches covered.">            if (getKeyAlgorithms().contains(&quot;-1&quot;) || keyAlgs.contains(getKeyAlg(publicKey, fingerprint))) {</span>
<span class="fc" id="L186">                keyAlgMatched = true;</span>
            }
        }
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (keyAlgMatched) {</span>
<span class="fc" id="L190">            final String message = &quot;Public key with id &quot; + entry.getID() + &quot; and fingerprint &quot; + fingerprint</span>
                    + &quot; found in public key blacklist.&quot;;
<span class="fc" id="L192">            messages.add(&quot;Invalid: &quot; + message);</span>
<span class="fc" id="L193">        } else {</span>
<span class="fc" id="L194">            log.trace(&quot;publicKeyBlacklist passed&quot;);</span>
        }

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            for (String message : messages) {</span>
<span class="nc" id="L199">                log.debug(message);</span>
<span class="nc" id="L200">            }</span>
        }
<span class="fc" id="L202">        return messages;</span>
    }

    private final String getKeyAlg(PublicKey publicKey, String fingerprint) {
        String keyAlg;
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (publicKey instanceof BCRSAPublicKey) {</span>
<span class="fc" id="L208">            keyAlg = publicKey.getAlgorithm().toUpperCase();</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        } else if (publicKey instanceof BCECPublicKey) {</span>
<span class="fc" id="L210">            keyAlg = publicKey.getAlgorithm().toUpperCase();</span>
        } else {
<span class="nc" id="L212">            keyAlg = publicKey.getAlgorithm().toUpperCase();</span>
        }
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L215">            log.trace(&quot;Key algorithm &quot; + keyAlg + &quot; determined for public key with fp: &quot; + fingerprint);</span>
        }
<span class="fc" id="L217">        return keyAlg;</span>
    }

    protected void setUseOnlyCache(boolean useOnlyCache) {
<span class="fc" id="L221">        this.useOnlyCache = useOnlyCache;</span>
<span class="fc" id="L222">    }</span>

    @Override
    public String getValidatorTypeIdentifier() {
<span class="nc" id="L226">        return TYPE_IDENTIFIER;</span>
    }

    @Override
    public String getLabel() {
<span class="nc" id="L231">        return INTRES.getLocalizedMessage(&quot;validator.implementation.key.blacklist&quot;);</span>
    }

    @Override
    protected Class&lt;? extends Profile&gt; getImplementationClass() {
<span class="fc" id="L236">        return PublicKeyBlacklistKeyValidator.class;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>