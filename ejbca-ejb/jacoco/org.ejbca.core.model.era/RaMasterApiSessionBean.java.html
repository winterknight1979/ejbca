<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RaMasterApiSessionBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">EJBCA EJB Library</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.model.era</a> &gt; <span class="el_source">RaMasterApiSessionBean.java</span></div><h1>RaMasterApiSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.ejbca.core.model.era;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SignatureException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceException;
import javax.persistence.Query;
import javax.persistence.QueryTimeoutException;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.cesecore.CesecoreException;
import org.cesecore.ErrorCode;
import org.cesecore.audit.enums.EventType;
import org.cesecore.audit.log.SecurityEventsLoggerSessionLocal;
import org.cesecore.authentication.AuthenticationFailedException;
import org.cesecore.authentication.tokens.AlwaysAllowLocalAuthenticationToken;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authentication.tokens.PublicAccessAuthenticationTokenMetaData;
import org.cesecore.authentication.tokens.UsernamePrincipal;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.authorization.AuthorizationSessionLocal;
import org.cesecore.authorization.access.AccessSet;
import org.cesecore.authorization.cache.AccessTreeUpdateSessionLocal;
import org.cesecore.authorization.control.AuditLogRules;
import org.cesecore.authorization.control.StandardRules;
import org.cesecore.authorization.user.matchvalues.AccessMatchValue;
import org.cesecore.authorization.user.matchvalues.AccessMatchValueReverseLookupRegistry;
import org.cesecore.certificates.ca.ApprovalRequestType;
import org.cesecore.certificates.ca.CA;
import org.cesecore.certificates.ca.CAConstants;
import org.cesecore.certificates.ca.CADoesntExistsException;
import org.cesecore.certificates.ca.CAInfo;
import org.cesecore.certificates.ca.CAOfflineException;
import org.cesecore.certificates.ca.CaSessionLocal;
import org.cesecore.certificates.ca.IllegalNameException;
import org.cesecore.certificates.ca.IllegalValidityException;
import org.cesecore.certificates.ca.InvalidAlgorithmException;
import org.cesecore.certificates.ca.SignRequestException;
import org.cesecore.certificates.ca.SignRequestSignatureException;
import org.cesecore.certificates.certificate.CertificateConstants;
import org.cesecore.certificates.certificate.CertificateCreateException;
import org.cesecore.certificates.certificate.CertificateCreateSessionLocal;
import org.cesecore.certificates.certificate.CertificateDataWrapper;
import org.cesecore.certificates.certificate.CertificateRevokeException;
import org.cesecore.certificates.certificate.CertificateStatus;
import org.cesecore.certificates.certificate.CertificateStoreSessionLocal;
import org.cesecore.certificates.certificate.CertificateWrapper;
import org.cesecore.certificates.certificate.IllegalKeyException;
import org.cesecore.certificates.certificate.NoConflictCertificateStoreSessionLocal;
import org.cesecore.certificates.certificate.certextensions.CertificateExtensionException;
import org.cesecore.certificates.certificate.exception.CertificateSerialNumberException;
import org.cesecore.certificates.certificate.exception.CustomCertificateSerialNumberException;
import org.cesecore.certificates.certificate.request.PKCS10RequestMessage;
import org.cesecore.certificates.certificate.request.RequestMessageUtils;
import org.cesecore.certificates.certificate.request.ResponseMessage;
import org.cesecore.certificates.certificate.request.X509ResponseMessage;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificateprofile.CertificateProfileConstants;
import org.cesecore.certificates.certificateprofile.CertificateProfileDoesNotExistException;
import org.cesecore.certificates.certificateprofile.CertificateProfileSessionLocal;
import org.cesecore.certificates.crl.CrlStoreSessionLocal;
import org.cesecore.certificates.endentity.EndEntityConstants;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.config.GlobalCesecoreConfiguration;
import org.cesecore.config.RaStyleInfo;
import org.cesecore.configuration.GlobalConfigurationSessionLocal;
import org.cesecore.keys.token.CryptoTokenOfflineException;
import org.cesecore.keys.token.CryptoTokenSessionLocal;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.keys.validation.DnsNameValidator;
import org.cesecore.keys.validation.KeyValidatorSessionLocal;
import org.cesecore.keys.validation.Validator;
import org.cesecore.roles.Role;
import org.cesecore.roles.RoleExistsException;
import org.cesecore.roles.management.RoleDataSessionLocal;
import org.cesecore.roles.management.RoleSessionLocal;
import org.cesecore.roles.member.RoleMember;
import org.cesecore.roles.member.RoleMemberData;
import org.cesecore.roles.member.RoleMemberSessionLocal;
import org.cesecore.util.CertTools;
import org.cesecore.util.EJBTools;
import org.cesecore.util.StringTools;
import org.cesecore.util.ValidityDate;
import org.ejbca.config.GlobalConfiguration;
import org.ejbca.config.GlobalCustomCssConfiguration;
import org.ejbca.core.EjbcaException;
import org.ejbca.core.ejb.EnterpriseEditionEjbBridgeSessionLocal;
import org.ejbca.core.ejb.approval.ApprovalExecutionSessionLocal;
import org.ejbca.core.ejb.approval.ApprovalProfileSessionLocal;
import org.ejbca.core.ejb.approval.ApprovalSessionLocal;
import org.ejbca.core.ejb.authentication.cli.CliAuthenticationTokenMetaData;
import org.ejbca.core.ejb.authorization.AuthorizationSystemSessionLocal;
import org.ejbca.core.ejb.ca.auth.EndEntityAuthenticationSessionLocal;
import org.ejbca.core.ejb.ca.caadmin.CAAdminSessionLocal;
import org.ejbca.core.ejb.ca.publisher.PublisherQueueSessionLocal;
import org.ejbca.core.ejb.ca.publisher.PublisherSessionLocal;
import org.ejbca.core.ejb.ca.sign.SignSessionLocal;
import org.ejbca.core.ejb.ca.store.CertReqHistorySessionLocal;
import org.ejbca.core.ejb.dto.CertRevocationDto;
import org.ejbca.core.ejb.hardtoken.HardTokenSessionLocal;
import org.ejbca.core.ejb.keyrecovery.KeyRecoverySessionLocal;
import org.ejbca.core.ejb.ra.CertificateRequestSessionLocal;
import org.ejbca.core.ejb.ra.CouldNotRemoveEndEntityException;
import org.ejbca.core.ejb.ra.EndEntityAccessSessionLocal;
import org.ejbca.core.ejb.ra.EndEntityExistsException;
import org.ejbca.core.ejb.ra.EndEntityManagementSessionLocal;
import org.ejbca.core.ejb.ra.KeyStoreCreateSessionLocal;
import org.ejbca.core.ejb.ra.NoSuchEndEntityException;
import org.ejbca.core.ejb.ra.raadmin.EndEntityProfileSessionLocal;
import org.ejbca.core.ejb.ra.userdatasource.UserDataSourceSessionLocal;
import org.ejbca.core.ejb.rest.EjbcaRestHelperSessionLocal;
import org.ejbca.core.ejb.ws.EjbcaWSHelperSessionLocal;
import org.ejbca.core.model.CertificateSignatureException;
import org.ejbca.core.model.InternalEjbcaResources;
import org.ejbca.core.model.SecConst;
import org.ejbca.core.model.approval.AdminAlreadyApprovedRequestException;
import org.ejbca.core.model.approval.Approval;
import org.ejbca.core.model.approval.ApprovalDataText;
import org.ejbca.core.model.approval.ApprovalDataVO;
import org.ejbca.core.model.approval.ApprovalException;
import org.ejbca.core.model.approval.ApprovalRequest;
import org.ejbca.core.model.approval.ApprovalRequestExecutionException;
import org.ejbca.core.model.approval.ApprovalRequestExpiredException;
import org.ejbca.core.model.approval.SelfApprovalException;
import org.ejbca.core.model.approval.WaitingForApprovalException;
import org.ejbca.core.model.approval.approvalrequests.AddEndEntityApprovalRequest;
import org.ejbca.core.model.approval.approvalrequests.EditEndEntityApprovalRequest;
import org.ejbca.core.model.approval.profile.ApprovalProfile;
import org.ejbca.core.model.authorization.AccessRulesConstants;
import org.ejbca.core.model.ca.AuthLoginException;
import org.ejbca.core.model.ca.AuthStatusException;
import org.ejbca.core.model.ca.publisher.PublisherDoesntExistsException;
import org.ejbca.core.model.ca.publisher.PublisherException;
import org.ejbca.core.model.ca.store.CertReqHistory;
import org.ejbca.core.model.ra.AlreadyRevokedException;
import org.ejbca.core.model.ra.CustomFieldException;
import org.ejbca.core.model.ra.EndEntityInformationFiller;
import org.ejbca.core.model.ra.EndEntityProfileValidationRaException;
import org.ejbca.core.model.ra.KeyStoreGeneralRaException;
import org.ejbca.core.model.ra.NotFoundException;
import org.ejbca.core.model.ra.RAAuthorization;
import org.ejbca.core.model.ra.RevokeBackDateNotAllowedForProfileException;
import org.ejbca.core.model.ra.raadmin.EndEntityProfile;
import org.ejbca.core.model.ra.raadmin.EndEntityProfileNotFoundException;
import org.ejbca.core.model.ra.raadmin.EndEntityProfileValidationException;
import org.ejbca.core.model.ra.raadmin.UserDoesntFullfillEndEntityProfile;
import org.ejbca.core.protocol.NoSuchAliasException;
import org.ejbca.core.protocol.acme.AcmeAccount;
import org.ejbca.core.protocol.acme.AcmeAccountDataSessionLocal;
import org.ejbca.core.protocol.acme.AcmeAuthorization;
import org.ejbca.core.protocol.acme.AcmeAuthorizationDataSessionLocal;
import org.ejbca.core.protocol.acme.AcmeChallenge;
import org.ejbca.core.protocol.acme.AcmeChallengeDataSessionLocal;
import org.ejbca.core.protocol.acme.AcmeOrder;
import org.ejbca.core.protocol.acme.AcmeOrderDataSessionLocal;
import org.ejbca.core.protocol.cmp.CmpMessageDispatcherSessionLocal;
import org.ejbca.core.protocol.est.EstOperationsSessionLocal;
import org.ejbca.core.protocol.rest.EnrollPkcs10CertificateRequest;
import org.ejbca.core.protocol.scep.ScepMessageDispatcherSessionLocal;
import org.ejbca.core.protocol.ws.common.CertificateHelper;
import org.ejbca.core.protocol.ws.objects.UserDataVOWS;
import org.ejbca.core.protocol.ws.objects.UserMatch;
import org.ejbca.cvc.exception.ConstructionException;
import org.ejbca.cvc.exception.ParseException;
import org.ejbca.ui.web.protocol.CertificateRenewalException;
import org.ejbca.util.query.ApprovalMatch;
import org.ejbca.util.query.BasicMatch;
import org.ejbca.util.query.IllegalQueryException;

/**
 * Implementation of the RaMasterApi that invokes functions at the local node.
 *
 * @version $Id: RaMasterApiSessionBean.java 34207 2020-01-08 13:22:50Z samuellb $
 */
@SuppressWarnings(&quot;deprecation&quot;)
@Stateless//(mappedName = JndiConstants.APP_JNDI_PREFIX + &quot;RaMasterApiSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
<span class="nc" id="L230">public class RaMasterApiSessionBean implements RaMasterApiSessionLocal {</span>

<span class="nc" id="L232">    private static final Logger log = Logger.getLogger(RaMasterApiSessionBean.class);</span>
<span class="nc" id="L233">    private static final InternalEjbcaResources intres = InternalEjbcaResources.getInstance();</span>

    @EJB
    private AccessTreeUpdateSessionLocal accessTreeUpdateSession;
    @EJB
    private ApprovalProfileSessionLocal approvalProfileSession;
    @EJB
    private ApprovalSessionLocal approvalSession;
    @EJB
    private ApprovalExecutionSessionLocal approvalExecutionSession;
    @EJB
    private SecurityEventsLoggerSessionLocal auditSession;
    @EJB
    private AuthorizationSessionLocal authorizationSession;
    @EJB
    private AuthorizationSystemSessionLocal authorizationSystemSession;
    @EJB
    private CaSessionLocal caSession;
    @EJB
    private CAAdminSessionLocal caAdminSession;
    @EJB
    private CertificateProfileSessionLocal certificateProfileSession;
    @EJB
    private CertificateRequestSessionLocal certificateRequestSession;
    @EJB
    private CertificateStoreSessionLocal certificateStoreSession;
    @EJB
    private CertificateCreateSessionLocal certificateCreateSession;
    @EJB
    private CmpMessageDispatcherSessionLocal cmpMessageDispatcherSession;
    @EJB
    private CryptoTokenSessionLocal cryptoTokenSession;
    @EJB
    private EnterpriseEditionEjbBridgeSessionLocal enterpriseEditionEjbBridgeSession;
    @EJB
    private EjbcaWSHelperSessionLocal ejbcaWSHelperSession;
    @EJB
    private PublisherSessionLocal publisherSession;
    @EJB
    private PublisherQueueSessionLocal publisherQueueSession;
    @EJB
    private CertReqHistorySessionLocal certreqHistorySession;
    @EJB
    private CrlStoreSessionLocal crlStoreSession;
    @EJB
    private EjbcaRestHelperSessionLocal ejbcaRestHelperSession;
    @EJB
    private EndEntityAccessSessionLocal endEntityAccessSession;
    @EJB
    private EndEntityManagementSessionLocal endEntityManagementSession;
    @EJB
    private EndEntityProfileSessionLocal endEntityProfileSession;
    @EJB
    private EstOperationsSessionLocal estOperationsSessionLocal;
    @EJB
    private GlobalConfigurationSessionLocal globalConfigurationSession;
    @EJB
    private HardTokenSessionLocal hardTokenSession;
    @EJB
    private KeyRecoverySessionLocal keyRecoverySessionLocal;
    @EJB
    private KeyStoreCreateSessionLocal keyStoreCreateSessionLocal;
    @EJB
    private NoConflictCertificateStoreSessionLocal noConflictCertificateStoreSession;
    @EJB
    private UserDataSourceSessionLocal userDataSourceSession;
    @EJB
    private ScepMessageDispatcherSessionLocal scepMessageDispatcherSession;
    @EJB
    private SignSessionLocal signSessionLocal;
    @EJB
    private EndEntityAuthenticationSessionLocal endEntityAuthenticationSessionLocal;
    @EJB
    private RoleSessionLocal roleSession;
    @EJB
    private RoleDataSessionLocal roleDataSession;
    @EJB
    private RoleMemberSessionLocal roleMemberSession;
    @EJB
    private KeyValidatorSessionLocal keyValidatorSession;
    @EJB
    private AcmeAccountDataSessionLocal acmeAccountDataSession;
    @EJB
    private AcmeOrderDataSessionLocal acmeOrderDataSession;
    @EJB
    private AcmeAuthorizationDataSessionLocal acmeAuthorizationDataSession;
    @EJB
    private AcmeChallengeDataSessionLocal acmeChallengeDataSession;
    

    @PersistenceContext(unitName = CesecoreConfiguration.PERSISTENCE_UNIT)
    private EntityManager entityManager;

    /**
     * Defines the current RA Master API version.
     *
     * &lt;p&gt;List of versions:
     * &lt;table&gt;
     * &lt;tr&gt;&lt;th&gt;0&lt;td&gt;=&lt;td&gt;6.6.0
     * &lt;tr&gt;&lt;th&gt;1&lt;td&gt;=&lt;td&gt;6.8.0
     * &lt;tr&gt;&lt;th&gt;2&lt;td&gt;=&lt;td&gt;6.11.0
     * &lt;tr&gt;&lt;th&gt;3&lt;td&gt;=&lt;td&gt;6.12.0
     * &lt;tr&gt;&lt;th&gt;4&lt;td&gt;=&lt;td&gt;6.14.0
     * &lt;tr&gt;&lt;th&gt;4&lt;td&gt;=&lt;td&gt;6.15.0
     */
    private static final int RA_MASTER_API_VERSION = 5; // 6.15.0

    /** Cached value of an active CA, so we don't have to list through all CAs every time as this is a critical path executed every time */
<span class="nc" id="L341">    private int activeCaIdCache = -1;</span>

    @Override
    public boolean isBackendAvailable() {
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (activeCaIdCache != -1) {</span>
<span class="nc" id="L346">            CAInfo activeCa = caSession.getCAInfoInternal(activeCaIdCache);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (activeCa != null) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (activeCa.getStatus() == CAConstants.CA_ACTIVE) {</span>
<span class="nc" id="L349">                    return true;</span>
                }
            } else {
<span class="nc" id="L352">                activeCaIdCache = -1;</span>
<span class="nc" id="L353">                log.debug(&quot;Fail to get info for cached CA with ID &quot; + activeCaIdCache);</span>
            }

        }

        // If the cached activeCaIdCache was not active, or didn't exist, we move on to check all in the list
<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (int caId : caSession.getAllCaIds()) {</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (caSession.getCAInfoInternal(caId).getStatus() == CAConstants.CA_ACTIVE) {</span>
<span class="nc" id="L361">                activeCaIdCache = caId; // Remember this value for the next time</span>
<span class="nc" id="L362">                return true;</span>
            }
<span class="nc" id="L364">        }</span>
<span class="nc" id="L365">        return false;</span>
    }

    @Override
    public int getApiVersion() {
<span class="nc" id="L370">        return RA_MASTER_API_VERSION;</span>
    }

    @Override
    public boolean isAuthorizedNoLogging(AuthenticationToken authenticationToken, String... resources) {
<span class="nc" id="L375">        return authorizationSession.isAuthorizedNoLogging(authenticationToken, resources);</span>
    }

    @Override
    public RaAuthorizationResult getAuthorization(AuthenticationToken authenticationToken) throws AuthenticationFailedException {
<span class="nc" id="L380">        final HashMap&lt;String, Boolean&gt; accessRules = authorizationSession.getAccessAvailableToAuthenticationToken(authenticationToken);</span>
<span class="nc" id="L381">        final int updateNumber = accessTreeUpdateSession.getAccessTreeUpdateNumber();</span>
<span class="nc" id="L382">        return new RaAuthorizationResult(accessRules, updateNumber);</span>
    }

    @Override
    @Deprecated
    public AccessSet getUserAccessSet(final AuthenticationToken authenticationToken) throws AuthenticationFailedException  {
<span class="nc" id="L388">        return authorizationSystemSession.getAccessSetForAuthToken(authenticationToken);</span>
    }

    @Override
    @Deprecated
    public List&lt;AccessSet&gt; getUserAccessSets(final List&lt;AuthenticationToken&gt; authenticationTokens)  {
<span class="nc" id="L394">        final List&lt;AccessSet&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        for (final AuthenticationToken authenticationToken : authenticationTokens) {</span>
            try {
<span class="nc" id="L397">                ret.add(authorizationSystemSession.getAccessSetForAuthToken(authenticationToken));</span>
<span class="nc" id="L398">            } catch (AuthenticationFailedException e) {</span>
                // Always add, even if null. Otherwise the caller won't be able to determine which AccessSet belongs to which AuthenticationToken
<span class="nc" id="L400">                ret.add(null);</span>
<span class="nc" id="L401">            }</span>
<span class="nc" id="L402">        }</span>
<span class="nc" id="L403">        return ret;</span>
    }

    @Override
    public List&lt;CAInfo&gt; getAuthorizedCas(AuthenticationToken authenticationToken) {
<span class="nc" id="L408">        return caSession.getAuthorizedCaInfos(authenticationToken);</span>
    }

    private LinkedHashMap&lt;Integer, RaStyleInfo&gt; getAllCustomRaCss() {
<span class="nc" id="L412">        GlobalCustomCssConfiguration globalCustomCssConfiguration = (GlobalCustomCssConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalCustomCssConfiguration.CSS_CONFIGURATION_ID);</span>
        // Returns an empty map if no CSS was found
<span class="nc" id="L414">        return globalCustomCssConfiguration.getRaStyleInfo();</span>
    }

    @Override
    public LinkedHashMap&lt;Integer,RaStyleInfo&gt; getAllCustomRaStyles(AuthenticationToken authenticationToken) throws AuthorizationDeniedException {
<span class="nc" id="L419">        boolean authorizedToCssArchives = isAuthorizedNoLogging(authenticationToken,</span>
<span class="nc" id="L420">                StandardRules.SYSTEMCONFIGURATION_VIEW.resource(), StandardRules.VIEWROLES.resource());</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (!authorizedToCssArchives) {</span>
<span class="nc" id="L422">            throw new AuthorizationDeniedException(authenticationToken + &quot; is not authorized to CSS archives&quot;);</span>
        }
<span class="nc" id="L424">        return getAllCustomRaCss();</span>
    }

    @Override
    public List&lt;RaStyleInfo&gt; getAvailableCustomRaStyles(AuthenticationToken authenticationToken, int hashCodeOfCurrentList) {
<span class="nc" id="L429">        List&lt;RaStyleInfo&gt; associatedCss = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L430">        LinkedHashMap&lt;Integer, RaStyleInfo&gt; allCssInfos = getAllCustomRaCss();</span>
<span class="nc" id="L431">        List&lt;Role&gt; isMemberOf = roleSession.getRolesAuthenticationTokenIsMemberOf(authenticationToken);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        for (Role role : isMemberOf) {</span>
<span class="nc" id="L433">            RaStyleInfo cssToAdd = allCssInfos.get(role.getStyleId());</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (cssToAdd != null) {</span>
<span class="nc" id="L435">                associatedCss.add(allCssInfos.get(role.getStyleId()));</span>
            }
<span class="nc" id="L437">        }</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (associatedCss.hashCode() == hashCodeOfCurrentList) {</span>
<span class="nc" id="L439">            return null;</span>
        } else {
<span class="nc" id="L441">            return associatedCss;</span>

        }
    }

    @Override
    public List&lt;Role&gt; getAuthorizedRoles(AuthenticationToken authenticationToken) {
<span class="nc" id="L448">        return roleSession.getAuthorizedRoles(authenticationToken);</span>
    }

    @Override
    public Role getRole(final AuthenticationToken authenticationToken, final int roleId) throws AuthorizationDeniedException {
<span class="nc" id="L453">        return roleSession.getRole(authenticationToken, roleId);</span>
    }

    @Override
    public List&lt;String&gt; getAuthorizedRoleNamespaces(final AuthenticationToken authenticationToken, final int roleId) {
        // Skip roles that come from other peers if roleId is set
        try {
<span class="nc bnc" id="L460" title="All 4 branches missed.">            if (roleId != Role.ROLE_ID_UNASSIGNED &amp;&amp; getRole(authenticationToken, roleId) == null) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L462">                    log.debug(&quot;Requested role with ID &quot; + roleId + &quot; does not exist on this system, returning empty list of namespaces&quot;);</span>
                }
<span class="nc" id="L464">                return new ArrayList&lt;&gt;();</span>
            }
<span class="nc" id="L466">        } catch (AuthorizationDeniedException e) {</span>
            // Should usually not happen
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L469">                log.debug(&quot;Client &quot; + authenticationToken + &quot;was denied authorization to role with ID &quot; + roleId + &quot;, returning empty list of namespaces&quot;);</span>
            }
<span class="nc" id="L471">            return new ArrayList&lt;&gt;();</span>
<span class="nc" id="L472">        }</span>

<span class="nc" id="L474">        return roleSession.getAuthorizedNamespaces(authenticationToken);</span>
    }

    @Override
    public Map&lt;String,RaRoleMemberTokenTypeInfo&gt; getAvailableRoleMemberTokenTypes(final AuthenticationToken authenticationToken) {
<span class="nc" id="L479">        final Map&lt;String,RaRoleMemberTokenTypeInfo&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        for (final String tokenType : AccessMatchValueReverseLookupRegistry.INSTANCE.getAllTokenTypes()) {</span>
            // Disallow access to Public Access and CLI token types on the RA, as well as non-user-configurable token types such as AlwaysAllowLocal
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (!AccessMatchValueReverseLookupRegistry.INSTANCE.getMetaData(tokenType).isUserConfigurable() ||</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                    PublicAccessAuthenticationTokenMetaData.TOKEN_TYPE.equals(tokenType) ||</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                    CliAuthenticationTokenMetaData.TOKEN_TYPE.equals(tokenType)) {</span>
<span class="nc" id="L485">                continue;</span>
            }

<span class="nc" id="L488">            final Map&lt;String,Integer&gt; stringToNumberMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            for (final Entry&lt;String,AccessMatchValue&gt; entry : AccessMatchValueReverseLookupRegistry.INSTANCE.getNameLookupRegistryForTokenType(tokenType).entrySet()) {</span>
<span class="nc" id="L490">                stringToNumberMap.put(entry.getKey(), entry.getValue().getNumericValue());</span>
<span class="nc" id="L491">            }</span>
<span class="nc" id="L492">            final AccessMatchValue defaultValue = AccessMatchValueReverseLookupRegistry.INSTANCE.getDefaultValueForTokenType(tokenType);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            final boolean hasMatchTypes = !defaultValue.getAvailableAccessMatchTypes().isEmpty();</span>

<span class="nc" id="L495">            result.put(tokenType, new RaRoleMemberTokenTypeInfo(stringToNumberMap, defaultValue.name(), defaultValue.isIssuedByCa(),</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">                    hasMatchTypes, hasMatchTypes ? defaultValue.getAvailableAccessMatchTypes().get(0).getNumericValue() : 0));</span>

<span class="nc" id="L498">        }</span>
<span class="nc" id="L499">        return result;</span>
    }

    @Override
    public Role saveRole(final AuthenticationToken authenticationToken, final Role role) throws AuthorizationDeniedException, RoleExistsException {
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (role.getRoleId() != Role.ROLE_ID_UNASSIGNED) {</span>
            // Updating a role
<span class="nc" id="L506">            Role oldRole = roleSession.getRole(authenticationToken, role.getRoleId());</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (oldRole == null) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L509">                    log.debug(&quot;Role with ID &quot; + role.getRoleId() + &quot; does not exist on this system, and will not be updated here. The role name to save was '&quot; + role.getRoleNameFull() + &quot;'&quot;);</span>
                }
<span class="nc" id="L511">                return null; // not present on this system</span>
            }
        }
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L515">            log.debug(&quot;Persisting a role with ID &quot; + role.getRoleId() + &quot; and name '&quot; + role.getRoleNameFull() + &quot;'&quot;);</span>
        }
<span class="nc" id="L517">        return roleSession.persistRole(authenticationToken, role);</span>
    }

    @Override
    public boolean deleteRole(AuthenticationToken authenticationToken, int roleId) throws AuthorizationDeniedException {
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L523">            log.debug(&quot;Deleting role with ID &quot; + roleId);</span>
        }
<span class="nc" id="L525">        return roleSession.deleteRoleIdempotent(authenticationToken, roleId);</span>
    }

    @Override
    public RoleMember getRoleMember(final AuthenticationToken authenticationToken, final int roleMemberId) throws AuthorizationDeniedException {
<span class="nc" id="L530">        return roleMemberSession.getRoleMember(authenticationToken, roleMemberId);</span>
    }

    @Override
    public RoleMember saveRoleMember(final AuthenticationToken authenticationToken, final RoleMember roleMember) throws AuthorizationDeniedException {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L536">            log.debug(&quot;Persisting a role member with ID &quot; + roleMember.getRoleId() + &quot; and match value '&quot; + roleMember.getTokenMatchValue() + &quot;'&quot;);</span>
        }
<span class="nc" id="L538">        return roleMemberSession.persist(authenticationToken, roleMember);</span>
    }

    @Override
    public boolean deleteRoleMember(AuthenticationToken authenticationToken, int roleId, int roleMemberId) throws AuthorizationDeniedException {
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L544">            log.debug(&quot;Removing role member with ID &quot; + roleMemberId + &quot; from the role with ID &quot; + roleId);</span>
        }
<span class="nc" id="L546">        final RoleMember roleMember = roleMemberSession.getRoleMember(authenticationToken, roleMemberId);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (roleMember == null) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L549">                log.debug(&quot;Can't delete role member with ID &quot; + roleMemberId + &quot; because it does not exist.&quot;);</span>
            }
<span class="nc" id="L551">            log.info(&quot;Client &quot; + authenticationToken + &quot; failed to delete role member with ID &quot; + roleMemberId + &quot; because it does not exist.&quot;);</span>
<span class="nc" id="L552">            return false;</span>
        }
        // Sanity check that there's no ID collision
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (roleMember.getRoleId() != roleId) {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L557">                log.debug(&quot;Role member has an unexpected Role ID &quot; + roleMemberId + &quot;. Role ID &quot; + roleId);</span>
            }
<span class="nc" id="L559">            return false;</span>
        }

<span class="nc" id="L562">        return roleMemberSession.remove(authenticationToken, roleMemberId);</span>
    }


    private ApprovalDataVO getApprovalDataNoAuth(final int id) {
<span class="nc" id="L567">        final org.ejbca.util.query.Query query = new org.ejbca.util.query.Query(org.ejbca.util.query.Query.TYPE_APPROVALQUERY);</span>
<span class="nc" id="L568">        query.add(ApprovalMatch.MATCH_WITH_UNIQUEID, BasicMatch.MATCH_TYPE_EQUALS, Integer.toString(id));</span>

        final List&lt;ApprovalDataVO&gt; approvals;
        try {
<span class="nc" id="L572">            approvals = approvalSession.query(query, 0, 100, &quot;&quot;, &quot;&quot;); // authorization checks are performed afterwards</span>
<span class="nc" id="L573">        } catch (IllegalQueryException e) {</span>
<span class="nc" id="L574">            throw new IllegalStateException(&quot;Query for approval request failed: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L575">        }</span>

<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (approvals.isEmpty()) {</span>
<span class="nc" id="L578">            return null;</span>
        }

<span class="nc" id="L581">        return approvals.iterator().next();</span>
    }

    /** @param approvalId Calculated hash of the request (this somewhat confusing name is re-used from the ApprovalRequest class)
     * @return ApprovalDataVO or null if not found
     */
    private ApprovalDataVO getApprovalDataByRequestHash(final int approvalId) {
<span class="nc" id="L588">        final List&lt;ApprovalDataVO&gt; approvalDataVOs = approvalSession.findApprovalDataVO(approvalId);</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        return approvalDataVOs.isEmpty() ? null : approvalDataVOs.get(0);</span>
    }

    /** Gets the complete text representation of a request (unlike ApprovalRequest.getNewRequestDataAsText which doesn't do any database queries) 
     * @param authenticationToken Token
     * @param approval Approval
     * @return Data */
    private List&lt;ApprovalDataText&gt; getRequestDataAsText(final AuthenticationToken authenticationToken, final ApprovalDataVO approval) {
<span class="nc" id="L597">        final ApprovalRequest approvalRequest = approval.getApprovalRequest();</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (approvalRequest instanceof EditEndEntityApprovalRequest) {</span>
<span class="nc" id="L599">            return ((EditEndEntityApprovalRequest)approvalRequest).getNewRequestDataAsText(caSession, endEntityProfileSession, certificateProfileSession, hardTokenSession);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        } else if (approvalRequest instanceof AddEndEntityApprovalRequest) {</span>
<span class="nc" id="L601">            return ((AddEndEntityApprovalRequest)approvalRequest).getNewRequestDataAsText(caSession, endEntityProfileSession, certificateProfileSession, hardTokenSession);</span>
        } else {
<span class="nc" id="L603">            return approvalRequest.getNewRequestDataAsText(authenticationToken);</span>
        }
    }

    private RaEditableRequestData getRequestEditableData(final AuthenticationToken authenticationToken, final ApprovalDataVO advo) {
<span class="nc" id="L608">        final ApprovalRequest approvalRequest = advo.getApprovalRequest();</span>
<span class="nc" id="L609">        final RaEditableRequestData editableData = new RaEditableRequestData();</span>
<span class="nc" id="L610">        EndEntityInformation userdata = null;</span>

<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (approvalRequest instanceof EditEndEntityApprovalRequest) {</span>
<span class="nc" id="L613">            final EditEndEntityApprovalRequest req = (EditEndEntityApprovalRequest)approvalRequest;</span>
<span class="nc" id="L614">            userdata = req.getNewEndEntityInformation();</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        } else if (approvalRequest instanceof AddEndEntityApprovalRequest) {</span>
<span class="nc" id="L616">            final AddEndEntityApprovalRequest req = (AddEndEntityApprovalRequest)approvalRequest;</span>
<span class="nc" id="L617">            userdata = req.getEndEntityInformation();</span>
        }
        // TODO handle more types or approval requests? (ECA-5290)

<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (userdata != null) {</span>
<span class="nc" id="L622">            editableData.setUsername(userdata.getUsername());</span>
<span class="nc" id="L623">            editableData.setEmail(userdata.getEmail());</span>
<span class="nc" id="L624">            editableData.setSubjectDN(userdata.getDN());</span>
<span class="nc" id="L625">            editableData.setSubjectAltName(userdata.getSubjectAltName());</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            if (userdata.getExtendedInformation() != null) {</span>
<span class="nc" id="L627">                final ExtendedInformation ei = userdata.getExtendedInformation();</span>
<span class="nc" id="L628">                editableData.setSubjectDirAttrs(ei.getSubjectDirectoryAttributes());</span>
            }
        }

<span class="nc" id="L632">        return editableData;</span>
    }

    @Override
    public RaApprovalRequestInfo getApprovalRequest(final AuthenticationToken authenticationToken, final int id) {
<span class="nc" id="L637">        final ApprovalDataVO advo = getApprovalDataNoAuth(id);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (advo == null) {</span>
<span class="nc" id="L639">            return null;</span>
        }
<span class="nc" id="L641">        return getApprovalRequest(authenticationToken, advo);</span>
    }

    @Override
    public RaApprovalRequestInfo getApprovalRequestByRequestHash(final AuthenticationToken authenticationToken, final int approvalId) {
<span class="nc" id="L646">        final ApprovalDataVO advo = getApprovalDataByRequestHash(approvalId);</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (advo == null) {</span>
<span class="nc" id="L648">            return null;</span>
        }
<span class="nc" id="L650">        return getApprovalRequest(authenticationToken, advo);</span>
    }

    private RaApprovalRequestInfo getApprovalRequest(final AuthenticationToken authenticationToken, final ApprovalDataVO advo) {
        // By getting the CA we perform an implicit auth check
        String caName;
<span class="nc bnc" id="L656" title="All 2 branches missed.">        if (advo.getCAId() == ApprovalDataVO.ANY_CA) {</span>
<span class="nc" id="L657">            caName = null;</span>
        } else {
            try {
<span class="nc" id="L660">                final CAInfo cainfo = caSession.getCAInfo(authenticationToken, advo.getCAId());</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (cainfo != null) {</span>
<span class="nc" id="L662">                    caName = cainfo.getName();</span>
                } else {
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L665">                        log.debug(&quot;Appproval request &quot; + advo.getId() + &quot; references CA ID &quot; + advo.getCAId() + &quot; which doesn't exist&quot;);</span>
                    }
<span class="nc" id="L667">                    caName = &quot;Missing CA ID &quot; + advo.getCAId();</span>
                }
<span class="nc" id="L669">            } catch (AuthorizationDeniedException e) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L671">                    log.debug(&quot;Administrator &quot; + authenticationToken + &quot; was denied access to CA &quot; + advo.getCAId()</span>
<span class="nc" id="L672">                            + &quot;. Returning null instead of the approval with ID &quot; + advo.getId());</span>
                }
<span class="nc" id="L674">                return null;</span>
<span class="nc" id="L675">            }</span>
        }

<span class="nc" id="L678">        final ApprovalRequest approvalRequest = advo.getApprovalRequest();</span>
<span class="nc" id="L679">        final String endEntityProfileName = endEntityProfileSession.getEndEntityProfileName(advo.getEndEntityProfileId());</span>
<span class="nc" id="L680">        final EndEntityProfile endEntityProfile = endEntityProfileSession.getEndEntityProfile(advo.getEndEntityProfileId());</span>
        final String certificateProfileName;
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (approvalRequest instanceof AddEndEntityApprovalRequest) {</span>
<span class="nc" id="L683">            certificateProfileName = certificateProfileSession.getCertificateProfileName(((AddEndEntityApprovalRequest)approvalRequest).getEndEntityInformation().getCertificateProfileId());</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        } else if (approvalRequest instanceof EditEndEntityApprovalRequest) {</span>
<span class="nc" id="L685">            certificateProfileName = certificateProfileSession.getCertificateProfileName(((EditEndEntityApprovalRequest)approvalRequest).getNewEndEntityInformation().getCertificateProfileId());</span>
        } else {
<span class="nc" id="L687">            certificateProfileName = null;</span>
        }

        // Get request data as text
<span class="nc" id="L691">        final List&lt;ApprovalDataText&gt; requestData = getRequestDataAsText(authenticationToken, advo);</span>

        // Editable data
<span class="nc" id="L694">        final RaEditableRequestData editableData = getRequestEditableData(authenticationToken, advo);</span>

<span class="nc" id="L696">        return new RaApprovalRequestInfo(authenticationToken, caName, endEntityProfileName, endEntityProfile, certificateProfileName, advo,</span>
                requestData, editableData);

    }

    @Override
    public RaApprovalRequestInfo editApprovalRequest(final AuthenticationToken authenticationToken, final RaApprovalEditRequest edit) throws AuthorizationDeniedException {
<span class="nc" id="L703">        final int id = edit.getId();</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L705">            log.debug(&quot;Editing approval request &quot; + id + &quot;. Administrator: &quot; + authenticationToken);</span>
        }
<span class="nc" id="L707">        final ApprovalDataVO advo = getApprovalDataNoAuth(id);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">        if (advo == null) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L710">                log.debug(&quot;Approval Request with ID &quot; + id + &quot; not found in editApprovalRequest&quot;);</span>
            }
            // This method may be called on multiple nodes (e.g. both locally on RA, and on multiple CAs),
            // so we must not throw any exceptions on the nodes where the request does not exist.
<span class="nc" id="L714">            return null;</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        } else if (getApprovalRequest(authenticationToken, advo) == null) { // Authorization check</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L717">                log.debug(&quot;Authorization denied to approval request with ID &quot; + id + &quot; for administrator '&quot; + authenticationToken + &quot;'&quot;);</span>
            }
<span class="nc" id="L719">            throw new AuthorizationDeniedException(authenticationToken + &quot; is not authorized to the Request with ID &quot; + id + &quot; at this point&quot;);</span>
        }

<span class="nc bnc" id="L722" title="All 2 branches missed.">        if (advo.getStatus() != ApprovalDataVO.STATUS_WAITINGFORAPPROVAL) {</span>
<span class="nc" id="L723">            throw new IllegalStateException(&quot;Was not in waiting for approval state&quot;);</span>
        }

<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (!advo.getApprovals().isEmpty()) {</span>
<span class="nc" id="L727">            throw new IllegalStateException(&quot;Can't edit a request that has one or more approvals&quot;);</span>
        }

<span class="nc" id="L730">        final ApprovalRequest approvalRequest = advo.getApprovalRequest();</span>
<span class="nc" id="L731">        final RaEditableRequestData editData = edit.getEditableData();</span>

        // Can only edit approvals that we have requested, or that we are authorized to approve (ECA-5408)
<span class="nc" id="L734">        final AuthenticationToken requestAdmin = approvalRequest.getRequestAdmin();</span>
<span class="nc bnc" id="L735" title="All 4 branches missed.">        final boolean requestedByMe = requestAdmin != null &amp;&amp; requestAdmin.equals(authenticationToken);</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (requestedByMe) {</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L738">                log.debug(&quot;Request (ID &quot; + id + &quot;) was created by this administrator, so authorization is granted. Editing administrator: '&quot; + authenticationToken + &quot;'&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L742">                log.debug(&quot;Will perform approval authorization check, because request (ID &quot; + id + &quot;) was create by another administrator '&quot; + requestAdmin + &quot;'. Editing administrator: '&quot; + authenticationToken + &quot;'&quot;);</span>
            }
<span class="nc" id="L744">            approvalExecutionSession.assertAuthorizedToApprove(authenticationToken, advo);</span>
        }

<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (approvalRequest instanceof AddEndEntityApprovalRequest) {</span>
            // Quick check for obviously illegal values
<span class="nc bnc" id="L749" title="All 4 branches missed.">            if (StringUtils.isEmpty(editData.getUsername()) || StringUtils.isEmpty(editData.getSubjectDN())) {</span>
<span class="nc" id="L750">                throw new IllegalArgumentException(&quot;Attempted to set Username or Subject DN to an empty value&quot;);</span>
            }

<span class="nc" id="L753">            final AddEndEntityApprovalRequest addReq = (AddEndEntityApprovalRequest) approvalRequest;</span>
<span class="nc" id="L754">            final EndEntityInformation userdata = addReq.getEndEntityInformation();</span>
<span class="nc" id="L755">            userdata.setUsername(editData.getUsername());</span>
<span class="nc" id="L756">            userdata.setEmail(editData.getEmail());</span>
<span class="nc" id="L757">            userdata.setDN(editData.getSubjectDN());</span>
<span class="nc" id="L758">            userdata.setSubjectAltName(editData.getSubjectAltName());</span>
<span class="nc bnc" id="L759" title="All 4 branches missed.">            if (userdata.getExtendedInformation() == null &amp;&amp; editData.getSubjectDirAttrs() != null) {</span>
<span class="nc" id="L760">                userdata.setExtendedInformation(new ExtendedInformation());</span>
            }
<span class="nc" id="L762">            final ExtendedInformation ei = userdata.getExtendedInformation();</span>
<span class="nc" id="L763">            ei.setSubjectDirectoryAttributes(editData.getSubjectDirAttrs());</span>
<span class="nc" id="L764">        } else {</span>
            // TODO implement more types of requests? (ECA-5290)
<span class="nc bnc" id="L766" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L767">                log.debug(&quot;Tried to edit approval request with ID &quot; + id + &quot; which is of an unsupported type: &quot; + approvalRequest.getClass().getName());</span>
            }
<span class="nc" id="L769">            throw new IllegalStateException(&quot;Editing of this type of request is not implemented: &quot; + approvalRequest.getClass().getName());</span>
        }

        try {
<span class="nc" id="L773">            approvalSession.editApprovalRequest(authenticationToken, id, approvalRequest);</span>
<span class="nc" id="L774">        } catch (ApprovalException e) {</span>
            // Shouldn't happen
<span class="nc" id="L776">            throw new IllegalStateException(e);</span>
<span class="nc" id="L777">        }</span>

<span class="nc" id="L779">        final int newCalculatedHash = approvalRequest.generateApprovalId();</span>
<span class="nc" id="L780">        final Collection&lt;ApprovalDataVO&gt; advosNew = approvalSession.findApprovalDataVO(newCalculatedHash);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (advosNew.isEmpty()) {</span>
<span class="nc" id="L782">            throw new IllegalStateException(&quot;Approval with calculated hash (approvalId) &quot; + newCalculatedHash + &quot; could not be found&quot;);</span>
        }
<span class="nc" id="L784">        final ApprovalDataVO advoNew = advosNew.iterator().next();</span>
<span class="nc" id="L785">        return getApprovalRequest(authenticationToken, advoNew);</span>
    }

    @Override
    public void extendApprovalRequest(final AuthenticationToken authenticationToken, final int id, final long extendForMillis) throws AuthorizationDeniedException {
<span class="nc" id="L790">        final ApprovalDataVO advo = getApprovalDataNoAuth(id);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (advo == null) {</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L793">                log.debug(&quot;Approval request with ID &quot; + id + &quot; does not exist on this node.&quot;);</span>
            }
<span class="nc" id="L795">            return;</span>
        }

<span class="nc bnc" id="L798" title="All 2 branches missed.">        if (getApprovalRequest(authenticationToken, advo) == null) { // Check read authorization (includes authorization to referenced CAs)</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L800">                log.debug(&quot;Authorization denied to approval request ID &quot; + id + &quot; for &quot; + authenticationToken);</span>
            }
<span class="nc" id="L802">            throw new AuthorizationDeniedException(authenticationToken + &quot; is not authorized to the Request with ID &quot; + id + &quot; at this point&quot;);</span>
        }

        // Check specifically for approval authorization
<span class="nc" id="L806">        approvalExecutionSession.assertAuthorizedToApprove(authenticationToken, advo);</span>

<span class="nc" id="L808">        approvalSession.extendApprovalRequestNoAuth(authenticationToken, id, extendForMillis);</span>
<span class="nc" id="L809">    }</span>

    @Override
    public boolean addRequestResponse(final AuthenticationToken authenticationToken, final RaApprovalResponseRequest requestResponse)
            throws AuthorizationDeniedException, ApprovalException, ApprovalRequestExpiredException, ApprovalRequestExecutionException,
            AdminAlreadyApprovedRequestException, SelfApprovalException, AuthenticationFailedException {
<span class="nc" id="L815">        final ApprovalDataVO advo = getApprovalDataNoAuth(requestResponse.getId());</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (advo == null) {</span>
            // Return false so the next master api backend can see if it can handle the approval
<span class="nc" id="L818">            return false;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">        } else if (getApprovalRequest(authenticationToken, advo) == null) { // Check read authorization (includes authorization to referenced CAs)</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L821">                log.debug(&quot;Authorization denied to approval request ID &quot; + requestResponse.getId() + &quot; for &quot; + authenticationToken);</span>
            }
<span class="nc" id="L823">            throw new AuthorizationDeniedException(authenticationToken + &quot; is not authorized to the Request with ID &quot; + requestResponse.getId() + &quot; at this point&quot;);</span>
        }

        // Check specifically for approval authorization
<span class="nc" id="L827">        approvalExecutionSession.assertAuthorizedToApprove(authenticationToken, advo);</span>

        // Save the update request (needed if there are properties, e.g. checkboxes etc. in the partitions)
<span class="nc" id="L830">        approvalSession.updateApprovalRequest(advo.getId(), requestResponse.getApprovalRequest());</span>

        // Add the approval
<span class="nc" id="L833">        final Approval approval = new Approval(requestResponse.getComment(), requestResponse.getStepIdentifier(), requestResponse.getPartitionIdentifier());</span>
<span class="nc bnc" id="L834" title="All 4 branches missed.">        switch (requestResponse.getAction()) {</span>
        case APPROVE:
<span class="nc" id="L836">            approvalExecutionSession.approve(authenticationToken, advo.getApprovalId(), approval);</span>
<span class="nc" id="L837">            return true;</span>
        case REJECT:
<span class="nc" id="L839">            approvalExecutionSession.reject(authenticationToken, advo.getApprovalId(), approval);</span>
<span class="nc" id="L840">            return true;</span>
        case SAVE:
            // All work is already done above
<span class="nc" id="L843">            return true;</span>
        default:
<span class="nc" id="L845">            throw new IllegalStateException(&quot;Invalid action&quot;);</span>
        }
    }

    @Override
    public RaRequestsSearchResponse searchForApprovalRequests(final AuthenticationToken authenticationToken, final RaRequestsSearchRequest request) {
<span class="nc" id="L851">        final RaRequestsSearchResponse response = new RaRequestsSearchResponse();</span>
<span class="nc" id="L852">        final List&lt;CAInfo&gt; authorizedCas = getAuthorizedCas(authenticationToken);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (authorizedCas.size() == 0) {</span>
<span class="nc" id="L854">            return response; // not authorized to any CAs. return empty response</span>
        }
<span class="nc" id="L856">        final Map&lt;Integer,String&gt; caIdToNameMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">        for (final CAInfo cainfo : authorizedCas) {</span>
<span class="nc" id="L858">            caIdToNameMap.put(cainfo.getCAId(), cainfo.getName());</span>
<span class="nc" id="L859">        }</span>

<span class="nc bnc" id="L861" title="All 8 branches missed.">        if (!request.isSearchingWaitingForMe() &amp;&amp; !request.isSearchingPending() &amp;&amp; !request.isSearchingHistorical() &amp;&amp; !request.isSearchingExpired()) {</span>
<span class="nc" id="L862">            return response; // not searching for anything. return empty response</span>
        }

        final List&lt;ApprovalDataVO&gt; approvals;
        try {
<span class="nc" id="L867">            String endEntityProfileAuthorizationString = getEndEntityProfileAuthorizationString(authenticationToken, AccessRulesConstants.APPROVE_END_ENTITY);</span>
<span class="nc" id="L868">            RAAuthorization raAuthorization = new RAAuthorization(authenticationToken, globalConfigurationSession,</span>
                    authorizationSession, caSession, endEntityProfileSession);
<span class="nc bnc" id="L870" title="All 4 branches missed.">            approvals = approvalSession.queryByStatus(request.isSearchingWaitingForMe() || request.isSearchingPending(), request.isSearchingHistorical(),</span>
<span class="nc" id="L871">                    request.isSearchingExpired(), request.getStartDate(), request.getEndDate(), request.getExpiresBefore(), 0, 100, raAuthorization.getCAAuthorizationString(), endEntityProfileAuthorizationString);</span>
<span class="nc" id="L872">        } catch (AuthorizationDeniedException e) {</span>
            // Not currently ever thrown by query()
<span class="nc" id="L874">            throw new IllegalStateException(e);</span>
<span class="nc" id="L875">        }</span>
<span class="nc" id="L876">        final Date now = new Date();</span>

<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L879">            log.debug(&quot;Got &quot; + approvals.size() + &quot; approvals from Master API&quot;);</span>
        }

<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (approvals.size() &gt;= 100) {</span>
<span class="nc" id="L883">            response.setMightHaveMoreResults(true);</span>
        }

<span class="nc bnc" id="L886" title="All 2 branches missed.">        for (final ApprovalDataVO advo : approvals) {</span>
<span class="nc" id="L887">            final List&lt;ApprovalDataText&gt; requestDataLite = advo.getApprovalRequest().getNewRequestDataAsText(authenticationToken); // this method isn't guaranteed to return the full information</span>
<span class="nc" id="L888">            final RaEditableRequestData editableData = getRequestEditableData(authenticationToken, advo);</span>
            // We don't pass the end entity profile or certificate profile details for each approval request, when searching.
            // That information is only needed when viewing the details or editing a request.
<span class="nc" id="L891">            final RaApprovalRequestInfo ari = new RaApprovalRequestInfo(authenticationToken, caIdToNameMap.get(advo.getCAId()), null, null, null,</span>
                    advo, requestDataLite, editableData);

            // Check if this approval should be included in the search results
<span class="nc" id="L895">            boolean include = false;</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">            if (request.getIncludeOtherAdmins()) {</span>
<span class="nc bnc" id="L897" title="All 4 branches missed.">                include = (request.isSearchingWaitingForMe() &amp;&amp; ari.isWaitingForFirstApproval(now)) ||</span>
<span class="nc bnc" id="L898" title="All 4 branches missed.">                        (request.isSearchingPending() &amp;&amp; ari.isInProgress(now)) ||</span>
<span class="nc bnc" id="L899" title="All 4 branches missed.">                        (request.isSearchingHistorical() &amp;&amp; ari.isProcessed()) ||</span>
<span class="nc bnc" id="L900" title="All 4 branches missed.">                        (request.isSearchingExpired() &amp;&amp; ari.isExpired(now));</span>
            } else {
<span class="nc bnc" id="L902" title="All 4 branches missed.">                include = (request.isSearchingWaitingForMe() &amp;&amp; ari.isWaitingForMe(authenticationToken)) ||</span>
<span class="nc bnc" id="L903" title="All 4 branches missed.">                    (request.isSearchingPending() &amp;&amp; ari.isPending(authenticationToken)) ||</span>
<span class="nc bnc" id="L904" title="All 4 branches missed.">                    (request.isSearchingHistorical() &amp;&amp; ari.isProcessed()) ||</span>
<span class="nc bnc" id="L905" title="All 4 branches missed.">                    (request.isSearchingExpired() &amp;&amp; ari.isExpired(now));</span>
            }

<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (include) {</span>
<span class="nc" id="L909">                response.getApprovalRequests().add(ari);</span>
            }
<span class="nc" id="L911">        }</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L913">            log.debug(&quot;Returning &quot; + response.getApprovalRequests().size() + &quot; approvals from search&quot;);</span>
        }
<span class="nc" id="L915">        return response;</span>
    }

    // TODO this method is copied from RAAuthorization because we couldn't use ComplexAccessControlSession.
    // We should find a way to use ComplexAccessControlSession here instead
    private String getEndEntityProfileAuthorizationString(AuthenticationToken authenticationToken, String endentityAccessRule) throws AuthorizationDeniedException {
        // i.e approvals with endentityprofile ApprovalDataVO.ANY_ENDENTITYPROFILE
<span class="nc" id="L922">        boolean authorizedToApproveCAActions = authorizationSession.isAuthorizedNoLogging(authenticationToken, AccessRulesConstants.REGULAR_APPROVECAACTION);</span>
        // i.e approvals with endentityprofile not ApprovalDataVO.ANY_ENDENTITYPROFILE
<span class="nc" id="L924">        boolean authorizedToApproveRAActions = authorizationSession.isAuthorizedNoLogging(authenticationToken, AccessRulesConstants.REGULAR_APPROVEENDENTITY);</span>
<span class="nc" id="L925">        boolean authorizedToAudit = authorizationSession.isAuthorizedNoLogging(authenticationToken, AuditLogRules.VIEW.resource());</span>
<span class="nc" id="L926">        boolean authorizedToViewApprovals = authorizationSession.isAuthorizedNoLogging(authenticationToken, AccessRulesConstants.REGULAR_VIEWAPPROVALS);</span>
<span class="nc bnc" id="L927" title="All 8 branches missed.">        if (!authorizedToApproveCAActions &amp;&amp; !authorizedToApproveRAActions &amp;&amp; !authorizedToAudit &amp;&amp; !authorizedToViewApprovals) {</span>
<span class="nc" id="L928">            throw new AuthorizationDeniedException(authenticationToken + &quot; not authorized to query for approvals: &quot;+authorizedToApproveCAActions+&quot;, &quot;+authorizedToApproveRAActions</span>
                    +&quot;, &quot;+authorizedToAudit+&quot; or &quot;+authorizedToViewApprovals);
        }

<span class="nc" id="L932">        String endentityauth = null;</span>
<span class="nc" id="L933">        GlobalConfiguration globalconfiguration = (GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID);</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">        if (globalconfiguration.getEnableEndEntityProfileLimitations()){</span>
<span class="nc" id="L935">            endentityauth = getEndEntityProfileAuthorizationString(authenticationToken, true, endentityAccessRule);</span>
<span class="nc bnc" id="L936" title="All 4 branches missed.">            if(authorizedToApproveCAActions &amp;&amp; authorizedToApproveRAActions){</span>
<span class="nc" id="L937">                endentityauth = getEndEntityProfileAuthorizationString(authenticationToken, true, endentityAccessRule);</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">                if(endentityauth != null){</span>
<span class="nc" id="L939">                  endentityauth = &quot;(&quot; + getEndEntityProfileAuthorizationString(authenticationToken, false, endentityAccessRule) + &quot; OR endEntityProfileId=&quot; + ApprovalDataVO.ANY_ENDENTITYPROFILE + &quot; ) &quot;;</span>
                }
<span class="nc bnc" id="L941" title="All 2 branches missed.">            }else if (authorizedToApproveCAActions) {</span>
<span class="nc" id="L942">                endentityauth = &quot; endEntityProfileId=&quot; + ApprovalDataVO.ANY_ENDENTITYPROFILE;</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            }else if (authorizedToApproveRAActions) {</span>
<span class="nc" id="L944">                endentityauth = getEndEntityProfileAuthorizationString(authenticationToken, true, endentityAccessRule);</span>
            }

        }
<span class="nc bnc" id="L948" title="All 2 branches missed.">        return endentityauth == null ? endentityauth : endentityauth.trim();</span>
    }

    // TODO this method is copied from RAAuthorization because we couldn't use ComplexAccessControlSession.
    // We should find a way to use ComplexAccessControlSession here instead
    private String getEndEntityProfileAuthorizationString(AuthenticationToken authenticationToken, boolean includeparanteses, String endentityAccessRule){
<span class="nc" id="L954">        String authendentityprofilestring=null;</span>
<span class="nc" id="L955">          Collection&lt;Integer&gt; profileIds = new ArrayList&lt;&gt;(endEntityProfileSession.getEndEntityProfileIdToNameMap().keySet());</span>
<span class="nc" id="L956">          Collection&lt;Integer&gt; result = getAuthorizedEndEntityProfileIds(authenticationToken, AccessRulesConstants.VIEW_END_ENTITY, profileIds);</span>
<span class="nc" id="L957">          result.retainAll(this.endEntityProfileSession.getAuthorizedEndEntityProfileIds(authenticationToken, endentityAccessRule));</span>
<span class="nc" id="L958">          Iterator&lt;Integer&gt; iter = result.iterator();</span>

<span class="nc bnc" id="L960" title="All 2 branches missed.">          while(iter.hasNext()){</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">            if(authendentityprofilestring == null) {</span>
<span class="nc" id="L962">              authendentityprofilestring = &quot; endEntityProfileId = &quot; + iter.next().toString();</span>
            } else {
<span class="nc" id="L964">              authendentityprofilestring = authendentityprofilestring + &quot; OR endEntityProfileId = &quot; + iter.next().toString();</span>
            }
          }

<span class="nc bnc" id="L968" title="All 2 branches missed.">          if(authendentityprofilestring != null) {</span>
<span class="nc" id="L969">            authendentityprofilestring = &quot;( &quot; + authendentityprofilestring + &quot; )&quot;;</span>
          }

<span class="nc" id="L972">        return authendentityprofilestring;</span>
      }

    // TODO this method is copied from ComplexAccessControlSession. We should find a way to use ComplexAccessControlSession here instead
    private Collection&lt;Integer&gt; getAuthorizedEndEntityProfileIds(AuthenticationToken authenticationToken, String rapriviledge,
            Collection&lt;Integer&gt; availableEndEntityProfileId) {
<span class="nc" id="L978">        ArrayList&lt;Integer&gt; returnval = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">        for (final Integer profileid : availableEndEntityProfileId) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            if (authorizationSession.isAuthorizedNoLogging(authenticationToken, AccessRulesConstants.ENDENTITYPROFILEPREFIX + profileid + rapriviledge)) {</span>
<span class="nc" id="L981">                returnval.add(profileid);</span>
            } else {
<span class="nc bnc" id="L983" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L984">                    log.debug(&quot;Administrator &quot; + authenticationToken + &quot; is not authorized to end entity profile: &quot; + profileid);</span>
                }
            }
<span class="nc" id="L987">        }</span>
<span class="nc" id="L988">        return returnval;</span>
    }

    private boolean authorizedToCert(final AuthenticationToken authenticationToken, final CertificateDataWrapper cdw) {
<span class="nc bnc" id="L992" title="All 2 branches missed.">        if (!caSession.authorizedToCANoLogging(authenticationToken, cdw.getCertificateData().getIssuerDN().hashCode())) {</span>
<span class="nc" id="L993">            return false;</span>
        }
        // Check EEP authorization (allow an highly privileged admin, e.g. superadmin, that can access all profiles to ignore this check
        // so certificates can still be accessed by this admin even after a EEP has been removed.
        // Also, if we have access to the EMPTY profile, then we allow access to certificates with zero/null profile IDs, so they can at least be revoked.
<span class="nc" id="L998">        final Collection&lt;Integer&gt; authorizedEepIds = new ArrayList&lt;&gt;(endEntityProfileSession.getAuthorizedEndEntityProfileIds(authenticationToken, AccessRulesConstants.VIEW_END_ENTITY));</span>
<span class="nc" id="L999">        final boolean accessAnyEepAvailable = authorizedEepIds.containsAll(endEntityProfileSession.getEndEntityProfileIdToNameMap().keySet());</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">        if (authorizedEepIds.contains(EndEntityConstants.EMPTY_END_ENTITY_PROFILE)) {</span>
<span class="nc" id="L1001">            authorizedEepIds.add(EndEntityConstants.NO_END_ENTITY_PROFILE);</span>
        }
<span class="nc bnc" id="L1003" title="All 4 branches missed.">        if (!accessAnyEepAvailable &amp;&amp; !authorizedEepIds.contains(Integer.valueOf(cdw.getCertificateData().getEndEntityProfileIdOrZero()))) {</span>
<span class="nc" id="L1004">            return false;</span>
        }
<span class="nc" id="L1006">        return true;</span>
    }

    @Override
    public CertificateDataWrapper searchForCertificate(final AuthenticationToken authenticationToken, final String fingerprint) {
<span class="nc" id="L1011">        final CertificateDataWrapper cdw = certificateStoreSession.getCertificateData(fingerprint);</span>
<span class="nc bnc" id="L1012" title="All 4 branches missed.">        if (cdw==null || !authorizedToCert(authenticationToken, cdw)) {</span>
<span class="nc" id="L1013">            return null;</span>
        }
<span class="nc" id="L1015">        return cdw;</span>
    }

    @Override
    public CertificateDataWrapper searchForCertificateByIssuerAndSerial(final AuthenticationToken authenticationToken, final String issuerDN, final String serno) {
<span class="nc" id="L1020">        final CertificateDataWrapper cdw = certificateStoreSession.getCertificateDataByIssuerAndSerno(issuerDN, new BigInteger(serno, 16));</span>
<span class="nc bnc" id="L1021" title="All 4 branches missed.">        if (cdw==null || !authorizedToCert(authenticationToken, cdw)) {</span>
<span class="nc" id="L1022">            return null;</span>
        }
<span class="nc" id="L1024">        return cdw;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public RaCertificateSearchResponse searchForCertificates(AuthenticationToken authenticationToken, RaCertificateSearchRequest request) {
<span class="nc" id="L1030">        final RaCertificateSearchResponse response = new RaCertificateSearchResponse();</span>
<span class="nc" id="L1031">        final List&lt;Integer&gt; authorizedLocalCaIds = new ArrayList&lt;&gt;(caSession.getAuthorizedCaIds(authenticationToken));</span>
        // Only search a subset of the requested CAs if requested
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (!request.getCaIds().isEmpty()) {</span>
<span class="nc" id="L1034">            authorizedLocalCaIds.retainAll(request.getCaIds());</span>
        }
<span class="nc" id="L1036">        final List&lt;String&gt; issuerDns = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        for (final int caId : authorizedLocalCaIds) {</span>
<span class="nc" id="L1038">            final String issuerDn = CertTools.stringToBCDNString(StringTools.strip(caSession.getCAInfoInternal(caId).getSubjectDN()));</span>
<span class="nc" id="L1039">            issuerDns.add(issuerDn);</span>
<span class="nc" id="L1040">        }</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">        if (issuerDns.isEmpty()) {</span>
            // Empty response since there were no authorized CAs
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1044">                log.debug(&quot;Client '&quot;+authenticationToken+&quot;' was not authorized to any of the requested CAs and the search request will be dropped.&quot;);</span>
            }
<span class="nc" id="L1046">            return response;</span>
        }
        // Check Certificate Profile authorization
<span class="nc" id="L1049">        final List&lt;Integer&gt; authorizedCpIds = new ArrayList&lt;&gt;(certificateProfileSession.getAuthorizedCertificateProfileIds(authenticationToken, 0));</span>
<span class="nc" id="L1050">        final boolean accessAnyCpAvailable = authorizedCpIds.containsAll(certificateProfileSession.getCertificateProfileIdToNameMap().keySet());</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        if (!request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1052">            authorizedCpIds.retainAll(request.getCpIds());</span>
        }
<span class="nc bnc" id="L1054" title="All 2 branches missed.">        if (authorizedCpIds.isEmpty()) {</span>
            // Empty response since there were no authorized Certificate Profiles
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1057">                log.debug(&quot;Client '&quot;+authenticationToken+&quot;' was not authorized to any of the requested CPs and the search request will be dropped.&quot;);</span>
            }
<span class="nc" id="L1059">            return response;</span>
        }
        // Check End Entity Profile authorization
<span class="nc" id="L1062">        final Collection&lt;Integer&gt; authorizedEepIds = new ArrayList&lt;&gt;(endEntityProfileSession.getAuthorizedEndEntityProfileIds(authenticationToken, AccessRulesConstants.VIEW_END_ENTITY));</span>
<span class="nc" id="L1063">        final boolean accessAnyEepAvailable = authorizedEepIds.containsAll(endEntityProfileSession.getEndEntityProfileIdToNameMap().keySet());</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        if (!request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1065">            authorizedEepIds.retainAll(request.getEepIds());</span>
        }
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if (authorizedEepIds.isEmpty()) {</span>
            // Empty response since there were no authorized End Entity Profiles
<span class="nc bnc" id="L1069" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1070">                log.debug(&quot;Client '&quot;+authenticationToken+&quot;' was not authorized to any of the requested EEPs and the search request will be dropped.&quot;);</span>
            }
<span class="nc" id="L1072">            return response;</span>
        }
        // If we have access to the EMPTY profile, then allow viewing certificates with zero/null profile IDs, so they can at least be revoked
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (authorizedEepIds.contains(EndEntityConstants.EMPTY_END_ENTITY_PROFILE)) {</span>
<span class="nc" id="L1076">            authorizedEepIds.add(EndEntityConstants.NO_END_ENTITY_PROFILE);</span>
<span class="nc" id="L1077">            authorizedCpIds.add(CertificateProfileConstants.NO_CERTIFICATE_PROFILE);</span>
        }
<span class="nc" id="L1079">        final String subjectDnSearchString = request.getSubjectDnSearchString();</span>
<span class="nc" id="L1080">        final String subjectAnSearchString = request.getSubjectAnSearchString();</span>
<span class="nc" id="L1081">        final String usernameSearchString = request.getUsernameSearchString();</span>
<span class="nc" id="L1082">        final String serialNumberSearchStringFromDec = request.getSerialNumberSearchStringFromDec();</span>
<span class="nc" id="L1083">        final String serialNumberSearchStringFromHex = request.getSerialNumberSearchStringFromHex();</span>
<span class="nc" id="L1084">        final StringBuilder sb = new StringBuilder(&quot;SELECT a.fingerprint FROM CertificateData a WHERE (a.issuerDN IN (:issuerDN))&quot;);</span>
<span class="nc bnc" id="L1085" title="All 6 branches missed.">        if (!subjectDnSearchString.isEmpty() || !subjectAnSearchString.isEmpty() || !usernameSearchString.isEmpty() ||</span>
<span class="nc bnc" id="L1086" title="All 4 branches missed.">                !serialNumberSearchStringFromDec.isEmpty() || !serialNumberSearchStringFromHex.isEmpty()) {</span>
<span class="nc" id="L1087">            sb.append(&quot; AND (&quot;);</span>
<span class="nc" id="L1088">            boolean firstAppended = false;</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (!subjectDnSearchString.isEmpty()) {</span>
<span class="nc" id="L1090">                sb.append(&quot;UPPER(a.subjectDN) LIKE :subjectDN&quot;);</span>
<span class="nc" id="L1091">                firstAppended = true;</span>
            }
<span class="nc bnc" id="L1093" title="All 2 branches missed.">            if (!subjectAnSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">                if (firstAppended) {</span>
<span class="nc" id="L1095">                    sb.append(&quot; OR &quot;);</span>
                } else {
<span class="nc" id="L1097">                    firstAppended = true;</span>
                }
<span class="nc" id="L1099">                sb.append(&quot;a.subjectAltName LIKE :subjectAltName&quot;);</span>
            }
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            if (!usernameSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                if (firstAppended) {</span>
<span class="nc" id="L1103">                    sb.append(&quot; OR &quot;);</span>
                } else {
<span class="nc" id="L1105">                    firstAppended = true;</span>
                }
<span class="nc" id="L1107">                sb.append(&quot;UPPER(a.username) LIKE :username&quot;);</span>
            }
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            if (!serialNumberSearchStringFromDec.isEmpty()) {</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                if (firstAppended) {</span>
<span class="nc" id="L1111">                    sb.append(&quot; OR &quot;);</span>
                } else {
<span class="nc" id="L1113">                    firstAppended = true;</span>
                }
<span class="nc" id="L1115">                sb.append(&quot;a.serialNumber LIKE :serialNumberDec&quot;);</span>
            }
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if (!serialNumberSearchStringFromHex.isEmpty()) {</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                if (firstAppended) {</span>
<span class="nc" id="L1119">                    sb.append(&quot; OR &quot;);</span>
                }
<span class="nc" id="L1121">                sb.append(&quot;a.serialNumber LIKE :serialNumberHex&quot;);</span>
            }
<span class="nc" id="L1123">            sb.append(&quot;)&quot;);</span>
        }
        // NOTE: notBefore is not indexed.. we might want to disallow such search.
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (request.isIssuedAfterUsed()) {</span>
<span class="nc" id="L1127">            sb.append(&quot; AND (a.notBefore &gt; :issuedAfter)&quot;);</span>
        }
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        if (request.isIssuedBeforeUsed()) {</span>
<span class="nc" id="L1130">            sb.append(&quot; AND (a.notBefore &lt; :issuedBefore)&quot;);</span>
        }
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (request.isExpiresAfterUsed()) {</span>
<span class="nc" id="L1133">            sb.append(&quot; AND (a.expireDate &gt; :expiresAfter)&quot;);</span>
        }
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (request.isExpiresBeforeUsed()) {</span>
<span class="nc" id="L1136">            sb.append(&quot; AND (a.expireDate &lt; :expiresBefore)&quot;);</span>
        }
        // NOTE: revocationDate is not indexed.. we might want to disallow such search.
<span class="nc bnc" id="L1139" title="All 2 branches missed.">        if (request.isRevokedAfterUsed()) {</span>
<span class="nc" id="L1140">            sb.append(&quot; AND (a.revocationDate &gt; :revokedAfter)&quot;);</span>
        }
<span class="nc bnc" id="L1142" title="All 2 branches missed.">        if (request.isRevokedBeforeUsed()) {</span>
<span class="nc" id="L1143">            sb.append(&quot; AND (a.revocationDate &lt; :revokedBefore)&quot;);</span>
        }
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        if (!request.getStatuses().isEmpty()) {</span>
<span class="nc" id="L1146">            sb.append(&quot; AND (a.status IN (:status))&quot;);</span>
<span class="nc bnc" id="L1147" title="All 4 branches missed.">            if ((request.getStatuses().contains(CertificateConstants.CERT_REVOKED) || request.getStatuses().contains(CertificateConstants.CERT_ARCHIVED)) &amp;&amp;</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                    !request.getRevocationReasons().isEmpty()) {</span>
<span class="nc" id="L1149">                sb.append(&quot; AND (a.revocationReason IN (:revocationReason))&quot;);</span>
            }
        }
        // Don't constrain results to certain certificate profiles if root access is available and &quot;any&quot; CP is requested
<span class="nc bnc" id="L1153" title="All 4 branches missed.">        if (!accessAnyCpAvailable || !request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1154">            sb.append(&quot; AND (a.certificateProfileId IN (:certificateProfileId))&quot;);</span>
        }
        // Don't constrain results to certain end entity profiles if root access is available and &quot;any&quot; EEP is requested
<span class="nc bnc" id="L1157" title="All 4 branches missed.">        if (!accessAnyEepAvailable || !request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1158">            sb.append(&quot; AND (a.endEntityProfileId IN (:endEntityProfileId))&quot;);</span>
        }
<span class="nc" id="L1160">        final Query query = entityManager.createQuery(sb.toString());</span>
<span class="nc" id="L1161">        query.setParameter(&quot;issuerDN&quot;, issuerDns);</span>
<span class="nc bnc" id="L1162" title="All 4 branches missed.">        if (!accessAnyCpAvailable || !request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1163">            query.setParameter(&quot;certificateProfileId&quot;, authorizedCpIds);</span>
        }
<span class="nc bnc" id="L1165" title="All 4 branches missed.">        if (!accessAnyEepAvailable || !request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1166">            query.setParameter(&quot;endEntityProfileId&quot;, authorizedEepIds);</span>
        }
<span class="nc bnc" id="L1168" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1169">            log.debug(&quot; issuerDN: &quot; + Arrays.toString(issuerDns.toArray()));</span>
<span class="nc bnc" id="L1170" title="All 4 branches missed.">            if (!accessAnyCpAvailable || !request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1171">                log.debug(&quot; certificateProfileId: &quot; + Arrays.toString(authorizedCpIds.toArray()));</span>
            } else {
<span class="nc" id="L1173">                log.debug(&quot; certificateProfileId: Any (even deleted) profile(s) due to root access.&quot;);</span>
            }
<span class="nc bnc" id="L1175" title="All 4 branches missed.">            if (!accessAnyEepAvailable || !request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1176">                log.debug(&quot; endEntityProfileId: &quot; + Arrays.toString(authorizedEepIds.toArray()));</span>
            } else {
<span class="nc" id="L1178">                log.debug(&quot; endEntityProfileId: Any (even deleted) profile(s) due to root access.&quot;);</span>
            }
        }
<span class="nc bnc" id="L1181" title="All 2 branches missed.">        if (!subjectDnSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            if (request.isSubjectDnSearchExact()) {</span>
<span class="nc" id="L1183">                query.setParameter(&quot;subjectDN&quot;, subjectDnSearchString.toUpperCase());</span>
            } else {
<span class="nc" id="L1185">                query.setParameter(&quot;subjectDN&quot;, &quot;%&quot; + subjectDnSearchString.toUpperCase() + &quot;%&quot;);</span>
            }
        }
<span class="nc bnc" id="L1188" title="All 2 branches missed.">        if (!subjectAnSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (request.isSubjectAnSearchExact()) {</span>
<span class="nc" id="L1190">                query.setParameter(&quot;subjectAltName&quot;, subjectAnSearchString);</span>
            } else {
<span class="nc" id="L1192">                query.setParameter(&quot;subjectAltName&quot;, &quot;%&quot; + subjectAnSearchString + &quot;%&quot;);</span>
            }
        }
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        if (!usernameSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            if (request.isUsernameSearchExact()) {</span>
<span class="nc" id="L1197">                query.setParameter(&quot;username&quot;, usernameSearchString.toUpperCase());</span>
            } else {
<span class="nc" id="L1199">                query.setParameter(&quot;username&quot;, &quot;%&quot; + usernameSearchString.toUpperCase() + &quot;%&quot;);</span>
            }
        }
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        if (!serialNumberSearchStringFromDec.isEmpty()) {</span>
<span class="nc" id="L1203">            query.setParameter(&quot;serialNumberDec&quot;, serialNumberSearchStringFromDec);</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1205">                log.debug(&quot; serialNumberDec: &quot; + serialNumberSearchStringFromDec);</span>
            }
        }
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        if (!serialNumberSearchStringFromHex.isEmpty()) {</span>
<span class="nc" id="L1209">            query.setParameter(&quot;serialNumberHex&quot;, serialNumberSearchStringFromHex);</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1211">                log.debug(&quot; serialNumberHex: &quot; + serialNumberSearchStringFromHex);</span>
            }
        }
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        if (request.isIssuedAfterUsed()) {</span>
<span class="nc" id="L1215">            query.setParameter(&quot;issuedAfter&quot;, request.getIssuedAfter());</span>
        }
<span class="nc bnc" id="L1217" title="All 2 branches missed.">        if (request.isIssuedBeforeUsed()) {</span>
<span class="nc" id="L1218">            query.setParameter(&quot;issuedBefore&quot;, request.getIssuedBefore());</span>
        }
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (request.isExpiresAfterUsed()) {</span>
<span class="nc" id="L1221">            query.setParameter(&quot;expiresAfter&quot;, request.getExpiresAfter());</span>
        }
<span class="nc bnc" id="L1223" title="All 2 branches missed.">        if (request.isExpiresBeforeUsed()) {</span>
<span class="nc" id="L1224">            query.setParameter(&quot;expiresBefore&quot;, request.getExpiresBefore());</span>
        }
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        if (request.isRevokedAfterUsed()) {</span>
<span class="nc" id="L1227">            query.setParameter(&quot;revokedAfter&quot;, request.getRevokedAfter());</span>
        }
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (request.isRevokedBeforeUsed()) {</span>
<span class="nc" id="L1230">            query.setParameter(&quot;revokedBefore&quot;, request.getRevokedBefore());</span>
        }
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (!request.getStatuses().isEmpty()) {</span>
<span class="nc" id="L1233">            query.setParameter(&quot;status&quot;, request.getStatuses());</span>
<span class="nc bnc" id="L1234" title="All 4 branches missed.">            if ((request.getStatuses().contains(CertificateConstants.CERT_REVOKED) || request.getStatuses().contains(CertificateConstants.CERT_ARCHIVED)) &amp;&amp;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">                    !request.getRevocationReasons().isEmpty()) {</span>
<span class="nc" id="L1236">                query.setParameter(&quot;revocationReason&quot;, request.getRevocationReasons());</span>
            }
        }
<span class="nc" id="L1239">        final int maxResults = Math.min(getGlobalCesecoreConfiguration().getMaximumQueryCount(), request.getMaxResults());</span>
<span class="nc" id="L1240">        final int offset = request.getPageNumber() * maxResults;</span>
<span class="nc" id="L1241">        query.setMaxResults(maxResults);</span>
<span class="nc" id="L1242">        query.setFirstResult(offset);</span>

        /* Try to use the non-portable hint (depends on DB and JDBC driver) to specify how long in milliseconds the query may run. Possible behaviors:
         * - The hint is ignored
         * - A QueryTimeoutException is thrown
         * - A PersistenceException is thrown (and the transaction which don't have here is marked for roll-back)
         */
<span class="nc" id="L1249">        final long queryTimeout = getGlobalCesecoreConfiguration().getMaximumQueryTimeout();</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        if (queryTimeout&gt;0L) {</span>
<span class="nc" id="L1251">            query.setHint(&quot;javax.persistence.query.timeout&quot;, String.valueOf(queryTimeout));</span>
        }
        final List&lt;String&gt; fingerprints;
        try {
<span class="nc" id="L1255">            fingerprints = query.getResultList();</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">            for (final String fingerprint : fingerprints) {</span>
<span class="nc" id="L1257">                response.getCdws().add(certificateStoreSession.getCertificateData(fingerprint));</span>
<span class="nc" id="L1258">            }</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">            response.setMightHaveMoreResults(fingerprints.size()==maxResults);</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1261">                log.debug(&quot;Certificate search query: &quot; + sb.toString() + &quot; LIMIT &quot; + maxResults + &quot; \u2192 &quot; + fingerprints.size() + &quot; results. queryTimeout=&quot; + queryTimeout + &quot;ms&quot;);</span>
            }
<span class="nc" id="L1263">        } catch (QueryTimeoutException e) {</span>
            // Query.toString() does not return the SQL query executed just a java object hash. If Hibernate is being used we can get it using:
            // query.unwrap(org.hibernate.Query.class).getQueryString()
            // We don't have access to hibernate when building this class though, all querying should be moved to the ejbca-entity package.
            // See ECA-5341
<span class="nc" id="L1268">            final Query q = e.getQuery();</span>
<span class="nc" id="L1269">            String queryString = null;</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">            if (q != null) {</span>
<span class="nc" id="L1271">                queryString = q.toString();</span>
            }
//            try {
//                queryString = e.getQuery().unwrap(org.hibernate.Query.class).getQueryString();
//            } catch (PersistenceException pe) {
//                log.debug(&quot;Query.unwrap(org.hibernate.Query.class) is not supported by JPA provider&quot;);
//            }
<span class="nc" id="L1278">            log.info(&quot;Requested search query by &quot; + authenticationToken +  &quot; took too long. Query was '&quot; + queryString + &quot;'. &quot; + e.getMessage());</span>
<span class="nc" id="L1279">            response.setMightHaveMoreResults(true);</span>
<span class="nc" id="L1280">        } catch (PersistenceException e) {</span>
<span class="nc" id="L1281">            log.info(&quot;Requested search query by &quot; + authenticationToken +  &quot; failed, possibly due to timeout. &quot; + e.getMessage());</span>
<span class="nc" id="L1282">            response.setMightHaveMoreResults(true);</span>
<span class="nc" id="L1283">        }</span>
<span class="nc" id="L1284">        return response;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public RaEndEntitySearchResponse searchForEndEntities(AuthenticationToken authenticationToken, RaEndEntitySearchRequest request) {
<span class="nc" id="L1290">        final RaEndEntitySearchResponse response = new RaEndEntitySearchResponse();</span>
<span class="nc" id="L1291">        final List&lt;Integer&gt; authorizedLocalCaIds = new ArrayList&lt;&gt;(caSession.getAuthorizedCaIds(authenticationToken));</span>
        // Only search a subset of the requested CAs if requested
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (!request.getCaIds().isEmpty()) {</span>
<span class="nc" id="L1294">            authorizedLocalCaIds.retainAll(request.getCaIds());</span>
        }
<span class="nc bnc" id="L1296" title="All 2 branches missed.">        if (authorizedLocalCaIds.isEmpty()) {</span>
            // Empty response since there were no authorized CAs
<span class="nc bnc" id="L1298" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1299">                log.debug(&quot;Client '&quot;+authenticationToken+&quot;' was not authorized to any of the requested CAs and the search request will be dropped.&quot;);</span>
            }
<span class="nc" id="L1301">            return response;</span>
        }
        // Check Certificate Profile authorization
<span class="nc" id="L1304">        final List&lt;Integer&gt; authorizedCpIds = new ArrayList&lt;&gt;(certificateProfileSession.getAuthorizedCertificateProfileIds(authenticationToken, 0));</span>
<span class="nc" id="L1305">        final boolean accessAnyCpAvailable = authorizedCpIds.containsAll(certificateProfileSession.getCertificateProfileIdToNameMap().keySet());</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">        if (!request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1307">            authorizedCpIds.retainAll(request.getCpIds());</span>
        }
<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if (authorizedCpIds.isEmpty()) {</span>
            // Empty response since there were no authorized Certificate Profiles
<span class="nc bnc" id="L1311" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1312">                log.debug(&quot;Client '&quot;+authenticationToken+&quot;' was not authorized to any of the requested CPs and the search request will be dropped.&quot;);</span>
            }
<span class="nc" id="L1314">            return response;</span>
        }
        // Check End Entity Profile authorization
<span class="nc" id="L1317">        final Collection&lt;Integer&gt; authorizedEepIds = new ArrayList&lt;&gt;(endEntityProfileSession.getAuthorizedEndEntityProfileIds(authenticationToken, AccessRulesConstants.VIEW_END_ENTITY));</span>
<span class="nc" id="L1318">        final boolean accessAnyEepAvailable = authorizedEepIds.containsAll(endEntityProfileSession.getEndEntityProfileIdToNameMap().keySet());</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">        if (!request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1320">            authorizedEepIds.retainAll(request.getEepIds());</span>
        }
<span class="nc bnc" id="L1322" title="All 2 branches missed.">        if (authorizedEepIds.isEmpty()) {</span>
            // Empty response since there were no authorized End Entity Profiles
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1325">                log.debug(&quot;Client '&quot;+authenticationToken+&quot;' was not authorized to any of the requested EEPs and the search request will be dropped.&quot;);</span>
            }
<span class="nc" id="L1327">            return response;</span>
        }
<span class="nc" id="L1329">        final String subjectDnSearchString = request.getSubjectDnSearchString();</span>
<span class="nc" id="L1330">        final String subjectAnSearchString = request.getSubjectAnSearchString();</span>
<span class="nc" id="L1331">        final String usernameSearchString = request.getUsernameSearchString();</span>
<span class="nc" id="L1332">        final StringBuilder sb = new StringBuilder(&quot;SELECT a.username FROM UserData a WHERE (a.caId IN (:caId))&quot;);</span>
<span class="nc bnc" id="L1333" title="All 6 branches missed.">        if (!subjectDnSearchString.isEmpty() || !subjectAnSearchString.isEmpty() || !usernameSearchString.isEmpty()) {</span>
<span class="nc" id="L1334">            sb.append(&quot; AND (&quot;);</span>
<span class="nc" id="L1335">            boolean firstAppended = false;</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">            if (!subjectDnSearchString.isEmpty()) {</span>
<span class="nc" id="L1337">                sb.append(&quot;UPPER(a.subjectDN) LIKE :subjectDN&quot;);</span>
<span class="nc" id="L1338">                firstAppended = true;</span>
            }
<span class="nc bnc" id="L1340" title="All 2 branches missed.">            if (!subjectAnSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">                if (firstAppended) {</span>
<span class="nc" id="L1342">                    sb.append(&quot; OR &quot;);</span>
                } else {
<span class="nc" id="L1344">                    firstAppended = true;</span>
                }
<span class="nc" id="L1346">                sb.append(&quot;a.subjectAltName LIKE :subjectAltName&quot;);</span>
            }
<span class="nc bnc" id="L1348" title="All 2 branches missed.">            if (!usernameSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">                if (firstAppended) {</span>
<span class="nc" id="L1350">                    sb.append(&quot; OR &quot;);</span>
                } else {
<span class="nc" id="L1352">                    firstAppended = true;</span>
                }
<span class="nc" id="L1354">                sb.append(&quot;UPPER(a.username) LIKE :username&quot;);</span>
            }
<span class="nc" id="L1356">            sb.append(&quot;)&quot;);</span>
        }

<span class="nc bnc" id="L1359" title="All 2 branches missed.">        if (request.isModifiedAfterUsed()) {</span>
<span class="nc" id="L1360">            sb.append(&quot; AND (a.timeModified &gt; :modifiedAfter)&quot;);</span>
        }
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        if (request.isModifiedBeforeUsed()) {</span>
<span class="nc" id="L1363">            sb.append(&quot; AND (a.timeModified &lt; :modifiedBefore)&quot;);</span>
        }
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        if (!request.getStatuses().isEmpty()) {</span>
<span class="nc" id="L1366">            sb.append(&quot; AND (a.status IN (:status))&quot;);</span>
        }
        // Don't constrain results to certain end entity profiles if root access is available and &quot;any&quot; CP is requested
<span class="nc bnc" id="L1369" title="All 4 branches missed.">        if (!accessAnyCpAvailable || !request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1370">            sb.append(&quot; AND (a.certificateProfileId IN (:certificateProfileId))&quot;);</span>
        }
        // Don't constrain results to certain end entity profiles if root access is available and &quot;any&quot; EEP is requested
<span class="nc bnc" id="L1373" title="All 4 branches missed.">        if (!accessAnyEepAvailable || !request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1374">            sb.append(&quot; AND (a.endEntityProfileId IN (:endEntityProfileId))&quot;);</span>
        }
<span class="nc" id="L1376">        final Query query = entityManager.createQuery(sb.toString());</span>
<span class="nc" id="L1377">        query.setParameter(&quot;caId&quot;, authorizedLocalCaIds);</span>
<span class="nc bnc" id="L1378" title="All 4 branches missed.">        if (!accessAnyCpAvailable || !request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1379">            query.setParameter(&quot;certificateProfileId&quot;, authorizedCpIds);</span>
        }
<span class="nc bnc" id="L1381" title="All 4 branches missed.">        if (!accessAnyEepAvailable || !request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1382">            query.setParameter(&quot;endEntityProfileId&quot;, authorizedEepIds);</span>
        }
<span class="nc bnc" id="L1384" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1385">            log.debug(&quot; CA IDs: &quot; + Arrays.toString(authorizedLocalCaIds.toArray()));</span>
<span class="nc bnc" id="L1386" title="All 4 branches missed.">            if (!accessAnyCpAvailable || !request.getCpIds().isEmpty()) {</span>
<span class="nc" id="L1387">                log.debug(&quot; certificateProfileId: &quot; + Arrays.toString(authorizedCpIds.toArray()));</span>
            } else {
<span class="nc" id="L1389">                log.debug(&quot; certificateProfileId: Any (even deleted) profile(s) due to root access.&quot;);</span>
            }
<span class="nc bnc" id="L1391" title="All 4 branches missed.">            if (!accessAnyEepAvailable || !request.getEepIds().isEmpty()) {</span>
<span class="nc" id="L1392">                log.debug(&quot; endEntityProfileId: &quot; + Arrays.toString(authorizedEepIds.toArray()));</span>
            } else {
<span class="nc" id="L1394">                log.debug(&quot; endEntityProfileId: Any (even deleted) profile(s) due to root access.&quot;);</span>
            }
        }
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (!subjectDnSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">            if (request.isSubjectDnSearchExact()) {</span>
<span class="nc" id="L1399">                query.setParameter(&quot;subjectDN&quot;, subjectDnSearchString.toUpperCase());</span>
            } else {
<span class="nc" id="L1401">                query.setParameter(&quot;subjectDN&quot;, &quot;%&quot; + subjectDnSearchString.toUpperCase() + &quot;%&quot;);</span>
            }
        }
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        if (!subjectAnSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">            if (request.isSubjectAnSearchExact()) {</span>
<span class="nc" id="L1406">                query.setParameter(&quot;subjectAltName&quot;, subjectAnSearchString);</span>
            } else {
<span class="nc" id="L1408">                query.setParameter(&quot;subjectAltName&quot;, &quot;%&quot; + subjectAnSearchString + &quot;%&quot;);</span>
            }
        }
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        if (!usernameSearchString.isEmpty()) {</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">            if (request.isUsernameSearchExact()) {</span>
<span class="nc" id="L1413">                query.setParameter(&quot;username&quot;, usernameSearchString.toUpperCase());</span>
            } else {
<span class="nc" id="L1415">                query.setParameter(&quot;username&quot;, &quot;%&quot; + usernameSearchString.toUpperCase() + &quot;%&quot;);</span>
            }
        }
<span class="nc bnc" id="L1418" title="All 2 branches missed.">        if (request.isModifiedAfterUsed()) {</span>
<span class="nc" id="L1419">            query.setParameter(&quot;modifiedAfter&quot;, request.getModifiedAfter());</span>
        }
<span class="nc bnc" id="L1421" title="All 2 branches missed.">        if (request.isModifiedBeforeUsed()) {</span>
<span class="nc" id="L1422">            query.setParameter(&quot;modifiedBefore&quot;, request.getModifiedBefore());</span>
        }
<span class="nc bnc" id="L1424" title="All 2 branches missed.">        if (!request.getStatuses().isEmpty()) {</span>
<span class="nc" id="L1425">            query.setParameter(&quot;status&quot;, request.getStatuses());</span>
        }
<span class="nc" id="L1427">        final int maxResults = Math.min(getGlobalCesecoreConfiguration().getMaximumQueryCount(), request.getMaxResults());</span>
<span class="nc" id="L1428">        final int offset = maxResults * request.getPageNumber();</span>
<span class="nc" id="L1429">        query.setMaxResults(maxResults);</span>
<span class="nc" id="L1430">        query.setFirstResult(offset);</span>
        /* Try to use the non-portable hint (depends on DB and JDBC driver) to specify how long in milliseconds the query may run. Possible behaviors:
         * - The hint is ignored
         * - A QueryTimeoutException is thrown
         * - A PersistenceException is thrown (and the transaction which don't have here is marked for roll-back)
         */
<span class="nc" id="L1436">        final long queryTimeout = getGlobalCesecoreConfiguration().getMaximumQueryTimeout();</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">        if (queryTimeout&gt;0L) {</span>
<span class="nc" id="L1438">            query.setHint(&quot;javax.persistence.query.timeout&quot;, String.valueOf(queryTimeout));</span>
        }
        final List&lt;String&gt; usernames;
        try {
<span class="nc" id="L1442">            usernames = query.getResultList();</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">            for (final String username : usernames) {</span>
<span class="nc" id="L1444">                response.getEndEntities().add(endEntityAccessSession.findUser(username));</span>
<span class="nc" id="L1445">            }</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">            response.setMightHaveMoreResults(usernames.size()==maxResults);</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1448">                log.debug(&quot;Certificate search query: &quot; + sb.toString() + &quot; LIMIT &quot; + maxResults + &quot; \u2192 &quot; + usernames.size() + &quot; results. queryTimeout=&quot; + queryTimeout + &quot;ms&quot;);</span>
            }
<span class="nc" id="L1450">        } catch (QueryTimeoutException e) {</span>
<span class="nc" id="L1451">            log.info(&quot;Requested search query by &quot; + authenticationToken +  &quot; took too long. Query was &quot; + e.getQuery().toString() + &quot;. &quot; + e.getMessage());</span>
<span class="nc" id="L1452">            response.setMightHaveMoreResults(true);</span>
<span class="nc" id="L1453">        } catch (PersistenceException e) {</span>
<span class="nc" id="L1454">            log.info(&quot;Requested search query by &quot; + authenticationToken +  &quot; failed, possibly due to timeout. &quot; + e.getMessage());</span>
<span class="nc" id="L1455">            response.setMightHaveMoreResults(true);</span>
<span class="nc" id="L1456">        }</span>
<span class="nc" id="L1457">        return response;</span>
    }

    @Override
    public RaRoleSearchResponse searchForRoles(AuthenticationToken authenticationToken, RaRoleSearchRequest request) {
        // TODO optimize this (ECA-5721), should filter with a database query
<span class="nc" id="L1463">        final List&lt;Role&gt; authorizedRoles = getAuthorizedRoles(authenticationToken);</span>
<span class="nc" id="L1464">        final RaRoleSearchResponse searchResponse = new RaRoleSearchResponse();</span>
<span class="nc" id="L1465">        final String searchString = request.getGenericSearchString();</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">        for (final Role role : authorizedRoles) {</span>
<span class="nc bnc" id="L1467" title="All 4 branches missed.">            if (searchString == null || StringUtils.containsIgnoreCase(role.getRoleName(), searchString) ||</span>
<span class="nc bnc" id="L1468" title="All 4 branches missed.">                    (role.getNameSpace() != null &amp;&amp; StringUtils.containsIgnoreCase(role.getNameSpace(), searchString))) {</span>
<span class="nc" id="L1469">                searchResponse.getRoles().add(role);</span>
            }
<span class="nc" id="L1471">        }</span>
<span class="nc" id="L1472">        return searchResponse;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public RaRoleMemberSearchResponse searchForRoleMembers(AuthenticationToken authenticationToken, RaRoleMemberSearchRequest request) {
<span class="nc" id="L1478">        final RaRoleMemberSearchResponse response = new RaRoleMemberSearchResponse();</span>

<span class="nc" id="L1480">        final List&lt;Integer&gt; authorizedLocalCaIds = new ArrayList&lt;&gt;(caSession.getAuthorizedCaIds(authenticationToken));</span>
<span class="nc" id="L1481">        authorizedLocalCaIds.add(RoleMember.NO_ISSUER);</span>
        // Only search a subset of the requested CAs if requested
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        if (!request.getCaIds().isEmpty()) {</span>
<span class="nc" id="L1484">            authorizedLocalCaIds.retainAll(request.getCaIds());</span>
        }

        // Dito for roles
<span class="nc" id="L1488">        final List&lt;Integer&gt; authorizedLocalRoleIds = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">        for (final Role role : roleSession.getAuthorizedRoles(authenticationToken)) {</span>
<span class="nc" id="L1490">            final int roleId = role.getRoleId();</span>
<span class="nc bnc" id="L1491" title="All 4 branches missed.">            if (request.getRoleIds().isEmpty() || request.getRoleIds().contains(roleId)) {</span>
<span class="nc" id="L1492">                authorizedLocalRoleIds.add(roleId);</span>
            }
<span class="nc" id="L1494">        }</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        if (request.getRoleIds().contains(RoleMember.NO_ROLE)) {</span>
<span class="nc" id="L1496">            authorizedLocalRoleIds.add(RoleMember.NO_ROLE);</span>
        }

        // Token types
<span class="nc" id="L1500">        final List&lt;String&gt; authorizedLocalTokenTypes = new ArrayList&lt;&gt;(getAvailableRoleMemberTokenTypes(authenticationToken).keySet());</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">        if (!request.getTokenTypes().isEmpty()) {</span>
<span class="nc" id="L1502">            authorizedLocalTokenTypes.retainAll(request.getTokenTypes());</span>
        }

<span class="nc bnc" id="L1505" title="All 2 branches missed.">        if (authorizedLocalCaIds.isEmpty()) {</span>
<span class="nc" id="L1506">            log.debug(&quot;No authorized CAs found for cleint &quot; + authenticationToken + &quot;. Returning empty response in role member search&quot;);</span>
<span class="nc" id="L1507">            return response;</span>
        }
<span class="nc bnc" id="L1509" title="All 2 branches missed.">        if (authorizedLocalRoleIds.isEmpty()) {</span>
<span class="nc" id="L1510">            log.debug(&quot;No authorized Roles found for cleint &quot; + authenticationToken + &quot; Returning empty response in role member search&quot;);</span>
<span class="nc" id="L1511">            return response;</span>
        }
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (authorizedLocalTokenTypes.isEmpty()) {</span>
<span class="nc" id="L1514">            log.debug(&quot;No authorized token types found for cleint &quot; + authenticationToken + &quot; Returning empty response in role member search&quot;);</span>
<span class="nc" id="L1515">            return response;</span>
        }

        // Build query
<span class="nc" id="L1519">        final StringBuilder sb = new StringBuilder(&quot;SELECT a FROM RoleMemberData a WHERE a.tokenIssuerId IN (:caId) AND a.roleId IN (:roleId) AND a.tokenType IN (:tokenType)&quot;);</span>
        // TODO only search by exact tokenMatchValue if it seems to be a serial number?
<span class="nc bnc" id="L1521" title="All 2 branches missed.">        if (!StringUtils.isEmpty(request.getGenericSearchString())) {</span>
<span class="nc" id="L1522">            sb.append(&quot; AND (a.tokenMatchValueColumn LIKE :searchStringInexact OR a.descriptionColumn LIKE :searchStringInexact)&quot;);</span>
        }
<span class="nc" id="L1524">        final Query query = entityManager.createQuery(sb.toString());</span>
<span class="nc" id="L1525">        query.setParameter(&quot;caId&quot;, authorizedLocalCaIds);</span>
<span class="nc" id="L1526">        query.setParameter(&quot;roleId&quot;, authorizedLocalRoleIds);</span>
<span class="nc" id="L1527">        query.setParameter(&quot;tokenType&quot;, authorizedLocalTokenTypes);</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        if (!StringUtils.isEmpty(request.getGenericSearchString())) {</span>
            //query.setParameter(&quot;searchString&quot;, request.getGenericSearchString());
<span class="nc" id="L1530">            query.setParameter(&quot;searchStringInexact&quot;, request.getGenericSearchString() + '%');</span>
        }

<span class="nc" id="L1533">        final int maxResults = getGlobalCesecoreConfiguration().getMaximumQueryCount();</span>
<span class="nc" id="L1534">        query.setMaxResults(maxResults);</span>
<span class="nc" id="L1535">        final long queryTimeout = getGlobalCesecoreConfiguration().getMaximumQueryTimeout();</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">        if (queryTimeout&gt;0L) {</span>
<span class="nc" id="L1537">            query.setHint(&quot;javax.persistence.query.timeout&quot;, String.valueOf(queryTimeout));</span>
        }

        // Execute
        try {
<span class="nc" id="L1542">            final List&lt;RoleMemberData&gt; roleMemberDatas = query.getResultList();</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">            for (final RoleMemberData roleMemberData : roleMemberDatas) {</span>
<span class="nc" id="L1544">                response.getRoleMembers().add(roleMemberData.asValueObject());</span>
<span class="nc" id="L1545">            }</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">            response.setMightHaveMoreResults(roleMemberDatas.size()==maxResults);</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1548">                log.debug(&quot;Role Member search query: &quot; + sb.toString() + &quot; LIMIT &quot; + maxResults + &quot; \u2192 &quot; + roleMemberDatas.size() + &quot; results. queryTimeout=&quot; + queryTimeout + &quot;ms&quot;);</span>
            }
<span class="nc" id="L1550">        } catch (QueryTimeoutException e) {</span>
<span class="nc" id="L1551">            log.info(&quot;Requested search query by &quot; + authenticationToken +  &quot; took too long. Query was &quot; + e.getQuery().toString() + &quot;. &quot; + e.getMessage());</span>
<span class="nc" id="L1552">            response.setMightHaveMoreResults(true);</span>
<span class="nc" id="L1553">        } catch (PersistenceException e) {</span>
<span class="nc" id="L1554">            log.info(&quot;Requested search query by &quot; + authenticationToken +  &quot; failed, possibly due to timeout. &quot; + e.getMessage());</span>
<span class="nc" id="L1555">            response.setMightHaveMoreResults(true);</span>
<span class="nc" id="L1556">        }</span>
<span class="nc" id="L1557">        return response;</span>
    }

    @Override
    public Map&lt;Integer, String&gt; getAuthorizedEndEntityProfileIdsToNameMap(AuthenticationToken authenticationToken) {
<span class="nc" id="L1562">        final Collection&lt;Integer&gt; authorizedEepIds = endEntityProfileSession.getAuthorizedEndEntityProfileIds(authenticationToken, AccessRulesConstants.VIEW_END_ENTITY);</span>
<span class="nc" id="L1563">        final Map&lt;Integer, String&gt; idToNameMap = endEntityProfileSession.getEndEntityProfileIdToNameMap();</span>
<span class="nc" id="L1564">        final Map&lt;Integer, String&gt; authorizedIdToNameMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">        for (final Integer eepId : authorizedEepIds) {</span>
<span class="nc" id="L1566">            authorizedIdToNameMap.put(eepId, idToNameMap.get(eepId));</span>
<span class="nc" id="L1567">        }</span>
<span class="nc" id="L1568">        return authorizedIdToNameMap;</span>
    }

    @Override
    public Map&lt;Integer, String&gt; getAuthorizedCertificateProfileIdsToNameMap(AuthenticationToken authenticationToken) {
<span class="nc" id="L1573">        final List&lt;Integer&gt; authorizedCpIds = new ArrayList&lt;&gt;(certificateProfileSession.getAuthorizedCertificateProfileIds(authenticationToken, 0));</span>
        // There is no reason to return a certificate profile if it is not present in one of the authorized EEPs
<span class="nc" id="L1575">        final Collection&lt;Integer&gt; authorizedEepIds = endEntityProfileSession.getAuthorizedEndEntityProfileIds(authenticationToken, AccessRulesConstants.VIEW_END_ENTITY);</span>
<span class="nc" id="L1576">        final Set&lt;Integer&gt; cpIdsInAuthorizedEeps = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        for (final Integer eepId : authorizedEepIds) {</span>
<span class="nc" id="L1578">            final EndEntityProfile eep = endEntityProfileSession.getEndEntityProfile(eepId);</span>
<span class="nc" id="L1579">            cpIdsInAuthorizedEeps.addAll(eep.getAvailableCertificateProfileIds());</span>
<span class="nc" id="L1580">        }</span>
<span class="nc" id="L1581">        authorizedCpIds.retainAll(cpIdsInAuthorizedEeps);</span>
<span class="nc" id="L1582">        final Map&lt;Integer, String&gt; idToNameMap = certificateProfileSession.getCertificateProfileIdToNameMap();</span>
<span class="nc" id="L1583">        final Map&lt;Integer, String&gt; authorizedIdToNameMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">        for (final Integer cpId : authorizedCpIds) {</span>
<span class="nc" id="L1585">            authorizedIdToNameMap.put(cpId, idToNameMap.get(cpId));</span>
<span class="nc" id="L1586">        }</span>
<span class="nc" id="L1587">        return authorizedIdToNameMap;</span>
    }

    @Override
    public IdNameHashMap&lt;EndEntityProfile&gt; getAuthorizedEndEntityProfiles(final AuthenticationToken authenticationToken, final String endEntityAccessRule) {
<span class="nc" id="L1592">        Collection&lt;Integer&gt; ids = endEntityProfileSession.getAuthorizedEndEntityProfileIds(authenticationToken, endEntityAccessRule);</span>
<span class="nc" id="L1593">        Map&lt;Integer, String&gt; idToNameMap = endEntityProfileSession.getEndEntityProfileIdToNameMap();</span>
<span class="nc" id="L1594">        IdNameHashMap&lt;EndEntityProfile&gt; authorizedEndEntityProfiles = new IdNameHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">        for (Integer id : ids){</span>
<span class="nc" id="L1596">            authorizedEndEntityProfiles.put(id, idToNameMap.get(id), endEntityProfileSession.getEndEntityProfile(id));</span>
<span class="nc" id="L1597">        }</span>
<span class="nc" id="L1598">        return authorizedEndEntityProfiles;</span>
    }

    @Override
    public IdNameHashMap&lt;CertificateProfile&gt; getAuthorizedCertificateProfiles(AuthenticationToken authenticationToken){
<span class="nc" id="L1603">        IdNameHashMap&lt;CertificateProfile&gt; authorizedCertificateProfiles = new IdNameHashMap&lt;&gt;();</span>
<span class="nc" id="L1604">        List&lt;Integer&gt; authorizedCertificateProfileIds = certificateProfileSession.getAuthorizedCertificateProfileIds(authenticationToken, CertificateConstants.CERTTYPE_ENDENTITY);</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">        for (Integer certificateProfileId : authorizedCertificateProfileIds){</span>
<span class="nc" id="L1606">            CertificateProfile certificateProfile = certificateProfileSession.getCertificateProfile(certificateProfileId);</span>
<span class="nc" id="L1607">            String certificateProfilename = certificateProfileSession.getCertificateProfileName(certificateProfileId);</span>
<span class="nc" id="L1608">            authorizedCertificateProfiles.put(certificateProfileId, certificateProfilename, certificateProfile);</span>
<span class="nc" id="L1609">        }</span>
<span class="nc" id="L1610">        return authorizedCertificateProfiles;</span>
    }

    @Override
    public CertificateProfile getCertificateProfile(int id) {
<span class="nc" id="L1615">        return certificateProfileSession.getCertificateProfile(id);</span>
    }

    @Override
    public IdNameHashMap&lt;CAInfo&gt; getAuthorizedCAInfos(AuthenticationToken authenticationToken) {
<span class="nc" id="L1620">        IdNameHashMap&lt;CAInfo&gt; authorizedCAInfos = new IdNameHashMap&lt;&gt;();</span>
<span class="nc" id="L1621">        List&lt;CAInfo&gt; authorizedCAInfosList = caSession.getAuthorizedAndNonExternalCaInfos(authenticationToken);</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        for (CAInfo caInfo : authorizedCAInfosList){</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">            if (caInfo.getStatus() == CAConstants.CA_ACTIVE) {</span>
<span class="nc" id="L1624">                authorizedCAInfos.put(caInfo.getCAId(), caInfo.getName(), caInfo);</span>
            }
<span class="nc" id="L1626">        }</span>
<span class="nc" id="L1627">        return authorizedCAInfos;</span>
    }

    @Override
    public void checkSubjectDn(final AuthenticationToken admin, final EndEntityInformation endEntity) throws AuthorizationDeniedException, EjbcaException{
<span class="nc" id="L1632">        KeyToValueHolder&lt;CAInfo&gt; caInfoEntry = getAuthorizedCAInfos(admin).get(endEntity.getCAId());</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">        if(caInfoEntry == null) {</span>
<span class="nc" id="L1634">            log.info(&quot;No authorized CAs found for &quot; + admin);</span>
<span class="nc" id="L1635">            return;</span>
        }
        try {
<span class="nc" id="L1638">            certificateCreateSession.assertSubjectEnforcements(caInfoEntry.getValue(), endEntity);</span>
<span class="nc" id="L1639">        } catch (CertificateCreateException e) {</span>
            //Wrapping the CesecoreException.errorCode
<span class="nc" id="L1641">            throw new EjbcaException(e);</span>
<span class="nc" id="L1642">        }</span>
<span class="nc" id="L1643">    }</span>

    @Override
    public boolean addUser(final AuthenticationToken admin, final EndEntityInformation endEntity, final boolean clearpwd) throws AuthorizationDeniedException,
    EjbcaException, WaitingForApprovalException{
        //Authorization
<span class="nc bnc" id="L1649" title="All 2 branches missed.">        if (!endEntityManagementSession.isAuthorizedToEndEntityProfile(admin, endEntity.getEndEntityProfileId(),</span>
                AccessRulesConstants.DELETE_END_ENTITY)) {
<span class="nc" id="L1651">            log.warn(&quot;Missing *&quot; + AccessRulesConstants.DELETE_END_ENTITY + &quot; rights for user '&quot; + admin</span>
                    + &quot;' to be able to add an end entity (Delete is only needed for clean-up if something goes wrong after an end-entity has been added)&quot;);
<span class="nc" id="L1653">            return false;</span>
        }

        try {
<span class="nc" id="L1657">            endEntityManagementSession.addUser(admin, endEntity, clearpwd);</span>
<span class="nc" id="L1658">        } catch (CesecoreException e) {</span>
            //Wrapping the CesecoreException.errorCode
<span class="nc" id="L1660">            throw new EjbcaException(e);</span>
<span class="nc" id="L1661">        } catch (EndEntityProfileValidationException e) {</span>
            //Wraps @WebFault Exception based with @NonSensitive EjbcaException based
<span class="nc" id="L1663">            throw new EndEntityProfileValidationRaException(e);</span>
<span class="nc" id="L1664">        }</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">        return endEntityAccessSession.findUser(endEntity.getUsername()) != null;</span>
    }

    @Override
    public boolean addUserFromWS(final AuthenticationToken admin, UserDataVOWS userDataVOWS, final boolean clearpwd)
            throws AuthorizationDeniedException, EndEntityProfileValidationException, EndEntityExistsException, WaitingForApprovalException,
            CADoesntExistsException, IllegalNameException, CertificateSerialNumberException, EjbcaException {
<span class="nc" id="L1672">        EndEntityInformation endEntityInformation = ejbcaWSHelperSession.convertUserDataVOWS(admin, userDataVOWS);</span>
<span class="nc" id="L1673">        final int profileId = endEntityInformation.getEndEntityProfileId();</span>
<span class="nc" id="L1674">        final EndEntityProfile profile = endEntityProfileSession.getEndEntityProfileNoClone(profileId);</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">        if (profile.getAllowMergeDnWebServices()) {</span>
<span class="nc" id="L1676">            endEntityInformation = EndEntityInformationFiller.fillUserDataWithDefaultValues(endEntityInformation, profile);</span>
        }
<span class="nc" id="L1678">        endEntityManagementSession.addUser(admin, endEntityInformation, clearpwd);</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">        return endEntityAccessSession.findUser(endEntityInformation.getUsername()) != null;</span>
    }


    @Override
    public void deleteUser(final AuthenticationToken admin, final String username) throws AuthorizationDeniedException{
        try {
<span class="nc" id="L1686">            endEntityManagementSession.deleteUser(admin, username);</span>
<span class="nc" id="L1687">        } catch (NoSuchEndEntityException | CouldNotRemoveEndEntityException e) {</span>
<span class="nc" id="L1688">            log.info(e.getMessage());</span>
<span class="nc" id="L1689">        }</span>
<span class="nc" id="L1690">    }</span>

    @Override
    public EndEntityInformation searchUser(final AuthenticationToken admin, String username) {
        try {
<span class="nc" id="L1695">            return endEntityAccessSession.findUser(admin, username);</span>
<span class="nc" id="L1696">        } catch (AuthorizationDeniedException e) {</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1698">                log.debug(&quot;Not authorized to end entity '&quot; + username + &quot;'&quot;);</span>
            }
<span class="nc" id="L1700">            return null;</span>
        }
    }

    @Override
    public void checkUserStatus(AuthenticationToken admin, String username, String password) throws NoSuchEndEntityException, AuthStatusException, AuthLoginException {
<span class="nc" id="L1706">        endEntityAuthenticationSessionLocal.authenticateUser(admin, username, password);</span>
<span class="nc" id="L1707">    }</span>

    @Override
    public void finishUserAfterLocalKeyRecovery(final AuthenticationToken authenticationToken, final String username, final String password) throws AuthorizationDeniedException, EjbcaException {
<span class="nc" id="L1711">        EndEntityInformation userdata = endEntityAccessSession.findUser(username);</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        if (userdata == null) {</span>
<span class="nc" id="L1713">            throw new EjbcaException(ErrorCode.USER_NOT_FOUND, &quot;User '&quot;+username+&quot;' does not exist&quot;);</span>
        }
<span class="nc bnc" id="L1715" title="All 2 branches missed.">        if (userdata.getStatus() != EndEntityConstants.STATUS_KEYRECOVERY) {</span>
<span class="nc" id="L1716">            throw new EjbcaException(ErrorCode.USER_WRONG_STATUS, &quot;User '&quot;+username+&quot;' is not in KEYRECOVERY status&quot;);</span>
        }
        try {
<span class="nc" id="L1719">            final GlobalConfiguration globalConfig = (GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID);</span>
<span class="nc bnc" id="L1720" title="All 2 branches missed.">            if (globalConfig.getEnableEndEntityProfileLimitations()) {</span>
                // Check if administrator is authorized to perform key recovery
<span class="nc" id="L1722">                endEntityManagementSession.isAuthorizedToEndEntityProfile(authenticationToken, userdata.getEndEntityProfileId(), AccessRulesConstants.KEYRECOVERY_RIGHTS);</span>
            }
<span class="nc" id="L1724">            endEntityAuthenticationSessionLocal.authenticateUser(authenticationToken, username, password);</span>
<span class="nc" id="L1725">            final boolean shouldFinishUser = caSession.getCAInfo(authenticationToken, userdata.getCAId()).getFinishUser();</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">            if (shouldFinishUser) {</span>
<span class="nc" id="L1727">                    endEntityAuthenticationSessionLocal.finishUser(userdata);</span>
            }

<span class="nc" id="L1730">            userdata = endEntityAccessSession.findUser(username);</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            if (userdata.getStatus() == EndEntityConstants.STATUS_GENERATED) {</span>
                // We require keyrecovery access. The operation below should not require edit access, so we use an AlwaysAllowLocalAuthenticationToken
<span class="nc" id="L1733">                endEntityManagementSession.setClearTextPassword(new AlwaysAllowLocalAuthenticationToken(</span>
                        new UsernamePrincipal(&quot;Implicit authorization from key recovery operation to reset password.&quot;)), username, null);
            }
<span class="nc" id="L1736">        } catch (NoSuchEndEntityException | EndEntityProfileValidationException e) {</span>
<span class="nc" id="L1737">            throw new IllegalStateException(e);</span>
<span class="nc" id="L1738">        }</span>
<span class="nc" id="L1739">    }</span>

    @Override
    public byte[] generateKeyStore(final AuthenticationToken admin, final EndEntityInformation endEntity) throws AuthorizationDeniedException, EjbcaException {
        KeyStore keyStore;
        try {
<span class="nc" id="L1745">            final EndEntityProfile endEntityProfile = endEntityProfileSession.getEndEntityProfile(endEntity.getEndEntityProfileId());</span>
<span class="nc" id="L1746">            boolean usekeyrecovery = ((GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID)).getEnableKeyRecovery();</span>
<span class="nc" id="L1747">            EndEntityInformation data = endEntityAccessSession.findUser(endEntity.getUsername());</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">            if (data == null) {</span>
<span class="nc" id="L1749">                throw new EjbcaException(ErrorCode.USER_NOT_FOUND, &quot;User '&quot;+endEntity.getUsername()+&quot;' does not exist&quot;);</span>
            }
<span class="nc bnc" id="L1751" title="All 6 branches missed.">            final boolean savekeys = data.getKeyRecoverable() &amp;&amp; usekeyrecovery &amp;&amp; (data.getStatus() != EndEntityConstants.STATUS_KEYRECOVERY);</span>
<span class="nc bnc" id="L1752" title="All 4 branches missed.">            final boolean loadkeys = (data.getStatus() == EndEntityConstants.STATUS_KEYRECOVERY) &amp;&amp; usekeyrecovery;</span>
<span class="nc" id="L1753">            final boolean reusecertificate = endEntityProfile.getReUseKeyRecoveredCertificate();</span>
<span class="nc" id="L1754">            ExtendedInformation ei = endEntity.getExtendedInformation();</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">            if (ei == null) {</span>
                // ExtendedInformation is optional, and we don't want any NPEs here
            	// Make it easy for ourselves and create a default one if there is none in the end entity
<span class="nc" id="L1758">                ei = new ExtendedInformation();</span>
            }
<span class="nc" id="L1760">            final String encodedValidity = ei.getCertificateEndTime();</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">            final Date notAfter = encodedValidity == null ? null : ValidityDate.getDate(encodedValidity, new Date());</span>
<span class="nc" id="L1762">            keyStore = keyStoreCreateSessionLocal.generateOrKeyRecoverToken(admin, // Authentication token</span>
<span class="nc" id="L1763">                    endEntity.getUsername(), // Username</span>
<span class="nc" id="L1764">                    endEntity.getPassword(), // Enrollment code</span>
<span class="nc" id="L1765">                    endEntity.getCAId(), // The CA signing the private keys</span>
<span class="nc" id="L1766">                    ei.getKeyStoreAlgorithmSubType(), // Keylength</span>
<span class="nc" id="L1767">                    ei.getKeyStoreAlgorithmType(), // Signature algorithm</span>
                    null, // Not valid before
                    notAfter, // Not valid after
<span class="nc bnc" id="L1770" title="All 2 branches missed.">                    endEntity.getTokenType() == SecConst.TOKEN_SOFT_JKS, // Type of token</span>
                    loadkeys, // Perform key recovery?
                    savekeys, // Save private keys?
                    reusecertificate, // Reuse recovered cert?
<span class="nc" id="L1774">                    endEntity.getEndEntityProfileId()); // Identifier for end entity</span>
<span class="nc" id="L1775">        } catch (KeyStoreException | InvalidAlgorithmParameterException | CADoesntExistsException | IllegalKeyException</span>
                | CertificateCreateException | IllegalNameException | CertificateRevokeException | CertificateSerialNumberException
                | CryptoTokenOfflineException | IllegalValidityException | CAOfflineException | InvalidAlgorithmException
                | CustomCertificateSerialNumberException | CertificateException | NoSuchAlgorithmException | InvalidKeySpecException
                | EndEntityProfileValidationException | CertificateSignatureException | NoSuchEndEntityException e) {
<span class="nc" id="L1780">            throw new KeyStoreGeneralRaException(e);</span>
<span class="nc" id="L1781">        }</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">        if(endEntity.getTokenType() == EndEntityConstants.TOKEN_SOFT_PEM){</span>
<span class="nc" id="L1783">            try(ByteArrayOutputStream outputStream = new ByteArrayOutputStream()){</span>
<span class="nc" id="L1784">                outputStream.write(KeyTools.getSinglePemFromKeyStore(keyStore, endEntity.getPassword().toCharArray()));</span>
<span class="nc" id="L1785">                return outputStream.toByteArray();</span>
<span class="nc" id="L1786">            } catch (IOException | CertificateEncodingException | UnrecoverableKeyException | KeyStoreException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1787">                log.error(e); //should never happen if keyStore is valid object</span>
<span class="nc" id="L1788">            }</span>
        }else{
<span class="nc" id="L1790">            try(ByteArrayOutputStream outputStream = new ByteArrayOutputStream()){</span>
<span class="nc" id="L1791">                keyStore.store(outputStream, endEntity.getPassword().toCharArray());</span>
<span class="nc" id="L1792">                return outputStream.toByteArray();</span>
<span class="nc" id="L1793">            } catch (IOException | KeyStoreException | NoSuchAlgorithmException | CertificateException e) {</span>
<span class="nc" id="L1794">                log.error(e); //should never happen if keyStore is valid object</span>
            }
        }
<span class="nc" id="L1797">        return null;</span>
    }

    @Override
    public byte[] createCertificate(AuthenticationToken authenticationToken, EndEntityInformation endEntityInformation)
            throws AuthorizationDeniedException, EjbcaException {
<span class="nc bnc" id="L1803" title="All 4 branches missed.">        if(endEntityInformation.getExtendedInformation() == null || endEntityInformation.getExtendedInformation().getCertificateRequest() == null){</span>
<span class="nc" id="L1804">            throw new IllegalArgumentException(&quot;Could not find CSR for end entity with username &quot; + endEntityInformation.getUsername() + &quot; CSR must be set under endEntityInformation.extendedInformation.certificateRequest&quot;);</span>
        }

<span class="nc" id="L1807">        PKCS10RequestMessage req = null;</span>
<span class="nc" id="L1808">        req = RequestMessageUtils.genPKCS10RequestMessage(endEntityInformation.getExtendedInformation().getCertificateRequest());</span>
<span class="nc" id="L1809">        req.setUsername(endEntityInformation.getUsername());</span>
<span class="nc" id="L1810">        req.setPassword(endEntityInformation.getPassword());</span>
<span class="nc" id="L1811">        final String encodedValidity = endEntityInformation.getExtendedInformation().getCertificateEndTime();</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">        req.setNotAfter(encodedValidity == null ? null : ValidityDate.getDate(encodedValidity, new Date()));</span>
        try {
<span class="nc" id="L1814">            ResponseMessage resp = signSessionLocal.createCertificate(authenticationToken, req, X509ResponseMessage.class, null);</span>
<span class="nc" id="L1815">            X509Certificate cert = CertTools.getCertfromByteArray(resp.getResponseMessage(), X509Certificate.class);</span>
<span class="nc" id="L1816">            return cert.getEncoded();</span>
<span class="nc" id="L1817">        } catch (NoSuchEndEntityException | CustomCertificateSerialNumberException | CryptoTokenOfflineException | IllegalKeyException</span>
                | CADoesntExistsException | SignRequestException | SignRequestSignatureException | IllegalNameException | CertificateCreateException
                | CertificateRevokeException | CertificateSerialNumberException | IllegalValidityException | CAOfflineException
                | InvalidAlgorithmException | CertificateExtensionException e) {
<span class="nc" id="L1821">            throw new EjbcaException(e);</span>
<span class="nc" id="L1822">        } catch (CertificateParsingException | CertificateEncodingException e) {</span>
<span class="nc" id="L1823">            throw new IllegalStateException(&quot;Internal error with creating X509Certificate from CertificateResponseMessage&quot;);</span>
        }
    }


    @Override
    public byte[] createCertificateRest(final AuthenticationToken authenticationToken, EnrollPkcs10CertificateRequest enrollcertificateRequest)
            throws CertificateProfileDoesNotExistException, CADoesntExistsException, AuthorizationDeniedException, EndEntityProfileNotFoundException,
            EjbcaException, EndEntityProfileValidationException {

<span class="nc" id="L1833">        EndEntityInformation endEntityInformation = ejbcaRestHelperSession.convertToEndEntityInformation(authenticationToken, enrollcertificateRequest);</span>
        try {
<span class="nc" id="L1835">            byte[] certificate = certificateRequestSession.processCertReq(authenticationToken,</span>
                    endEntityInformation,
<span class="nc" id="L1837">                    enrollcertificateRequest.getCertificateRequest(),</span>
                    CertificateHelper.CERT_REQ_TYPE_PKCS10,
                    null,
                    CertificateConstants.CERT_RES_TYPE_CERTIFICATE);
<span class="nc" id="L1841">            return certificate;</span>
<span class="nc" id="L1842">        } catch (NotFoundException e) {</span>
<span class="nc" id="L1843">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1844">            throw e; // NFE extends EjbcaException</span>
<span class="nc" id="L1845">        } catch (CertificateExtensionException e) {</span>
<span class="nc" id="L1846">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1847">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
<span class="nc" id="L1848">        } catch (InvalidKeyException e) {</span>
<span class="nc" id="L1849">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1850">            throw new EjbcaException(ErrorCode.INVALID_KEY, e.getMessage());</span>
<span class="nc" id="L1851">        } catch (IllegalKeyException e) {</span>
<span class="nc" id="L1852">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1853">            throw new EjbcaException(ErrorCode.ILLEGAL_KEY, e.getMessage());</span>
<span class="nc" id="L1854">        } catch (AuthStatusException e) {</span>
<span class="nc" id="L1855">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1856">            throw new EjbcaException(ErrorCode.USER_WRONG_STATUS, e.getMessage());</span>
<span class="nc" id="L1857">        } catch (AuthLoginException e) {</span>
<span class="nc" id="L1858">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1859">            throw new EjbcaException(ErrorCode.LOGIN_ERROR, e.getMessage());</span>
<span class="nc" id="L1860">        } catch (SignatureException e) {</span>
<span class="nc" id="L1861">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1862">            throw new EjbcaException(ErrorCode.SIGNATURE_ERROR, e.getMessage());</span>
<span class="nc" id="L1863">        } catch (SignRequestSignatureException e) {</span>
<span class="nc" id="L1864">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1865">            throw new EjbcaException(e.getMessage());</span>
<span class="nc" id="L1866">        } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L1867">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1868">            throw new EjbcaException(ErrorCode.INVALID_KEY_SPEC, e.getMessage());</span>
<span class="nc" id="L1869">        } catch (NoSuchAlgorithmException | NoSuchProviderException | CertificateException | IOException e) {</span>
<span class="nc" id="L1870">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1871">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
<span class="nc" id="L1872">        } catch (CesecoreException e) {</span>
<span class="nc" id="L1873">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
            // Will convert the CESecore exception to an EJBCA exception with the same error code
<span class="nc" id="L1875">            throw new EjbcaException(e.getErrorCode(), e);</span>
<span class="nc" id="L1876">        } catch (RuntimeException e) {  // EJBException, ClassCastException, ...</span>
<span class="nc" id="L1877">            log.debug(&quot;EJBCA REST exception&quot;, e);</span>
<span class="nc" id="L1878">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
        }
    }


    @Override
    public byte[] createCertificateWS(final AuthenticationToken authenticationToken, final UserDataVOWS userdata, final String requestData, final int requestType,
            final String hardTokenSN, final String responseType) throws AuthorizationDeniedException, ApprovalException, EjbcaException,
            EndEntityProfileValidationException {
        try {
            // Some of the session beans are only needed for authentication or certificate operations, and are passed as null
<span class="nc" id="L1889">            final EndEntityInformation endEntityInformation = ejbcaWSHelperSession.convertUserDataVOWS(authenticationToken, userdata);</span>
<span class="nc" id="L1890">            int responseTypeInt = CertificateConstants.CERT_RES_TYPE_CERTIFICATE;</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">            if (!responseType.equalsIgnoreCase(CertificateHelper.RESPONSETYPE_CERTIFICATE)) {</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                if (responseType.equalsIgnoreCase(CertificateHelper.RESPONSETYPE_PKCS7)) {</span>
<span class="nc" id="L1893">                    responseTypeInt = CertificateConstants.CERT_RES_TYPE_PKCS7;</span>
                }
<span class="nc bnc" id="L1895" title="All 2 branches missed.">                else if (responseType.equalsIgnoreCase(CertificateHelper.RESPONSETYPE_PKCS7WITHCHAIN)) {</span>
<span class="nc" id="L1896">                    responseTypeInt = CertificateConstants.CERT_RES_TYPE_PKCS7WITHCHAIN;</span>
                }
                else{
<span class="nc" id="L1899">                    throw new NoSuchAlgorithmException(&quot;Bad responseType:&quot; + responseType);</span>
                }
            }
<span class="nc" id="L1902">            return certificateRequestSession.processCertReq(authenticationToken, endEntityInformation, requestData, requestType, hardTokenSN, responseTypeInt);</span>
<span class="nc" id="L1903">        } catch (NotFoundException e) {</span>
<span class="nc" id="L1904">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1905">            throw e; // NFE extends EjbcaException</span>
<span class="nc" id="L1906">        } catch (CertificateExtensionException e) {</span>
<span class="nc" id="L1907">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1908">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
<span class="nc" id="L1909">        } catch (InvalidKeyException e) {</span>
<span class="nc" id="L1910">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1911">            throw new EjbcaException(ErrorCode.INVALID_KEY, e.getMessage());</span>
<span class="nc" id="L1912">        } catch (IllegalKeyException e) {</span>
<span class="nc" id="L1913">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1914">            throw new EjbcaException(ErrorCode.ILLEGAL_KEY, e.getMessage());</span>
<span class="nc" id="L1915">        } catch (AuthStatusException e) {</span>
<span class="nc" id="L1916">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1917">            throw new EjbcaException(ErrorCode.USER_WRONG_STATUS, e.getMessage());</span>
<span class="nc" id="L1918">        } catch (AuthLoginException e) {</span>
<span class="nc" id="L1919">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1920">            throw new EjbcaException(ErrorCode.LOGIN_ERROR, e.getMessage());</span>
<span class="nc" id="L1921">        } catch (SignatureException e) {</span>
<span class="nc" id="L1922">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1923">            throw new EjbcaException(ErrorCode.SIGNATURE_ERROR, e.getMessage());</span>
<span class="nc" id="L1924">        } catch (SignRequestSignatureException e) {</span>
<span class="nc" id="L1925">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1926">            throw new EjbcaException(e.getMessage());</span>
<span class="nc" id="L1927">        } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L1928">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1929">            throw new EjbcaException(ErrorCode.INVALID_KEY_SPEC, e.getMessage());</span>
<span class="nc" id="L1930">        } catch (NoSuchAlgorithmException | NoSuchProviderException | CertificateException | IOException e) {</span>
<span class="nc" id="L1931">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1932">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
<span class="nc" id="L1933">        } catch (CesecoreException e) {</span>
<span class="nc" id="L1934">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
            // Will convert the CESecore exception to an EJBCA exception with the same error code
<span class="nc" id="L1936">            throw new EjbcaException(e.getErrorCode(), e);</span>
<span class="nc" id="L1937">        } catch (RuntimeException e) {  // EJBException, ClassCastException, ...</span>
<span class="nc" id="L1938">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L1939">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
        }
    }

    @Override
    public List&lt;CertificateWrapper&gt; getLastCertChain(final AuthenticationToken authenticationToken, final String username) throws AuthorizationDeniedException, EjbcaException {
<span class="nc bnc" id="L1945" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1946">            log.trace(&quot;&gt;getLastCertChain: &quot;+username);</span>
        }
<span class="nc" id="L1948">        final List&lt;CertificateWrapper&gt; retval = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">        if (endEntityAccessSession.findUser(authenticationToken, username) != null) { // checks authorization on CA and profiles and view_end_entity</span>
<span class="nc" id="L1950">            Collection&lt;CertificateWrapper&gt; certs = certificateStoreSession.findCertificatesByUsername(username);</span>
<span class="nc bnc" id="L1951" title="All 2 branches missed.">            if (certs.size() &gt; 0) {</span>
                // The latest certificate will be first
<span class="nc" id="L1953">                CertificateWrapper firstcert = certs.iterator().next();</span>
                Certificate lastcert;
<span class="nc bnc" id="L1955" title="All 2 branches missed.">                if (firstcert != null) {</span>
<span class="nc" id="L1956">                    retval.add(firstcert);</span>
<span class="nc" id="L1957">                    lastcert = firstcert.getCertificate();</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1959">                        log.debug(&quot;Found certificate for user with subjectDN: &quot;+CertTools.getSubjectDN(lastcert)+&quot; and serialNo: &quot;+CertTools.getSerialNumberAsString(lastcert));</span>
                    }
                    // If we added a certificate, we will also append the CA certificate chain
<span class="nc" id="L1962">                    boolean selfSigned = false;</span>
<span class="nc" id="L1963">                    int iteration = 0; // to control so we don't enter an infinite loop. Max chain length is 10</span>
<span class="nc bnc" id="L1964" title="All 4 branches missed.">                    while (!selfSigned &amp;&amp; iteration &lt; 10) {</span>
<span class="nc" id="L1965">                        iteration++;</span>
<span class="nc" id="L1966">                        final String issuerDN = CertTools.getIssuerDN(lastcert);</span>
<span class="nc" id="L1967">                        final Collection&lt;Certificate&gt; cacerts = certificateStoreSession.findCertificatesBySubject(issuerDN);</span>
<span class="nc bnc" id="L1968" title="All 4 branches missed.">                        if (cacerts == null || cacerts.size() == 0) {</span>
<span class="nc" id="L1969">                            log.info(&quot;No certificate found for CA with subjectDN: &quot;+issuerDN);</span>
<span class="nc" id="L1970">                            break;</span>
                        }
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                        for (final Certificate cert : cacerts) {</span>
                            try {
<span class="nc" id="L1974">                                lastcert.verify(cert.getPublicKey());</span>
                                // this was the right certificate
<span class="nc" id="L1976">                                retval.add(EJBTools.wrap(cert));</span>
                                // To determine if we have found the last certificate or not
<span class="nc" id="L1978">                                selfSigned = CertTools.isSelfSigned(cert);</span>
                                // Find the next certificate in the chain now
<span class="nc" id="L1980">                                lastcert = cert;</span>
<span class="nc" id="L1981">                                break; // Break of iteration over this CAs certs</span>
<span class="nc" id="L1982">                            } catch (Exception e) {</span>
<span class="nc" id="L1983">                                log.debug(&quot;Failed verification when looking for CA certificate, this was not the correct CA certificate. IssuerDN: &quot;+issuerDN+&quot;, serno: &quot;+CertTools.getSerialNumberAsString(cert));</span>
                            }
<span class="nc" id="L1985">                        }</span>
<span class="nc" id="L1986">                    }</span>

<span class="nc" id="L1988">                } else {</span>
<span class="nc" id="L1989">                    log.debug(&quot;Found no certificate (in non null list??) for user &quot;+username);</span>
                }
<span class="nc" id="L1991">            } else {</span>
<span class="nc" id="L1992">                log.debug(&quot;Found no certificate for user &quot;+username);</span>
            }
<span class="nc" id="L1994">        } else {</span>
<span class="nc" id="L1995">            String msg = intres.getLocalizedMessage(&quot;ra.errorentitynotexist&quot;, username);</span>
<span class="nc" id="L1996">            log.debug(msg);</span>
        }
<span class="nc bnc" id="L1998" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1999">            log.trace(&quot;&lt;getLastCertChain: &quot;+username);</span>
        }
<span class="nc" id="L2001">        return retval;</span>
    }

    @Override
    public boolean markForRecovery(AuthenticationToken authenticationToken, String username, String newPassword, CertificateWrapper cert, boolean localKeyGeneration) throws AuthorizationDeniedException, ApprovalException,
                                    CADoesntExistsException, WaitingForApprovalException, NoSuchEndEntityException, EndEntityProfileValidationException {
        boolean keyRecoverySuccessful;
<span class="nc" id="L2008">        boolean authorized = true;</span>
        // If called from the wrong instance, return to proxybean and try next implementation
<span class="nc" id="L2010">        final EndEntityInformation endEntityInformation = endEntityAccessSession.findUser(authenticationToken, username);</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">        if (endEntityInformation == null) {</span>
<span class="nc" id="L2012">            return false;</span>
        }
<span class="nc" id="L2014">        int endEntityProfileId = endEntityInformation.getEndEntityProfileId();</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">        if (((GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID)).getEnableEndEntityProfileLimitations()) {</span>
<span class="nc" id="L2016">            authorized = authorizationSession.isAuthorized(authenticationToken, AccessRulesConstants.ENDENTITYPROFILEPREFIX + Integer.toString(endEntityProfileId) + AccessRulesConstants.KEYRECOVERY_RIGHTS,</span>
                                                            AccessRulesConstants.REGULAR_RAFUNCTIONALITY + AccessRulesConstants.KEYRECOVERY_RIGHTS);
        }
<span class="nc bnc" id="L2019" title="All 2 branches missed.">        if (authorized) {</span>
            try {
<span class="nc bnc" id="L2021" title="All 2 branches missed.">                if (!localKeyGeneration) {</span>
<span class="nc" id="L2022">                    keyRecoverySuccessful = endEntityManagementSession.prepareForKeyRecovery(authenticationToken, username, endEntityProfileId, cert.getCertificate());</span>
                } else {
                    // In this case, the users status is set to 'Key Recovery' but not the flag in KeyRecoveryData since
                    // this is stored in another instance database
<span class="nc" id="L2026">                    keyRecoverySuccessful = endEntityManagementSession.prepareForKeyRecoveryInternal(authenticationToken, username, endEntityProfileId, cert.getCertificate());</span>
                }
<span class="nc bnc" id="L2028" title="All 4 branches missed.">                if (keyRecoverySuccessful &amp;&amp; newPassword != null) {</span>
                    // No approval required, continue by setting a new enrollment code
<span class="nc" id="L2030">                    endEntityManagementSession.setPassword(authenticationToken, username, newPassword);</span>
                }
<span class="nc" id="L2032">            } catch (WaitingForApprovalException e) {</span>
                // Set new EE password anyway
<span class="nc bnc" id="L2034" title="All 2 branches missed.">                if (newPassword != null) { // Password may null if there is a call from EjbcaWS</span>
<span class="nc" id="L2035">                    endEntityManagementSession.setPassword(authenticationToken, username, newPassword);</span>
                }
<span class="nc" id="L2037">                throw e;</span>
<span class="nc" id="L2038">            }</span>
<span class="nc" id="L2039">            return keyRecoverySuccessful;</span>
        }
<span class="nc" id="L2041">        return false;</span>
    }

    @Override
    public boolean editUser(AuthenticationToken authenticationToken, EndEntityInformation endEntityInformation)
            throws AuthorizationDeniedException, EndEntityProfileValidationException,
            WaitingForApprovalException, CADoesntExistsException, ApprovalException,
            CertificateSerialNumberException, IllegalNameException, NoSuchEndEntityException, CustomFieldException {
<span class="nc bnc" id="L2049" title="All 2 branches missed.">        if (endEntityAccessSession.findUser(authenticationToken, endEntityInformation.getUsername()) == null) {</span>
            // If called from the wrong instance, return to proxybean and try next implementation
<span class="nc" id="L2051">            return false;</span>
        } else {
<span class="nc" id="L2053">            endEntityManagementSession.changeUser(authenticationToken, endEntityInformation, false);</span>
<span class="nc" id="L2054">            return true;</span>
        }
    }

    @Override
    public boolean editUserWs(AuthenticationToken authenticationToken, UserDataVOWS userDataVOWS)
            throws AuthorizationDeniedException, EndEntityProfileValidationException,
            WaitingForApprovalException, CADoesntExistsException, CertificateSerialNumberException, IllegalNameException, NoSuchEndEntityException, EjbcaException {
<span class="nc" id="L2062">        return editUser(authenticationToken, ejbcaWSHelperSession.convertUserDataVOWS(authenticationToken, userDataVOWS));</span>
    }

    @Override
    public List&lt;UserDataVOWS&gt; findUserWS(AuthenticationToken authenticationToken, UserMatch usermatch, int maxNumberOfRows) throws AuthorizationDeniedException, IllegalQueryException, EjbcaException, EndEntityProfileNotFoundException {
<span class="nc" id="L2067">        List&lt;UserDataVOWS&gt; retval = null;</span>
        try {
<span class="nc" id="L2069">            final org.ejbca.util.query.Query query = ejbcaWSHelperSession.convertUserMatch(authenticationToken, usermatch);</span>
<span class="nc" id="L2070">            final Collection&lt;EndEntityInformation&gt; result = endEntityAccessSession.query(authenticationToken, query, null,null, maxNumberOfRows, AccessRulesConstants.VIEW_END_ENTITY); // also checks authorization</span>
<span class="nc bnc" id="L2071" title="All 2 branches missed.">            if (result.size() &gt; 0) {</span>
<span class="nc" id="L2072">                retval = new ArrayList&lt;&gt;(result.size());</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">                for (final EndEntityInformation userdata : result) {</span>
<span class="nc" id="L2074">                    retval.add(ejbcaWSHelperSession.convertEndEntityInformation(userdata));</span>
<span class="nc" id="L2075">                }</span>
            }
<span class="nc" id="L2077">        } catch (CesecoreException e) {</span>
            // Convert cesecore exception to EjbcaException
<span class="nc" id="L2079">            throw  new EjbcaException(e.getErrorCode(), e);</span>
<span class="nc" id="L2080">        }</span>
<span class="nc" id="L2081">        return retval;</span>
    }

    @Override
    public int getPublisherQueueLength(AuthenticationToken authenticationToken, String name) throws AuthorizationDeniedException, PublisherDoesntExistsException {
<span class="nc" id="L2086">        final int id = publisherSession.getPublisherId(name);</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">        if (id == 0) {</span>
<span class="nc" id="L2088">            throw new PublisherDoesntExistsException(&quot;Publisher does not exist: &quot; + name);</span>
        }
<span class="nc" id="L2090">        return publisherQueueSession.getPendingEntriesCountForPublisher(id);</span>
    }

    @Override
    public boolean keyRecoveryPossible(final AuthenticationToken authenticationToken, Certificate cert, String username) {
<span class="nc" id="L2095">        boolean returnval = true;</span>
<span class="nc" id="L2096">        returnval = isAuthorizedNoLogging(authenticationToken, AccessRulesConstants.REGULAR_KEYRECOVERY);</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">        if (((GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID)).getEnableEndEntityProfileLimitations()) {</span>
            try {
<span class="nc" id="L2099">                EndEntityInformation data = endEntityAccessSession.findUser(authenticationToken, username);</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">                if (data != null) {</span>
<span class="nc" id="L2101">                    int profileid = data.getEndEntityProfileId();</span>
<span class="nc" id="L2102">                    returnval = endEntityAuthorization(authenticationToken, profileid, AccessRulesConstants.KEYRECOVERY_RIGHTS, false);</span>
<span class="nc" id="L2103">                } else {</span>
<span class="nc" id="L2104">                    returnval = false;</span>
                }
<span class="nc" id="L2106">            } catch (AuthorizationDeniedException e) {</span>
<span class="nc" id="L2107">                log.debug(&quot;Administrator: &quot; + authenticationToken + &quot; was not authorized to perform key recovery for end entity: &quot; + username);</span>
<span class="nc" id="L2108">                return false;</span>
<span class="nc" id="L2109">            }</span>
        }
<span class="nc bnc" id="L2111" title="All 6 branches missed.">        return returnval &amp;&amp; keyRecoverySessionLocal.existsKeys(EJBTools.wrap(cert)) &amp;&amp; !keyRecoverySessionLocal.isUserMarked(username);</span>
    }

    @Override
    public void keyRecoverWS(AuthenticationToken authenticationToken, String username, String certSNinHex, String issuerDN) throws EjbcaException, AuthorizationDeniedException,
                WaitingForApprovalException, ApprovalException, CADoesntExistsException {
        try {
<span class="nc" id="L2118">            final boolean usekeyrecovery = ((GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID)).getEnableKeyRecovery();</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">            if (!usekeyrecovery) {</span>
<span class="nc" id="L2120">                throw new EjbcaException(ErrorCode.KEY_RECOVERY_NOT_AVAILABLE, &quot;Keyrecovery must be enabled in the system configuration in order to execute this command.&quot;);</span>

            }
<span class="nc" id="L2123">            final EndEntityInformation userdata = endEntityAccessSession.findUser(authenticationToken, username);</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">            if (userdata == null) {</span>
<span class="nc" id="L2125">                log.info(intres.getLocalizedMessage(&quot;ra.errorentitynotexist&quot;, username));</span>
<span class="nc" id="L2126">                final String msg = intres.getLocalizedMessage(&quot;ra.errorentitynotexist&quot;, username);</span>
<span class="nc" id="L2127">                throw new NotFoundException(msg);</span>
            }
<span class="nc bnc" id="L2129" title="All 2 branches missed.">            if (keyRecoverySessionLocal.isUserMarked(username)) {</span>
                // User is already marked for recovery.
<span class="nc" id="L2131">                return;</span>
            }
            // check CAID
<span class="nc" id="L2134">            final int caid = userdata.getCAId();</span>
<span class="nc" id="L2135">            caSession.verifyExistenceOfCA(caid);</span>
<span class="nc bnc" id="L2136" title="All 2 branches missed.">            if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CAACCESS.resource() + caid)) {</span>
<span class="nc" id="L2137">                final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;, StandardRules.CAACCESS.resource() +caid, null);</span>
<span class="nc" id="L2138">                throw new AuthorizationDeniedException(msg);</span>
            }

            // find certificate to recover
<span class="nc" id="L2142">            final Certificate cert = certificateStoreSession.findCertificateByIssuerAndSerno(issuerDN, new BigInteger(certSNinHex,16));</span>
<span class="nc bnc" id="L2143" title="All 2 branches missed.">            if (cert == null) {</span>
<span class="nc" id="L2144">                final String msg = intres.getLocalizedMessage(&quot;ra.errorfindentitycert&quot;, issuerDN, certSNinHex);</span>
<span class="nc" id="L2145">                throw new NotFoundException(msg);</span>
            }

            // Do the work, mark user for key recovery
<span class="nc bnc" id="L2149" title="All 2 branches missed.">            if (!endEntityManagementSession.prepareForKeyRecovery(authenticationToken, userdata.getUsername(), userdata.getEndEntityProfileId(), cert)) {</span>
                // Reset user status and throw exception
<span class="nc" id="L2151">                endEntityManagementSession.setUserStatus(authenticationToken, username, userdata.getStatus());</span>
<span class="nc" id="L2152">                throw new EjbcaException(ErrorCode.KEY_RECOVERY_NOT_AVAILABLE, &quot;Key recovery data not found for user '&quot; + username + &quot;'&quot;);</span>
            }
<span class="nc" id="L2154">        } catch (NotFoundException e) {</span>
<span class="nc" id="L2155">            log.debug(&quot;EJBCA WebService error&quot;, e);</span>
<span class="nc" id="L2156">            throw e; // extends EjbcaException</span>
<span class="nc" id="L2157">        } catch (NoSuchEndEntityException e) {</span>
<span class="nc" id="L2158">            throw new NotFoundException(intres.getLocalizedMessage(&quot;ra.errorentitynotexist&quot;, username));</span>
<span class="nc" id="L2159">        }</span>
<span class="nc" id="L2160">    }</span>

    @Override
    public byte[] keyRecoverEnrollWS(AuthenticationToken authenticationToken, String username, String certSNinHex, String issuerDN, String password, String hardTokenSN)
            throws AuthorizationDeniedException, ApprovalException, CADoesntExistsException, EjbcaException, WaitingForApprovalException {
<span class="nc" id="L2165">        keyRecoverWS(authenticationToken, username, certSNinHex, issuerDN);</span>
<span class="nc" id="L2166">        EndEntityInformation userData = endEntityAccessSession.findUser(authenticationToken, username);</span>
<span class="nc" id="L2167">        userData.setPassword(password);</span>
<span class="nc" id="L2168">        byte[] keyStoreBytes = generateKeyStore(authenticationToken, userData);</span>

        // Lots of checks. Can't know what WS client sends in.
<span class="nc bnc" id="L2171" title="All 6 branches missed.">        if (!StringUtils.isEmpty(hardTokenSN) &amp;&amp; !hardTokenSN.equals(&quot;NONE&quot;) &amp;&amp; !hardTokenSN.equals(&quot;null&quot;)) {</span>
            final KeyStore keyStore;
            try {
<span class="nc bnc" id="L2174" title="All 2 branches missed.">                if (userData.getTokenType() == EndEntityConstants.TOKEN_SOFT_P12) {</span>
<span class="nc" id="L2175">                    keyStore = KeyStore.getInstance(&quot;PKCS12&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
                } else {
<span class="nc" id="L2177">                    keyStore = KeyStore.getInstance(&quot;JKS&quot;);</span>
                }
<span class="nc" id="L2179">                keyStore.load(new ByteArrayInputStream(keyStoreBytes), password.toCharArray());</span>
<span class="nc" id="L2180">                final Enumeration&lt;String&gt; en = keyStore.aliases();</span>
<span class="nc" id="L2181">                final String alias = en.nextElement();</span>
<span class="nc" id="L2182">                final X509Certificate cert = (X509Certificate) keyStore.getCertificate(alias);</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">                if (cert != null) {</span>
<span class="nc" id="L2184">                    hardTokenSession.addHardTokenCertificateMapping(authenticationToken,hardTokenSN,cert);</span>
                }

<span class="nc" id="L2187">            } catch (CertificateParsingException e) {</span>
<span class="nc" id="L2188">                throw new EjbcaException(ErrorCode.CERT_COULD_NOT_BE_PARSED, e.getMessage());</span>
<span class="nc" id="L2189">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2190">                throw new EjbcaException(ErrorCode.NOT_SUPPORTED_KEY_STORE, e.getMessage());</span>
<span class="nc" id="L2191">            } catch (CertificateException e) {</span>
<span class="nc" id="L2192">                throw new EjbcaException(ErrorCode.CERT_COULD_NOT_BE_PARSED, e.getMessage());</span>
<span class="nc" id="L2193">            } catch (IOException e) {</span>
<span class="nc" id="L2194">                throw new EjbcaException(ErrorCode.NOT_SUPPORTED_KEY_STORE, e.getMessage());</span>
<span class="nc" id="L2195">            } catch (KeyStoreException e) {</span>
<span class="nc" id="L2196">                throw new EjbcaException(ErrorCode.NOT_SUPPORTED_KEY_STORE, e.getMessage());</span>
<span class="nc" id="L2197">            } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L2198">                throw new EjbcaException(ErrorCode.NOT_SUPPORTED_KEY_STORE, e.getMessage());</span>
<span class="nc" id="L2199">            }</span>
        }
<span class="nc" id="L2201">        return keyStoreBytes;</span>
    }

    /** Help function used to check end entity profile authorization. 
     * @param admin Admin
     * @param profileid ID
     * @param rights Rights
     * @param log Log
     * @return bool */
    private boolean endEntityAuthorization(AuthenticationToken admin, int profileid, String rights, boolean log) {
<span class="nc" id="L2211">        boolean returnval = false;</span>
<span class="nc bnc" id="L2212" title="All 2 branches missed.">        if (log) {</span>
<span class="nc" id="L2213">            returnval = authorizationSession.isAuthorized(admin, AccessRulesConstants.ENDENTITYPROFILEPREFIX + Integer.toString(profileid) + rights,</span>
                    AccessRulesConstants.REGULAR_RAFUNCTIONALITY + rights);
        } else {
<span class="nc" id="L2216">            returnval = isAuthorizedNoLogging(admin, AccessRulesConstants.ENDENTITYPROFILEPREFIX + Integer.toString(profileid)</span>
                    + rights, AccessRulesConstants.REGULAR_RAFUNCTIONALITY + rights);
        }
<span class="nc" id="L2219">        return returnval;</span>
    }

    @Override
    public boolean changeCertificateStatus(final AuthenticationToken authenticationToken, final String fingerprint, final int newStatus, final int newRevocationReason)
            throws ApprovalException, WaitingForApprovalException {
<span class="nc" id="L2225">        final CertificateDataWrapper cdw = searchForCertificate(authenticationToken, fingerprint);</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">        if (cdw!=null) {</span>
<span class="nc" id="L2227">            final BigInteger serialNumber = new BigInteger(cdw.getCertificateData().getSerialNumber());</span>
<span class="nc" id="L2228">            final String issuerDn = cdw.getCertificateData().getIssuerDN();</span>
            try {
                // This call checks CA authorization, EEP authorization (if enabled) and /ra_functionality/revoke_end_entity
<span class="nc" id="L2231">                endEntityManagementSession.revokeCert(authenticationToken, serialNumber, issuerDn, newRevocationReason);</span>
<span class="nc" id="L2232">                return true;</span>
<span class="nc" id="L2233">            } catch (AlreadyRevokedException e) {</span>
                // If it is already revoked, great! The client got what the client wanted.. (almost at least, since reason might differ)
<span class="nc" id="L2235">                log.info(&quot;Client '&quot;+authenticationToken+&quot;' requested status change of when status was already set for certificate '&quot;+fingerprint+&quot;'. Considering operation successful.&quot;);</span>
<span class="nc" id="L2236">                return true;</span>
<span class="nc" id="L2237">            } catch (AuthorizationDeniedException e) {</span>
<span class="nc" id="L2238">                log.info(&quot;Client '&quot;+authenticationToken+&quot;' requested status change of certificate '&quot;+fingerprint+&quot;' but is not authorized to revoke certificates.&quot;);</span>
<span class="nc" id="L2239">            } catch (NoSuchEndEntityException e) {</span>
                // The certificate did exist a few lines ago, but must have been removed since then. Treat this like it never existed
<span class="nc" id="L2241">                log.info(&quot;Client '&quot;+authenticationToken+&quot;' requested status change of certificate '&quot;+fingerprint+&quot;' that does not exist.&quot;);</span>
<span class="nc" id="L2242">            }</span>
<span class="nc" id="L2243">        } else {</span>
<span class="nc" id="L2244">            log.info(&quot;Client '&quot;+authenticationToken+&quot;' requested status change of certificate '&quot;+fingerprint+&quot;' that does not exist or the client is not authorized to see.&quot;);</span>
        }
<span class="nc" id="L2246">        return false;</span>
    }

    @Override
    public void revokeCert(AuthenticationToken authenticationToken, BigInteger certserno, Date revocationdate, String issuerdn, int reason, boolean checkDate)
            throws AuthorizationDeniedException, NoSuchEndEntityException, ApprovalException, WaitingForApprovalException,
            RevokeBackDateNotAllowedForProfileException, AlreadyRevokedException, CADoesntExistsException {
        // First check if we handle the CA, to fail-fast, and reflect the functionality of remote API (WS)
<span class="nc" id="L2254">        final int caid = CertTools.stringToBCDNString(issuerdn).hashCode();</span>
<span class="nc" id="L2255">        caSession.verifyExistenceOfCA(caid);</span>
<span class="nc" id="L2256">        endEntityManagementSession.revokeCert(authenticationToken, certserno, revocationdate, issuerdn, reason, checkDate);</span>
<span class="nc" id="L2257">    }</span>

    @Override
    public void revokeCertWithMetadata(AuthenticationToken authenticationToken, CertRevocationDto certRevocationDto)
            throws AuthorizationDeniedException, NoSuchEndEntityException, ApprovalException, WaitingForApprovalException,
            RevokeBackDateNotAllowedForProfileException, AlreadyRevokedException, CADoesntExistsException, IllegalArgumentException, CertificateProfileDoesNotExistException {
        // First check if we handle the CA, to fail-fast, and reflect the functionality of remote API (WS)

<span class="nc" id="L2265">        final int caId = CertTools.stringToBCDNString(certRevocationDto.getIssuerDN()).hashCode();</span>
<span class="nc" id="L2266">        caSession.verifyExistenceOfCA(caId);</span>
<span class="nc" id="L2267">        endEntityManagementSession.revokeCertWithMetadata(authenticationToken, certRevocationDto);</span>
<span class="nc" id="L2268">    }</span>

    @Override
    public void revokeUser(final AuthenticationToken authenticationToken, final String username, final int reason, final boolean deleteUser) throws AuthorizationDeniedException, CADoesntExistsException,
        ApprovalException, WaitingForApprovalException, AlreadyRevokedException, NoSuchEndEntityException, CouldNotRemoveEndEntityException, EjbcaException {
<span class="nc" id="L2273">        endEntityManagementSession.revokeUser(authenticationToken, username, reason, deleteUser);</span>
<span class="nc" id="L2274">    }</span>

    @Override
    public CertificateStatus getCertificateStatus(AuthenticationToken authenticationToken, String issuerdn, BigInteger serno) throws CADoesntExistsException, AuthorizationDeniedException {
        // First check if we handle the CA, to fail-fast, and reflect the functionality of remote API (WS)
<span class="nc" id="L2279">        final int caid = CertTools.stringToBCDNString(issuerdn).hashCode();</span>
<span class="nc" id="L2280">        caSession.verifyExistenceOfCA(caid);</span>
        // Check if we are authorized to this CA
<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if(!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CAACCESS.resource() +caid)) {</span>
<span class="nc" id="L2283">            final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;, StandardRules.CAACCESS.resource() +caid, null);</span>
<span class="nc" id="L2284">            throw new AuthorizationDeniedException(msg);</span>
        }

<span class="nc" id="L2287">        return noConflictCertificateStoreSession.getStatus(issuerdn, serno);</span>
    }

    private GlobalCesecoreConfiguration getGlobalCesecoreConfiguration() {
<span class="nc" id="L2291">        return (GlobalCesecoreConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalCesecoreConfiguration.CESECORE_CONFIGURATION_ID);</span>
    }

    @Override
    public ApprovalProfile getApprovalProfileForAction(final AuthenticationToken authenticationToken, final ApprovalRequestType action, final int caId, final int certificateProfileId) throws AuthorizationDeniedException{
<span class="nc" id="L2296">        KeyToValueHolder&lt;CAInfo&gt; caInfoHolder = getAuthorizedCAInfos(authenticationToken).get(caId);</span>
<span class="nc" id="L2297">        KeyToValueHolder&lt;CertificateProfile&gt; certificateProfileHolder = getAuthorizedCertificateProfiles(authenticationToken).get(certificateProfileId);</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">        if(caInfoHolder == null){</span>
<span class="nc" id="L2299">            throw new AuthorizationDeniedException(&quot;Could not get approval profile because &quot; + authenticationToken + &quot; doesn't have access to CA with ID = &quot; + caId);</span>
        }
<span class="nc bnc" id="L2301" title="All 2 branches missed.">        if(certificateProfileHolder == null){</span>
<span class="nc" id="L2302">            throw new AuthorizationDeniedException(&quot;Could not get approval profile because &quot; + authenticationToken + &quot; doesn't have access to certificate profile with ID = &quot; + certificateProfileId);</span>
        }
<span class="nc" id="L2304">        return approvalProfileSession.getApprovalProfileForAction(action, caInfoHolder.getValue(), certificateProfileHolder.getValue());</span>
    }

    @Override
    public byte[] scepDispatch(final AuthenticationToken authenticationToken, final String operation, final String message, final String scepConfigurationAlias)
            throws CertificateEncodingException, NoSuchAliasException, CADoesntExistsException, NoSuchEndEntityException, CustomCertificateSerialNumberException,
            CryptoTokenOfflineException, IllegalKeyException, SignRequestException, SignRequestSignatureException, AuthStatusException, AuthLoginException, IllegalNameException,
            CertificateCreateException, CertificateRevokeException, CertificateSerialNumberException, IllegalValidityException, CAOfflineException, InvalidAlgorithmException,
            SignatureException, CertificateException, AuthorizationDeniedException, CertificateExtensionException, CertificateRenewalException {
<span class="nc" id="L2313">        return scepMessageDispatcherSession.dispatchRequest(authenticationToken, operation, message, scepConfigurationAlias);</span>
    }

    @Override
    public byte[] cmpDispatch(final AuthenticationToken authenticationToken, final byte[] pkiMessageBytes, final String cmpConfigurationAlias) throws NoSuchAliasException {
<span class="nc" id="L2318">        return cmpMessageDispatcherSession.dispatchRequest(authenticationToken, pkiMessageBytes, cmpConfigurationAlias);</span>
    }

    @Override
    public byte[] estDispatch(String operation, String alias, X509Certificate cert, String username, String password, byte[] requestBody)
            throws NoSuchAliasException, CADoesntExistsException, CertificateCreateException, CertificateRenewalException, AuthenticationFailedException {
        // throws UnsupportedOperationException if EST is not available (Community);
<span class="nc" id="L2325">        return estOperationsSessionLocal.dispatchRequest(operation, alias, cert, username, password, requestBody);</span>
    }

    @Override
    public Collection&lt;CertificateWrapper&gt; getCertificateChain(final AuthenticationToken authenticationToken, int caid) throws AuthorizationDeniedException, CADoesntExistsException {
<span class="nc bnc" id="L2330" title="All 2 branches missed.">        if(!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CAACCESS.resource() +caid)) {</span>
<span class="nc" id="L2331">            final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;, StandardRules.CAACCESS.resource() +caid, null);</span>
<span class="nc" id="L2332">            throw new AuthorizationDeniedException(msg);</span>
        }
<span class="nc" id="L2334">        CAInfo caInfo = caSession.getCAInfoInternal(caid);</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">        if(caInfo == null) {</span>
<span class="nc" id="L2336">            throw new CADoesntExistsException(&quot;CA with ID &quot; + caid + &quot; doesn't exist&quot;);</span>
        }
<span class="nc" id="L2338">        return EJBTools.wrapCertCollection(caInfo.getCertificateChain());</span>
    }

    private Date getDate(long days) {
<span class="nc" id="L2342">        Date findDate = new Date();</span>
<span class="nc" id="L2343">        long millis = (days * 24 * 60 * 60 * 1000);</span>
<span class="nc" id="L2344">        findDate.setTime(findDate.getTime() + millis);</span>
<span class="nc" id="L2345">        return findDate;</span>
    }

    @Override
    public int getCountOfCertificatesByExpirationTime(final AuthenticationToken authenticationToken, long days) throws AuthorizationDeniedException {
<span class="nc bnc" id="L2350" title="All 2 branches missed.">        if(!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CAFUNCTIONALITY.resource()+&quot;/view_certificate&quot;)) {</span>
<span class="nc" id="L2351">            final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;, StandardRules.CAFUNCTIONALITY.resource()+&quot;/view_certificate&quot;, null);</span>
<span class="nc" id="L2352">            throw new AuthorizationDeniedException(msg);</span>
        }
<span class="nc" id="L2354">        Date findDate = getDate(days);</span>
<span class="nc" id="L2355">        return certificateStoreSession.findNumberOfExpiringCertificates(findDate);</span>
    }

    @Override
    public void customLog(final AuthenticationToken authenticationToken, final String type, final String caName, final String username, final String certificateSn,
    		final String msg, final EventType event) throws AuthorizationDeniedException, CADoesntExistsException {
<span class="nc" id="L2361">        caAdminSession.customLog(authenticationToken, type, caName, username, certificateSn, msg, event);</span>
<span class="nc" id="L2362">    }</span>

    @Override
    public Collection&lt;CertificateWrapper&gt; getCertificatesByUsername(final AuthenticationToken authenticationToken, final String username, final boolean onlyValid, final long now)
            throws AuthorizationDeniedException, CertificateEncodingException {
<span class="nc" id="L2367">        return endEntityAccessSession.findCertificatesByUsername(authenticationToken, username, onlyValid, now);</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getAvailableCertificateProfiles(final AuthenticationToken authenticationToken, final int entityProfileId)
            throws AuthorizationDeniedException, EndEntityProfileNotFoundException {
<span class="nc" id="L2373">        return endEntityProfileSession.getAvailableCertificateProfiles(authenticationToken, entityProfileId);</span>
    }

    @Override
    public Map&lt;String, Integer&gt; getAvailableCasInProfile(final AuthenticationToken authenticationToken, final int entityProfileId)
            throws AuthorizationDeniedException, EndEntityProfileNotFoundException {
<span class="nc" id="L2379">        return endEntityProfileSession.getAvailableCasInProfile(authenticationToken, entityProfileId);</span>
    }

    @Override
    public CertificateWrapper getCertificate(AuthenticationToken authenticationToken, String certSNinHex, String issuerDN)
            throws AuthorizationDeniedException, CADoesntExistsException, EjbcaException {
<span class="nc" id="L2385">        return endEntityAccessSession.getCertificate(authenticationToken, certSNinHex, issuerDN);</span>
    }

    @Override
    public Collection&lt;CertificateWrapper&gt; getCertificatesByExpirationTime(final AuthenticationToken authenticationToken, final long days,
            final int maxNumberOfResults, final int offset) throws AuthorizationDeniedException {
<span class="nc bnc" id="L2391" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CAFUNCTIONALITY.resource() + &quot;/view_certificate&quot;)) {</span>
<span class="nc" id="L2392">            final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;,</span>
<span class="nc" id="L2393">                    StandardRules.CAFUNCTIONALITY.resource() + &quot;/view_certificate&quot;, null);</span>
<span class="nc" id="L2394">            throw new AuthorizationDeniedException(msg);</span>
        }
<span class="nc" id="L2396">        Date findDate = getDate(days);</span>
<span class="nc" id="L2397">        return EJBTools.wrapCertCollection(certificateStoreSession.findExpiringCertificates(findDate, maxNumberOfResults, offset));</span>
    }

    @Override
    public Collection&lt;CertificateWrapper&gt; getCertificatesByExpirationTimeAndType(AuthenticationToken authenticationToken, long days, int certificateType, int maxNumberOfResults)
            throws AuthorizationDeniedException, EjbcaException {
<span class="nc bnc" id="L2403" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CAFUNCTIONALITY.resource() + &quot;/view_certificate&quot;)) {</span>
<span class="nc" id="L2404">            final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;,</span>
<span class="nc" id="L2405">                    StandardRules.CAFUNCTIONALITY.resource() + &quot;/view_certificate&quot;, null);</span>
<span class="nc" id="L2406">            throw new AuthorizationDeniedException(msg);</span>
        }
<span class="nc" id="L2408">        final Date findDate = new Date();</span>
<span class="nc" id="L2409">        final long millis = (days * 24 * 60 * 60 * 1000);</span>
<span class="nc" id="L2410">        findDate.setTime(findDate.getTime() + millis);</span>
<span class="nc" id="L2411">        final List&lt;Certificate&gt; result = certificateStoreSession.findCertificatesByExpireTimeAndTypeWithLimit(findDate, certificateType, maxNumberOfResults);</span>
<span class="nc" id="L2412">        return EJBTools.wrapCertCollection(result);</span>
    }

    @Override
    public Collection&lt;CertificateWrapper&gt; getCertificatesByExpirationTimeAndIssuer(AuthenticationToken authenticationToken, long days, String issuerDN, int maxNumberOfResults)
            throws AuthorizationDeniedException, EjbcaException {
<span class="nc bnc" id="L2418" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CAFUNCTIONALITY.resource() + &quot;/view_certificate&quot;)) {</span>
<span class="nc" id="L2419">            final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;,</span>
<span class="nc" id="L2420">                    StandardRules.CAFUNCTIONALITY.resource() + &quot;/view_certificate&quot;, null);</span>
<span class="nc" id="L2421">            throw new AuthorizationDeniedException(msg);</span>
        }
<span class="nc" id="L2423">        final Date findDate = new Date();</span>
<span class="nc" id="L2424">        final long millis = (days * 24 * 60 * 60 * 1000);</span>
<span class="nc" id="L2425">        findDate.setTime(findDate.getTime() + millis);</span>
<span class="nc" id="L2426">        final List&lt;java.security.cert.Certificate&gt; result = certificateStoreSession.findCertificatesByExpireTimeAndIssuerWithLimit(findDate, issuerDN, maxNumberOfResults);</span>
<span class="nc" id="L2427">        return EJBTools.wrapCertCollection(result);</span>
    }

    @Override
    public Collection&lt;CertificateWrapper&gt; getLastCaChain(final AuthenticationToken authenticationToken, final String caName)
            throws AuthorizationDeniedException, CADoesntExistsException {
<span class="nc" id="L2433">        return caSession.getCaChain(authenticationToken, caName);</span>
    }

    @Override
    public byte[] processCertificateRequest(final AuthenticationToken authenticationToken, final String username, final String password, final String req, final int reqType,
            final String hardTokenSN, final String responseType)
            throws AuthorizationDeniedException, EjbcaException, CesecoreException,
            CADoesntExistsException, CertificateExtensionException, InvalidKeyException, SignatureException,
            InvalidKeySpecException, NoSuchAlgorithmException, NoSuchProviderException, CertificateException, IOException,
            AuthStatusException, AuthLoginException {
        try {
<span class="nc" id="L2444">            return signSessionLocal.createCertificateWS(authenticationToken, username, password, req, reqType, hardTokenSN, responseType);</span>
<span class="nc" id="L2445">        } catch (ParseException | ConstructionException | NoSuchFieldException e) {</span>
<span class="nc" id="L2446">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
        }
    }

    @Override
    public byte[] getLatestCrl(final AuthenticationToken authenticationToken, final String caName, final boolean deltaCRL)
            throws AuthorizationDeniedException, CADoesntExistsException {
<span class="nc" id="L2453">        final CAInfo cainfo = caSession.getCAInfo(authenticationToken, caName);</span>
<span class="nc bnc" id="L2454" title="All 2 branches missed.">        if (cainfo == null) {</span>
<span class="nc" id="L2455">            throw new CADoesntExistsException(&quot;CA with name &quot; + caName + &quot; doesn't exist.&quot;);</span>
        }
<span class="nc" id="L2457">        return crlStoreSession.getLastCRL(cainfo.getSubjectDN(), deltaCRL);</span>
    }

    @Override
    public byte[] getLatestCrlByIssuerDn(AuthenticationToken authenticationToken, String issuerDn, boolean deltaCRL) throws AuthorizationDeniedException, EjbcaException, CADoesntExistsException {
<span class="nc" id="L2462">        final CAInfo cainfo = caSession.getCAInfo(authenticationToken, issuerDn.hashCode());</span>
<span class="nc bnc" id="L2463" title="All 2 branches missed.">        if (cainfo == null) {</span>
<span class="nc" id="L2464">            throw new CADoesntExistsException(&quot;CA with subjectDn &quot; + issuerDn + &quot; doesn't exist.&quot;);</span>
        }
<span class="nc" id="L2466">        return crlStoreSession.getLastCRL(issuerDn, deltaCRL);</span>
    }

    @Override
    public Integer getRemainingNumberOfApprovals(final AuthenticationToken authenticationToken, final int requestId)
            throws AuthorizationDeniedException, ApprovalException, ApprovalRequestExpiredException {
<span class="nc" id="L2472">        return approvalSession.getRemainingNumberOfApprovals(requestId);</span>
    }

    @Override
    public Integer isApproved(final AuthenticationToken authenticationToken, final int approvalId)
            throws AuthorizationDeniedException, ApprovalException, ApprovalRequestExpiredException {
<span class="nc" id="L2478">        return approvalSession.isApproved(approvalId);</span>
    }

    @Override
    public boolean isAuthorized(final AuthenticationToken authenticationToken, final String... resource) {
<span class="nc" id="L2483">        return authorizationSession.isAuthorized(authenticationToken, resource);</span>
    }

    @Override
    public void republishCertificate(AuthenticationToken authenticationToken, String serialNumberInHex, String issuerDN)
            throws AuthorizationDeniedException, CADoesntExistsException, PublisherException, EjbcaException {
<span class="nc" id="L2489">        final String bcIssuerDN = CertTools.stringToBCDNString(issuerDN);</span>
<span class="nc" id="L2490">        caSession.verifyExistenceOfCA(bcIssuerDN.hashCode());</span>
<span class="nc" id="L2491">        final CertReqHistory certReqHistory = certreqHistorySession.retrieveCertReqHistory(new BigInteger(serialNumberInHex,16), bcIssuerDN);</span>
<span class="nc bnc" id="L2492" title="All 2 branches missed.">        if(certReqHistory == null){</span>
<span class="nc" id="L2493">            throw new PublisherException(&quot;Error: the certificate with serialnumber : &quot; + serialNumberInHex +&quot; and issuerdn &quot; + issuerDN + &quot; couldn't be found in database.&quot;);</span>
        }
<span class="nc" id="L2495">        ejbcaWSHelperSession.isAuthorizedToRepublish(authenticationToken, certReqHistory.getUsername(),bcIssuerDN.hashCode());</span>
<span class="nc" id="L2496">        final CertificateProfile certificateProfile = certificateProfileSession.getCertificateProfile(certReqHistory.getEndEntityInformation().getCertificateProfileId());</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">        if (certificateProfile != null) {</span>
<span class="nc bnc" id="L2498" title="All 2 branches missed.">            if (certificateProfile.getPublisherList().size() &gt; 0) {</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">                if (publisherSession.storeCertificate(authenticationToken, certificateProfile.getPublisherList(), certReqHistory.getFingerprint(),</span>
<span class="nc" id="L2500">                        certReqHistory.getEndEntityInformation().getPassword(), certReqHistory.getEndEntityInformation().getCertificateDN(), certReqHistory.getEndEntityInformation().getExtendedInformation())) {</span>
                } else {
<span class="nc" id="L2502">                    throw new PublisherException(&quot;Error: publication failed to at least one of the defined publishers.&quot;);</span>
                }
            } else {
<span class="nc" id="L2505">                throw new PublisherException(&quot;Error no publisher defined for the given certificate.&quot;);</span>
            }
        } else {
<span class="nc" id="L2508">            throw new PublisherException(&quot;Error : Certificate profile couldn't be found for the given certificate.&quot;);</span>
        }
<span class="nc" id="L2510">    }</span>

    @Override
    public byte[] generateOrKeyRecoverToken(final AuthenticationToken authenticationToken, final String username, final String password, final String hardTokenSN, final String keySpecification,
            final String keyAlgorithm) throws AuthorizationDeniedException, CADoesntExistsException, NotFoundException, EjbcaException {
<span class="nc" id="L2515">        return keyStoreCreateSessionLocal.generateOrKeyRecoverTokenAsByteArray(authenticationToken, username, password, hardTokenSN, keySpecification, keyAlgorithm);</span>
    }

    @Override
    public byte[] getEndEntityProfileAsXml(final AuthenticationToken authenticationToken, final int profileId)
            throws AuthorizationDeniedException, EndEntityProfileNotFoundException {
<span class="nc" id="L2521">        return endEntityProfileSession.getProfileAsXml(authenticationToken, profileId);</span>
    }

    @Override
    public byte[] getCertificateProfileAsXml(final AuthenticationToken authenticationToken, final int profileId)
            throws AuthorizationDeniedException, CertificateProfileDoesNotExistException {
<span class="nc" id="L2527">        return certificateProfileSession.getProfileAsXml(authenticationToken, profileId);</span>
    }

    @Override
    public Collection&lt;CertificateWrapper&gt; processCardVerifiableCertificateRequest(final AuthenticationToken authenticationToken, final String username, final String password, final String cvcreq)
            throws AuthorizationDeniedException, CADoesntExistsException, UserDoesntFullfillEndEntityProfile, NotFoundException,
            ApprovalException, EjbcaException, WaitingForApprovalException, SignRequestException, CertificateExpiredException, CesecoreException {
<span class="nc" id="L2534">        return signSessionLocal.createCardVerifiableCertificateWS(authenticationToken, username, password, cvcreq);</span>
    }

    @Override
    public HashSet&lt;String&gt; getCaaIdentities(final AuthenticationToken authenticationToken, final int caId)
            throws AuthorizationDeniedException, CADoesntExistsException {
<span class="nc" id="L2540">        final HashSet&lt;String&gt; caaIdentities = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L2541">        final CA ca = caSession.getCA(authenticationToken, caId);</span>
<span class="nc bnc" id="L2542" title="All 2 branches missed.">        if (ca == null) {</span>
<span class="nc" id="L2543">            throw new CADoesntExistsException(&quot;The CA with id &quot; + caId + &quot; does not exist on peer.&quot;);</span>
        }
<span class="nc bnc" id="L2545" title="All 2 branches missed.">        for (final int validatorId : ca.getValidators()) {</span>
<span class="nc" id="L2546">            final Validator validator = keyValidatorSession.getValidator(validatorId);</span>
<span class="nc bnc" id="L2547" title="All 2 branches missed.">            if (validator == null) {</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L2549">                    log.debug(&quot;Missing validator ID &quot; + validatorId + &quot; in CA '&quot; + ca.getName() + &quot;'&quot;);</span>
                }
                continue;
            }
<span class="nc bnc" id="L2553" title="All 2 branches missed.">            if (validator.getValidatorTypeIdentifier().equals(DnsNameValidator.CAA_TYPE_IDENTIFIER)) {</span>
<span class="nc" id="L2554">                caaIdentities.addAll(((DnsNameValidator) validator).getIssuers());</span>
            }
<span class="nc" id="L2556">        }</span>
<span class="nc" id="L2557">        return caaIdentities;</span>
    }

    @Override
    public AcmeAccount getAcmeAccountById(String accountId) {
<span class="nc" id="L2562">        return acmeAccountDataSession.getAcmeAccount(accountId);</span>
    }

    @Override
    public AcmeAccount getAcmeAccountByPublicKeyStorageId(final String publicKeyStorageId) {
<span class="nc" id="L2567">        return acmeAccountDataSession.getAcmeAccountByPublicKeyStorageId(publicKeyStorageId);</span>
    }

    @Override
    public String persistAcmeAccount(final AcmeAccount acmeAccount) {
<span class="nc" id="L2572">        return acmeAccountDataSession.createOrUpdate(acmeAccount);</span>
    }

    @Override
    public AcmeOrder getAcmeOrderById(final String orderId) {
<span class="nc" id="L2577">        return acmeOrderDataSession.getAcmeOrder(orderId);</span>
    }
    
    @Override
    public Set&lt;AcmeOrder&gt; getAcmeOrdersByAccountId(String accountId) {
<span class="nc" id="L2582">        return acmeOrderDataSession.getAcmeOrdersByAccountId(accountId);</span>
    }

    @Override
    public Set&lt;AcmeOrder&gt; getFinalizedAcmeOrdersByFingerprint(String fingerprint) {
<span class="nc" id="L2587">        return acmeOrderDataSession.getFinalizedAcmeOrdersByFingerprint(fingerprint);</span>
    }
    
    @Override
    public String persistAcmeOrder(final AcmeOrder acmeOrder) {
<span class="nc" id="L2592">        return acmeOrderDataSession.createOrUpdate(acmeOrder);</span>
    }

    @Override
    public List&lt;String&gt; persistAcmeOrders(final List&lt;AcmeOrder&gt; acmeOrders) {
<span class="nc" id="L2597">        return acmeOrderDataSession.createOrUpdate(acmeOrders);</span>
    }
    
    @Override
    public void removeAcmeOrder(String orderId) {
<span class="nc" id="L2602">        acmeOrderDataSession.remove(orderId);</span>
<span class="nc" id="L2603">    }</span>
    
    @Override
    public void removeAcmeOrders(List&lt;String&gt; orderIds) {
<span class="nc" id="L2607">        acmeOrderDataSession.removeAll(orderIds);</span>
<span class="nc" id="L2608">    }</span>
    
    @Override
    public AcmeAuthorization getAcmeAuthorizationById(String authorizationId) {
<span class="nc" id="L2612">        return acmeAuthorizationDataSession.getAcmeAuthorization(authorizationId);</span>
    }

    @Override
    public List&lt;AcmeAuthorization&gt; getAcmeAuthorizationsByOrderId(String orderId) {
<span class="nc" id="L2617">        return acmeAuthorizationDataSession.getAcmeAuthorizationsByOrderId(orderId);</span>
    }

    @Override
    public List&lt;AcmeAuthorization&gt; getAcmeAuthorizationsByAccountId(String accountId) {
<span class="nc" id="L2622">        return acmeAuthorizationDataSession.getAcmeAuthorizationsByAccountId(accountId);</span>
    }

    @Override
    public String persistAcmeAuthorization(AcmeAuthorization acmeAuthorization) {
<span class="nc" id="L2627">        return acmeAuthorizationDataSession.createOrUpdate(acmeAuthorization);</span>
    }

    @Override
    public void persistAcmeAuthorizationList(List&lt;AcmeAuthorization&gt; acmeAuthorizations) {
<span class="nc" id="L2632">        acmeAuthorizationDataSession.createOrUpdateList(acmeAuthorizations);</span>
<span class="nc" id="L2633">    }</span>

    @Override
    public AcmeChallenge getAcmeChallengeById(String challengeId) {
<span class="nc" id="L2637">        return acmeChallengeDataSession.getAcmeChallenge(challengeId);</span>
    }

    @Override
    public List&lt;AcmeChallenge&gt; getAcmeChallengesByAuthorizationId(String authorizationId) {
<span class="nc" id="L2642">        return acmeChallengeDataSession.getAcmeChallengesByAuthorizationId(authorizationId);</span>
    }

    @Override
    public String persistAcmeChallenge(AcmeChallenge acmeChallenge) {
<span class="nc" id="L2647">        return acmeChallengeDataSession.createOrUpdate(acmeChallenge);</span>
    }

    @Override
    public void persistAcmeChallengeList(List&lt;AcmeChallenge&gt; acmeChallenges) {
<span class="nc" id="L2652">        acmeChallengeDataSession.createOrUpdateList(acmeChallenges);</span>
<span class="nc" id="L2653">    }</span>

    @Override
    public byte[] addUserAndGenerateKeyStore(AuthenticationToken authenticationToken, EndEntityInformation endEntity, boolean clearpwd) throws AuthorizationDeniedException, EjbcaException, WaitingForApprovalException {
        //Authorization
<span class="nc bnc" id="L2658" title="All 2 branches missed.">        if (!endEntityManagementSession.isAuthorizedToEndEntityProfile(authenticationToken, endEntity.getEndEntityProfileId(),</span>
                AccessRulesConstants.DELETE_END_ENTITY)) {
<span class="nc" id="L2660">            log.warn(&quot;Missing *&quot; + AccessRulesConstants.DELETE_END_ENTITY + &quot; rights for user '&quot; + authenticationToken</span>
                    + &quot;' to be able to add an end entity (Delete is only needed for clean-up if something goes wrong after an end-entity has been added)&quot;);
<span class="nc" id="L2662">            return null;</span>
        }

        try {
<span class="nc" id="L2666">            endEntity = endEntityManagementSession.addUser(authenticationToken, endEntity, clearpwd);</span>
<span class="nc" id="L2667">        } catch (CesecoreException e) {</span>
            //Wrapping the CesecoreException.errorCode
<span class="nc" id="L2669">            throw new EjbcaException(e);</span>
<span class="nc" id="L2670">        } catch (EndEntityProfileValidationException e) {</span>
            //Wraps @WebFault Exception based with @NonSensitive EjbcaException based
<span class="nc" id="L2672">            throw new EndEntityProfileValidationRaException(e);</span>
<span class="nc" id="L2673">        }</span>
        KeyStore keyStore;
        try {
<span class="nc" id="L2676">            final EndEntityProfile endEntityProfile = endEntityProfileSession.getEndEntityProfile(endEntity.getEndEntityProfileId());</span>
<span class="nc" id="L2677">            boolean usekeyrecovery = ((GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID)).getEnableKeyRecovery();</span>
<span class="nc" id="L2678">            EndEntityInformation data = endEntityAccessSession.findUser(endEntity.getUsername());</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">            if (data == null) {</span>
<span class="nc" id="L2680">                throw new EjbcaException(ErrorCode.USER_NOT_FOUND, &quot;User '&quot; + endEntity.getUsername() + &quot;' does not exist&quot;);</span>
            }
<span class="nc bnc" id="L2682" title="All 6 branches missed.">            final boolean savekeys = data.getKeyRecoverable() &amp;&amp; usekeyrecovery &amp;&amp; (data.getStatus() != EndEntityConstants.STATUS_KEYRECOVERY);</span>
<span class="nc bnc" id="L2683" title="All 4 branches missed.">            final boolean loadkeys = (data.getStatus() == EndEntityConstants.STATUS_KEYRECOVERY) &amp;&amp; usekeyrecovery;</span>
<span class="nc" id="L2684">            final boolean reusecertificate = endEntityProfile.getReUseKeyRecoveredCertificate();</span>
<span class="nc" id="L2685">            final String encodedValidity = endEntity.getExtendedInformation().getCertificateEndTime();</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">            final Date notAfter = encodedValidity == null ? null : ValidityDate.getDate(encodedValidity, new Date());</span>
<span class="nc" id="L2687">            keyStore = keyStoreCreateSessionLocal.generateOrKeyRecoverToken(authenticationToken,</span>
<span class="nc" id="L2688">                    endEntity.getUsername(), // Username</span>
<span class="nc" id="L2689">                    endEntity.getPassword(), // Enrollment code</span>
<span class="nc" id="L2690">                    endEntity.getCAId(), // The CA signing the private keys</span>
<span class="nc" id="L2691">                    endEntity.getExtendedInformation().getKeyStoreAlgorithmSubType(), // Keylength</span>
<span class="nc" id="L2692">                    endEntity.getExtendedInformation().getKeyStoreAlgorithmType(), // Signature algorithm</span>
                    null, // Not valid before
                    notAfter, // Not valid after
<span class="nc bnc" id="L2695" title="All 2 branches missed.">                    endEntity.getTokenType() == SecConst.TOKEN_SOFT_JKS, // Type of token</span>
                    loadkeys, // Perform key recovery?
                    savekeys, // Save private keys?
                    reusecertificate, // Reuse recovered cert?
<span class="nc" id="L2699">                    endEntity.getEndEntityProfileId()); // Identifier for end entity</span>
<span class="nc" id="L2700">        } catch (KeyStoreException | InvalidAlgorithmParameterException | CADoesntExistsException | IllegalKeyException</span>
                | CertificateCreateException | IllegalNameException | CertificateRevokeException | CertificateSerialNumberException
                | CryptoTokenOfflineException | IllegalValidityException | CAOfflineException | InvalidAlgorithmException
                | CustomCertificateSerialNumberException | CertificateException | NoSuchAlgorithmException | InvalidKeySpecException
                | EndEntityProfileValidationException | CertificateSignatureException | NoSuchEndEntityException e) {
<span class="nc" id="L2705">            throw new KeyStoreGeneralRaException(e);</span>
<span class="nc" id="L2706">        }</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">        if (endEntity.getTokenType() == EndEntityConstants.TOKEN_SOFT_PEM) {</span>
<span class="nc" id="L2708">            try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="nc" id="L2709">                outputStream.write(KeyTools.getSinglePemFromKeyStore(keyStore, endEntity.getPassword().toCharArray()));</span>
<span class="nc" id="L2710">                return outputStream.toByteArray();</span>
<span class="nc" id="L2711">            } catch (IOException | CertificateEncodingException | UnrecoverableKeyException | KeyStoreException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2712">                log.error(e); //should never happen if keyStore is valid object</span>
<span class="nc" id="L2713">            }</span>
        } else {
<span class="nc" id="L2715">            try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="nc" id="L2716">                keyStore.store(outputStream, endEntity.getPassword().toCharArray());</span>
<span class="nc" id="L2717">                return outputStream.toByteArray();</span>
<span class="nc" id="L2718">            } catch (IOException | KeyStoreException | NoSuchAlgorithmException | CertificateException e) {</span>
<span class="nc" id="L2719">                log.error(e); //should never happen if keyStore is valid object</span>
            }
        }
<span class="nc" id="L2722">        return null;</span>
    }


    @Override
    public byte[] addUserAndCreateCertificate(AuthenticationToken authenticationToken, EndEntityInformation endEntityInformation, boolean clearpwd) throws AuthorizationDeniedException, EjbcaException, WaitingForApprovalException {
<span class="nc bnc" id="L2728" title="All 4 branches missed.">        if(endEntityInformation.getExtendedInformation() == null || endEntityInformation.getExtendedInformation().getCertificateRequest() == null){</span>
<span class="nc" id="L2729">            throw new IllegalArgumentException(&quot;Could not find CSR for end entity with username &quot; + endEntityInformation.getUsername() + &quot; CSR must be set under endEntityInformation.extendedInformation.certificateRequest&quot;);</span>
        }
        //Authorization
<span class="nc bnc" id="L2732" title="All 2 branches missed.">        if (!endEntityManagementSession.isAuthorizedToEndEntityProfile(authenticationToken, endEntityInformation.getEndEntityProfileId(),</span>
                AccessRulesConstants.DELETE_END_ENTITY)) {
<span class="nc" id="L2734">            log.warn(&quot;Missing *&quot; + AccessRulesConstants.DELETE_END_ENTITY + &quot; rights for user '&quot; + authenticationToken</span>
                    + &quot;' to be able to add an end entity (Delete is only needed for clean-up if something goes wrong after an end-entity has been added)&quot;);
<span class="nc" id="L2736">            return null;</span>
        }

        try {
<span class="nc" id="L2740">            endEntityInformation = endEntityManagementSession.addUser(authenticationToken, endEntityInformation, clearpwd);</span>
<span class="nc" id="L2741">        } catch (CesecoreException e) {</span>
            //Wrapping the CesecoreException.errorCode
<span class="nc" id="L2743">            throw new EjbcaException(e);</span>
<span class="nc" id="L2744">        } catch (EndEntityProfileValidationException e) {</span>
            //Wraps @WebFault Exception based with @NonSensitive EjbcaException based
<span class="nc" id="L2746">            throw new EndEntityProfileValidationRaException(e);</span>
<span class="nc" id="L2747">        }</span>
<span class="nc" id="L2748">        PKCS10RequestMessage req = RequestMessageUtils.genPKCS10RequestMessage(endEntityInformation.getExtendedInformation().getCertificateRequest());</span>
<span class="nc" id="L2749">        req.setUsername(endEntityInformation.getUsername());</span>
<span class="nc" id="L2750">        req.setPassword(endEntityInformation.getPassword());</span>
<span class="nc" id="L2751">        final String encodedValidity = endEntityInformation.getExtendedInformation().getCertificateEndTime();</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">        req.setNotAfter(encodedValidity == null ? null : ValidityDate.getDate(encodedValidity, new Date()));</span>
        try {
<span class="nc" id="L2754">            ResponseMessage resp = signSessionLocal.createCertificate(authenticationToken, req, X509ResponseMessage.class, null);</span>
<span class="nc" id="L2755">            X509Certificate cert = CertTools.getCertfromByteArray(resp.getResponseMessage(), X509Certificate.class);</span>
<span class="nc" id="L2756">            return cert.getEncoded();</span>
<span class="nc" id="L2757">        } catch (NoSuchEndEntityException | CustomCertificateSerialNumberException | CryptoTokenOfflineException | IllegalKeyException</span>
                | CADoesntExistsException | SignRequestException | SignRequestSignatureException | IllegalNameException | CertificateCreateException
                | CertificateRevokeException | CertificateSerialNumberException | IllegalValidityException | CAOfflineException
                | InvalidAlgorithmException | CertificateExtensionException e) {
<span class="nc" id="L2761">            throw new EjbcaException(e);</span>
<span class="nc" id="L2762">        } catch (CertificateParsingException | CertificateEncodingException e) {</span>
<span class="nc" id="L2763">            throw new IllegalStateException(&quot;Internal error with creating X509Certificate from CertificateResponseMessage&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>