<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CustomPublisherContainer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">EJB-CA Common code</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.model.ca.publisher</a> &gt; <span class="el_source">CustomPublisherContainer.java</span></div><h1>CustomPublisherContainer.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
 
package org.ejbca.core.model.ca.publisher;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.cert.Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.certificates.certificate.Base64CertData;
import org.cesecore.certificates.certificate.CertificateData;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.cesecore.util.StringTools;



/**
 * CustomPublisherContainer is a class handling a custom publisher. It is used 
 * to store and retrieve custom publisher configuration to database.
 * 
 *
 * @version $Id: CustomPublisherContainer.java 34192 2020-01-07 15:10:21Z aminkh $
 */
public class CustomPublisherContainer extends BasePublisher {
	private static final long serialVersionUID = -7060678968358301488L;

<span class="nc" id="L54">    private static final Logger log = Logger.getLogger(CustomPublisherContainer.class);</span>

<span class="nc" id="L56">    private ICustomPublisher custompublisher = null; </span>
	
	public static final float LATEST_VERSION = 1;
		
	// Default Values
    
    public static final String CLASSPATH = &quot;classpath&quot;;
    protected static final String PROPERTYDATA = &quot;propertydata&quot;;
		
    public CustomPublisherContainer(){
<span class="nc" id="L66">    	super();</span>
<span class="nc" id="L67">    	data.put(TYPE, Integer.valueOf(PublisherConst.TYPE_CUSTOMPUBLISHERCONTAINER));</span>
<span class="nc" id="L68">    	setClassPath(&quot;&quot;);</span>
    	try {
<span class="nc" id="L70">            setPropertyData(&quot;&quot;);</span>
<span class="nc" id="L71">        } catch (PublisherException e) {</span>
<span class="nc" id="L72">            throw new IllegalStateException();</span>
<span class="nc" id="L73">        }</span>
<span class="nc" id="L74">    }</span>
    
    /**
     * Copy constructor taking a BasePublisher returning a CustomPublisherContainer based on its values. 
     * @param basePublisher publisher
     */
	public CustomPublisherContainer(BasePublisher basePublisher) {
<span class="nc" id="L81">		super(basePublisher);</span>
<span class="nc" id="L82">		data.put(TYPE, Integer.valueOf(PublisherConst.TYPE_CUSTOMPUBLISHERCONTAINER));</span>
<span class="nc" id="L83">		setClassPath(&quot;&quot;);</span>
		try {
<span class="nc" id="L85">			setPropertyData(&quot;&quot;);</span>
<span class="nc" id="L86">		} catch (PublisherException e) {</span>
<span class="nc" id="L87">			throw new IllegalStateException();</span>
<span class="nc" id="L88">		}</span>
<span class="nc" id="L89">	}</span>
    
    // Public Methods    
    /**
     *  Returns the class path of custom publisher used.
     * @return path
     */    
    public String getClassPath() {
<span class="nc" id="L97">    	return (String) data.get(CLASSPATH);</span>
    }

    /**
     *  Sets the class path of custom publisher used.
     * @param classpath Path
     */        
	public void setClassPath(String classpath){
<span class="nc" id="L105">	  data.put(CLASSPATH, classpath);	</span>
<span class="nc" id="L106">	}</span>

	/**
	 *  Returns the propertydata used to configure this custom publisher.
	 * @return Data
	 */    
	public String getPropertyData(){
<span class="nc" id="L113">		return (String) data.get(PROPERTYDATA);</span>
	}

	/**
	 *  Sets the propertydata used to configure this custom publisher.
	 * @param propertydata data
	 * @throws PublisherException on fail 
	 */   
	public void setPropertyData(String propertydata) throws PublisherException {
<span class="nc bnc" id="L122" title="All 2 branches missed.">	    if(isCustomUiRenderingSupported()) {</span>
<span class="nc" id="L123">            CustomPublisherUiSupport publisher = (CustomPublisherUiSupport) getCustomPublisher();</span>
	        //Check if any fields are passwords, and encrypt those
<span class="nc" id="L125">	        Properties properties = new Properties();</span>
	        try {
<span class="nc" id="L127">	            properties.load(new ByteArrayInputStream(propertydata.getBytes()));</span>
<span class="nc" id="L128">	        } catch (IOException e) {</span>
<span class="nc" id="L129">	            throw new IllegalArgumentException(&quot;Properties could not be loaded.&quot;, e);</span>
<span class="nc" id="L130">	        }</span>
<span class="nc" id="L131">	        StringBuilder encryptedProperties = new StringBuilder();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">	        for(Object key : properties.keySet()) {</span>
	            String value;
<span class="nc" id="L134">	            int propertyType = publisher.getPropertyType((String)key);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">	            if(propertyType == CustomPublisherProperty.UI_TEXTINPUT_PASSWORD) {</span>
	                //Property is of a type that shouldn't be written in clear text to disk. Encrypt!
	                try {
<span class="nc" id="L138">                        value = StringTools.pbeEncryptStringWithSha256Aes192(properties.getProperty((String) key));</span>
<span class="nc" id="L139">                    } catch (InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException</span>
                            | InvalidKeySpecException e) {
<span class="nc" id="L141">                        throw new IllegalStateException(&quot;Could not encrypt private key password!&quot;, e);</span>
<span class="nc" id="L142">                    }</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">				} else if ((propertyType == CustomPublisherProperty.UI_TEXTINPUT)</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">						&amp;&amp; &quot;dataSource&quot;.equals((String) key)) {</span>
<span class="nc" id="L145">					value = properties.getProperty((String) key);</span>
<span class="nc" id="L146">					validateDataSource(value);</span>
				} else {
<span class="nc" id="L148">					value = properties.getProperty((String) key);</span>
				}
<span class="nc" id="L150">	            encryptedProperties.append(key + &quot;=&quot; + value + &quot;\n&quot;);</span>
<span class="nc" id="L151">	        }</span>
<span class="nc" id="L152">	        data.put(PROPERTYDATA, encryptedProperties.toString());  </span>
<span class="nc" id="L153">	    } else {</span>
<span class="nc" id="L154">	        data.put(PROPERTYDATA, propertydata);  </span>
	    }

		
<span class="nc" id="L158">	}</span>
	
	public boolean isCustomAccessRulesSupported() {
<span class="nc" id="L161">	    return getCustomPublisher() instanceof CustomPublisherAccessRulesSupport;</span>
	}
	
    public boolean isAuthorizedToPublisher(AuthenticationToken authenticationToken) {
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (getCustomPublisher() instanceof CustomPublisherAccessRulesSupport) {</span>
<span class="nc" id="L166">            return ((CustomPublisherAccessRulesSupport)getCustomPublisher()).isAuthorizedToPublisher(authenticationToken);</span>
        }
<span class="nc" id="L168">        return true;</span>
    }

    public boolean isCustomUiRenderingSupported() {
<span class="nc" id="L172">	    return getCustomPublisher() instanceof CustomPublisherUiSupport;</span>
	}
    public List&lt;CustomPublisherProperty&gt; getCustomUiPropertyList(final AuthenticationToken authenticationToken) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (getCustomPublisher() instanceof CustomPublisherUiSupport) {</span>
<span class="nc" id="L176">            return ((CustomPublisherUiSupport)getCustomPublisher()).getCustomUiPropertyList(authenticationToken);</span>
        }
<span class="nc" id="L178">        return new ArrayList&lt;&gt;();</span>
    }
    
    private List&lt;String&gt; getCustomUiPropertyNames() {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (getCustomPublisher() instanceof CustomPublisherUiSupport) {</span>
<span class="nc" id="L183">            return ((CustomPublisherUiSupport)getCustomPublisher()).getCustomUiPropertyNames();</span>
        }
<span class="nc" id="L185">        return new ArrayList&lt;&gt;();</span>
    }
	
    public Properties getProperties() {
<span class="nc" id="L189">        final Properties properties = new Properties();</span>
<span class="nc" id="L190">        final String propertyData = getPropertyData();</span>
        // Re-Factor: Here the strings are escaped: \\ -&gt; \; \n -&gt; new line, etc.
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (propertyData != null) {</span>
            try {
<span class="nc" id="L194">                properties.load(new ByteArrayInputStream(propertyData.getBytes()));</span>
<span class="nc" id="L195">            } catch (IOException e) {</span>
<span class="nc" id="L196">                throw new IllegalStateException(&quot;Could not retrieve properties from database&quot;, e);</span>
<span class="nc" id="L197">            }</span>
        }
        /*
         * The below code is only to be able to handle the change of our EnterpriseValidationAuthorityPublisher from
         * built in to custom type.
         * 
         * Since the built in type had its properties in XML we need to provide a one time upgrade path.
         * The old settings will still be present in the XML, but can be removed in a future version with a
         * deterministic upgrade gate version to ensure that all installation data looks the same.
         * 
         * Note that for example get/setDescription belongs to the BasePublisher and not the ICustomPublisher instance.
         * This is just one of many small things that needs to be corrected in a major version rewrite.
         */
<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (final String key : getCustomUiPropertyNames()) {</span>
<span class="nc bnc" id="L211" title="All 4 branches missed.">            if (!properties.containsKey(key) &amp;&amp; data.get(key)!=null) {</span>
                // If this is a publisher that used to have it's specific properties in the &quot;data&quot;, we need to provide an upgrade conversion path ONCE
<span class="nc" id="L213">                properties.setProperty(key, String.valueOf(data.get(key)));</span>
            }
<span class="nc" id="L215">        }</span>
<span class="nc" id="L216">		return properties;</span>
	}
  
	@Override
	public boolean isFullEntityPublishingSupported() {
<span class="nc bnc" id="L221" title="All 2 branches missed.">	    return getCustomPublisher() instanceof FullEntityPublisher</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">	            &amp;&amp; ((FullEntityPublisher)getCustomPublisher()).isFullEntityPublishingSupported();</span>
	}
    
    @Override
    public boolean storeCertificate(final AuthenticationToken authenticationToken, final CertificateData certificateData, final Base64CertData base64CertData) throws PublisherException {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (isFullEntityPublishingSupported()) {</span>
<span class="nc" id="L228">            return ((FullEntityPublisher)this.getCustomPublisher()).storeCertificate(authenticationToken, certificateData, base64CertData);</span>
        } else {
<span class="nc" id="L230">            return super.storeCertificate(authenticationToken, certificateData, base64CertData);</span>
        }
    }

	/**
	 * @see org.ejbca.core.model.ca.publisher.BasePublisher
	 */
    @Override
    public boolean storeCertificate(AuthenticationToken admin, Certificate incert, String username, String password, String userDN, String cafp,
            int status, int type, long revocationDate, int revocationReason, String tag, int certificateProfileId, long lastUpdate,
            ExtendedInformation extendedinformation) throws PublisherException {
<span class="nc" id="L241">        return this.getCustomPublisher().storeCertificate(admin, incert, username, password, userDN, cafp, status, type, revocationDate,</span>
                revocationReason, tag, certificateProfileId, lastUpdate, extendedinformation);
    }
	
	/**
	 * @see org.ejbca.core.model.ca.publisher.BasePublisher
	 */    
	public boolean storeCRL(AuthenticationToken admin, byte[] incrl, String cafp, int number, String userDN) throws PublisherException{
<span class="nc" id="L249">		return this.getCustomPublisher().storeCRL(admin,incrl,cafp,number,userDN);		</span>
	}
    
	/**
	 * @see org.ejbca.core.model.ca.publisher.BasePublisher
	 */    
	public void testConnection() throws PublisherConnectionException{
<span class="nc" id="L256">        this.getCustomPublisher().testConnection();</span>
<span class="nc" id="L257">	} </span>

	/**
	 * The ICustomPublisher is the custom implementation used for the actual publishing work.
	 * 
	 * Note that this class can only be queried about its specific settings (and not common base settings like
	 * publisher description or queue settings).
	 * 
	 * @return the custom publisher wrapped by this class, null if none is defined. 
	 */
	public ICustomPublisher getCustomPublisher() {
<span class="nc bnc" id="L268" title="All 2 branches missed.">		if(custompublisher == null){</span>
<span class="nc" id="L269">		    final String classPath = getClassPath();</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">		    if (classPath==null || classPath.isEmpty()) {</span>
<span class="nc" id="L271">		        return null;</span>
		    }
			try{
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L275">                Class&lt;? extends ICustomPublisher&gt; implClass = (Class&lt;? extends ICustomPublisher&gt;) Class.forName( classPath );</span>
<span class="nc" id="L276">				this.custompublisher =  implClass.getConstructor().newInstance();</span>
<span class="nc" id="L277">				this.custompublisher.init(getProperties());				</span>
<span class="nc" id="L278">            } catch (ClassNotFoundException e) {</span>
                // Probably means that we have not built in our custom publisher here in EJBCA, or it's an Enterprise only 
                // publisher configured (Peer publisher for example)
<span class="nc" id="L281">                log.info(&quot;Publisher class &quot;+classPath+&quot; is not available in this version/build of EJBCA.&quot;);</span>
<span class="nc" id="L282">                return null;</span>
<span class="nc" id="L283">            } catch (IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException iae) {</span>
<span class="nc" id="L284">                throw new IllegalStateException(iae);</span>
<span class="nc" id="L285">            } </span>
		}
		
<span class="nc" id="L288">		return custompublisher;</span>
	}
		
	/** 
	 * @see org.ejbca.core.model.ca.publisher.BasePublisher#clone()
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L296">		CustomPublisherContainer clone = new CustomPublisherContainer();</span>
<span class="nc" id="L297">        HashMap clonedata = (HashMap) clone.saveData();</span>

<span class="nc" id="L299">		Iterator i = (data.keySet()).iterator();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">		while(i.hasNext()){</span>
<span class="nc" id="L301">			Object key = i.next();</span>
<span class="nc" id="L302">			clonedata.put(key, data.get(key));</span>
<span class="nc" id="L303">		}</span>

<span class="nc" id="L305">		clone.loadData(clonedata);</span>
<span class="nc" id="L306">		return clone;	</span>
		}

	/* *
	 * @see org.ejbca.core.model.ca.publisher.BasePublisher#getLatestVersion()
	 */
	public float getLatestVersion() {		
<span class="nc" id="L313">		return LATEST_VERSION;</span>
	}

	/**
	 * Resets the current custom publisher
	 * @see org.cesecore.internal.UpgradeableDataHashMap#saveData()
	 */
	public Object saveData() {
<span class="nc" id="L321">		this.custompublisher = null;</span>
<span class="nc" id="L322">		return super.saveData();</span>
	}

    @Override
    public boolean willPublishCertificate(int status, int revocationReason) {
<span class="nc" id="L327">        return getCustomPublisher().willPublishCertificate(status, revocationReason);</span>
    }

    @Override
    public void validateDataSource(String dataSource) throws PublisherException {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (StringUtils.isNotBlank(dataSource)) {</span>
<span class="nc" id="L333">            final Pattern dataSourcePattern = Pattern.compile(&quot;^(java):/.*$&quot;);</span>
<span class="nc" id="L334">            final Matcher dataSrouceMatcher = dataSourcePattern.matcher(dataSource);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (dataSrouceMatcher.find()) {</span>
<span class="nc" id="L336">                return;</span>
            }
        }
<span class="nc" id="L339">        throw new PublisherException(&quot;Invalid data source!&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>