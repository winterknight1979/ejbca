<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GlobalAcmeConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ejbca-common</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.config</a> &gt; <span class="el_source">GlobalAcmeConfiguration.java</span></div><h1>GlobalAcmeConfiguration.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA - Proprietary Modules: Enterprise Certificate Authority        *
 *                                                                       *
 *  Copyright (c), PrimeKey Solutions AB. All rights reserved.           *
 *  The use of the Proprietary Modules are subject to specific           * 
 *  commercial license terms.                                            *
 *                                                                       *
 *************************************************************************/
package org.ejbca.config;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.configuration.ConfigurationBase;

/**
 * Global Configuration object which holds all the AcmeConfigurations and generic protocol settings.
 * 
 * @version $Id: GlobalAcmeConfiguration.java 29424 2018-07-02 10:08:09Z jekaterina_b_helmes $
 */
<span class="nc" id="L30">public class GlobalAcmeConfiguration extends ConfigurationBase {</span>

    private static final long serialVersionUID = 1L;
    //private static final Logger log = Logger.getLogger(GlobalAcmeConfiguration.class);

    public static final String ACME_CONFIGURATION_ID = &quot;ACME&quot;;
    
    private static final String KEY_INITIALIZED = &quot;initialized&quot;;
    private static final String KEY_DEFAULT_ACME_CONFIGURATION_ID = &quot;defaultAcmeConfigurationId&quot;;
    private static final String KEY_ACME_CONFIGURATION_PREFIX = &quot;acmeConfiguration_&quot;;
    private static final String KEY_REPLAY_NONCE_VALIDITY = &quot;replayNonceValiditity&quot;;
    private static final String KEY_REPLAY_NONCE_SECRETS_HMAC_WITH_SHA256 = &quot;replayNonceSecretsHmacWithSHA256&quot;;

    @Override
<span class="nc" id="L44">    public void upgrade() {}</span>

    @Override
    public String getConfigurationId() {
<span class="nc" id="L48">        return ACME_CONFIGURATION_ID;</span>
    }

    public Properties getAsProperties() {
<span class="nc" id="L52">        final Properties properties = new Properties();</span>
<span class="nc" id="L53">        properties.put(KEY_INITIALIZED, isInitialized());</span>
<span class="nc" id="L54">        properties.put(KEY_DEFAULT_ACME_CONFIGURATION_ID, getDefaultAcmeConfigurationId());</span>
<span class="nc" id="L55">        properties.put(KEY_REPLAY_NONCE_VALIDITY, getReplayNonceValidity());</span>
<span class="nc" id="L56">        properties.put(&quot;acmeConfigurationIds&quot;, Arrays.toString(getAcmeConfigurationIds().toArray()));</span>
<span class="nc" id="L57">        properties.put(KEY_REPLAY_NONCE_SECRETS_HMAC_WITH_SHA256,</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">                getReplayNonceSharedSecrets(PKCSObjectIdentifiers.id_hmacWithSHA256.getId())==null ? &quot;not configured&quot; : &quot;configured&quot;);</span>
<span class="nc" id="L59">        return properties;</span>
    }

    /** @return true if this global configuration has been initialized */
    public boolean isInitialized() {
<span class="nc" id="L64">        return Boolean.valueOf((String)super.data.get(KEY_INITIALIZED));</span>
    }
    /** @param initialized Set to true when this global configuration has been initialized */
    public void setInitialized(final boolean initialized) {
<span class="nc" id="L68">        super.data.put(KEY_INITIALIZED, String.valueOf(initialized));</span>
<span class="nc" id="L69">    }</span>

    /** @return the default configured AcmeConfiguration IDs that will be used if none is specified in the request path */
    public String getDefaultAcmeConfigurationId() {
<span class="nc" id="L73">        return (String) data.get(KEY_DEFAULT_ACME_CONFIGURATION_ID);</span>
    }
    /** @param defaultAcmeConfigurationId Set the default configured AcmeConfiguration IDs that will be used if none is specified in the request path */
    public void setDefaultAcmeConfigurationId(final String defaultAcmeConfigurationId) {
<span class="nc" id="L77">        data.put(KEY_DEFAULT_ACME_CONFIGURATION_ID, defaultAcmeConfigurationId);</span>
<span class="nc" id="L78">    }</span>

    /** @return all the configured AcmeConfiguration IDs */
    public List&lt;String&gt; getAcmeConfigurationIds() {
<span class="nc" id="L82">        final Set&lt;String&gt; acmeConfigurationIds = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        for (final Object key : data.keySet()) {</span>
<span class="nc bnc" id="L84" title="All 4 branches missed.">            if (key instanceof String &amp;&amp; ((String)key).startsWith(KEY_ACME_CONFIGURATION_PREFIX)) {</span>
<span class="nc" id="L85">                acmeConfigurationIds.add(((String)key).substring(KEY_ACME_CONFIGURATION_PREFIX.length()));</span>
            }
<span class="nc" id="L87">        }</span>
<span class="nc" id="L88">        return new ArrayList&lt;String&gt;(acmeConfigurationIds);</span>
    }

    /** @param configurationId ID
     * @return the AcmeConfiguration that will be based on the configurationId specified in the request path */
    public AcmeConfiguration getAcmeConfiguration(final String configurationId) {
<span class="nc" id="L94">        final Object upgradeableDataHashMapData = data.get(KEY_ACME_CONFIGURATION_PREFIX + configurationId);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (upgradeableDataHashMapData==null) {</span>
<span class="nc" id="L96">            return null;</span>
        }
<span class="nc" id="L98">        final AcmeConfiguration acmeConfiguration = new AcmeConfiguration(upgradeableDataHashMapData);</span>
<span class="nc" id="L99">        acmeConfiguration.setConfigurationId(configurationId);</span>
<span class="nc" id="L100">        return acmeConfiguration;</span>
    }
    /** @param acmeConfiguration Overwrite and update the persisted AcmeConfiguration */
    public void updateAcmeConfiguration(final AcmeConfiguration acmeConfiguration) {
<span class="nc" id="L104">        data.put(KEY_ACME_CONFIGURATION_PREFIX + acmeConfiguration.getConfigurationId(), acmeConfiguration.saveData());</span>
<span class="nc" id="L105">    }</span>

    /** @return the validity period of newly generated nonces */
    public long getReplayNonceValidity() {
<span class="nc" id="L109">        final Long replayNonceValidity = (Long)data.get(KEY_REPLAY_NONCE_VALIDITY);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        return replayNonceValidity==null ? 600*1000L : replayNonceValidity.longValue();</span>
    }
    public void setReplayNonceValidity(final long replayNonceValidity) {
<span class="nc" id="L113">        data.put(KEY_REPLAY_NONCE_VALIDITY, replayNonceValidity);</span>
<span class="nc" id="L114">    }</span>

    /** @param hmacOid OID
     * @return all replay-nonce secrets for the specified algorithm that have been configured 
     * @throws IllegalArgumentException Bad arg 
     * @throws IllegalStateException BAd state */
    @SuppressWarnings(&quot;unchecked&quot;)
    public ArrayList&lt;String&gt; getReplayNonceSharedSecrets(final String hmacOid) throws IllegalArgumentException, IllegalStateException {
        final ArrayList&lt;String&gt; sharedSecretStrings;
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (PKCSObjectIdentifiers.id_hmacWithSHA256.getId().equals(hmacOid)) {</span>
<span class="nc" id="L124">            sharedSecretStrings = (ArrayList&lt;String&gt;)data.get(KEY_REPLAY_NONCE_SECRETS_HMAC_WITH_SHA256);</span>
        } else {
<span class="nc" id="L126">            throw new IllegalArgumentException(&quot;Unsupported hmac algorithm '&quot; + hmacOid + &quot;'.&quot;);</span>
        }
<span class="nc bnc" id="L128" title="All 4 branches missed.">        if (sharedSecretStrings==null || sharedSecretStrings.isEmpty()) {</span>
<span class="nc" id="L129">            throw new IllegalStateException(&quot;No secret for replay protection has been configured yet for this algorithm '&quot; + hmacOid + &quot;'.&quot;);</span>
        }
<span class="nc" id="L131">        return sharedSecretStrings;</span>
    }

    /** @param hmacOid OID
     * @return the latest replay-nonce secret for the specified algorithm that have been configured 
     * @throws IllegalArgumentException Bad arg 
     * @throws IllegalStateException  Bad state */
    public byte[] getReplayNonceSharedSecretCurrent(final String hmacOid) throws IllegalArgumentException, IllegalStateException {
<span class="nc" id="L139">        final ArrayList&lt;String&gt; replayNonceSharedSecrets = getReplayNonceSharedSecrets(hmacOid);</span>
<span class="nc" id="L140">        return Hex.decode(replayNonceSharedSecrets.get(replayNonceSharedSecrets.size()-1));</span>
    }

    /** Add a new replay-nonce secret for the specified algorithm to use for all new generated replay-nonces 
     * @param hmacOid OID
     * @param secret Secret
     * @throws IllegalArgumentException BAd arg 
     * @throws IllegalStateException Bad state*/
    public void addReplayNonceSharedSecret(final String hmacOid, byte[] secret) throws IllegalArgumentException, IllegalStateException {
        // TODO: Use obfuscation during serialized transfer, but StringTools.encrypt when data is at rest
        // TODO: Consider also adding a timestamp to when the new secret was added, to allow smooth purge of old secret during roll-over
<span class="nc" id="L151">        final String sharedSecretString = new String(Hex.encode(secret), StandardCharsets.UTF_8);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (PKCSObjectIdentifiers.id_hmacWithSHA256.getId().equals(hmacOid)) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L154">            ArrayList&lt;String&gt; sharedSecretStrings = (ArrayList&lt;String&gt;)data.get(KEY_REPLAY_NONCE_SECRETS_HMAC_WITH_SHA256);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (sharedSecretStrings==null) {</span>
<span class="nc" id="L156">                sharedSecretStrings = new ArrayList&lt;&gt;();</span>
            }
<span class="nc" id="L158">            sharedSecretStrings.add(sharedSecretString);</span>
<span class="nc" id="L159">            data.put(KEY_REPLAY_NONCE_SECRETS_HMAC_WITH_SHA256, sharedSecretStrings);</span>
<span class="nc" id="L160">        } else {</span>
<span class="nc" id="L161">            throw new IllegalArgumentException(&quot;Unsupported hmac algorithm '&quot; + hmacOid + &quot;'.&quot;);</span>
        }
<span class="nc" id="L163">    }</span>

    public boolean aliasExists(String configurationId) {
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if(StringUtils.isNotEmpty(configurationId)) {</span>
<span class="nc" id="L167">            AcmeConfiguration acmeConfiguration = getAcmeConfiguration(configurationId);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            return acmeConfiguration != null;</span>
        }
<span class="nc" id="L170">        return false;</span>
    }

    public void renameConfigId(String newConfigId, String oldConfigId){
<span class="nc" id="L174">        AcmeConfiguration acmeConfiguration = getAcmeConfiguration(oldConfigId);</span>
<span class="nc" id="L175">        acmeConfiguration.setConfigurationId(newConfigId);</span>
<span class="nc" id="L176">        removeConfigId(oldConfigId);</span>
<span class="nc" id="L177">        updateAcmeConfiguration(acmeConfiguration);</span>
<span class="nc" id="L178">    }</span>

    public void removeConfigId(String configId){
<span class="nc" id="L181">        data.remove(KEY_ACME_CONFIGURATION_PREFIX + configId);</span>
<span class="nc" id="L182">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>