<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AdminGroupData.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-entity</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.roles</a> &gt; <span class="el_source">AdminGroupData.java</span></div><h1>AdminGroupData.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.roles;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import javax.persistence.Entity;
import javax.persistence.PostLoad;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;
import javax.persistence.Transient;
import org.cesecore.authorization.rules.AccessRuleData;
import org.cesecore.authorization.rules.AccessRuleState;
import org.cesecore.authorization.user.AccessUserAspectData;
import org.cesecore.dbprotection.ProtectedData;
import org.cesecore.dbprotection.ProtectionStringBuilder;

/**
 * Represents a role, and is based in the AdminGroup concept from EJBCA.
 *
 * @version $Id: AdminGroupData.java 25021 2017-01-18 01:30:19Z jeklund $
 */
@Deprecated // EJBCA 6.8.0
@Entity
@Table(name = &quot;AdminGroupData&quot;)
public class AdminGroupData extends ProtectedData
    implements Serializable, Comparable&lt;AdminGroupData&gt; {

      /** Param. */
  public static final String DEFAULT_ROLE_NAME = &quot;DEFAULT&quot;;

  private static final long serialVersionUID = -160810489638829430L;
  /** Param. */
  private Integer primaryKey;
  /** Param. */
  private Map&lt;Integer, AccessRuleData&gt; accessRules;
  /** Param. */
  private Map&lt;Integer, AccessUserAspectData&gt; accessUsers;
  /** Param. */
  private String roleName;
  /** Param. */
<span class="pc" id="L54">  private int rowVersion = 0;</span>
  /** Param. */
  private String rowProtection;

  /**
   * Null constructor. */
<span class="nc" id="L60">  public AdminGroupData() { }</span>

  /**
   * @param aPrimaryKey PK
   * @param aRoleName Name
   */
<span class="fc" id="L66">  public AdminGroupData(final Integer aPrimaryKey, final String aRoleName) {</span>
<span class="fc" id="L67">    this.primaryKey = aPrimaryKey;</span>
<span class="fc" id="L68">    this.roleName = aRoleName;</span>
<span class="fc" id="L69">    accessUsers = new HashMap&lt;Integer, AccessUserAspectData&gt;();</span>
<span class="fc" id="L70">    accessRules = new HashMap&lt;Integer, AccessRuleData&gt;();</span>
<span class="fc" id="L71">  }</span>

  /**
   * @return PK
   */
  // @Id @Column
  public Integer getPrimaryKey() {
<span class="fc" id="L78">    return primaryKey;</span>
  }

  /**
   * @param aPrimaryKey PK
   */
  public void setPrimaryKey(final Integer aPrimaryKey) {
<span class="fc" id="L85">    this.primaryKey = aPrimaryKey;</span>
<span class="fc" id="L86">  }</span>

  /**
   * @return name
   */
  // @Column
  public String getRoleName() {
<span class="fc" id="L93">    return roleName;</span>
  }

  /**
   * @param aRoleName name
   */
  public void setRoleName(final String aRoleName) {
<span class="fc" id="L100">    this.roleName = aRoleName;</span>
<span class="fc" id="L101">  }</span>

  /**
   * @return version
   */
  // @Version @Column
  public int getRowVersion() {
<span class="fc" id="L108">    return rowVersion;</span>
  }

  /**
   * @param aRowVersion version
   */
  public void setRowVersion(final int aRowVersion) {
<span class="fc" id="L115">    this.rowVersion = aRowVersion;</span>
<span class="fc" id="L116">  }</span>

  // @Column @Lob
  @Override
  public String getRowProtection() {
<span class="fc" id="L121">    return rowProtection;</span>
  }

  @Override
  public void setRowProtection(final String aRowProtection) {
<span class="fc" id="L126">    this.rowProtection = aRowProtection;</span>
<span class="fc" id="L127">  }</span>

  /**
   * If we use lazy fetching we have to take care so that the Entity is
   * managed until we fetch the values. Set works better with eager fetching for
   * Hibernate.
 * @return map
   */
  // @OneToMany(cascade = { CascadeType.ALL }, fetch = FetchType.EAGER)
  // @JoinColumn(name = &quot;RoleData_accessUsers&quot;)
  public Map&lt;Integer, AccessUserAspectData&gt; getAccessUsers() {
<span class="fc" id="L138">    return accessUsers;</span>
  }

  /**
   * @param theAccessUsers mao
   */
  public void setAccessUsers(
      final Map&lt;Integer, AccessUserAspectData&gt; theAccessUsers) {
<span class="fc" id="L146">    this.accessUsers = theAccessUsers;</span>
<span class="fc" id="L147">  }</span>

  /**
   * If we use lazy fetching we have to take care so that the Entity is
   * managed until we fetch the values. Set works better with eager fetching for
   * Hibernate.
 * @return map
   */
  // @OneToMany(cascade = { CascadeType.ALL }, fetch = FetchType.EAGER)
  // @JoinColumn(name = &quot;RoleData_accessRules&quot;)
  public Map&lt;Integer, AccessRuleData&gt; getAccessRules() {
<span class="fc" id="L158">    return accessRules;</span>
  }

  /**
   * @param theAccessRules rules
   */
  public void setAccessRules(
          final Map&lt;Integer, AccessRuleData&gt; theAccessRules) {
<span class="fc" id="L166">    this.accessRules = theAccessRules;</span>
<span class="fc" id="L167">  }</span>

  /**
   * Utility method that makes a tree search of this Role's rules and checks for
   * a positive match.
   *
   * @param rule the rule to check
   * @return true if this Role has access to the given rule.
   */
  @Transient
  public boolean hasAccessToRule(final String rule) {
<span class="fc" id="L178">    return hasAccessToRule(rule, false);</span>
  }

  /**
   * Utility method that makes a tree search of this Role's rules and checks for
   * a positive match.
   *
   * @param rule the rule to check
   * @param requireRecursive if rule has to be recursive (for an an exact match)
   * @return true if this Role has access to the given rule.
   */
  @Transient
  public boolean hasAccessToRule(
      final String rule, final boolean requireRecursive) {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">    if (!rule.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L193">      throw new IllegalArgumentException(&quot;Rule must start with a \&quot;/\&quot;&quot;);</span>
    }
<span class="fc" id="L195">    boolean result = false;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">    for (AccessRuleData accessRuleData : accessRules.values()) {</span>
<span class="fc" id="L197">      String currentRule = accessRuleData.getAccessRuleName();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">      if (rule.equals(currentRule)) {</span>
<span class="fc" id="L199">        if (accessRuleData</span>
<span class="fc" id="L200">            .getInternalState()</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            .equals(AccessRuleState.RULE_ACCEPT)) {</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">          if (requireRecursive) {</span>
<span class="fc" id="L203">            result = accessRuleData.getRecursiveBool();</span>
          } else {
<span class="fc" id="L205">            result = true;</span>
          }
        } else {
<span class="fc" id="L208">          result = false;</span>
<span class="fc" id="L209">          break;</span>
        }
<span class="fc bfc" id="L211" title="All 4 branches covered.">      } else if (rule.startsWith(currentRule) || currentRule.startsWith(rule)) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (rule.length() &gt; currentRule.length()</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            &amp;&amp; currentRule.length() &gt; 1</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">            &amp;&amp; rule.charAt(currentRule.length()) != '/') {</span>
          // Not a parent rule but just one with a similar name, compare
          // /foo/bar to /foo_bar,
          // also ignoring the root &quot;/&quot; rule.
<span class="fc" id="L218">          continue;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        } else if (rule.length() &lt; currentRule.length()</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            &amp;&amp; currentRule.charAt(rule.length()) != '/') {</span>
          // This is not a subrule (i.e rule == /foo, currentRule == /foo/bar
<span class="fc" id="L222">          continue;</span>
        } else {
<span class="fc" id="L224">          if (accessRuleData</span>
<span class="fc" id="L225">                  .getInternalState()</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                  .equals(AccessRuleState.RULE_ACCEPT)</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">              &amp;&amp; accessRuleData.getRecursive()) {</span>
            // A possible match, but there may be a contraindicator down the
            // line
<span class="fc" id="L230">            result = true;</span>
<span class="fc" id="L231">          } else if (accessRuleData</span>
<span class="fc" id="L232">              .getInternalState()</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">              .equals(AccessRuleState.RULE_DECLINE)) {</span>
            // Definitely a non-match, break.
<span class="fc" id="L235">            result = false;</span>
<span class="fc" id="L236">            break;</span>
          }
        }
      }
<span class="fc" id="L240">    }</span>
<span class="fc" id="L241">    return result;</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L246">    final int prime = 31;</span>
<span class="nc" id="L247">    int result = 1;</span>
<span class="nc" id="L248">    result =</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        prime * result + ((accessRules == null) ? 0 : accessRules.hashCode());</span>
<span class="nc" id="L250">    result =</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        prime * result + ((accessUsers == null) ? 0 : accessUsers.hashCode());</span>
<span class="nc" id="L252">    result =</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        prime * result + ((primaryKey == null) ? 0 : primaryKey.hashCode());</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">    result = prime * result + ((roleName == null) ? 0 : roleName.hashCode());</span>
<span class="nc" id="L255">    return result;</span>
  }

  @Override
  public boolean equals(final Object obj) {
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (this == obj) {</span>
<span class="nc" id="L261">      return true;</span>
    }
<span class="nc bnc" id="L263" title="All 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L264">      return false;</span>
    }
<span class="nc bnc" id="L266" title="All 2 branches missed.">    if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L267">      return false;</span>
    }
<span class="nc" id="L269">    AdminGroupData other = (AdminGroupData) obj;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    if (accessRules == null) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (other.accessRules != null) {</span>
<span class="nc" id="L272">        return false;</span>
      }
<span class="nc bnc" id="L274" title="All 2 branches missed.">    } else if (!accessRules.equals(other.accessRules)) {</span>
<span class="nc" id="L275">      return false;</span>
    }
<span class="nc bnc" id="L277" title="All 2 branches missed.">    if (accessUsers == null) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">      if (other.accessUsers != null) {</span>
<span class="nc" id="L279">        return false;</span>
      }
<span class="nc bnc" id="L281" title="All 2 branches missed.">    } else if (!accessUsers.equals(other.accessUsers)) {</span>
<span class="nc" id="L282">      return false;</span>
    }
<span class="nc bnc" id="L284" title="All 2 branches missed.">    if (primaryKey == null) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">      if (other.primaryKey != null) {</span>
<span class="nc" id="L286">        return false;</span>
      }
<span class="nc bnc" id="L288" title="All 2 branches missed.">    } else if (!primaryKey.equals(other.primaryKey)) {</span>
<span class="nc" id="L289">      return false;</span>
    }
<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (roleName == null) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (other.roleName != null) {</span>
<span class="nc" id="L293">        return false;</span>
      }
<span class="nc bnc" id="L295" title="All 2 branches missed.">    } else if (!roleName.equals(other.roleName)) {</span>
<span class="nc" id="L296">      return false;</span>
    }
<span class="nc" id="L298">    return true;</span>
  }

  //
  // Start Database integrity protection methods
  //

  @Transient
  @Override
  protected String getProtectString(final int version) {
<span class="nc" id="L308">    final ProtectionStringBuilder build = new ProtectionStringBuilder();</span>
    // What is important to protect here is the data that we define, id, name
    // and certificate profile data
    // rowVersion is automatically updated by JPA, so it's not important, it is
    // only used for optimistic locking
<span class="nc" id="L313">    build.append(getPrimaryKey()).append(getRoleName());</span>
<span class="nc" id="L314">    return build.toString();</span>
  }

  @Transient
  @Override
  protected int getProtectVersion() {
<span class="nc" id="L320">    return 1;</span>
  }

  @PrePersist
  @PreUpdate
  @Override
  protected void protectData() {
<span class="fc" id="L327">    super.protectData();</span>
<span class="fc" id="L328">  }</span>

  @PostLoad
  @Override
  protected void verifyData() {
<span class="nc" id="L333">    super.verifyData();</span>
<span class="nc" id="L334">  }</span>

  @Override
  @Transient
  protected String getRowId() {
<span class="nc" id="L339">    return String.valueOf(getPrimaryKey());</span>
  }

  //
  // End Database integrity protection methods
  //

  @Override
  public int compareTo(final AdminGroupData o) {
<span class="nc" id="L348">    return roleName.compareToIgnoreCase(o.roleName);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L353">    return roleName;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>