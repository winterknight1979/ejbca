<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CesecoreConfiguration.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">ejbca-test-aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.config</a> &gt; <span class="el_source">CesecoreConfiguration.java</span></div><h1>CesecoreConfiguration.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.config;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

/**
 * This file handles configuration from ejbca.properties
 *
 * @version $Id: CesecoreConfiguration.java 34415 2020-01-30 12:29:30Z aminkh $
 */
public final class CesecoreConfiguration {


<span class="fc" id="L32">    private static final Logger log = Logger.getLogger(CesecoreConfiguration.class);</span>

    /** NOTE: diff between EJBCA and CESeCore */
    public static final String PERSISTENCE_UNIT = &quot;ejbca&quot;;
    public static final String AVAILABLE_CIPHER_SUITES_SPLIT_CHAR = &quot;;&quot;;
    public static final String DEFAULT_SERIAL_NUMBER_OCTET_SIZE_NEWCA = &quot;20&quot;;
    private static final String DEFAULT_SERIAL_NUMBER_OCTET_SIZE_EXISTINGCA = &quot;8&quot;;

    /** This is a singleton so it's not allowed to create an instance explicitly */
    private CesecoreConfiguration() {
    }

    private static final String TRUE = &quot;true&quot;;

    /**
     * @return Cesecore Datasource name
     */
    public static String getDataSourceJndiName() {
<span class="nc" id="L50">        String prefix = ConfigurationHolder.getString(&quot;datasource.jndi-name-prefix&quot;);</span>
<span class="nc" id="L51">        String name = ConfigurationHolder.getString(&quot;datasource.jndi-name&quot;);</span>

<span class="nc" id="L53">        return prefix + name;</span>
    }

    /**
     * @return Password used to protect CA keystores in the database.
     */
    public static String getCaKeyStorePass() {
<span class="fc" id="L60">        return ConfigurationHolder.getExpandedString(&quot;ca.keystorepass&quot;);</span>
    }

    /**
     * @return The length in octets of certificate serial numbers generated for legacy CAs. (8 octets is a 64 bit serial number.)
     */
    public static int getSerialNumberOctetSizeForExistingCa() {
<span class="nc" id="L67">        String value = ConfigurationHolder.getConfiguredString(&quot;ca.serialnumberoctetsize&quot;);</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L70">                log.debug(&quot;Using default value of &quot; + DEFAULT_SERIAL_NUMBER_OCTET_SIZE_EXISTINGCA + &quot; for existing CA's ca.serialnumberoctetsize&quot;);</span>
            }
<span class="nc" id="L72">            value = DEFAULT_SERIAL_NUMBER_OCTET_SIZE_EXISTINGCA;</span>
        }
<span class="nc" id="L74">        return Integer.parseInt(value);</span>
    }

    /**
     * @return The length in octets of certificate serial numbers generated for new CAs.
     */
    public static int getSerialNumberOctetSizeForNewCa() {
<span class="fc" id="L81">        String value = ConfigurationHolder.getConfiguredString(&quot;ca.serialnumberoctetsize&quot;); </span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L84">                log.debug(&quot;Using default value of &quot; + DEFAULT_SERIAL_NUMBER_OCTET_SIZE_NEWCA + &quot; for new CA's ca.serialnumberoctetsize&quot;);</span>
            }
<span class="fc" id="L86">            value = DEFAULT_SERIAL_NUMBER_OCTET_SIZE_NEWCA;</span>
        }
<span class="fc" id="L88">        return Integer.parseInt(value);</span>
    }
    
        
    /**
     * @return The algorithm that should be used to generate random numbers (Random Number Generator Algorithm)
     */
    public static String getCaSerialNumberAlgorithm() {
<span class="fc" id="L96">        return ConfigurationHolder.getString(&quot;ca.rngalgorithm&quot;);</span>
    }

    /**
     * @return The date and time from which an expire date of a certificate is to be considered to be too far in the future.
     */
    public static String getCaTooLateExpireDate() {
<span class="fc" id="L103">        return ConfigurationHolder.getExpandedString(&quot;ca.toolateexpiredate&quot;);</span>
    }

    /**
     * The relative time offset for the notBefore value of CA and end entity certificates. Changing this value,
     * also changes the notAfter attribute of the certificates, if a relative time is used for its validity. While
     * certificate issuance this value can be overwritten by the corresponding value in the certificate profile used.
     * @see org.cesecore.certificates.certificateprofile.CertificateProfile#getCertificateValidityOffset()
     * @see org.cesecore.util.SimpleTime
     * @return offset
     */
    public static String getCertificateValidityOffset() {
<span class="fc" id="L115">        return ConfigurationHolder.getExpandedString(&quot;certificate.validityoffset&quot;);</span>
    }

    /**
     * @return true if it is permitted to use an extractable private key in a HSM.
     */
    public static boolean isPermitExtractablePrivateKeys() {
<span class="nc" id="L122">        final String value = ConfigurationHolder.getString(&quot;ca.doPermitExtractablePrivateKeys&quot;);</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">        return value != null &amp;&amp; value.trim().equalsIgnoreCase(TRUE);</span>
    }

    /**
     * @return The language that should be used internally for logging, exceptions and approval notifications.
     */
    public static String getInternalResourcesPreferredLanguage() {
<span class="fc" id="L130">        return ConfigurationHolder.getExpandedString(&quot;intresources.preferredlanguage&quot;);</span>
    }

    /**
     * @return The language used internally if a resource not found in the preferred language
     */
    public static String getInternalResourcesSecondaryLanguage() {
<span class="fc" id="L137">        return ConfigurationHolder.getExpandedString(&quot;intresources.secondarylanguage&quot;);</span>
    }

    /**
     * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
     */
    public static String getEcdsaImplicitlyCaQ() {
<span class="fc" id="L144">        return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.q&quot;);</span>
    }

    /**
     * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
     */
    public static String getEcdsaImplicitlyCaA() {
<span class="fc" id="L151">        return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.a&quot;);</span>
    }

    /**
     * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
     */
    public static String getEcdsaImplicitlyCaB() {
<span class="fc" id="L158">        return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.b&quot;);</span>
    }

    /**
     * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
     */
    public static String getEcdsaImplicitlyCaG() {
<span class="fc" id="L165">        return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.g&quot;);</span>
    }

    /**
     * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
     */
    public static String getEcdsaImplicitlyCaN() {
<span class="fc" id="L172">        return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.n&quot;);</span>
    }

    /**
     * Flag indicating if the BC provider should be removed before installing it again. When developing and re-deploying alot this is needed so you
     * don't have to restart JBoss all the time. In production it may cause failures because the BC provider may get removed just when another thread
     * wants to use it. Therefore the default value is false.
     * @return flag
     */
    public static boolean isDevelopmentProviderInstallation() {
<span class="fc" id="L182">        return TRUE.equalsIgnoreCase(ConfigurationHolder.getString(&quot;development.provider.installation&quot;));</span>
    }

    /** @return Parameter to specify if retrieving CAInfo and CA from CAAdminSession should be cached, and in that case for how long. */
    public static long getCacheCaTimeInCaSession() {
        // Cache for 10 seconds is the default (Changed 2013-02-14 under ECA-2801.)
<span class="fc" id="L188">        return getLongValue(&quot;cainfo.cachetime&quot;, 10000L, &quot;milliseconds to cache CA info&quot;);</span>
    }

    /** @return configuration for when cached CryptoTokens are considered stale and will be refreshed from the database. */
    public static long getCacheTimeCryptoToken() {
<span class="nc" id="L193">        return getLongValue(&quot;cryptotoken.cachetime&quot;, 10000L, &quot;milliseconds&quot;);</span>
    }

    /** @return configuration for when cached SignersMapping are considered stale and will be refreshed from the database. */
    public static long getCacheTimeInternalKeyBinding() {
<span class="nc" id="L198">        return getLongValue(&quot;internalkeybinding.cachetime&quot;, 10000L, &quot;milliseconds&quot;);</span>
    }

    /** @return Parameter to specify if retrieving Certificate profiles in StoreSession should be cached, and in that case for how long. */
    public static long getCacheCertificateProfileTime() {
<span class="nc" id="L203">        return getLongValue(&quot;certprofiles.cachetime&quot;, 1000L, &quot;milliseconds to cache Certificate profiles&quot;);</span>
    }

    /**
     * @return Parameter to specify if retrieving GlobalOcspConfiguration (in GlobalConfigurationSessionBean) should be cached, and in that case for how long.
     */
    public static long getCacheGlobalOcspConfigurationTime() {
<span class="nc" id="L210">        return getLongValue(&quot;ocspconfigurationcache.cachetime&quot;, 30000, &quot;milliseconds to cache OCSP settings&quot;);</span>
    }

    /**
     * @return Parameter to specify if retrieving PublicKeyBlacklist objects from PublicKeyBlacklistSession should be cached, and in that case for how long.
     */
    public static long getCachePublicKeyBlacklistTime() {
<span class="fc" id="L217">        return getLongValue(&quot;blacklist.cachetime&quot;, 30000L, &quot;milliseconds to cache public key blacklist entries&quot;);</span>
    }

    /**
     * @return Parameter to specify if retrieving KeyValidator objects from KeyValidatorSession should be cached, and in that case for how long.
     */
    public static long getCacheKeyValidatorTime() {
<span class="fc" id="L224">        return getLongValue(&quot;validator.cachetime&quot;, 30000L, &quot;milliseconds to cache validators&quot;);</span>
    }

    /** @return Parameter to specify if retrieving Authorization Access Rules (in AuthorizationSession) should be cached, and in that case for how long. */
    public static long getCacheAuthorizationTime() {
<span class="nc" id="L229">        return getLongValue(&quot;authorization.cachetime&quot;, 30000L, &quot;milliseconds to cache authorization&quot;);</span>
    }

    /**
     * @return Parameter to specify if retrieving GlobalConfiguration (in GlobalConfigurationSessionBean) should be cached, and in that case for how long.
     */
    public static long getCacheGlobalConfigurationTime() {
<span class="nc" id="L236">        return getLongValue(&quot;globalconfiguration.cachetime&quot;, 30000L, &quot;milliseconds to cache authorization&quot;);</span>
    }

    private static long getLongValue(final String propertyName, final long defaultValue, final String unit) {
<span class="fc" id="L240">        final String value = ConfigurationHolder.getString(propertyName);</span>
<span class="fc" id="L241">        long time = defaultValue;</span>
        try {
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (value!=null) {</span>
<span class="fc" id="L244">                time = Long.valueOf(value);</span>
            }
<span class="nc" id="L246">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L247">            log.error(&quot;Invalid value for &quot; + propertyName + &quot;. Using default &quot; + defaultValue + &quot;. Value must be decimal number (&quot; + unit + &quot;): &quot; + e.getMessage());</span>
<span class="fc" id="L248">        }</span>
<span class="fc" id="L249">        return time;</span>
    }

    public static Class&lt;?&gt; getTrustedTimeProvider() throws ClassNotFoundException {
<span class="nc" id="L253">        String providerClass = ConfigurationHolder.getString(&quot;time.provider&quot;);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if(log.isDebugEnabled()) {</span>
<span class="nc" id="L255">            log.debug(&quot;TrustedTimeProvider class: &quot;+providerClass);</span>
        }
<span class="nc" id="L257">        return Class.forName(providerClass);</span>
    }

    /**
     * @return Regular Expression to fetch the NTP offset from an NTP client output
     * 
     */
    public static Pattern getTrustedTimeNtpPattern() {
<span class="nc" id="L265">        String regex = ConfigurationHolder.getString(&quot;time.ntp.pattern&quot;);</span>
<span class="nc" id="L266">        return Pattern.compile(regex);</span>
    }

    /**
     * @return System command to execute an NTP client call and obtain information about the selected peers and their offsets
     */
    public static String getTrustedTimeNtpCommand() {
<span class="nc" id="L273">        return ConfigurationHolder.getString(&quot;time.ntp.command&quot;);</span>
    }

    /**
     * Option if we should keep internal CA keystores in the CAData table to be compatible with CeSecore 1.1/EJBCA 5.0.
     * Default to true. Set to false when all nodes in a cluster have been upgraded to CeSecore 1.2/EJBCA 5.1 or later,
     * then internal keystore in CAData will be replaced with a foreign key in to the migrated entry in CryptotokenData.
     * @return boolean
     */
    public static boolean isKeepInternalCAKeystores() {
<span class="nc" id="L283">        final String value = ConfigurationHolder.getString(&quot;db.keepinternalcakeystores&quot;);</span>
<span class="nc bnc" id="L284" title="All 4 branches missed.">        return value == null || !value.trim().equalsIgnoreCase(&quot;false&quot;);</span>
    }

    /**
     * When we run in a cluster, each node should have it's own identifier. By default we use the DNS name.
     * @return ID
     */
    public static String getNodeIdentifier() {
<span class="nc" id="L292">    	final String PROPERTY_NAME = &quot;cluster.nodeid&quot;;</span>
<span class="nc" id="L293">    	final String PROPERTY_VALUE = &quot;undefined&quot;;</span>
<span class="nc" id="L294">        String value = ConfigurationHolder.getString(PROPERTY_NAME);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (value == null) {</span>
        	try {
<span class="nc" id="L297">				value = InetAddress.getLocalHost().getHostName();</span>
<span class="nc" id="L298">			} catch (UnknownHostException e) {</span>
<span class="nc" id="L299">				log.warn(PROPERTY_NAME + &quot; is undefined on this host and was not able to resolve hostname. Using &quot; + PROPERTY_VALUE + &quot; which is fine if use a single node.&quot;);</span>
<span class="nc" id="L300">				value = PROPERTY_VALUE;</span>
<span class="nc" id="L301">			}</span>
			// Update configuration, so we don't have to make a hostname lookup each time we call this method.
<span class="nc" id="L303">            ConfigurationHolder.updateConfigurationWithoutBackup(PROPERTY_NAME, value);</span>
        }
<span class="nc" id="L305">        return value;</span>
    }

    /** @return Oid tree for GOST32410 */
    public static String getOidGost3410() {
<span class="fc" id="L310">        return ConfigurationHolder.getString(&quot;extraalgs.gost3410.oidtree&quot;);</span>
    }

    /** @return Oid tree for DSTU4145 */
    public static String getOidDstu4145() {
<span class="fc" id="L315">        return ConfigurationHolder.getString(&quot;extraalgs.dstu4145.oidtree&quot;);</span>
    }

    /** @return extraalgs such as GOST, DSTU */
    public static List&lt;String&gt; getExtraAlgs() {
<span class="fc" id="L320">        return ConfigurationHolder.getPrefixedPropertyNames(&quot;extraalgs&quot;);</span>
    }

    /** @param algName Name
     * @return title of the algorithm */
    public static String getExtraAlgTitle(String algName) {
<span class="nc" id="L326">        return ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName.toLowerCase() + &quot;.title&quot;);</span>
    }

    /** @param algName Name
     * @return &quot;subalgorithms&quot;, e.g. different keylengths or curves */
    public static List&lt;String&gt; getExtraAlgSubAlgs(String algName) {
<span class="nc" id="L332">        return ConfigurationHolder.getPrefixedPropertyNames(&quot;extraalgs.&quot; + algName + &quot;.subalgs&quot;);</span>
    }

    public static String getExtraAlgSubAlgTitle(String algName, String subAlg) {
<span class="nc" id="L336">        String name = ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.title&quot;);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (name == null) {</span>
            // Show the algorithm name, if it has one
<span class="nc" id="L339">            String end = ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.name&quot;);</span>
            // Otherwise, show the key name in the configuration
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (end == null) { end = subAlg; }</span>
<span class="nc" id="L342">            name = ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.title&quot;) + &quot; &quot; + end;</span>
        }
<span class="nc" id="L344">        return name;</span>
    }

    public static String getExtraAlgSubAlgName(String algName, String subAlg) {
<span class="nc" id="L348">        String name = ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.name&quot;);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (name == null) {</span>
            // Not a named algorithm
<span class="nc" id="L351">            name = getExtraAlgSubAlgOid(algName, subAlg);</span>
        }
<span class="nc" id="L353">        return name;</span>
    }

    public static String getExtraAlgSubAlgOid(String algName, String subAlg) {
<span class="nc" id="L357">        final String oidTree = ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.oidtree&quot;);</span>
<span class="nc" id="L358">        final String oidEnd = ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.oid&quot;);</span>

<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (oidEnd != null &amp;&amp; oidTree != null) { return oidTree + &quot;.&quot; + oidEnd; }</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (oidEnd != null) { return oidEnd; }</span>
<span class="nc" id="L362">        else { return null; }</span>
    }

    /**
     * @return true if the Base64CertData table should be used for storing the certificates.
     */
    public static boolean useBase64CertTable() {
<span class="nc" id="L369">        final String value = ConfigurationHolder.getString(&quot;database.useSeparateCertificateTable&quot;);</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">        return value!=null &amp;&amp; Boolean.parseBoolean(value.trim());</span>
    }

    /** @param tableName Name of DB table
     * @return If database integrity protection should be used or not. */
    public static boolean useDatabaseIntegrityProtection(final String tableName) {
        // First check if we have explicit configuration for this entity
<span class="nc" id="L377">        final String enableProtect = ConfigurationHolder.getString(&quot;databaseprotection.enablesign.&quot; + tableName);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (enableProtect != null) {</span>
<span class="nc" id="L379">            return Boolean.TRUE.toString().equalsIgnoreCase(enableProtect);</span>
        }
        // Otherwise use the global or default
<span class="nc" id="L382">        return Boolean.TRUE.toString().equalsIgnoreCase(ConfigurationHolder.getString(&quot;databaseprotection.enablesign&quot;));</span>
    }

    /** @param tableName Name of DB table
     * @return If database integrity verification should be used or not. */
    public static boolean useDatabaseIntegrityVerification(final String tableName) {
        // First check if we have explicit configuration for this entity
<span class="nc" id="L389">        final String enableVerify = ConfigurationHolder.getString(&quot;databaseprotection.enableverify.&quot; + tableName);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (enableVerify != null) {</span>
<span class="nc" id="L391">            return Boolean.TRUE.toString().equalsIgnoreCase(enableVerify);</span>
        }
        // Otherwise use the global or default
<span class="nc" id="L394">        return Boolean.TRUE.toString().equalsIgnoreCase(ConfigurationHolder.getString(&quot;databaseprotection.enableverify&quot;));</span>
    }

    public static boolean getCaKeepOcspExtendedService() {
<span class="nc" id="L398">        return Boolean.valueOf(ConfigurationHolder.getString(&quot;ca.keepocspextendedservice&quot;).toLowerCase());</span>
    }

    /** @return the number of rows that should be fetched at the time when creating CRLs. */
    public static int getDatabaseRevokedCertInfoFetchSize() {
<span class="nc" id="L403">        return Long.valueOf(getLongValue(&quot;database.crlgenfetchsize&quot;, 500000L, &quot;rows&quot;)).intValue();</span>
    }

    /**
     * Used just in {@link #getForbiddenCharacters()}. The method is called very
     * often so we declare this String in the class so it does not have to be
     * each time the method is called.
     */
    final static private String FORBIDDEN_CARACTERS_KEY = &quot;forbidden.characters&quot;;
    /**
     * Characters forbidden in fields to be stored in the DB.
     * @return all forbidden characters.
     */
    public static char[] getForbiddenCharacters() {
        // Using 'instance().getString' instead of 'getString' since an empty
        // String (size 0) must be returned when the property is defined without
        // any value.
<span class="fc" id="L420">        final String s = ConfigurationHolder.instance().getString(FORBIDDEN_CARACTERS_KEY);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">        if (s==null) {</span>
<span class="fc" id="L422">            return ConfigurationHolder.getDefaultValue(FORBIDDEN_CARACTERS_KEY).toCharArray();</span>
        }
<span class="fc" id="L424">        return s.toCharArray();</span>
    }

    /**
     * @return true if sign mechanisms that uses pkcs#11 for hashing should be disabled.
     */
    public static boolean p11disableHashingSignMechanisms() {
<span class="nc" id="L431">        final String value = ConfigurationHolder.getString(&quot;pkcs11.disableHashingSignMechanisms&quot;);</span>
<span class="nc bnc" id="L432" title="All 4 branches missed.">        return value==null || Boolean.parseBoolean(value.trim());</span>
    }

    /** @return true key store content of Crypto Tokens should be cached. */
    public static boolean isKeyStoreCacheEnabled() {
<span class="fc" id="L437">        return Boolean.parseBoolean(ConfigurationHolder.getString(&quot;cryptotoken.keystorecache&quot;));</span>
    }

    /** @return a list of enabled TLS protocol versions and cipher suites */
    /*
     * Java 6: http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider
     *  TLS versions: SSLv3, TLSv1, SSLv2Hello
     * Java 7: http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider
     *  TLS versions: SSLv3, TLSv1, TLSv1.1, TLSv1.2
     *  Cipher suites with SHA384 and SHA256 are available only for TLS 1.2 or later.
     * Java 8: http://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider
     *  TLS versions: SSLv3, TLSv1, TLSv1.1, TLSv1.2
     *  Cipher suites with SHA384 and SHA256 are available only for TLS 1.2 or later.
     */
    public static String[] getAvailableCipherSuites() {
<span class="nc" id="L452">        final List&lt;String&gt; availableCipherSuites = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        for (int i=0; i&lt;255; i++) {</span>
<span class="nc" id="L454">            final String key = &quot;authkeybind.ciphersuite.&quot; + i;</span>
<span class="nc" id="L455">            final String value = ConfigurationHolder.getString(key);</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">            if (value==null || value.indexOf(AVAILABLE_CIPHER_SUITES_SPLIT_CHAR)==-1) {</span>
<span class="nc" id="L457">                continue;</span>
            }
<span class="nc" id="L459">            availableCipherSuites.add(value);</span>
        }
<span class="nc" id="L461">        return availableCipherSuites.toArray(new String[0]);</span>
    }

    /**
     * Gets the maximum number of entries in the CT cache. Each entry contains the SCTs for a
     * given certificate. Each SCT will be around 100-150 bytes, and a certificate will typically
     * have 2-4 SCTs. Also, the cache may temporarily overshoot by 50%. There's also some overhead
     * for the cache data structure (ConcurrentCache).
     *
     * -1 means no limit (and not &quot;off&quot;). The default is 100 000.
     * @return max entries
     *
     * @see #getCTCacheEnabled
     */
    public static long getCTCacheMaxEntries() {
<span class="nc" id="L476">        return getLongValue(&quot;ct.cache.maxentries&quot;, 100000L, &quot;number of entries in cache&quot;);</span>
    }

    /**
     * @return How many milliseconds between periodic cache cleanup. The cleanup routine is only
     * run when the cache is filled with too many entries.
     */
    public static long getCTCacheCleanupInterval() {
<span class="nc" id="L484">        return getLongValue(&quot;ct.cache.cleanupinterval&quot;, 10000L, &quot;milliseconds between periodic cache cleanup&quot;);</span>
    }

    /** @return Whether caching of SCTs should be enabled. The default is true. */
    public static boolean getCTCacheEnabled() {
<span class="nc" id="L489">        final String value = ConfigurationHolder.getString(&quot;ct.cache.enabled&quot;);</span>
<span class="nc bnc" id="L490" title="All 4 branches missed.">        return value == null || !value.trim().equalsIgnoreCase(&quot;false&quot;);</span>
    }

    /**
     * @return Whether log availability should be tracked, and requests should &quot;fast fail&quot;
     * whenever a log is known to be down. A log is &quot;known to be down&quot; when it
     * is either unreachable or responds with an HTTP error status to a request.
     */
    public static boolean getCTFastFailEnabled() {
<span class="nc" id="L499">        final String value = ConfigurationHolder.getString(&quot;ct.fastfail.enabled&quot;);</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">        return value != null &amp;&amp; value.trim().equalsIgnoreCase(TRUE);</span>
    }

    /**
     * @return How long time (in milliseconds) EJBCA should wait until trying to use a log
     * which has failed to respond to a request.
     */
    public static long getCTFastFailBackOff() {
<span class="nc" id="L508">        return getLongValue(&quot;ct.fastfail.backoff&quot;, 1000L, &quot;milliseconds&quot;);</span>
    }

    /**
     * @return true if key should be unmodifiable after generation.
     */
    public static boolean makeKeyUnmodifiableAfterGeneration() {
<span class="fc" id="L515">        final String value = ConfigurationHolder.getString(&quot;pkcs11.makeKeyUnmodifiableAfterGeneration&quot;);</span>
<span class="pc bpc" id="L516" title="2 of 4 branches missed.">        return value!=null &amp;&amp; Boolean.parseBoolean(value.trim());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>