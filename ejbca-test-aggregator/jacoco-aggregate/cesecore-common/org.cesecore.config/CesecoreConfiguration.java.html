<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CesecoreConfiguration.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.config</a> &gt; <span class="el_source">CesecoreConfiguration.java</span></div><h1>CesecoreConfiguration.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.config;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.apache.log4j.Logger;

/**
 * This file handles configuration from ejbca.properties.
 *
 * @version $Id: CesecoreConfiguration.java 34415 2020-01-30 12:29:30Z aminkh $
 */
public final class CesecoreConfiguration {

    /** Logger. */
<span class="fc" id="L31">  private static final Logger LOG =</span>
<span class="fc" id="L32">      Logger.getLogger(CesecoreConfiguration.class);</span>

  /** NOTE: diff between EJBCA and CESeCore. */
  public static final String PERSISTENCE_UNIT = &quot;ejbca&quot;;
  /** Splitter. */
  public static final String AVAILABLE_CIPHER_SUITES_SPLIT_CHAR = &quot;;&quot;;
  /** SN size. */
  public static final String DEFAULT_SERIAL_NUMBER_OCTET_SIZE_NEWCA = &quot;20&quot;;
  /** SN size. **/
  private static final String DEFAULT_SERIAL_NUMBER_OCTET_SIZE_EXISTINGCA = &quot;8&quot;;

  /**
   * This is a singleton so it's not allowed to create an instance explicitly.
   */
  private CesecoreConfiguration() { }

  /** Boolean true. */
  private static final String TRUE = &quot;true&quot;;

  /** @return Cesecore Datasource name */
  public static String getDataSourceJndiName() {
<span class="nc" id="L53">    String prefix =</span>
<span class="nc" id="L54">        ConfigurationHolder.getString(&quot;datasource.jndi-name-prefix&quot;);</span>
<span class="nc" id="L55">    String name = ConfigurationHolder.getString(&quot;datasource.jndi-name&quot;);</span>

<span class="nc" id="L57">    return prefix + name;</span>
  }

  /** @return Password used to protect CA keystores in the database. */
  public static String getCaKeyStorePass() {
<span class="fc" id="L62">    return ConfigurationHolder.getExpandedString(&quot;ca.keystorepass&quot;);</span>
  }

  /**
   * @return The length in octets of certificate serial numbers generated for
   *     legacy CAs. (8 octets is a 64 bit serial number.)
   */
  public static int getSerialNumberOctetSizeForExistingCa() {
<span class="nc" id="L70">    String value =</span>
<span class="nc" id="L71">        ConfigurationHolder.getConfiguredString(&quot;ca.serialnumberoctetsize&quot;);</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L74">        LOG.debug(</span>
            &quot;Using default value of &quot;
                + DEFAULT_SERIAL_NUMBER_OCTET_SIZE_EXISTINGCA
                + &quot; for existing CA's ca.serialnumberoctetsize&quot;);
      }
<span class="nc" id="L79">      value = DEFAULT_SERIAL_NUMBER_OCTET_SIZE_EXISTINGCA;</span>
    }
<span class="nc" id="L81">    return Integer.parseInt(value);</span>
  }

  /**
   * @return The length in octets of certificate serial numbers generated for
   *     new CAs.
   */
  public static int getSerialNumberOctetSizeForNewCa() {
<span class="fc" id="L89">    String value =</span>
<span class="fc" id="L90">        ConfigurationHolder.getConfiguredString(&quot;ca.serialnumberoctetsize&quot;);</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L93">        LOG.debug(</span>
            &quot;Using default value of &quot;
                + DEFAULT_SERIAL_NUMBER_OCTET_SIZE_NEWCA
                + &quot; for new CA's ca.serialnumberoctetsize&quot;);
      }
<span class="fc" id="L98">      value = DEFAULT_SERIAL_NUMBER_OCTET_SIZE_NEWCA;</span>
    }
<span class="fc" id="L100">    return Integer.parseInt(value);</span>
  }

  /**
   * @return The algorithm that should be used to generate random numbers
   *     (Random Number Generator Algorithm)
   */
  public static String getCaSerialNumberAlgorithm() {
<span class="fc" id="L108">    return ConfigurationHolder.getString(&quot;ca.rngalgorithm&quot;);</span>
  }

  /**
   * @return The date and time from which an expire date of a certificate is to
   *     be considered to be too far in the future.
   */
  public static String getCaTooLateExpireDate() {
<span class="fc" id="L116">    return ConfigurationHolder.getExpandedString(&quot;ca.toolateexpiredate&quot;);</span>
  }

  /**
   * The relative time offset for the notBefore value of CA and end entity
   * certificates. Changing this value, also changes the notAfter attribute of
   * the certificates, if a relative time is used for its validity. While
   * certificate issuance this value can be overwritten by the corresponding
   * value in the certificate profile used.
   *
   * @see
   *     org.cesecore.certificates.certificateprofile.CertificateProfile#getCertificateValidityOffset()
   * @see org.cesecore.util.SimpleTime
   * @return offset
   */
  public static String getCertificateValidityOffset() {
<span class="fc" id="L132">    return ConfigurationHolder.getExpandedString(&quot;certificate.validityoffset&quot;);</span>
  }

  /**
   * @return true if it is permitted to use an extractable private key in a HSM.
   */
  public static boolean isPermitExtractablePrivateKeys() {
<span class="nc" id="L139">    final String value =</span>
<span class="nc" id="L140">        ConfigurationHolder.getString(&quot;ca.doPermitExtractablePrivateKeys&quot;);</span>
<span class="nc bnc" id="L141" title="All 4 branches missed.">    return value != null &amp;&amp; value.trim().equalsIgnoreCase(TRUE);</span>
  }

  /**
   * @return The language that should be used internally for logging, exceptions
   *     and approval notifications.
   */
  public static String getInternalResourcesPreferredLanguage() {
<span class="fc" id="L149">    return ConfigurationHolder.getExpandedString(</span>
        &quot;intresources.preferredlanguage&quot;);
  }

  /**
   * @return The language used internally if a resource not found in the
   *     preferred language
   */
  public static String getInternalResourcesSecondaryLanguage() {
<span class="fc" id="L158">    return ConfigurationHolder.getExpandedString(</span>
        &quot;intresources.secondarylanguage&quot;);
  }

  /**
   * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
   */
  public static String getEcdsaImplicitlyCaQ() {
<span class="fc" id="L166">    return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.q&quot;);</span>
  }

  /**
   * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
   */
  public static String getEcdsaImplicitlyCaA() {
<span class="fc" id="L173">    return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.a&quot;);</span>
  }

  /**
   * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
   */
  public static String getEcdsaImplicitlyCaB() {
<span class="fc" id="L180">    return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.b&quot;);</span>
  }

  /**
   * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
   */
  public static String getEcdsaImplicitlyCaG() {
<span class="fc" id="L187">    return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.g&quot;);</span>
  }

  /**
   * @return Sets pre-defined EC curve parameters for the implicitlyCA facility.
   */
  public static String getEcdsaImplicitlyCaN() {
<span class="fc" id="L194">    return ConfigurationHolder.getExpandedString(&quot;ecdsa.implicitlyca.n&quot;);</span>
  }

  /**
   * Flag indicating if the BC provider should be removed before installing it
   * again. When developing and re-deploying alot this is needed so you don't
   * have to restart JBoss all the time. In production it may cause failures
   * because the BC provider may get removed just when another thread wants to
   * use it. Therefore the default value is false.
   *
   * @return flag
   */
  public static boolean isDevelopmentProviderInstallation() {
<span class="fc" id="L207">    return TRUE.equalsIgnoreCase(</span>
<span class="fc" id="L208">        ConfigurationHolder.getString(&quot;development.provider.installation&quot;));</span>
  }

  /**
   * @return Parameter to specify if retrieving CAInfo and CA from
   *     CAAdminSession should be cached, and in that case for how long.
   */
  public static long getCacheCaTimeInCaSession() {
    // Cache for 10 seconds is the default (Changed 2013-02-14 under ECA-2801.)
<span class="fc" id="L217">    return getLongValue(</span>
        &quot;cainfo.cachetime&quot;, TEN_SECONDS, &quot;milliseconds to cache CA info&quot;);
  }

  /**
   * @return configuration for when cached CryptoTokens are considered stale and
   *     will be refreshed from the database.
   */
  public static long getCacheTimeCryptoToken() {
<span class="nc" id="L226">    return getLongValue(&quot;cryptotoken.cachetime&quot;, TEN_SECONDS, &quot;milliseconds&quot;);</span>
  }

  /**
   * @return configuration for when cached SignersMapping are considered stale
   *     and will be refreshed from the database.
   */
  public static long getCacheTimeInternalKeyBinding() {
<span class="nc" id="L234">    return getLongValue(&quot;internalkeybinding.cachetime&quot;,</span>
            TEN_SECONDS, &quot;milliseconds&quot;);
  }

  /**
   * @return Parameter to specify if retrieving Certificate profiles in
   *     StoreSession should be cached, and in that case for how long.
   */
  public static long getCacheCertificateProfileTime() {
<span class="nc" id="L243">    return getLongValue(</span>
        &quot;certprofiles.cachetime&quot;,
        MS_PER_S,
        &quot;milliseconds to cache Certificate profiles&quot;);
  }

  /**
   * @return Parameter to specify if retrieving GlobalOcspConfiguration (in
   *     GlobalConfigurationSessionBean) should be cached, and in that case for
   *     how long.
   */
  public static long getCacheGlobalOcspConfigurationTime() {
<span class="nc" id="L255">    return getLongValue(</span>
        &quot;ocspconfigurationcache.cachetime&quot;,
        THIRTY_SECONDS,
        &quot;milliseconds to cache OCSP settings&quot;);
  }

  /**
   * @return Parameter to specify if retrieving PublicKeyBlacklist objects from
   *     PublicKeyBlacklistSession should be cached, and in that case for how
   *     long.
   */
  public static long getCachePublicKeyBlacklistTime() {
<span class="fc" id="L267">    return getLongValue(</span>
        &quot;blacklist.cachetime&quot;,
        THIRTY_SECONDS,
        &quot;milliseconds to cache public key blacklist entries&quot;);
  }

  /**
   * @return Parameter to specify if retrieving KeyValidator objects from
   *     KeyValidatorSession should be cached, and in that case for how long.
   */
  public static long getCacheKeyValidatorTime() {
<span class="fc" id="L278">    return getLongValue(</span>
        &quot;validator.cachetime&quot;,
        THIRTY_SECONDS, &quot;milliseconds to cache validators&quot;);
  }

  /**
   * @return Parameter to specify if retrieving Authorization Access Rules (in
   *     AuthorizationSession) should be cached, and in that case for how long.
   */
  public static long getCacheAuthorizationTime() {
<span class="nc" id="L288">    return getLongValue(</span>
        &quot;authorization.cachetime&quot;,
        THIRTY_SECONDS,
        &quot;milliseconds to cache authorization&quot;);
  }

  /**
   * @return Parameter to specify if retrieving GlobalConfiguration (in
   *     GlobalConfigurationSessionBean) should be cached, and in that case for
   *     how long.
   */
  public static long getCacheGlobalConfigurationTime() {
<span class="nc" id="L300">    return getLongValue(</span>
        &quot;globalconfiguration.cachetime&quot;,
        THIRTY_SECONDS,
        &quot;milliseconds to cache authorization&quot;);
  }

  private static long getLongValue(
      final String propertyName, final long defaultValue, final String unit) {
<span class="fc" id="L308">    final String value = ConfigurationHolder.getString(propertyName);</span>
<span class="fc" id="L309">    long time = defaultValue;</span>
    try {
<span class="fc bfc" id="L311" title="All 2 branches covered.">      if (value != null) {</span>
<span class="fc" id="L312">        time = Long.valueOf(value);</span>
      }
<span class="nc" id="L314">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L315">      LOG.error(</span>
          &quot;Invalid value for &quot;
              + propertyName
              + &quot;. Using default &quot;
              + defaultValue
              + &quot;. Value must be decimal number (&quot;
              + unit
              + &quot;): &quot;
<span class="nc" id="L323">              + e.getMessage());</span>
<span class="fc" id="L324">    }</span>
<span class="fc" id="L325">    return time;</span>
  }

  /**
   * @return provider
   * @throws ClassNotFoundException not found
   */
  public static Class&lt;?&gt; getTrustedTimeProvider()
      throws ClassNotFoundException {
<span class="nc" id="L334">    String providerClass = ConfigurationHolder.getString(&quot;time.provider&quot;);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L336">      LOG.debug(&quot;TrustedTimeProvider class: &quot; + providerClass);</span>
    }
<span class="nc" id="L338">    return Class.forName(providerClass);</span>
  }

  /**
   * @return Regular Expression to fetch the NTP offset from an NTP client
   *     output
   */
  public static Pattern getTrustedTimeNtpPattern() {
<span class="nc" id="L346">    String regex = ConfigurationHolder.getString(&quot;time.ntp.pattern&quot;);</span>
<span class="nc" id="L347">    return Pattern.compile(regex);</span>
  }

  /**
   * @return System command to execute an NTP client call and obtain information
   *     about the selected peers and their offsets
   */
  public static String getTrustedTimeNtpCommand() {
<span class="nc" id="L355">    return ConfigurationHolder.getString(&quot;time.ntp.command&quot;);</span>
  }

  /**
   * Option if we should keep internal CA keystores in the CAData table to be
   * compatible with CeSecore 1.1/EJBCA 5.0. Default to true. Set to false when
   * all nodes in a cluster have been upgraded to CeSecore 1.2/EJBCA 5.1 or
   * later, then internal keystore in CAData will be replaced with a foreign key
   * in to the migrated entry in CryptotokenData.
   *
   * @return boolean
   */
  public static boolean isKeepInternalCAKeystores() {
<span class="nc" id="L368">    final String value =</span>
<span class="nc" id="L369">        ConfigurationHolder.getString(&quot;db.keepinternalcakeystores&quot;);</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">    return value == null || !value.trim().equalsIgnoreCase(&quot;false&quot;);</span>
  }

  /**
   * When we run in a cluster, each node should have it's own identifier. By
   * default we use the DNS name.
   *
   * @return ID
   */
  public static String getNodeIdentifier() {
<span class="nc" id="L380">    final String propertyName = &quot;cluster.nodeid&quot;;</span>
<span class="nc" id="L381">    final String propertyValue = &quot;undefined&quot;;</span>
<span class="nc" id="L382">    String value = ConfigurationHolder.getString(propertyName);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (value == null) {</span>
      try {
<span class="nc" id="L385">        value = InetAddress.getLocalHost().getHostName();</span>
<span class="nc" id="L386">      } catch (UnknownHostException e) {</span>
<span class="nc" id="L387">        LOG.warn(</span>
            propertyName
                + &quot; is undefined on this host and was not able to resolve&quot;
                + &quot; hostname. Using &quot;
                + propertyValue
                + &quot; which is fine if use a single node.&quot;);
<span class="nc" id="L393">        value = propertyValue;</span>
<span class="nc" id="L394">      }</span>
      // Update configuration, so we don't have to make a hostname lookup each
      // time we call this method.
<span class="nc" id="L397">      ConfigurationHolder.updateConfigurationWithoutBackup(</span>
          propertyName, value);
    }
<span class="nc" id="L400">    return value;</span>
  }

  /** @return Oid tree for GOST32410 */
  public static String getOidGost3410() {
<span class="fc" id="L405">    return ConfigurationHolder.getString(&quot;extraalgs.gost3410.oidtree&quot;);</span>
  }

  /** @return Oid tree for DSTU4145 */
  public static String getOidDstu4145() {
<span class="fc" id="L410">    return ConfigurationHolder.getString(&quot;extraalgs.dstu4145.oidtree&quot;);</span>
  }

  /** @return extraalgs such as GOST, DSTU */
  public static List&lt;String&gt; getExtraAlgs() {
<span class="fc" id="L415">    return ConfigurationHolder.getPrefixedPropertyNames(&quot;extraalgs&quot;);</span>
  }

  /**
   * @param algName Name
   * @return title of the algorithm
   */
  public static String getExtraAlgTitle(final String algName) {
<span class="nc" id="L423">    return ConfigurationHolder.getString(</span>
<span class="nc" id="L424">        &quot;extraalgs.&quot; + algName.toLowerCase() + &quot;.title&quot;);</span>
  }

  /**
   * @param algName Name
   * @return &quot;subalgorithms&quot;, e.g. different keylengths or curves
   */
  public static List&lt;String&gt; getExtraAlgSubAlgs(final String algName) {
<span class="nc" id="L432">    return ConfigurationHolder.getPrefixedPropertyNames(</span>
        &quot;extraalgs.&quot; + algName + &quot;.subalgs&quot;);
  }

  /**
   * @param algName Alg
   * @param subAlg sub-alg
   * @return title
   */
  public static String getExtraAlgSubAlgTitle(
          final String algName, final String subAlg) {
<span class="nc" id="L443">    String name =</span>
<span class="nc" id="L444">        ConfigurationHolder.getString(</span>
            &quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.title&quot;);
<span class="nc bnc" id="L446" title="All 2 branches missed.">    if (name == null) {</span>
      // Show the algorithm name, if it has one
<span class="nc" id="L448">      String end =</span>
<span class="nc" id="L449">          ConfigurationHolder.getString(</span>
              &quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.name&quot;);
      // Otherwise, show the key name in the configuration
<span class="nc bnc" id="L452" title="All 2 branches missed.">      if (end == null) {</span>
<span class="nc" id="L453">        end = subAlg;</span>
      }
<span class="nc" id="L455">      name =</span>
<span class="nc" id="L456">          ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.title&quot;)</span>
              + &quot; &quot;
              + end;
    }
<span class="nc" id="L460">    return name;</span>
  }

  /**
   * @param algName Alg
   * @param subAlg Alg
   * @return Name
   */
  public static String getExtraAlgSubAlgName(
          final String algName, final String subAlg) {
<span class="nc" id="L470">    String name =</span>
<span class="nc" id="L471">        ConfigurationHolder.getString(</span>
            &quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.name&quot;);
<span class="nc bnc" id="L473" title="All 2 branches missed.">    if (name == null) {</span>
      // Not a named algorithm
<span class="nc" id="L475">      name = getExtraAlgSubAlgOid(algName, subAlg);</span>
    }
<span class="nc" id="L477">    return name;</span>
  }

  /**
   * @param algName Alg
   * @param subAlg Alg
   * @return Name
   */
  public static String getExtraAlgSubAlgOid(
          final String algName, final String subAlg) {
<span class="nc" id="L487">    final String oidTree =</span>
<span class="nc" id="L488">        ConfigurationHolder.getString(&quot;extraalgs.&quot; + algName + &quot;.oidtree&quot;);</span>
<span class="nc" id="L489">    final String oidEnd =</span>
<span class="nc" id="L490">        ConfigurationHolder.getString(</span>
            &quot;extraalgs.&quot; + algName + &quot;.subalgs.&quot; + subAlg + &quot;.oid&quot;);

<span class="nc bnc" id="L493" title="All 4 branches missed.">    if (oidEnd != null &amp;&amp; oidTree != null) {</span>
<span class="nc" id="L494">      return oidTree + &quot;.&quot; + oidEnd;</span>
    }
<span class="nc bnc" id="L496" title="All 2 branches missed.">    if (oidEnd != null) {</span>
<span class="nc" id="L497">      return oidEnd;</span>
    } else {
<span class="nc" id="L499">      return null;</span>
    }
  }

  /**
   * @return true if the Base64CertData table should be used for storing the
   *     certificates.
   */
  public static boolean useBase64CertTable() {
<span class="nc" id="L508">    final String value =</span>
<span class="nc" id="L509">        ConfigurationHolder.getString(&quot;database.useSeparateCertificateTable&quot;);</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">    return value != null &amp;&amp; Boolean.parseBoolean(value.trim());</span>
  }

  /**
   * @param tableName Name of DB table
   * @return If database integrity protection should be used or not.
   */
  public static boolean useDatabaseIntegrityProtection(final String tableName) {
    // First check if we have explicit configuration for this entity
<span class="nc" id="L519">    final String enableProtect =</span>
<span class="nc" id="L520">        ConfigurationHolder.getString(</span>
            &quot;databaseprotection.enablesign.&quot; + tableName);
<span class="nc bnc" id="L522" title="All 2 branches missed.">    if (enableProtect != null) {</span>
<span class="nc" id="L523">      return Boolean.TRUE.toString().equalsIgnoreCase(enableProtect);</span>
    }
    // Otherwise use the global or default
<span class="nc" id="L526">    return Boolean.TRUE</span>
<span class="nc" id="L527">        .toString()</span>
<span class="nc" id="L528">        .equalsIgnoreCase(</span>
<span class="nc" id="L529">            ConfigurationHolder.getString(&quot;databaseprotection.enablesign&quot;));</span>
  }

  /**
   * @param tableName Name of DB table
   * @return If database integrity verification should be used or not.
   */
  public static boolean useDatabaseIntegrityVerification(
      final String tableName) {
    // First check if we have explicit configuration for this entity
<span class="nc" id="L539">    final String enableVerify =</span>
<span class="nc" id="L540">        ConfigurationHolder.getString(</span>
            &quot;databaseprotection.enableverify.&quot; + tableName);
<span class="nc bnc" id="L542" title="All 2 branches missed.">    if (enableVerify != null) {</span>
<span class="nc" id="L543">      return Boolean.TRUE.toString().equalsIgnoreCase(enableVerify);</span>
    }
    // Otherwise use the global or default
<span class="nc" id="L546">    return Boolean.TRUE</span>
<span class="nc" id="L547">        .toString()</span>
<span class="nc" id="L548">        .equalsIgnoreCase(</span>
<span class="nc" id="L549">            ConfigurationHolder.getString(&quot;databaseprotection.enableverify&quot;));</span>
  }

  /**
   * @return bool
   */
  public static boolean getCaKeepOcspExtendedService() {
<span class="nc" id="L556">    return Boolean.valueOf(</span>
<span class="nc" id="L557">        ConfigurationHolder.getString(&quot;ca.keepocspextendedservice&quot;)</span>
<span class="nc" id="L558">            .toLowerCase());</span>
  }

  /**
   * @return the number of rows that should be fetched at the time when creating
   *     CRLs.
   */
  public static int getDatabaseRevokedCertInfoFetchSize() {
<span class="nc" id="L566">    return Long.valueOf(</span>
<span class="nc" id="L567">            getLongValue(&quot;database.crlgenfetchsize&quot;,  DEFAULT_FETCH, &quot;rows&quot;))</span>
<span class="nc" id="L568">        .intValue();</span>
  }

  /** Default fetch size. */
  private static final long DEFAULT_FETCH = 500000L;

  /**
   * Used just in {@link #getForbiddenCharacters()}. The method is called very
   * often so we declare this String in the class so it does not have to be each
   * time the method is called.
   */
  private static final String FORBIDDEN_CARACTERS_KEY = &quot;forbidden.characters&quot;;
  /**
   * Characters forbidden in fields to be stored in the DB.
   *
   * @return all forbidden characters.
   */
  public static char[] getForbiddenCharacters() {
    // Using 'instance().getString' instead of 'getString' since an empty
    // String (size 0) must be returned when the property is defined without
    // any value.
    final String s =
<span class="fc" id="L590">        ConfigurationHolder.instance().getString(FORBIDDEN_CARACTERS_KEY);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">    if (s == null) {</span>
<span class="fc" id="L592">      return ConfigurationHolder.getDefaultValue(FORBIDDEN_CARACTERS_KEY)</span>
<span class="fc" id="L593">          .toCharArray();</span>
    }
<span class="fc" id="L595">    return s.toCharArray();</span>
  }

  /**
   * @return true if sign mechanisms that uses pkcs#11 for hashing should be
   *     disabled.
   */
  public static boolean p11disableHashingSignMechanisms() {
<span class="nc" id="L603">    final String value =</span>
<span class="nc" id="L604">        ConfigurationHolder.getString(&quot;pkcs11.disableHashingSignMechanisms&quot;);</span>
<span class="nc bnc" id="L605" title="All 4 branches missed.">    return value == null || Boolean.parseBoolean(value.trim());</span>
  }

  /** @return true key store content of Crypto Tokens should be cached. */
  public static boolean isKeyStoreCacheEnabled() {
<span class="fc" id="L610">    return Boolean.parseBoolean(</span>
<span class="fc" id="L611">        ConfigurationHolder.getString(&quot;cryptotoken.keystorecache&quot;));</span>
  }

  /** Java 6: http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider
   *  TLS versions: SSLv3, TLSv1, SSLv2Hello
   * Java 7: http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider
   *  TLS versions: SSLv3, TLSv1, TLSv1.1, TLSv1.2
   *  Cipher suites with SHA384 and SHA256 are available only for TLS 1.2 or later.
   * Java 8: http://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider
   *  TLS versions: SSLv3, TLSv1, TLSv1.1, TLSv1.2
   *  Cipher suites with SHA384 and SHA256 are available only for TLS 1.2 or later.
   *  @return a list of enabled TLS protocol versions and cipher suites */
  public static String[] getAvailableCipherSuites() {
<span class="nc" id="L624">    final List&lt;String&gt; availableCipherSuites = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">    for (int i = 0; i &lt; MAX_SUITES; i++) {</span>
<span class="nc" id="L626">      final String key = &quot;authkeybind.ciphersuite.&quot; + i;</span>
<span class="nc" id="L627">      final String value = ConfigurationHolder.getString(key);</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">      if (value == null</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">          || value.indexOf(AVAILABLE_CIPHER_SUITES_SPLIT_CHAR) == -1) {</span>
<span class="nc" id="L630">        continue;</span>
      }
<span class="nc" id="L632">      availableCipherSuites.add(value);</span>
    }
<span class="nc" id="L634">    return availableCipherSuites.toArray(new String[0]);</span>
  }

  /** Max number of supported suites. */
  private static final int MAX_SUITES = 255;

  /**
   * Gets the maximum number of entries in the CT cache. Each entry contains the
   * SCTs for a given certificate. Each SCT will be around 100-150 bytes, and a
   * certificate will typically have 2-4 SCTs. Also, the cache may temporarily
   * overshoot by 50%. There's also some overhead for the cache data structure
   * (ConcurrentCache).
   *
   * &lt;p&gt;-1 means no limit (and not &quot;off&quot;). The default is 100 000.
   *
   * @return max entries
   * @see #getCTCacheEnabled
   */
  public static long getCTCacheMaxEntries() {
<span class="nc" id="L653">    return getLongValue(</span>
        &quot;ct.cache.maxentries&quot;, HUNDRED_SECONDS, &quot;number of entries in cache&quot;);
  }

  /**
   * @return How many milliseconds between periodic cache cleanup. The cleanup
   *     routine is only run when the cache is filled with too many entries.
   */
  public static long getCTCacheCleanupInterval() {
<span class="nc" id="L662">    return getLongValue(</span>
        &quot;ct.cache.cleanupinterval&quot;,
        TEN_SECONDS,
        &quot;milliseconds between periodic cache cleanup&quot;);
  }

  /** @return Whether caching of SCTs should be enabled. The default is true. */
  public static boolean getCTCacheEnabled() {
<span class="nc" id="L670">    final String value = ConfigurationHolder.getString(&quot;ct.cache.enabled&quot;);</span>
<span class="nc bnc" id="L671" title="All 4 branches missed.">    return value == null || !value.trim().equalsIgnoreCase(&quot;false&quot;);</span>
  }

  /**
   * @return Whether log availability should be tracked, and requests should
   *     &quot;fast fail&quot; whenever a log is known to be down. A log is &quot;known to be
   *     down&quot; when it is either unreachable or responds with an HTTP error
   *     status to a request.
   */
  public static boolean getCTFastFailEnabled() {
<span class="nc" id="L681">    final String value = ConfigurationHolder.getString(&quot;ct.fastfail.enabled&quot;);</span>
<span class="nc bnc" id="L682" title="All 4 branches missed.">    return value != null &amp;&amp; value.trim().equalsIgnoreCase(TRUE);</span>
  }

  /**
   * @return How long time (in milliseconds) EJBCA should wait until trying to
   *     use a log which has failed to respond to a request.
   */
  public static long getCTFastFailBackOff() {
<span class="nc" id="L690">    return getLongValue(&quot;ct.fastfail.backoff&quot;, MS_PER_S, &quot;milliseconds&quot;);</span>
  }

  /** Milliseconds. */
  private static final long MS_PER_S = 1000L;
  /** Ten seconds. */
  private static final long TEN_SECONDS = 10L * MS_PER_S;
  /** Thirty Seconds. */
  private static final long THIRTY_SECONDS = 30L * MS_PER_S;
  /** 100 seconds. */
  private static final long HUNDRED_SECONDS = 100L * MS_PER_S;

  /** @return true if key should be unmodifiable after generation. */
  public static boolean makeKeyUnmodifiableAfterGeneration() {
<span class="fc" id="L704">    final String value =</span>
<span class="fc" id="L705">        ConfigurationHolder.getString(</span>
            &quot;pkcs11.makeKeyUnmodifiableAfterGeneration&quot;);
<span class="pc bpc" id="L707" title="2 of 4 branches missed.">    return value != null &amp;&amp; Boolean.parseBoolean(value.trim());</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>