<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>X509CA.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca</a> &gt; <span class="el_source">X509CA.java</span></div><h1>X509CA.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.cert.CRLException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.SimpleTimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.DERGeneralizedTime;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.DERNull;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.DERSet;
import org.bouncycastle.asn1.icao.ICAOObjectIdentifiers;
import org.bouncycastle.asn1.nist.NISTObjectIdentifiers;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x500.X500NameStyle;
import org.bouncycastle.asn1.x509.AccessDescription;
import org.bouncycastle.asn1.x509.AuthorityInformationAccess;
import org.bouncycastle.asn1.x509.AuthorityKeyIdentifier;
import org.bouncycastle.asn1.x509.CRLDistPoint;
import org.bouncycastle.asn1.x509.CRLNumber;
import org.bouncycastle.asn1.x509.DistributionPoint;
import org.bouncycastle.asn1.x509.DistributionPointName;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.asn1.x509.ExtensionsGenerator;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.bouncycastle.asn1.x509.IssuingDistributionPoint;
import org.bouncycastle.asn1.x509.KeyUsage;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.cert.CertException;
import org.bouncycastle.cert.X509CRLHolder;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v2CRLBuilder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;
import org.bouncycastle.cert.jcajce.JcaX509ExtensionUtils;
import org.bouncycastle.cms.CMSEnvelopedData;
import org.bouncycastle.cms.CMSEnvelopedDataGenerator;
import org.bouncycastle.cms.CMSException;
import org.bouncycastle.cms.CMSProcessableByteArray;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import org.bouncycastle.cms.CMSSignedGenerator;
import org.bouncycastle.cms.CMSTypedData;
import org.bouncycastle.cms.RecipientInformation;
import org.bouncycastle.cms.RecipientInformationStore;
import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
import org.bouncycastle.cms.jcajce.JceCMSContentEncryptorBuilder;
import org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient;
import org.bouncycastle.cms.jcajce.JceKeyTransRecipientInfoGenerator;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.BufferingContentSigner;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
import org.bouncycastle.pkcs.PKCS10CertificationRequest;
import org.bouncycastle.util.CollectionStore;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.ErrorCode;
import org.cesecore.certificates.ca.catoken.CAToken;
import org.cesecore.certificates.ca.catoken.CATokenConstants;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAService;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceInfo;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceTypes;
import org.cesecore.certificates.ca.internal.CertificateValidity;
import org.cesecore.certificates.ca.internal.RequestAndPublicKeySelector;
import org.cesecore.certificates.ca.internal.SernoGenerator;
import org.cesecore.certificates.ca.internal.SernoGeneratorRandom;
import org.cesecore.certificates.certificate.CertificateConstants;
import org.cesecore.certificates.certificate.CertificateCreateException;
import org.cesecore.certificates.certificate.IllegalKeyException;
import org.cesecore.certificates.certificate.certextensions.AvailableCustomCertificateExtensionsConfiguration;
import org.cesecore.certificates.certificate.certextensions.CertificateExtension;
import org.cesecore.certificates.certificate.certextensions.CertificateExtensionException;
import org.cesecore.certificates.certificate.certextensions.CertificateExtensionFactory;
import org.cesecore.certificates.certificate.certextensions.CustomCertificateExtension;
import org.cesecore.certificates.certificate.request.RequestMessage;
import org.cesecore.certificates.certificateprofile.CertificatePolicy;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificatetransparency.CTLogException;
import org.cesecore.certificates.certificatetransparency.CTLogInfo;
import org.cesecore.certificates.certificatetransparency.CertificateTransparency;
import org.cesecore.certificates.certificatetransparency.CertificateTransparencyFactory;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.certificates.endentity.EndEntityType;
import org.cesecore.certificates.endentity.EndEntityTypes;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.cesecore.certificates.ocsp.SHA1DigestCalculator;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.certificates.util.dn.DNFieldsUtil;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.keys.token.CryptoToken;
import org.cesecore.keys.token.CryptoTokenOfflineException;
import org.cesecore.keys.token.IllegalCryptoTokenException;
import org.cesecore.keys.token.NullCryptoToken;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.keys.validation.IssuancePhase;
import org.cesecore.keys.validation.ValidationException;
import org.cesecore.util.CeSecoreNameStyle;
import org.cesecore.util.CertTools;
import org.cesecore.util.PrintableStringNameStyle;
import org.cesecore.util.SimpleTime;
import org.cesecore.util.StringTools;

/**
 * X509CA is a implementation of a CA and holds data specific for Certificate
 * and CRL generation according to the X509 standard.
 *
 * @version $Id: X509CA.java 31882 2019-03-18 13:50:56Z anatom $
 */
public class X509CA extends CA implements Serializable {

  private static final long serialVersionUID = -2882572653108530258L;
  /** Logger. */
<span class="fc" id="L173">  private static final Logger LOG = Logger.getLogger(X509CA.class);</span>

  /** Internal localization of logs and errors. */
  private static final InternalResources INTRES =
<span class="fc" id="L177">      InternalResources.getInstance();</span>

  /**
   * Version of this class, if this is increased the upgrade() method will be
   * called automatically.
   */
  public static final float LATEST_VERSION = 24;

  // protected fields for properties specific to this type of CA.
  /** Policies. */
  protected static final String POLICIES = &quot;policies&quot;;
  /** Name. */
  protected static final String SUBJECTALTNAME = &quot;subjectaltname&quot;;
  /** OD. */
  protected static final String USEAUTHORITYKEYIDENTIFIER =
      &quot;useauthoritykeyidentifier&quot;;
  /** ID. */
  protected static final String AUTHORITYKEYIDENTIFIERCRITICAL =
      &quot;authoritykeyidentifiercritical&quot;;
  /** Access. */
  protected static final String AUTHORITY_INFORMATION_ACCESS =
      &quot;authorityinformationaccess&quot;;
  /** URI. */
  protected static final String CERTIFICATE_AIA_DEFAULT_CA_ISSUER_URI =
      &quot;certificateaiadefaultcaissueruri&quot;;
  /** Number. */
  protected static final String USECRLNUMBER = &quot;usecrlnumber&quot;;
  /** Number. */
  protected static final String CRLNUMBERCRITICAL = &quot;crlnumbercritical&quot;;
  /** Distribution. */
  protected static final String DEFAULTCRLDISTPOINT = &quot;defaultcrldistpoint&quot;;
  /** Issuer. */
  protected static final String DEFAULTCRLISSUER = &quot;defaultcrlissuer&quot;;
  /** Locator. */
  protected static final String DEFAULTOCSPSERVICELOCATOR =
      &quot;defaultocspservicelocator&quot;;
  /** CRL. */
  protected static final String CADEFINEDFRESHESTCRL = &quot;cadefinedfreshestcrl&quot;;
  /** UTF8. */
  protected static final String USEUTF8POLICYTEXT = &quot;useutf8policytext&quot;;
  /** Printable. */
  protected static final String USEPRINTABLESTRINGSUBJECTDN =
      &quot;useprintablestringsubjectdn&quot;;
  /** Order. */
  protected static final String USELDAPDNORDER = &quot;useldapdnorder&quot;;
  /** Critical. */
  protected static final String USECRLDISTRIBUTIONPOINTONCRL =
      &quot;usecrldistributionpointoncrl&quot;;
  /** Critical. */
  protected static final String CRLDISTRIBUTIONPOINTONCRLCRITICAL =
      &quot;crldistributionpointoncrlcritical&quot;;
  /** Secret. */
  protected static final String CMPRAAUTHSECRET = &quot;cmpraauthsecret&quot;;
  /** Constraints. */
  protected static final String NAMECONSTRAINTSPERMITTED =
      &quot;nameconstraintspermitted&quot;;
  /** Constraints. */
  protected static final String NAMECONSTRAINTSEXCLUDED =
      &quot;nameconstraintsexcluded&quot;;
  /** External CDP. */
  protected static final String EXTERNALCDP = &quot;externalcdp&quot;;
  /** Name changed. */
  protected static final String NAMECHANGED = &quot;namechanged&quot;;
  /** Transparency. */
<span class="fc" id="L241">  private static final CertificateTransparency CT =</span>
<span class="fc" id="L242">      CertificateTransparencyFactory.getInstance();</span>

  // Public Methods
  /**
   * Creates a new instance of CA, this constructor should be used when a new CA
   * is created.
   *
   * @param cainfo Info
   */
  public X509CA(final X509CAInfo cainfo) {
<span class="fc" id="L252">    super(cainfo);</span>
    // Verify integrity if caInfo, either one SubjectDN or SubjectAltName needs
    // to be filled in
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">    if (StringUtils.isEmpty(</span>
<span class="fc" id="L256">            DNFieldsUtil.removeAllEmpties(cainfo.getSubjectDN()))</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        &amp;&amp; StringUtils.isEmpty(cainfo.getSubjectAltName())) {</span>
<span class="nc" id="L258">      throw new IllegalArgumentException(</span>
          &quot;Subject DN and Alt Name can't both be blank for an X509 CA.&quot;);
    }
<span class="fc" id="L261">    data.put(POLICIES, cainfo.getPolicies());</span>
<span class="fc" id="L262">    data.put(SUBJECTALTNAME, cainfo.getSubjectAltName());</span>
<span class="fc" id="L263">    setUseAuthorityKeyIdentifier(cainfo.getUseAuthorityKeyIdentifier());</span>
<span class="fc" id="L264">    setAuthorityKeyIdentifierCritical(</span>
<span class="fc" id="L265">        cainfo.getAuthorityKeyIdentifierCritical());</span>
<span class="fc" id="L266">    setUseCRLNumber(cainfo.getUseCRLNumber());</span>
<span class="fc" id="L267">    setCRLNumberCritical(cainfo.getCRLNumberCritical());</span>
<span class="fc" id="L268">    setDefaultCRLDistPoint(cainfo.getDefaultCRLDistPoint());</span>
<span class="fc" id="L269">    setDefaultCRLIssuer(cainfo.getDefaultCRLIssuer());</span>
<span class="fc" id="L270">    setCADefinedFreshestCRL(cainfo.getCADefinedFreshestCRL());</span>
<span class="fc" id="L271">    setDefaultOCSPServiceLocator(cainfo.getDefaultOCSPServiceLocator());</span>
<span class="fc" id="L272">    setUseUTF8PolicyText(cainfo.getUseUTF8PolicyText());</span>
<span class="fc" id="L273">    setUsePrintableStringSubjectDN(cainfo.getUsePrintableStringSubjectDN());</span>
<span class="fc" id="L274">    setUseLdapDNOrder(cainfo.getUseLdapDnOrder());</span>
<span class="fc" id="L275">    setUseCrlDistributionPointOnCrl(cainfo.getUseCrlDistributionPointOnCrl());</span>
<span class="fc" id="L276">    setCrlDistributionPointOnCrlCritical(</span>
<span class="fc" id="L277">        cainfo.getCrlDistributionPointOnCrlCritical());</span>
<span class="fc" id="L278">    setKeepExpiredCertsOnCRL(cainfo.getKeepExpiredCertsOnCRL());</span>
<span class="fc" id="L279">    setCmpRaAuthSecret(cainfo.getCmpRaAuthSecret());</span>
    // CA Issuer URI to put in CRLs (RFC5280 section 5.2.7, not the URI to put
    // in certs
<span class="fc" id="L282">    setAuthorityInformationAccess(cainfo.getAuthorityInformationAccess());</span>
<span class="fc" id="L283">    setCertificateAiaDefaultCaIssuerUri(</span>
<span class="fc" id="L284">        cainfo.getCertificateAiaDefaultCaIssuerUri());</span>
<span class="fc" id="L285">    setNameConstraintsPermitted(cainfo.getNameConstraintsPermitted());</span>
<span class="fc" id="L286">    setNameConstraintsExcluded(cainfo.getNameConstraintsExcluded());</span>
<span class="fc" id="L287">    data.put(CA.CATYPE, Integer.valueOf(CAInfo.CATYPE_X509));</span>
<span class="fc" id="L288">    data.put(VERSION, Float.valueOf(LATEST_VERSION));</span>
<span class="fc" id="L289">    setCaSerialNumberOctetSize(cainfo.getCaSerialNumberOctetSize());</span>
<span class="fc" id="L290">  }</span>

  /**
   * Constructor used when retrieving existing X509CA from database.
   *
   * @param data Data
   * @param caId ID
   * @param subjectDn DN
   * @param name Name
   * @param status Status
   * @param updateTime Updated
   * @param expireTime Expiry
   */
  @SuppressWarnings(&quot;deprecation&quot;)
  public X509CA(
      final HashMap&lt;Object, Object&gt; data,
      final int caId,
      final String subjectDn,
      final String name,
      final int status,
      final Date updateTime,
      final Date expireTime) {
<span class="fc" id="L312">    super(data);</span>
<span class="fc" id="L313">    setExpireTime(</span>
        expireTime); // Make sure the internal state is synched with the
                     // database column. Required for upgrades from EJBCA 3.5.6
                     // or
    // EJBCA 3.6.1 and earlier.
<span class="fc" id="L318">    final List&lt;ExtendedCAServiceInfo&gt; externalcaserviceinfos =</span>
        new ArrayList&lt;&gt;();
<span class="fc bfc" id="L320" title="All 2 branches covered.">    for (final Integer type : getExternalCAServiceTypes()) {</span>
      // Type was removed in 6.0.0. It is removed from the database in the
      // upgrade method in this class, but it needs to be ignored
      // for instantiation.
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">      if (type != ExtendedCAServiceTypes.TYPE_OCSPEXTENDEDSERVICE) {</span>
<span class="fc" id="L325">        ExtendedCAServiceInfo info =</span>
<span class="fc" id="L326">            this.getExtendedCAServiceInfo(type.intValue());</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (info != null) {</span>
<span class="fc" id="L328">          externalcaserviceinfos.add(info);</span>
        }
      }
<span class="fc" id="L331">    }</span>
<span class="fc" id="L332">    X509CAInfo info =</span>
        new X509CAInfo.X509CAInfoBuilder()
<span class="fc" id="L334">            .setSubjectDn(subjectDn)</span>
<span class="fc" id="L335">            .setName(name)</span>
<span class="fc" id="L336">            .setStatus(status)</span>
<span class="fc" id="L337">            .setUpdateTime(updateTime)</span>
<span class="fc" id="L338">            .setSubjectAltName(getSubjectAltName())</span>
<span class="fc" id="L339">            .setCertificateProfileId(getCertificateProfileId())</span>
<span class="fc" id="L340">            .setDefaultCertProfileId(getDefaultCertificateProfileId())</span>
<span class="fc" id="L341">            .setUseNoConflictCertificateData(isUseNoConflictCertificateData())</span>
<span class="fc" id="L342">            .setEncodedValidity(getEncodedValidity())</span>
<span class="fc" id="L343">            .setExpireTime(getExpireTime())</span>
<span class="fc" id="L344">            .setCaType(getCAType())</span>
<span class="fc" id="L345">            .setSignedBy(getSignedBy())</span>
<span class="fc" id="L346">            .setCertificateChain(getCertificateChain())</span>
<span class="fc" id="L347">            .setCaToken(getCAToken())</span>
<span class="fc" id="L348">            .setDescription(getDescription())</span>
<span class="fc" id="L349">            .setCaSerialNumberOctetSize(getSerialNumberOctetSize())</span>
<span class="fc" id="L350">            .setRevocationReason(getRevocationReason())</span>
<span class="fc" id="L351">            .setRevocationDate(getRevocationDate())</span>
<span class="fc" id="L352">            .setPolicies(getPolicies())</span>
<span class="fc" id="L353">            .setCrlPeriod(getCRLPeriod())</span>
<span class="fc" id="L354">            .setCrlIssueInterval(getCRLIssueInterval())</span>
<span class="fc" id="L355">            .setCrlOverlapTime(getCRLOverlapTime())</span>
<span class="fc" id="L356">            .setDeltaCrlPeriod(getDeltaCRLPeriod())</span>
<span class="fc" id="L357">            .setCrlPublishers(getCRLPublishers())</span>
<span class="fc" id="L358">            .setValidators(getValidators())</span>
<span class="fc" id="L359">            .setUseAuthorityKeyIdentifier(getUseAuthorityKeyIdentifier())</span>
<span class="fc" id="L360">            .setAuthorityKeyIdentifierCritical(</span>
<span class="fc" id="L361">                getAuthorityKeyIdentifierCritical())</span>
<span class="fc" id="L362">            .setUseCrlNumber(getUseCRLNumber())</span>
<span class="fc" id="L363">            .setCrlNumberCritical(getCRLNumberCritical())</span>
<span class="fc" id="L364">            .setDefaultCrlDistPoint(getDefaultCRLDistPoint())</span>
<span class="fc" id="L365">            .setDefaultCrlIssuer(getDefaultCRLIssuer())</span>
<span class="fc" id="L366">            .setDefaultOcspCerviceLocator(getDefaultOCSPServiceLocator())</span>
<span class="fc" id="L367">            .setAuthorityInformationAccess(getAuthorityInformationAccess())</span>
<span class="fc" id="L368">            .setCertificateAiaDefaultCaIssuerUri(</span>
<span class="fc" id="L369">                getCertificateAiaDefaultCaIssuerUri())</span>
<span class="fc" id="L370">            .setNameConstraintsPermitted(getNameConstraintsPermitted())</span>
<span class="fc" id="L371">            .setNameConstraintsExcluded(getNameConstraintsExcluded())</span>
<span class="fc" id="L372">            .setCaDefinedFreshestCrl(getCADefinedFreshestCRL())</span>
<span class="fc" id="L373">            .setFinishUser(getFinishUser())</span>
<span class="fc" id="L374">            .setExtendedCaServiceInfos(externalcaserviceinfos)</span>
<span class="fc" id="L375">            .setUseUtf8PolicyText(getUseUTF8PolicyText())</span>
<span class="fc" id="L376">            .setApprovals(getApprovals())</span>
<span class="fc" id="L377">            .setUsePrintableStringSubjectDN(getUsePrintableStringSubjectDN())</span>
<span class="fc" id="L378">            .setUseLdapDnOrder(getUseLdapDNOrder())</span>
<span class="fc" id="L379">            .setUseCrlDistributionPointOnCrl(getUseCrlDistributionPointOnCrl())</span>
<span class="fc" id="L380">            .setCrlDistributionPointOnCrlCritical(</span>
<span class="fc" id="L381">                getCrlDistributionPointOnCrlCritical())</span>
<span class="fc" id="L382">            .setIncludeInHealthCheck(getIncludeInHealthCheck())</span>
<span class="fc" id="L383">            .setDoEnforceUniquePublicKeys(isDoEnforceUniquePublicKeys())</span>
<span class="fc" id="L384">            .setDoEnforceUniqueDistinguishedName(</span>
<span class="fc" id="L385">                isDoEnforceUniqueDistinguishedName())</span>
<span class="fc" id="L386">            .setDoEnforceUniqueSubjectDNSerialnumber(</span>
<span class="fc" id="L387">                isDoEnforceUniqueSubjectDNSerialnumber())</span>
<span class="fc" id="L388">            .setUseCertReqHistory(isUseCertReqHistory())</span>
<span class="fc" id="L389">            .setUseUserStorage(isUseUserStorage())</span>
<span class="fc" id="L390">            .setUseCertificateStorage(isUseCertificateStorage())</span>
<span class="fc" id="L391">            .setAcceptRevocationNonExistingEntry(</span>
<span class="fc" id="L392">                isAcceptRevocationNonExistingEntry())</span>
<span class="fc" id="L393">            .setCmpRaAuthSecret(getCmpRaAuthSecret())</span>
<span class="fc" id="L394">            .setKeepExpiredCertsOnCRL(getKeepExpiredCertsOnCRL())</span>
<span class="fc" id="L395">            .build();</span>
<span class="fc" id="L396">    info.setExternalCdp(getExternalCdp());</span>
<span class="fc" id="L397">    info.setNameChanged(getNameChanged());</span>
    // These to settings were deprecated in 6.8.0, but are still set for upgrade
    // reasons
<span class="fc" id="L400">    info.setApprovalProfile(getApprovalProfile());</span>
<span class="fc" id="L401">    info.setApprovalSettings(getApprovalSettings());</span>
<span class="fc" id="L402">    super.setCAInfo(info);</span>
<span class="fc" id="L403">    setCAId(caId);</span>
<span class="fc" id="L404">  }</span>

  private boolean isUseNoConflictCertificateData() {
<span class="fc" id="L407">    return getBoolean(USENOCONFLICTCERTIFICATEDATA, false);</span>
  }

  // Public Methods.

  /** @return policies.*/
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;CertificatePolicy&gt; getPolicies() {
<span class="fc" id="L415">    return (List&lt;CertificatePolicy&gt;) data.get(POLICIES);</span>
  }
  /** @param policies policies */
  public void setPolicies(final List&lt;CertificatePolicy&gt; policies) {
<span class="fc" id="L419">    data.put(POLICIES, policies);</span>
<span class="fc" id="L420">  }</span>
  /** @return name */
  public String getSubjectAltName() {
<span class="fc" id="L423">    return (String) data.get(SUBJECTALTNAME);</span>
  }
  /** @param altName name */
  public void setSubjectAltName(final String altName) {
<span class="fc" id="L427">    data.put(SUBJECTALTNAME, altName);</span>
<span class="fc" id="L428">  }</span>

  /** @return boolean */
  public boolean getUseAuthorityKeyIdentifier() {
<span class="fc" id="L432">    return ((Boolean) data.get(USEAUTHORITYKEYIDENTIFIER)).booleanValue();</span>
  }
  /** @param useauthoritykeyidentifier boolean */
  public void setUseAuthorityKeyIdentifier(
          final boolean useauthoritykeyidentifier) {
<span class="fc" id="L437">    data.put(</span>
<span class="fc" id="L438">        USEAUTHORITYKEYIDENTIFIER, Boolean.valueOf(useauthoritykeyidentifier));</span>
<span class="fc" id="L439">  }</span>
  /**  @return boolean */
  public boolean getAuthorityKeyIdentifierCritical() {
<span class="fc" id="L442">    return ((Boolean) data.get(AUTHORITYKEYIDENTIFIERCRITICAL)).booleanValue();</span>
  }

  /** @param authoritykeyidentifiercritical boolean */
  public void setAuthorityKeyIdentifierCritical(
      final boolean authoritykeyidentifiercritical) {
<span class="fc" id="L448">    data.put(</span>
        AUTHORITYKEYIDENTIFIERCRITICAL,
<span class="fc" id="L450">        Boolean.valueOf(authoritykeyidentifiercritical));</span>
<span class="fc" id="L451">  }</span>

  /**
   * CA Issuer URI to put in CRLs (RFC5280 section 5.2.7, not the URI to put in
   * certs.
   *
   * @return List of strings
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getAuthorityInformationAccess() {
<span class="fc" id="L461">    return (List&lt;String&gt;) data.get(AUTHORITY_INFORMATION_ACCESS);</span>
  }

  /**
   * CA Issuer URI to put in CRLs (RFC5280 section 5.2.7, not the URI to put in
   * certs.
   *
   * @param authorityInformationAccess List of strings
   */
  public void setAuthorityInformationAccess(
      final List&lt;String&gt; authorityInformationAccess) {
<span class="fc" id="L472">    data.put(AUTHORITY_INFORMATION_ACCESS, authorityInformationAccess);</span>
<span class="fc" id="L473">  }</span>
  /** @return URIs */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getCertificateAiaDefaultCaIssuerUri() {
<span class="fc" id="L477">    return (List&lt;String&gt;) data.get(CERTIFICATE_AIA_DEFAULT_CA_ISSUER_URI);</span>
  }
  /** @param uris urls */
  public void setCertificateAiaDefaultCaIssuerUri(final List&lt;String&gt; uris) {
<span class="fc" id="L481">    data.put(CERTIFICATE_AIA_DEFAULT_CA_ISSUER_URI, uris);</span>
<span class="fc" id="L482">  }</span>
  /** @return boolean */
  public boolean getUseCRLNumber() {
<span class="fc" id="L485">    return ((Boolean) data.get(USECRLNUMBER)).booleanValue();</span>
  }
  /** @param usecrlnumber boolean */
  public void setUseCRLNumber(final boolean usecrlnumber) {
<span class="fc" id="L489">    data.put(USECRLNUMBER, Boolean.valueOf(usecrlnumber));</span>
<span class="fc" id="L490">  }</span>
  /** @return boolean  */
  public boolean getCRLNumberCritical() {
<span class="fc" id="L493">    return ((Boolean) data.get(CRLNUMBERCRITICAL)).booleanValue();</span>
  }
  /** @param crlnumbercritical boolean  */
  public void setCRLNumberCritical(final boolean crlnumbercritical) {
<span class="fc" id="L497">    data.put(CRLNUMBERCRITICAL, Boolean.valueOf(crlnumbercritical));</span>
<span class="fc" id="L498">  }</span>
  /** @return distribution */
  public String getDefaultCRLDistPoint() {
<span class="fc" id="L501">    return (String) data.get(DEFAULTCRLDISTPOINT);</span>
  }
  /** @param defaultcrldistpoint distribution */
  public void setDefaultCRLDistPoint(final String defaultcrldistpoint) {
<span class="fc bfc" id="L505" title="All 2 branches covered.">    if (defaultcrldistpoint == null) {</span>
<span class="fc" id="L506">      data.put(DEFAULTCRLDISTPOINT, &quot;&quot;);</span>
    } else {
<span class="fc" id="L508">      data.put(DEFAULTCRLDISTPOINT, defaultcrldistpoint);</span>
    }
<span class="fc" id="L510">  }</span>
  /** @return issuer */
  public String getDefaultCRLIssuer() {
<span class="fc" id="L513">    return (String) data.get(DEFAULTCRLISSUER);</span>
  }
  /** @param defaultcrlissuer issuer */
  public void setDefaultCRLIssuer(final String defaultcrlissuer) {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">    if (defaultcrlissuer == null) {</span>
<span class="fc" id="L518">      data.put(DEFAULTCRLISSUER, &quot;&quot;);</span>
    } else {
<span class="nc" id="L520">      data.put(DEFAULTCRLISSUER, defaultcrlissuer);</span>
    }
<span class="fc" id="L522">  }</span>
  /** @return CRL */
  public String getCADefinedFreshestCRL() {
<span class="fc" id="L525">    return (String) data.get(CADEFINEDFRESHESTCRL);</span>
  }
  /** @param cadefinedfreshestcrl CRL */
  public void setCADefinedFreshestCRL(final String cadefinedfreshestcrl) {
<span class="fc bfc" id="L529" title="All 2 branches covered.">    if (cadefinedfreshestcrl == null) {</span>
<span class="fc" id="L530">      data.put(CADEFINEDFRESHESTCRL, &quot;&quot;);</span>
    } else {
<span class="fc" id="L532">      data.put(CADEFINEDFRESHESTCRL, cadefinedfreshestcrl);</span>
    }
<span class="fc" id="L534">  }</span>
  /** @return boolean */
  public String getDefaultOCSPServiceLocator() {
<span class="fc" id="L537">    return (String) data.get(DEFAULTOCSPSERVICELOCATOR);</span>
  }
  /** @param defaultocsplocator boolean */
  public void setDefaultOCSPServiceLocator(final String defaultocsplocator) {
<span class="fc bfc" id="L541" title="All 2 branches covered.">    if (defaultocsplocator == null) {</span>
<span class="fc" id="L542">      data.put(DEFAULTOCSPSERVICELOCATOR, &quot;&quot;);</span>
    } else {
<span class="fc" id="L544">      data.put(DEFAULTOCSPSERVICELOCATOR, defaultocsplocator);</span>
    }
<span class="fc" id="L546">  }</span>
  /** @return boolean */
  public boolean getUseUTF8PolicyText() {
<span class="fc" id="L549">    return ((Boolean) data.get(USEUTF8POLICYTEXT)).booleanValue();</span>
  }
  /** @param useutf8 boolean */
  public void setUseUTF8PolicyText(final boolean useutf8) {
<span class="fc" id="L553">    data.put(USEUTF8POLICYTEXT, Boolean.valueOf(useutf8));</span>
<span class="fc" id="L554">  }</span>
  /** @return boolean */
  public boolean getUsePrintableStringSubjectDN() {
<span class="fc" id="L557">    return ((Boolean) data.get(USEPRINTABLESTRINGSUBJECTDN)).booleanValue();</span>
  }
  /** @param useprintablestring boolean */
  public void setUsePrintableStringSubjectDN(final boolean useprintablestring) {
<span class="fc" id="L561">    data.put(USEPRINTABLESTRINGSUBJECTDN, Boolean.valueOf(useprintablestring));</span>
<span class="fc" id="L562">  }</span>
  /** @return boolean */
  public boolean getUseLdapDNOrder() {
<span class="fc" id="L565">    return ((Boolean) data.get(USELDAPDNORDER)).booleanValue();</span>
  }
  /** @param useldapdnorder boolean */
  public void setUseLdapDNOrder(final boolean useldapdnorder) {
<span class="fc" id="L569">    data.put(USELDAPDNORDER, Boolean.valueOf(useldapdnorder));</span>
<span class="fc" id="L570">  }</span>
  /** @return boolean */
  public boolean getUseCrlDistributionPointOnCrl() {
<span class="fc" id="L573">    return ((Boolean) data.get(USECRLDISTRIBUTIONPOINTONCRL)).booleanValue();</span>
  }
  /** @param useCrlDistributionPointOnCrl boolean */
  public void setUseCrlDistributionPointOnCrl(
      final boolean useCrlDistributionPointOnCrl) {
<span class="fc" id="L578">    data.put(</span>
        USECRLDISTRIBUTIONPOINTONCRL,
<span class="fc" id="L580">        Boolean.valueOf(useCrlDistributionPointOnCrl));</span>
<span class="fc" id="L581">  }</span>
  /** @return boolean */
  public boolean getCrlDistributionPointOnCrlCritical() {
<span class="fc" id="L584">    return ((Boolean) data.get(CRLDISTRIBUTIONPOINTONCRLCRITICAL))</span>
<span class="fc" id="L585">        .booleanValue();</span>
  }
  /** @param crlDistributionPointOnCrlCritical boolean */
  public void setCrlDistributionPointOnCrlCritical(
      final boolean crlDistributionPointOnCrlCritical) {
<span class="fc" id="L590">    data.put(</span>
        CRLDISTRIBUTIONPOINTONCRLCRITICAL,
<span class="fc" id="L592">        Boolean.valueOf(crlDistributionPointOnCrlCritical));</span>
<span class="fc" id="L593">  }</span>

  /** @return Encoded name constraints to permit */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getNameConstraintsPermitted() {
<span class="fc" id="L598">    return (List&lt;String&gt;) data.get(NAMECONSTRAINTSPERMITTED);</span>
  }
  /** @param encodedNames names */
  public void setNameConstraintsPermitted(final List&lt;String&gt; encodedNames) {
<span class="fc" id="L602">    data.put(NAMECONSTRAINTSPERMITTED, encodedNames);</span>
<span class="fc" id="L603">  }</span>

  /** @return Encoded name constraints to exclude */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getNameConstraintsExcluded() {
<span class="fc" id="L608">    return (List&lt;String&gt;) data.get(NAMECONSTRAINTSEXCLUDED);</span>
  }
  /** @param encodedNames names */
  public void setNameConstraintsExcluded(final List&lt;String&gt; encodedNames) {
<span class="fc" id="L612">    data.put(NAMECONSTRAINTSEXCLUDED, encodedNames);</span>
<span class="fc" id="L613">  }</span>

  /** @return secret */
  public String getCmpRaAuthSecret() {
    // Default to empty value if it is not set. An empty value will be denied by
    // CRMFMessageHandler
<span class="fc" id="L619">    return (String) getMapValueWithDefault(CMPRAAUTHSECRET, &quot;&quot;);</span>
  }
  /** @param cmpRaAuthSecret secret */
  public void setCmpRaAuthSecret(final String cmpRaAuthSecret) {
<span class="fc" id="L623">    data.put(CMPRAAUTHSECRET, cmpRaAuthSecret);</span>
<span class="fc" id="L624">  }</span>

  /**
   * @return what should be a String formatted URL pointing to an external CA's
   *     CDP.
   */
  public String getExternalCdp() {
<span class="fc" id="L631">    return (String) getMapValueWithDefault(EXTERNALCDP, &quot;&quot;);</span>
  }

  /**
   * Set what should be a String formatted URL pointing to an external CA's CDP.
   *
   * @param externalCdp CDP
   */
  public void setExternalCdp(final String externalCdp) {
<span class="fc" id="L640">    data.put(EXTERNALCDP, externalCdp);</span>
<span class="fc" id="L641">  }</span>

  /** @return size of SN in bytes */
  public Integer getSerialNumberOctetSize() {
<span class="fc" id="L645">    return (Integer)</span>
<span class="fc" id="L646">        getMapValueWithDefault(</span>
            SERIALNUMBEROCTETSIZE,
<span class="fc" id="L648">            CesecoreConfiguration.getSerialNumberOctetSizeForNewCa());</span>
  }

  /** @param serialNumberOctetSize size of SN in bytes */
  public void setCaSerialNumberOctetSize(final int serialNumberOctetSize) {
<span class="fc" id="L653">    data.put(SERIALNUMBEROCTETSIZE, serialNumberOctetSize);</span>
<span class="fc" id="L654">  }</span>

  private Object getMapValueWithDefault(
      final String key, final Object defaultValue) {
<span class="fc" id="L658">    final Object o = data.get(key);</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">    if (o == null) {</span>
<span class="fc" id="L660">      return defaultValue;</span>
    }
<span class="fc" id="L662">    return o;</span>
  }

  /** @param nameChanged boolean */
  public void setNameChanged(final boolean nameChanged) {
<span class="nc bnc" id="L667" title="All 4 branches missed.">    if (getNameChanged() &amp;&amp; !nameChanged) {</span>
      // This must not happen. Once CA &quot;Name Changed&quot; value is set to true it
      // mustn't be set to false again
<span class="nc" id="L670">      LOG.warn(</span>
          &quot;Not supported operation of setting CA Name Change value from TRUE&quot;
              + &quot; to FALSE. Value not set!&quot;);
<span class="nc" id="L673">      return;</span>
    }
<span class="nc" id="L675">    data.put(NAMECHANGED, Boolean.valueOf(nameChanged));</span>
<span class="nc" id="L676">  }</span>

  /**
   * Retrieving NAMECHANGED flag that shows if this CA has gone through the Name
   * Change any time in its history renewal.
   *
   * @return boolean
   */
  public boolean getNameChanged() {
<span class="fc" id="L685">    Boolean v = ((Boolean) data.get(NAMECHANGED));</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">    return (v == null) ? false : v.booleanValue();</span>
  }

  @Override
  public void updateCA(
      final CryptoToken cryptoToken,
      final CAInfo cainfo,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws InvalidAlgorithmException {
<span class="fc" id="L695">    super.updateCA(cryptoToken, cainfo, cceConfig);</span>
<span class="fc" id="L696">    X509CAInfo info = (X509CAInfo) cainfo;</span>
<span class="fc" id="L697">    setPolicies(info.getPolicies());</span>
<span class="fc" id="L698">    setAuthorityInformationAccess(info.getAuthorityInformationAccess());</span>
<span class="fc" id="L699">    setCertificateAiaDefaultCaIssuerUri(</span>
<span class="fc" id="L700">        info.getCertificateAiaDefaultCaIssuerUri());</span>
<span class="fc" id="L701">    setUseAuthorityKeyIdentifier(info.getUseAuthorityKeyIdentifier());</span>
<span class="fc" id="L702">    setAuthorityKeyIdentifierCritical(info.getAuthorityKeyIdentifierCritical());</span>
<span class="fc" id="L703">    setUseCRLNumber(info.getUseCRLNumber());</span>
<span class="fc" id="L704">    setCRLNumberCritical(info.getCRLNumberCritical());</span>
<span class="fc" id="L705">    setDefaultCRLDistPoint(info.getDefaultCRLDistPoint());</span>
<span class="fc" id="L706">    setDefaultCRLIssuer(info.getDefaultCRLIssuer());</span>
<span class="fc" id="L707">    setCADefinedFreshestCRL(info.getCADefinedFreshestCRL());</span>
<span class="fc" id="L708">    setDefaultOCSPServiceLocator(info.getDefaultOCSPServiceLocator());</span>
<span class="fc" id="L709">    setUseUTF8PolicyText(info.getUseUTF8PolicyText());</span>
<span class="fc" id="L710">    setUsePrintableStringSubjectDN(info.getUsePrintableStringSubjectDN());</span>
<span class="fc" id="L711">    setUseLdapDNOrder(info.getUseLdapDnOrder());</span>
<span class="fc" id="L712">    setUseCrlDistributionPointOnCrl(info.getUseCrlDistributionPointOnCrl());</span>
<span class="fc" id="L713">    setCrlDistributionPointOnCrlCritical(</span>
<span class="fc" id="L714">        info.getCrlDistributionPointOnCrlCritical());</span>
<span class="fc" id="L715">    setCmpRaAuthSecret(info.getCmpRaAuthSecret());</span>
<span class="fc" id="L716">    setNameConstraintsPermitted(info.getNameConstraintsPermitted());</span>
<span class="fc" id="L717">    setNameConstraintsExcluded(info.getNameConstraintsExcluded());</span>
<span class="fc" id="L718">    setExternalCdp(info.getExternalCdp());</span>
<span class="fc" id="L719">    setSubjectAltName(info.getSubjectAltName());</span>
<span class="fc" id="L720">    setCaSerialNumberOctetSize(</span>
<span class="fc" id="L721">        Integer.valueOf(info.getCaSerialNumberOctetSize()));</span>
<span class="fc" id="L722">  }</span>

  /**
   * Allows updating of fields that are otherwise not changeable in existing
   * CAs.
   */
  @Override
  public void updateUninitializedCA(final CAInfo cainfo) {
<span class="nc" id="L730">    super.updateUninitializedCA(cainfo);</span>
<span class="nc" id="L731">    X509CAInfo info = (X509CAInfo) cainfo;</span>
<span class="nc" id="L732">    data.put(SUBJECTALTNAME, info.getSubjectAltName());</span>
<span class="nc" id="L733">    data.put(POLICIES, info.getPolicies());</span>
<span class="nc" id="L734">  }</span>

  @Override
  public byte[] createPKCS7(
      final CryptoToken cryptoToken,
      final X509Certificate cert,
      final boolean includeChain)
      throws SignRequestSignatureException {
    // First verify that we signed this certificate
<span class="fc" id="L743">    final X509Certificate cacert = (X509Certificate) getCACertificate();</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">    if (cert != null) {</span>
      try {
        final PublicKey verifyKey;
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        if (cacert != null) {</span>
<span class="fc" id="L748">          verifyKey = cacert.getPublicKey();</span>
        } else {
<span class="nc" id="L750">          verifyKey =</span>
<span class="nc" id="L751">              cryptoToken.getPublicKey(</span>
<span class="nc" id="L752">                  getCAToken()</span>
<span class="nc" id="L753">                      .getAliasFromPurpose(</span>
                          CATokenConstants.CAKEYPURPOSE_CERTSIGN));
        }
<span class="fc" id="L756">        cert.verify(verifyKey);</span>
<span class="nc" id="L757">      } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L758">        throw new SignRequestSignatureException(</span>
            &quot;The cryptotoken was not available, could not create a PKCS7&quot;, e);
<span class="nc" id="L760">      } catch (InvalidKeyException e) {</span>
<span class="nc" id="L761">        throw new SignRequestSignatureException(</span>
            &quot;The specified certificate contains the wrong public key.&quot;, e);
<span class="nc" id="L763">      } catch (CertificateException e) {</span>
<span class="nc" id="L764">        throw new SignRequestSignatureException(</span>
            &quot;An encoding error was encountered.&quot;, e);
<span class="nc" id="L766">      } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L767">        throw new SignRequestSignatureException(</span>
            &quot;The certificate provided was signed with an invalid algorithm.&quot;,
            e);
<span class="nc" id="L770">      } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L771">        throw new SignRequestSignatureException(</span>
            &quot;The crypto provider was not found for verification of the&quot;
                + &quot; certificate.&quot;,
            e);
<span class="nc" id="L775">      } catch (SignatureException e) {</span>
<span class="nc" id="L776">        throw new SignRequestSignatureException(</span>
            &quot;Cannot verify certificate in createPKCS7(), did I sign this?&quot;, e);
<span class="fc" id="L778">      }</span>
    }
<span class="fc" id="L780">    final List&lt;X509Certificate&gt; x509Chain = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">    if (cert != null) {</span>
<span class="fc" id="L782">      x509Chain.add(cert);</span>
    }
<span class="fc bfc" id="L784" title="All 2 branches covered.">    if (includeChain) {</span>
<span class="fc" id="L785">      x509Chain.addAll(</span>
<span class="fc" id="L786">          CertTools.convertCertificateChainToX509Chain(getCertificateChain()));</span>
    }
    List&lt;JcaX509CertificateHolder&gt; certList;
    try {
<span class="fc" id="L790">      certList = CertTools.convertToX509CertificateHolder(x509Chain);</span>
<span class="nc" id="L791">    } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L792">      throw new SignRequestSignatureException(</span>
          &quot;Could not encode certificate&quot;, e);
<span class="fc" id="L794">    }</span>
    try {
<span class="fc" id="L796">      CMSTypedData msg = new CMSProcessableByteArray(new byte[0]);</span>
<span class="fc" id="L797">      CMSSignedDataGenerator gen = new CMSSignedDataGenerator();</span>
<span class="fc" id="L798">      final PrivateKey privateKey =</span>
<span class="fc" id="L799">          cryptoToken.getPrivateKey(</span>
<span class="fc" id="L800">              getCAToken()</span>
<span class="fc" id="L801">                  .getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN));</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">      if (privateKey == null) {</span>
<span class="nc" id="L803">        String msg1 = &quot;createPKCS7: Private key does not exist!&quot;;</span>
<span class="nc" id="L804">        LOG.debug(msg1);</span>
<span class="nc" id="L805">        throw new SignRequestSignatureException(msg1);</span>
      }
<span class="fc" id="L807">      String signatureAlgorithmName =</span>
<span class="fc" id="L808">          AlgorithmTools.getAlgorithmNameFromDigestAndKey(</span>
<span class="fc" id="L809">              CMSSignedGenerator.DIGEST_SHA1, privateKey.getAlgorithm());</span>
      try {
<span class="fc" id="L811">        ContentSigner contentSigner =</span>
            new JcaContentSignerBuilder(signatureAlgorithmName)
<span class="fc" id="L813">                .setProvider(cryptoToken.getSignProviderName())</span>
<span class="fc" id="L814">                .build(privateKey);</span>
<span class="fc" id="L815">        JcaDigestCalculatorProviderBuilder calculatorProviderBuilder =</span>
            new JcaDigestCalculatorProviderBuilder()
<span class="fc" id="L817">                .setProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="fc" id="L818">        JcaSignerInfoGeneratorBuilder builder =</span>
            new JcaSignerInfoGeneratorBuilder(
<span class="fc" id="L820">                calculatorProviderBuilder.build());</span>
<span class="fc" id="L821">        gen.addSignerInfoGenerator(builder.build(contentSigner, cacert));</span>
<span class="nc" id="L822">      } catch (OperatorCreationException e) {</span>
<span class="nc" id="L823">        throw new IllegalStateException(</span>
            &quot;BouncyCastle failed in creating signature provider.&quot;, e);
<span class="fc" id="L825">      }</span>
<span class="fc" id="L826">      gen.addCertificates(new CollectionStore&lt;&gt;(certList));</span>
<span class="fc" id="L827">      CMSSignedData s = null;</span>
<span class="fc" id="L828">      CAToken catoken = getCAToken();</span>
<span class="pc bpc" id="L829" title="2 of 4 branches missed.">      if (catoken != null &amp;&amp; !(cryptoToken instanceof NullCryptoToken)) {</span>
<span class="fc" id="L830">        LOG.debug(</span>
            &quot;createPKCS7: Provider=&quot;
<span class="fc" id="L832">                + cryptoToken.getSignProviderName()</span>
                + &quot; using algorithm &quot;
<span class="fc" id="L834">                + privateKey.getAlgorithm());</span>
<span class="fc" id="L835">        s = gen.generate(msg, true);</span>
      } else {
<span class="nc" id="L837">        String msg1 = &quot;CA Token does not exist!&quot;;</span>
<span class="nc" id="L838">        LOG.debug(msg1);</span>
<span class="nc" id="L839">        throw new SignRequestSignatureException(msg1);</span>
      }
<span class="fc" id="L841">      return s.getEncoded();</span>
<span class="nc" id="L842">    } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L843">      throw new IllegalStateException(e);</span>
<span class="nc" id="L844">    } catch (Exception e) {</span>
      // FIXME: This right here is just nasty
<span class="nc" id="L846">      throw new IllegalStateException(e);</span>
    }
  }

  @Override
  public byte[] createPKCS7Rollover(final CryptoToken cryptoToken)
      throws SignRequestSignatureException {
<span class="nc" id="L853">    List&lt;Certificate&gt; nextChain = getRolloverCertificateChain();</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">    if (nextChain == null) {</span>
<span class="nc" id="L855">      LOG.debug(&quot;CA does not have a rollover chain, returning empty PKCS#7&quot;);</span>
<span class="nc" id="L856">      nextChain = Collections.emptyList();</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">    } else if (nextChain.isEmpty()) {</span>
<span class="nc" id="L858">      LOG.warn(&quot;next chain exists but is empty&quot;);</span>
    }

<span class="nc" id="L861">    ArrayList&lt;X509CertificateHolder&gt; certList = new ArrayList&lt;&gt;();</span>
    try {
<span class="nc bnc" id="L863" title="All 2 branches missed.">      for (Certificate certificate : nextChain) {</span>
<span class="nc" id="L864">        certList.add(</span>
            new JcaX509CertificateHolder((X509Certificate) certificate));
<span class="nc" id="L866">      }</span>
<span class="nc" id="L867">    } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L868">      throw new SignRequestSignatureException(</span>
          &quot;Could not encode certificate&quot;, e);
<span class="nc" id="L870">    }</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L872">      LOG.debug(</span>
          &quot;createPKCS7Rollover: Creating a rollover chain with &quot;
<span class="nc" id="L874">              + certList.size()</span>
              + &quot; certificates.&quot;);
    }
    try {
<span class="nc" id="L878">      CMSTypedData msg = new CMSProcessableByteArray(new byte[0]);</span>
<span class="nc" id="L879">      CMSSignedDataGenerator gen = new CMSSignedDataGenerator();</span>
      // We always sign with the current key, even during rollover, so the new
      // key can be linked to the old key. SCEP draft 23, &quot;4.6.1.  Get Next CA
      // Response Message Format&quot;
<span class="nc" id="L883">      final PrivateKey privateKey =</span>
<span class="nc" id="L884">          cryptoToken.getPrivateKey(</span>
<span class="nc" id="L885">              getCAToken()</span>
<span class="nc" id="L886">                  .getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN));</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">      if (privateKey == null) {</span>
<span class="nc" id="L888">        final String msg1 = &quot;createPKCS7Rollover: Private key does not exist!&quot;;</span>
<span class="nc" id="L889">        LOG.debug(msg1);</span>
<span class="nc" id="L890">        throw new SignRequestSignatureException(msg1);</span>
      }
<span class="nc" id="L892">      String signatureAlgorithmName =</span>
<span class="nc" id="L893">          AlgorithmTools.getAlgorithmNameFromDigestAndKey(</span>
<span class="nc" id="L894">              CMSSignedGenerator.DIGEST_SHA1, privateKey.getAlgorithm());</span>
      try {
<span class="nc" id="L896">        ContentSigner contentSigner =</span>
            new JcaContentSignerBuilder(signatureAlgorithmName)
<span class="nc" id="L898">                .setProvider(cryptoToken.getSignProviderName())</span>
<span class="nc" id="L899">                .build(privateKey);</span>
<span class="nc" id="L900">        JcaDigestCalculatorProviderBuilder calculatorProviderBuilder =</span>
            new JcaDigestCalculatorProviderBuilder()
<span class="nc" id="L902">                .setProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L903">        JcaSignerInfoGeneratorBuilder builder =</span>
            new JcaSignerInfoGeneratorBuilder(
<span class="nc" id="L905">                calculatorProviderBuilder.build());</span>
<span class="nc" id="L906">        gen.addSignerInfoGenerator(</span>
<span class="nc" id="L907">            builder.build(contentSigner, (X509Certificate) getCACertificate()));</span>
<span class="nc" id="L908">      } catch (OperatorCreationException e) {</span>
<span class="nc" id="L909">        throw new IllegalStateException(</span>
            &quot;BouncyCastle failed in creating signature provider.&quot;, e);
<span class="nc" id="L911">      } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L912">        throw new IllegalStateException(e);</span>
<span class="nc" id="L913">      }</span>
<span class="nc" id="L914">      gen.addCertificates(new CollectionStore&lt;&gt;(certList));</span>
<span class="nc" id="L915">      CMSSignedData s = null;</span>
<span class="nc" id="L916">      CAToken catoken = getCAToken();</span>
<span class="nc bnc" id="L917" title="All 4 branches missed.">      if (catoken != null &amp;&amp; !(cryptoToken instanceof NullCryptoToken)) {</span>
<span class="nc" id="L918">        LOG.debug(</span>
            &quot;createPKCS7Rollover: Provider=&quot;
<span class="nc" id="L920">                + cryptoToken.getSignProviderName()</span>
                + &quot; using algorithm &quot;
<span class="nc" id="L922">                + privateKey.getAlgorithm());</span>
        // Don't encapsulate any content, i.e. the bytes in the message. This
        // makes data section of the PKCS#7 message completely empty.
        // BER Sequence
        //   ObjectIdentifier(1.2.840.113549.1.7.1)
        // Instead of
        // BER Sequence
        //   ObjectIdentifier(1.2.840.113549.1.7.1)
        //   BER Tagged [0]
        //     BER Constructed Octet String[0]
<span class="nc" id="L932">        s = gen.generate(msg, false);</span>
      } else {
<span class="nc" id="L934">        String msg1 = &quot;CA Token does not exist!&quot;;</span>
<span class="nc" id="L935">        LOG.debug(msg1);</span>
<span class="nc" id="L936">        throw new SignRequestSignatureException(msg1);</span>
      }
<span class="nc" id="L938">      return s.getEncoded();</span>
<span class="nc" id="L939">    } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L940">      throw new IllegalStateException(e);</span>
<span class="nc" id="L941">    } catch (CMSException e) {</span>
<span class="nc" id="L942">      throw new IllegalStateException(e);</span>
<span class="nc" id="L943">    } catch (IOException e) {</span>
<span class="nc" id="L944">      throw new IllegalStateException(&quot;Failed to encode CMS data&quot;, e);</span>
    }
  }

  /**
   * @see CA#createRequest(CryptoToken, Collection, String, Certificate, int,
   *     CertificateProfile, AvailableCustomCertificateExtensionsConfiguration)
   */
  @Override
  public byte[] createRequest(
      final CryptoToken cryptoToken,
      final Collection&lt;ASN1Encodable&gt; attributes,
      final String signAlg,
      final Certificate cacert,
      final int signatureKeyPurpose,
      final CertificateProfile certificateProfile,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws CryptoTokenOfflineException, CertificateExtensionException {
<span class="fc" id="L962">    LOG.trace(</span>
        &quot;&gt;createRequest: &quot;
            + signAlg
            + &quot;, &quot;
<span class="fc" id="L966">            + CertTools.getSubjectDN(cacert)</span>
            + &quot;, &quot;
            + signatureKeyPurpose);
<span class="fc" id="L969">    ASN1Set attrset = new DERSet();</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">    if (attributes != null) {</span>
<span class="fc" id="L971">      LOG.debug(&quot;Adding attributes in the request&quot;);</span>
<span class="fc" id="L972">      ASN1EncodableVector vec = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">      for (final ASN1Encodable o : attributes) {</span>
<span class="fc" id="L974">        vec.add(o);</span>
<span class="fc" id="L975">      }</span>
<span class="fc" id="L976">      attrset = new DERSet(vec);</span>
    }
    final X500NameStyle nameStyle;
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">    if (getUsePrintableStringSubjectDN()) {</span>
<span class="nc" id="L980">      nameStyle = PrintableStringNameStyle.INSTANCE;</span>
    } else {
<span class="fc" id="L982">      nameStyle = CeSecoreNameStyle.INSTANCE;</span>
    }
<span class="fc" id="L984">    X500Name x509dn =</span>
<span class="fc" id="L985">        CertTools.stringToBcX500Name(</span>
<span class="fc" id="L986">            getSubjectDN(), nameStyle, getUseLdapDNOrder());</span>
    PKCS10CertificationRequest req;
    try {
<span class="fc" id="L989">      final CAToken catoken = getCAToken();</span>
<span class="fc" id="L990">      final String alias = catoken.getAliasFromPurpose(signatureKeyPurpose);</span>
<span class="fc" id="L991">      final KeyPair keyPair =</span>
          new KeyPair(
<span class="fc" id="L993">              cryptoToken.getPublicKey(alias),</span>
<span class="fc" id="L994">              cryptoToken.getPrivateKey(alias));</span>
<span class="fc" id="L995">      req =</span>
<span class="fc" id="L996">          CertTools.genPKCS10CertificationRequest(</span>
              signAlg,
              x509dn,
<span class="fc" id="L999">              keyPair.getPublic(),</span>
              attrset,
<span class="fc" id="L1001">              keyPair.getPrivate(),</span>
<span class="fc" id="L1002">              cryptoToken.getSignProviderName());</span>
<span class="fc" id="L1003">      LOG.trace(&quot;&lt;createRequest&quot;);</span>
<span class="fc" id="L1004">      return req.getEncoded();</span>
<span class="nc" id="L1005">    } catch (</span>
        CryptoTokenOfflineException e) { // NOPMD, since we catch wide below
<span class="nc" id="L1007">      throw e;</span>
<span class="nc" id="L1008">    } catch (Exception e) {</span>
<span class="nc" id="L1009">      throw new RuntimeException(e);</span>
    }
  }

  /** This method is not supported for X509 CAs. */
  @Override
  public byte[] createAuthCertSignRequest(
      final CryptoToken cryptoToken, final byte[] request)
      throws CryptoTokenOfflineException {
<span class="fc" id="L1018">    throw new UnsupportedOperationException(</span>
        &quot;Creation of authenticated CSRs is not supported for X509 CAs.&quot;);
  }

  /**
   * @param cryptoToken Token
   * @param createLinkCertificate boolean
   * @param certProfile Profile
   * @param cceConfig Config
   * @param caNameChange if set to false, regular X509 link certificate will be
   *     created. Otherwise, created link certificates will be modified as
   *     explained in the ICAO 9303 7th edition part 12. In addition to regular
   *     X509 link certificate format this link certificate will have: SubjectDN
   *     as CA's SubjectDN/IssuerDN after CA Name Change IssuerDN as CA's
   *     SubjectDN/IssuerDN before CA Name Change the Name Change Extension
   * @param oldCaCert to get expire date info from the old CA certificate to put
   *     in the link certificate
   * @throws CryptoTokenOfflineException if offline
   */
  private void createOrRemoveLinkCertificate(
      final CryptoToken cryptoToken,
      final boolean createLinkCertificate,
      final CertificateProfile certProfile,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig,
      final boolean caNameChange,
      final Certificate oldCaCert)
      throws CryptoTokenOfflineException {
<span class="nc" id="L1045">    byte[] ret = null;</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">    if (createLinkCertificate) {</span>
      try {
<span class="nc" id="L1048">        final CAToken catoken = getCAToken();</span>
        // Check if the input was a CA certificate, which is the same CA as
        // this. If all is true we should create a NewWithOld link-certificate
<span class="nc" id="L1051">        final X509Certificate currentCaCert =</span>
<span class="nc" id="L1052">            (X509Certificate) getCACertificate();</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1054">          LOG.debug(&quot;We will create a link certificate.&quot;);</span>
        }
<span class="nc" id="L1056">        final X509CAInfo info = (X509CAInfo) getCAInfo();</span>
<span class="nc" id="L1057">        final EndEntityInformation cadata =</span>
            new EndEntityInformation(
                &quot;nobody&quot;,
<span class="nc" id="L1060">                info.getSubjectDN(),</span>
<span class="nc" id="L1061">                info.getSubjectDN().hashCode(),</span>
<span class="nc" id="L1062">                info.getSubjectAltName(),</span>
                null,
                0,
                new EndEntityType(EndEntityTypes.INVALID),
                0,
<span class="nc" id="L1067">                info.getCertificateProfileId(),</span>
                null,
                null,
                0,
                0,
                null);
<span class="nc" id="L1073">        final PublicKey previousCaPublicKey =</span>
<span class="nc" id="L1074">            cryptoToken.getPublicKey(</span>
<span class="nc" id="L1075">                catoken.getAliasFromPurpose(</span>
                    CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS));
<span class="nc" id="L1077">        final PrivateKey previousCaPrivateKey =</span>
<span class="nc" id="L1078">            cryptoToken.getPrivateKey(</span>
<span class="nc" id="L1079">                catoken.getAliasFromPurpose(</span>
                    CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS));
<span class="nc" id="L1081">        final String provider = cryptoToken.getSignProviderName();</span>
        // The sequence is ignored later, but we fetch the same previous for now
        // to do this the same way as for CVC..
<span class="nc" id="L1084">        final String ignoredKeySequence =</span>
            catoken
<span class="nc" id="L1086">                .getProperties()</span>
<span class="nc" id="L1087">                .getProperty(CATokenConstants.PREVIOUS_SEQUENCE_PROPERTY);</span>
<span class="nc" id="L1088">        final Certificate retcert =</span>
<span class="nc" id="L1089">            generateCertificate(</span>
                cadata,
                null,
<span class="nc" id="L1092">                currentCaCert.getPublicKey(),</span>
                -1,
<span class="nc" id="L1094">                currentCaCert.getNotBefore(),</span>
<span class="nc" id="L1095">                ((X509Certificate) oldCaCert).getNotAfter(),</span>
                certProfile,
                null,
                ignoredKeySequence,
                previousCaPublicKey,
                previousCaPrivateKey,
                provider,
                null,
                cceConfig,
                /*createLinkCertificate=*/ true,
                caNameChange);
<span class="nc" id="L1106">        LOG.info(</span>
<span class="nc" id="L1107">            INTRES.getLocalizedMessage(</span>
                &quot;cvc.info.createlinkcert&quot;,
<span class="nc" id="L1109">                cadata.getDN(),</span>
<span class="nc" id="L1110">                ((X509Certificate) retcert).getIssuerDN().getName()));</span>
<span class="nc" id="L1111">        ret = retcert.getEncoded();</span>
<span class="nc" id="L1112">      } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L1113">        throw e;</span>
<span class="nc" id="L1114">      } catch (Exception e) {</span>
<span class="nc" id="L1115">        throw new IllegalStateException(</span>
            &quot;Error withing creating or removing link certificate.&quot;, e);
<span class="nc" id="L1117">      }</span>
    }
<span class="nc" id="L1119">    updateLatestLinkCertificate(ret);</span>
<span class="nc" id="L1120">  }</span>

  /**
   *
   * @param cryptoToken Token
   * @param createLinkCertificate bool
   * @param certProfile profile
   * @param cceConfig config
   * @param oldCaCert old certificate
   * @throws CryptoTokenOfflineException fail
   */
  public void createOrRemoveLinkCertificateDuringCANameChange(
      final CryptoToken cryptoToken,
      final boolean createLinkCertificate,
      final CertificateProfile certProfile,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig,
      final Certificate oldCaCert)
      throws CryptoTokenOfflineException {
<span class="nc" id="L1138">    createOrRemoveLinkCertificate(</span>
        cryptoToken,
        createLinkCertificate,
        certProfile,
        cceConfig, /*caNameChange*/
        true,
        oldCaCert);
<span class="nc" id="L1145">  }</span>

  @Override
  public void createOrRemoveLinkCertificate(
      final CryptoToken cryptoToken,
      final boolean createLinkCertificate,
      final CertificateProfile certProfile,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig,
      final Certificate oldCaCert)
      throws CryptoTokenOfflineException {
<span class="nc" id="L1155">    createOrRemoveLinkCertificate(</span>
        cryptoToken,
        createLinkCertificate,
        certProfile,
        cceConfig, /*caNameChange*/
        false,
        oldCaCert);
<span class="nc" id="L1162">  }</span>

  /**
   * @param request provided request message containing optional information,
   *     and will be set with the signing key and provider. If the certificate
   *     profile allows subject DN override this value will be used instead of
   *     the value from subject.getDN. Its public key is going to be used if
   *     publicKey == null &amp;amp;&amp;amp;
   *     subject.extendedInformation.certificateRequest == null. Can be null.
   * @param publicKey provided public key which will have precedence over public
   *     key from the provided RequestMessage but not over
   *     subject.extendedInformation.certificateRequest
   * @param subject end entity information. If it contains certificateRequest
   *     under extendedInformation, it will be used instead of the provided
   *     RequestMessage and publicKey
   */
  @Override
  public Certificate generateCertificate(
      final CryptoToken cryptoToken,
      final EndEntityInformation subject,
      final RequestMessage request,
      final PublicKey publicKey,
      final int keyusage,
      final Date notBefore,
      final Date notAfter,
      final CertificateProfile certProfile,
      final Extensions extensions,
      final String sequence,
      final CertificateGenerationParams certGenParams,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws CryptoTokenOfflineException, CAOfflineException,
          InvalidAlgorithmException, IllegalValidityException,
          IllegalNameException, OperatorCreationException,
          CertificateCreateException, CertificateExtensionException,
          SignatureException, IllegalKeyException {
    // Before we start, check if the CA is off-line, we don't have to waste time
    // one the stuff below of we are off-line. The line below will throw
    // CryptoTokenOfflineException of CA is offline
<span class="fc" id="L1200">    final CAToken catoken = getCAToken();</span>
    final int purpose =
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">        getUseNextCACert(request)</span>
<span class="nc" id="L1203">            ? CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT</span>
<span class="fc" id="L1204">            : CATokenConstants.CAKEYPURPOSE_CERTSIGN;</span>
<span class="fc" id="L1205">    final PublicKey caPublicKey =</span>
<span class="fc" id="L1206">        cryptoToken.getPublicKey(catoken.getAliasFromPurpose(purpose));</span>
<span class="fc" id="L1207">    final PrivateKey caPrivateKey =</span>
<span class="fc" id="L1208">        cryptoToken.getPrivateKey(catoken.getAliasFromPurpose(purpose));</span>
<span class="fc" id="L1209">    final String provider = cryptoToken.getSignProviderName();</span>
<span class="fc" id="L1210">    return generateCertificate(</span>
        subject,
        request,
        publicKey,
        keyusage,
        notBefore,
        notAfter,
        certProfile,
        extensions,
        sequence,
        caPublicKey,
        caPrivateKey,
        provider,
        certGenParams,
        cceConfig,
        /*linkCertificate=*/ false,
        /*caNameChange=*/ false);
  }

  /**
   * Sequence is ignored by X509CA. The ctParams argument will NOT be kept after
   * the function call returns, and is allowed to contain references to session
   * beans.
   *
   * @param providedRequestMessage provided request message containing optional
   *     information, and will be set with the signing key and provider. If the
   *     certificate profile allows subject DN override this value will be used
   *     instead of the value from subject.getDN. Its public key is going to be
   *     used if providedPublicKey == null &amp;&amp;
   *     subject.extendedInformation.certificateRequest == null. Can be null.
   * @param providedPublicKey provided public key which will have precedence
   *     over public key from providedRequestMessage but not over
   *     subject.extendedInformation.certificateRequest
   * @param subject end entity information. If it contains certificateRequest
   *     under extendedInformation, it will be used instead of
   *     providedRequestMessage and providedPublicKey Otherwise,
   *     providedRequestMessage will be used.
   * @param keyusage Usage
   * @param notBefore Start date
   * @param notAfter End date
   * @param certProfile Profile
   * @param extensions extensions
   * @param sequence sequence
   * @param caPublicKey Public Key
   * @param caPrivateKey Prvate Key
   * @param provider Provider
   * @param certGenParams Parameters
   * @param cceConfig config
   * @param linkCertificate boolean
   * @param caNameChange boolean
   * @return Certificate
   * @throws CAOfflineException if the CA wasn't active
   * @throws InvalidAlgorithmException if the signing algorithm in the
   *     certificate profile (or the CA Token if not found) was invalid.
   * @throws IllegalValidityException if validity was invalid
   * @throws IllegalNameException if the name specified in the certificate
   *     request was invalid
   * @throws CertificateExtensionException if any of the certificate extensions
   *     were invalid
   * @throws OperatorCreationException if CA's private key contained an unknown
   *     algorithm or provider
   * @throws CertificateCreateException if an error occurred when trying to
   *     create a certificate.
   * @throws SignatureException if the CA's certificate's and request's
   *     certificate's and signature algorithms differ
   * @throws IllegalKeyException if selected public key (check
   *     providedRequestMessage, providedPublicKey, subject) is not allowed with
   *     certProfile
   */
  private Certificate generateCertificate(
      final EndEntityInformation subject,
      final RequestMessage providedRequestMessage,
      final PublicKey providedPublicKey,
      final int keyusage,
      final Date notBefore,
      final Date notAfter,
      final CertificateProfile certProfile,
      final Extensions extensions,
      final String sequence,
      final PublicKey caPublicKey,
      final PrivateKey caPrivateKey,
      final String provider,
      final CertificateGenerationParams certGenParams,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig,
      final boolean linkCertificate,
      final  boolean caNameChange)
      throws CAOfflineException, InvalidAlgorithmException,
          IllegalValidityException, IllegalNameException,
          CertificateExtensionException, OperatorCreationException,
          CertificateCreateException, SignatureException, IllegalKeyException {

    // We must only allow signing to take place if the CA itself is on line,
    // even if the token is on-line.
    // We have to allow expired as well though, so we can renew expired CAs
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">    if ((getStatus() != CAConstants.CA_ACTIVE)</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        &amp;&amp; ((getStatus() != CAConstants.CA_EXPIRED))) {</span>
<span class="nc" id="L1306">      final String msg =</span>
<span class="nc" id="L1307">          INTRES.getLocalizedMessage(&quot;error.caoffline&quot;, getName(), getStatus());</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1309">        LOG.debug(</span>
            msg); // This is something we handle so no need to log with higher
                  // priority
      }
<span class="nc" id="L1313">      throw new CAOfflineException(msg);</span>
    }
    // Which public key and request shall we use?
<span class="fc" id="L1316">    final ExtendedInformation ei = subject.getExtendedInformation();</span>
<span class="fc" id="L1317">    final RequestAndPublicKeySelector pkSelector =</span>
        new RequestAndPublicKeySelector(
            providedRequestMessage, providedPublicKey, ei);
<span class="fc" id="L1320">    final PublicKey publicKey = pkSelector.getPublicKey();</span>
<span class="fc" id="L1321">    final RequestMessage request = pkSelector.getRequestMessage();</span>

<span class="fc" id="L1323">    certProfile.verifyKey(publicKey);</span>

    final String sigAlg;
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">    if (certProfile.getSignatureAlgorithm() == null) {</span>
<span class="fc" id="L1327">      sigAlg = getCAToken().getSignatureAlgorithm();</span>
    } else {
<span class="nc" id="L1329">      sigAlg = certProfile.getSignatureAlgorithm();</span>
    }
    // Check that the signature algorithm is one of the allowed ones
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">    if (!StringTools.containsCaseInsensitive(</span>
        AlgorithmConstants.AVAILABLE_SIGALGS, sigAlg)) {
<span class="nc" id="L1334">      final String msg =</span>
<span class="nc" id="L1335">          INTRES.getLocalizedMessage(</span>
              &quot;createcert.invalidsignaturealg&quot;,
              sigAlg,
<span class="nc" id="L1338">              ArrayUtils.toString(AlgorithmConstants.AVAILABLE_SIGALGS));</span>
<span class="nc" id="L1339">      throw new InvalidAlgorithmException(msg);</span>
    }
    // Check if this is a root CA we are creating
<span class="fc" id="L1342">    final boolean isRootCA =</span>
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">        certProfile.getType() == CertificateConstants.CERTTYPE_ROOTCA;</span>

<span class="fc" id="L1345">    final boolean useNextCACert = getUseNextCACert(request);</span>
    final X509Certificate cacert =
        (X509Certificate)
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">            (useNextCACert</span>
<span class="nc" id="L1349">                ? getRolloverCertificateChain().get(0)</span>
<span class="fc" id="L1350">                : getCACertificate());</span>
<span class="fc" id="L1351">    final Date now = new Date();</span>
    final Date checkDate =
<span class="pc bpc" id="L1353" title="3 of 4 branches missed.">        useNextCACert &amp;&amp; cacert.getNotBefore().after(now)</span>
<span class="nc" id="L1354">            ? cacert.getNotBefore()</span>
<span class="fc" id="L1355">            : now;</span>
    // Check CA certificate PrivateKeyUsagePeriod if it exists (throws
    // CAOfflineException if it exists and is not within this time)
<span class="fc" id="L1358">    CertificateValidity.checkPrivateKeyUsagePeriod(cacert, checkDate);</span>
    // Get certificate validity time notBefore and notAfter
<span class="fc" id="L1360">    final CertificateValidity val =</span>
        new CertificateValidity(
            subject,
            certProfile,
            notBefore,
            notAfter,
            cacert,
            isRootCA,
            linkCertificate);

    // Serialnumber is either random bits, where random generator is initialized
    // by the serno generator.
    // Or a custom serial number defined in the end entity object
    final BigInteger serno;

<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">      if (certProfile.getAllowCertSerialNumberOverride()) {</span>
<span class="nc bnc" id="L1376" title="All 4 branches missed.">        if (ei != null &amp;&amp; ei.certificateSerialNumber() != null) {</span>
<span class="nc" id="L1377">          serno = ei.certificateSerialNumber();</span>
        } else {
<span class="nc" id="L1379">          SernoGenerator instance =</span>
<span class="nc" id="L1380">              SernoGeneratorRandom.instance(getSerialNumberOctetSize());</span>
<span class="nc" id="L1381">          serno = instance.getSerno();</span>
<span class="nc" id="L1382">        }</span>
      } else {
<span class="fc" id="L1384">        SernoGenerator instance =</span>
<span class="fc" id="L1385">            SernoGeneratorRandom.instance(getSerialNumberOctetSize());</span>
<span class="fc" id="L1386">        serno = instance.getSerno();</span>

<span class="pc bpc" id="L1388" title="1 of 4 branches missed.">        if ((ei != null) &amp;&amp; (ei.certificateSerialNumber() != null)) {</span>
<span class="nc" id="L1389">          final String msg =</span>
<span class="nc" id="L1390">              INTRES.getLocalizedMessage(</span>
                  &quot;createcert.certprof_not_allowing&quot;
                  + &quot;_cert_sn_override_using_normal&quot;,
<span class="nc" id="L1393">                  ei.certificateSerialNumber().toString(16));</span>
<span class="nc" id="L1394">          LOG.info(msg);</span>
        }
      }


    // Make DNs
    final X500NameStyle nameStyle;
<span class="fc bfc" id="L1401" title="All 2 branches covered.">    if (getUsePrintableStringSubjectDN()) {</span>
<span class="fc" id="L1402">      nameStyle = PrintableStringNameStyle.INSTANCE;</span>
    } else {
<span class="fc" id="L1404">      nameStyle = CeSecoreNameStyle.INSTANCE;</span>
    }

<span class="fc" id="L1407">    String dn = subject.getCertificateDN();</span>
<span class="pc bpc" id="L1408" title="1 of 2 branches missed.">    if (certProfile.getUseSubjectDNSubSet()) {</span>
<span class="nc" id="L1409">      dn = certProfile.createSubjectDNSubSet(dn);</span>
    }
<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">    if (certProfile.getUseCNPostfix()) {</span>
<span class="nc" id="L1412">      dn = CertTools.insertCNPostfix(dn, certProfile.getCNPostfix(), nameStyle);</span>
    }

    // Will we use LDAP DN order (CN first) or X500 DN order (CN last) for the
    // subject DN
    final boolean ldapdnorder;
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">    if ((!getUseLdapDNOrder())</span>
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">        || (!certProfile.getUseLdapDnOrder())) {</span>
<span class="nc" id="L1420">      ldapdnorder = false;</span>
    } else {
<span class="fc" id="L1422">      ldapdnorder = true;</span>
    }
    // If we have a custom order defined in the certificate profile, take this.
    // If this is null or empty it will be ignored
<span class="fc" id="L1426">    String[] customDNOrder = null;</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">    if (certProfile.getUseCustomDnOrder()) {</span>
<span class="fc" id="L1428">      final ArrayList&lt;String&gt; order = certProfile.getCustomDnOrder();</span>
<span class="pc bpc" id="L1429" title="2 of 4 branches missed.">      if (order != null &amp;&amp; order.size() &gt; 0) {</span>
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1431">          LOG.debug(&quot;Using Custom DN order: &quot; + order);</span>
        }
<span class="fc" id="L1433">        customDNOrder = order.toArray(new String[0]);</span>
      }
    }
<span class="fc" id="L1436">    final boolean applyLdapToCustomOrder =</span>
<span class="fc" id="L1437">        certProfile.getUseCustomDnOrderWithLdap();</span>

    final X500Name subjectDNName;
<span class="pc bpc" id="L1440" title="1 of 4 branches missed.">    if (certProfile.getAllowDNOverride()</span>
        &amp;&amp; (request != null)
<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">        &amp;&amp; (request.getRequestX500Name() != null)) {</span>
<span class="fc" id="L1443">      subjectDNName = request.getRequestX500Name();</span>
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1445">        LOG.debug(&quot;Using X509Name from request instead of user's registered.&quot;);</span>
      }
    } else {
<span class="pc bpc" id="L1448" title="3 of 4 branches missed.">      if (certProfile.getAllowDNOverrideByEndEntityInformation()</span>
          &amp;&amp; ei != null
<span class="nc bnc" id="L1450" title="All 2 branches missed.">          &amp;&amp; ei.getRawSubjectDn() != null) {</span>
<span class="nc" id="L1451">        final String stripped = StringTools.strip(ei.getRawSubjectDn());</span>
<span class="nc" id="L1452">        final String escapedPluses = CertTools.handleUnescapedPlus(stripped);</span>
<span class="nc" id="L1453">        final String emptiesRemoved =</span>
<span class="nc" id="L1454">            DNFieldsUtil.removeAllEmpties(escapedPluses);</span>
<span class="nc" id="L1455">        final X500Name subjectDNNameFromEei =</span>
<span class="nc" id="L1456">            CertTools.stringToUnorderedX500Name(</span>
                emptiesRemoved, CeSecoreNameStyle.INSTANCE);
<span class="nc bnc" id="L1458" title="All 2 branches missed.">        if (subjectDNNameFromEei.toString().length() &gt; 0) {</span>
<span class="nc" id="L1459">          subjectDNName = subjectDNNameFromEei;</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1461">            LOG.debug(</span>
                &quot;Using X500Name from end entity information instead of user's&quot;
                    + &quot; registered subject DN fields.&quot;);
<span class="nc" id="L1464">            LOG.debug(</span>
                &quot;ExtendedInformation.getRawSubjectDn(): &quot;
<span class="nc" id="L1466">                    + ei.getRawSubjectDn()</span>
                    + &quot; will use: &quot;
<span class="nc" id="L1468">                    + CeSecoreNameStyle.INSTANCE.toString(subjectDNName));</span>
          }
        } else {
<span class="nc" id="L1471">          subjectDNName =</span>
<span class="nc" id="L1472">              CertTools.stringToBcX500Name(</span>
                  dn,
                  nameStyle,
                  ldapdnorder,
                  customDNOrder,
                  applyLdapToCustomOrder);
        }
<span class="nc" id="L1479">      } else {</span>
<span class="fc" id="L1480">        subjectDNName =</span>
<span class="fc" id="L1481">            CertTools.stringToBcX500Name(</span>
                dn,
                nameStyle,
                ldapdnorder,
                customDNOrder,
                applyLdapToCustomOrder);
      }
    }
    // Make sure the DN does not contain dangerous characters
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">    if (!StringTools.hasStripChars(subjectDNName.toString()).isEmpty()) {</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1492">        LOG.trace(&quot;DN with illegal name: &quot; + subjectDNName);</span>
      }
<span class="nc" id="L1494">      final String msg = INTRES.getLocalizedMessage(&quot;createcert.illegalname&quot;);</span>
<span class="nc" id="L1495">      throw new IllegalNameException(msg);</span>
    }
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1498">      LOG.debug(&quot;Using subjectDN: &quot; + subjectDNName.toString());</span>
    }

    // We must take the issuer DN directly from the CA-certificate otherwise we
    // risk re-ordering the DN
    // which many applications do not like.
    X500Name issuerDNName;
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">    if (isRootCA) {</span>
      // This will be an initial root CA, since no CA-certificate exists
      // Or it is a root CA, since the cert is self signed. If it is a root CA
      // we want to use the same encoding for subject and issuer,
      // it might have changed over the years.
<span class="nc bnc" id="L1510" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1511">        LOG.debug(</span>
            &quot;Using subject DN also as issuer DN, because it is a root CA&quot;);
      }
<span class="nc bnc" id="L1514" title="All 4 branches missed.">      if (linkCertificate &amp;&amp; caNameChange) {</span>
<span class="nc" id="L1515">        List&lt;Certificate&gt; renewedCertificateChain =</span>
<span class="nc" id="L1516">            getRenewedCertificateChain();</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">        if (renewedCertificateChain == null</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">            || renewedCertificateChain.isEmpty()) {</span>
          // &quot;Should not happen&quot; error
<span class="nc" id="L1520">          LOG.error(</span>
              &quot;CA name change is in process but renewed (old) certificates&quot;
                  + &quot; chain is empty&quot;);
<span class="nc" id="L1523">          throw new CertificateCreateException(</span>
              &quot;CA name change is in process but renewed (old) certificates&quot;
                  + &quot; chain is empty&quot;);
        }
<span class="nc" id="L1527">        issuerDNName =</span>
<span class="nc" id="L1528">            X500Name.getInstance(</span>
                ((X509Certificate)
<span class="nc" id="L1530">                        renewedCertificateChain.get(</span>
<span class="nc" id="L1531">                            renewedCertificateChain.size() - 1))</span>
<span class="nc" id="L1532">                    .getSubjectX500Principal()</span>
<span class="nc" id="L1533">                    .getEncoded());</span>
<span class="nc" id="L1534">      } else {</span>
<span class="nc" id="L1535">        issuerDNName = subjectDNName;</span>
      }
    } else {
<span class="fc" id="L1538">      issuerDNName =</span>
<span class="fc" id="L1539">          X500Name.getInstance(cacert.getSubjectX500Principal().getEncoded());</span>
<span class="pc bpc" id="L1540" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1541">        LOG.debug(</span>
            &quot;Using issuer DN directly from the CA certificate: &quot;
<span class="nc" id="L1543">                + issuerDNName.toString());</span>
      }
    }

<span class="fc" id="L1547">    SubjectPublicKeyInfo pkinfo =</span>
<span class="fc" id="L1548">        SubjectPublicKeyInfo.getInstance(publicKey.getEncoded());</span>
<span class="fc" id="L1549">    final X509v3CertificateBuilder certbuilder =</span>
        new X509v3CertificateBuilder(
            issuerDNName,
            serno,
<span class="fc" id="L1553">            val.getNotBefore(),</span>
<span class="fc" id="L1554">            val.getNotAfter(),</span>
            subjectDNName,
            pkinfo);

    // Only created and used if Certificate Transparency is enabled
    final X509v3CertificateBuilder precertbuilder =
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">        certProfile.isUseCertificateTransparencyInCerts()</span>
<span class="nc" id="L1561">            ? new X509v3CertificateBuilder(</span>
                issuerDNName,
                serno,
<span class="nc" id="L1564">                val.getNotBefore(),</span>
<span class="nc" id="L1565">                val.getNotAfter(),</span>
                subjectDNName,
                pkinfo)
<span class="fc" id="L1568">            : null;</span>

    // Check that the certificate fulfills name constraints
<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">    if (cacert != null) {</span>
<span class="fc" id="L1572">      GeneralNames altNameGNs = null;</span>
<span class="fc" id="L1573">      String altName = subject.getSubjectAltName();</span>
<span class="pc bpc" id="L1574" title="1 of 2 branches missed.">      if (certProfile.getUseSubjectAltNameSubSet()) {</span>
<span class="nc" id="L1575">        altName = certProfile.createSubjectAltNameSubSet(altName);</span>
      }
<span class="pc bpc" id="L1577" title="1 of 4 branches missed.">      if (altName != null &amp;&amp; altName.length() &gt; 0) {</span>
<span class="fc" id="L1578">        altNameGNs = CertTools.getGeneralNamesFromAltName(altName);</span>
      }
<span class="fc" id="L1580">      CertTools.checkNameConstraints(cacert, subjectDNName, altNameGNs);</span>
    }

    // If the subject has Name Constraints, then name constraints must be
    // enabled in the certificate profile!
<span class="fc bfc" id="L1585" title="All 2 branches covered.">    if (ei != null) {</span>
<span class="fc" id="L1586">      final List&lt;String&gt; permittedNC = ei.getNameConstraintsPermitted();</span>
<span class="fc" id="L1587">      final List&lt;String&gt; excludedNC = ei.getNameConstraintsExcluded();</span>
<span class="pc bpc" id="L1588" title="4 of 6 branches missed.">      if ((permittedNC != null &amp;&amp; !permittedNC.isEmpty())</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">          || (excludedNC != null &amp;&amp; !excludedNC.isEmpty())) {</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">        if (!certProfile.getUseNameConstraints()) {</span>
<span class="nc" id="L1591">          throw new CertificateCreateException(</span>
              &quot;Tried to issue a certificate with Name Constraints without&quot;
                  + &quot; having enabled NC in the certificate profile.&quot;);
        }
      }
    }

    //
    // X509 Certificate Extensions
    //

    // Extensions we will add to the certificate, later when we have filled the
    // structure with
    // everything we want.
<span class="fc" id="L1605">    final ExtensionsGenerator extgen = new ExtensionsGenerator();</span>

    // First we check if there is general extension override, and add all
    // extensions from
    // the request in that case
<span class="pc bpc" id="L1610" title="3 of 4 branches missed.">    if (certProfile.getAllowExtensionOverride() &amp;&amp; extensions != null) {</span>
<span class="nc" id="L1611">      Set&lt;String&gt; overridableExtensionOIDs =</span>
<span class="nc" id="L1612">          certProfile.getOverridableExtensionOIDs();</span>
<span class="nc" id="L1613">      Set&lt;String&gt; nonOverridableExtensionOIDs =</span>
<span class="nc" id="L1614">          certProfile.getNonOverridableExtensionOIDs();</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">      if (!overridableExtensionOIDs.isEmpty()</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">          &amp;&amp; !nonOverridableExtensionOIDs.isEmpty()) {</span>
        // If user have set both of these lists, user may not know what he/she
        // has done as it doesn't make sense
        // hence the result may not be the desired. To get attention to this,
        // log an error
<span class="nc" id="L1621">        LOG.error(</span>
            &quot;Both overridableExtensionOIDs and nonOverridableExtensionOIDs are&quot;
                + &quot; set in certificate profile which does not make sense.&quot;
                + &quot; NonOverridableExtensionOIDs will take precedence, is this&quot;
                + &quot; the desired behavior?&quot;);
      }
<span class="nc" id="L1627">      ASN1ObjectIdentifier[] oids = extensions.getExtensionOIDs();</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">      for (ASN1ObjectIdentifier oid : oids) {</span>
        // Start by excluding non overridable extensions
        // If there are no nonOverridableExtensionOIDs set, or if the set does
        // not contain our oid, we allow it so move on
        // (nonOverridableExtensionOIDs can never by null)
<span class="nc bnc" id="L1633" title="All 2 branches missed.">        if (!nonOverridableExtensionOIDs.contains(oid.getId())) {</span>
          // Now check if we have specified which ones are allowed, if this is
          // not set we allow everything
          // (overridableExtensionOIDs can never by null)
<span class="nc bnc" id="L1637" title="All 2 branches missed.">          if (overridableExtensionOIDs.size() == 0</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">              || overridableExtensionOIDs.contains(oid.getId())) {</span>
<span class="nc" id="L1639">            final Extension ext = extensions.getExtension(oid);</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1641">              LOG.debug(&quot;Overriding extension with oid: &quot; + oid.getId());</span>
            }
            try {
<span class="nc" id="L1644">              extgen.addExtension(oid, ext.isCritical(), ext.getParsedValue());</span>
<span class="nc" id="L1645">            } catch (IOException e) {</span>
<span class="nc" id="L1646">              throw new IllegalStateException(</span>
                  &quot;Caught unexpected IOException.&quot;, e);
<span class="nc" id="L1648">            }</span>
<span class="nc" id="L1649">          } else {</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1651">              LOG.debug(</span>
                  &quot;Extension is not among overridable extensions, ignoring&quot;
                      + &quot; extension from request with oid &quot;
<span class="nc" id="L1654">                      + oid.getId());</span>
            }
          }
        } else {
<span class="nc bnc" id="L1658" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1659">            LOG.debug(</span>
                &quot;Extension is among non-overridable extensions, ignoring&quot;
                    + &quot; extension from request with oid &quot;
<span class="nc" id="L1662">                    + oid.getId());</span>
          }
        }
      }
    }

    // Second we see if there is Key usage override
<span class="fc" id="L1669">    Extensions overridenexts = extgen.generate();</span>
<span class="pc bpc" id="L1670" title="3 of 4 branches missed.">    if (certProfile.getAllowKeyUsageOverride() &amp;&amp; (keyusage &gt;= 0)) {</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1672">        LOG.debug(</span>
            &quot;AllowKeyUsageOverride=true. Using KeyUsage from parameter: &quot;
                + keyusage);
      }
<span class="nc bnc" id="L1676" title="All 4 branches missed.">      if ((certProfile.getUseKeyUsage()) &amp;&amp; (keyusage &gt;= 0)) {</span>
<span class="nc" id="L1677">        final KeyUsage ku = new KeyUsage(keyusage);</span>
        // We don't want to try to add custom extensions with the same oid if we
        // have already added them
        // from the request, if AllowExtensionOverride is enabled.
        // Two extensions with the same oid is not allowed in the standard.
<span class="nc bnc" id="L1682" title="All 2 branches missed.">        if (overridenexts.getExtension(Extension.keyUsage) == null) {</span>
          try {
<span class="nc" id="L1684">            extgen.addExtension(</span>
<span class="nc" id="L1685">                Extension.keyUsage, certProfile.getKeyUsageCritical(), ku);</span>
<span class="nc" id="L1686">          } catch (IOException e) {</span>
<span class="nc" id="L1687">            throw new IllegalStateException(</span>
                &quot;Caught unexpected IOException.&quot;, e);
<span class="nc" id="L1689">          }</span>
        } else {
<span class="nc bnc" id="L1691" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1692">            LOG.debug(</span>
                &quot;KeyUsage was already overridden by an extension, not using&quot;
                    + &quot; KeyUsage from parameter.&quot;);
          }
        }
      }
    }

    // Third, check for standard Certificate Extensions that should be added.
    // Standard certificate extensions are defined in CertificateProfile and
    // CertificateExtensionFactory
    // and implemented in package org.ejbca.core.model.certextensions.standard
    final CertificateExtensionFactory fact =
<span class="fc" id="L1705">        CertificateExtensionFactory.getInstance();</span>
<span class="fc" id="L1706">    final List&lt;String&gt; usedStdCertExt =</span>
<span class="fc" id="L1707">        certProfile.getUsedStandardCertificateExtensions();</span>
<span class="fc" id="L1708">    final Iterator&lt;String&gt; certStdExtIter = usedStdCertExt.iterator();</span>
<span class="fc" id="L1709">    overridenexts = extgen.generate();</span>
<span class="fc bfc" id="L1710" title="All 2 branches covered.">    while (certStdExtIter.hasNext()) {</span>
<span class="fc" id="L1711">      final String oid = certStdExtIter.next();</span>
      // We don't want to try to add standard extensions with the same oid if we
      // have already added them
      // from the request, if AllowExtensionOverride is enabled.
      // Two extensions with the same oid is not allowed in the standard.
<span class="pc bpc" id="L1716" title="1 of 2 branches missed.">      if (overridenexts.getExtension(new ASN1ObjectIdentifier(oid)) == null) {</span>
<span class="fc" id="L1717">        final CertificateExtension certExt =</span>
<span class="fc" id="L1718">            fact.getStandardCertificateExtension(oid, certProfile);</span>
<span class="pc bpc" id="L1719" title="1 of 2 branches missed.">        if (certExt != null) {</span>
<span class="fc" id="L1720">          final byte[] value =</span>
<span class="fc" id="L1721">              certExt.getValueEncoded(</span>
                  subject, this, certProfile, publicKey, caPublicKey, val);
<span class="fc bfc" id="L1723" title="All 2 branches covered.">          if (value != null) {</span>
<span class="fc" id="L1724">            extgen.addExtension(</span>
<span class="fc" id="L1725">                new ASN1ObjectIdentifier(certExt.getOID()),</span>
<span class="fc" id="L1726">                certExt.isCriticalFlag(),</span>
                value);
          }
        }
<span class="fc" id="L1730">      } else {</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1732">          LOG.debug(</span>
              &quot;Extension with oid &quot;
                  + oid
                  + &quot; has been overridden, standard extension will not be&quot;
                  + &quot; added.&quot;);
        }
      }
<span class="fc" id="L1739">    }</span>

    // Fourth, ICAO standard extensions. Only Name Change extension is used and
    // added only for link certificates
<span class="pc bpc" id="L1743" title="1 of 2 branches missed.">    if (caNameChange) {</span>
      try {
<span class="nc" id="L1745">        extgen.addExtension(</span>
            ICAOObjectIdentifiers.id_icao_extensions_namechangekeyrollover,
            false,
            DERNull.INSTANCE);
<span class="nc" id="L1749">      } catch (IOException e) {</span>
        /*IOException with DERNull.INSTANCE will never happen*/
<span class="nc" id="L1751">      }</span>
    }

    // Fifth, check for custom Certificate Extensions that should be added.
    // Custom certificate extensions is defined in AdminGUI -&gt;
    // SystemConfiguration -&gt; Custom Certificate Extensions
<span class="fc" id="L1757">    final List&lt;Integer&gt; usedCertExt =</span>
<span class="fc" id="L1758">        certProfile.getUsedCertificateExtensions();</span>
<span class="fc" id="L1759">    final List&lt;Integer&gt; wildcardExt = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1760">    final Iterator&lt;Integer&gt; certExtIter = usedCertExt.iterator();</span>
<span class="fc" id="L1761">    Set&lt;String&gt; requestOids = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1762" title="All 2 branches covered.">    if (subject.getExtendedInformation() != null) {</span>
<span class="fc" id="L1763">      requestOids = subject.getExtendedInformation().getExtensionDataOids();</span>
    }
<span class="fc bfc" id="L1765" title="All 2 branches covered.">    while (certExtIter.hasNext()) {</span>
<span class="fc" id="L1766">      final int id = certExtIter.next();</span>
<span class="fc" id="L1767">      final CustomCertificateExtension certExt =</span>
<span class="fc" id="L1768">          cceConfig.getCustomCertificateExtension(id);</span>
<span class="pc bpc" id="L1769" title="1 of 2 branches missed.">      if (certExt != null) {</span>
<span class="pc bpc" id="L1770" title="1 of 2 branches missed.">        if (certExt.getOID().contains(&quot;*&quot;)) {</span>
          // Match wildcards later
<span class="nc" id="L1772">          wildcardExt.add(id);</span>
<span class="nc" id="L1773">          continue;</span>
        }
        // We don't want to try to add custom extensions with the same oid if we
        // have already added them
        // from the request, if AllowExtensionOverride is enabled.
        // Two extensions with the same oid is not allowed in the standard.
<span class="pc bpc" id="L1779" title="1 of 2 branches missed.">        if (overridenexts.getExtension(</span>
<span class="fc" id="L1780">                new ASN1ObjectIdentifier(certExt.getOID()))</span>
            == null) {
<span class="fc" id="L1782">          final byte[] value =</span>
<span class="fc" id="L1783">              certExt.getValueEncoded(</span>
                  subject, this, certProfile, publicKey, caPublicKey, val);
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">          if (value != null) {</span>
<span class="fc" id="L1786">            extgen.addExtension(</span>
<span class="fc" id="L1787">                new ASN1ObjectIdentifier(certExt.getOID()),</span>
<span class="fc" id="L1788">                certExt.isCriticalFlag(),</span>
                value);
<span class="fc" id="L1790">            requestOids.remove(certExt.getOID());</span>
          }
<span class="fc" id="L1792">        } else {</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1794">            LOG.debug(</span>
                &quot;Extension with oid &quot;
<span class="nc" id="L1796">                    + certExt.getOID()</span>
                    + &quot; has been overridden, custom extension will not be&quot;
                    + &quot; added.&quot;);
          }
        }
      }
<span class="fc" id="L1802">    }</span>
    // Match remaining extensions (wild cards)
<span class="fc" id="L1804">    final Iterator&lt;Integer&gt; certExtWildcardIter = wildcardExt.iterator();</span>
<span class="pc bpc" id="L1805" title="1 of 2 branches missed.">    while (certExtWildcardIter.hasNext()) {</span>
<span class="nc" id="L1806">      final int id = certExtWildcardIter.next();</span>
<span class="nc" id="L1807">      final int remainingOidsToMatch = requestOids.size();</span>
<span class="nc" id="L1808">      final CustomCertificateExtension certExt =</span>
<span class="nc" id="L1809">          cceConfig.getCustomCertificateExtension(id);</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">      if (certExt != null) {</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">        for (final String oid : requestOids) {</span>
          // Match requested OID with wildcard in CCE configuration
<span class="nc bnc" id="L1813" title="All 2 branches missed.">          if (oid.matches(CertTools.getOidWildcardPattern(certExt.getOID()))) {</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">            if (overridenexts.getExtension(new ASN1ObjectIdentifier(oid))</span>
                == null) {
<span class="nc" id="L1816">              final byte[] value =</span>
<span class="nc" id="L1817">                  certExt.getValueEncoded(</span>
                      subject,
                      this,
                      certProfile,
                      publicKey,
                      caPublicKey,
                      val,
                      oid);
<span class="nc bnc" id="L1825" title="All 2 branches missed.">              if (value != null) {</span>
<span class="nc" id="L1826">                extgen.addExtension(</span>
                    new ASN1ObjectIdentifier(oid),
<span class="nc" id="L1828">                    certExt.isCriticalFlag(),</span>
                    value);
<span class="nc" id="L1830">                requestOids.remove(oid);</span>
                // Each wildcard CCE configuration may only be matched once.
<span class="nc" id="L1832">                break;</span>
              }
<span class="nc" id="L1834">            } else {</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">              if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1836">                LOG.debug(</span>
                    &quot;Extension with oid &quot;
                        + oid
                        + &quot; has been overridden, custom extension will not be&quot;
                        + &quot; added.&quot;);
              }
            }
          }
<span class="nc" id="L1844">        }</span>
<span class="nc bnc" id="L1845" title="All 2 branches missed.">        if ((remainingOidsToMatch == requestOids.size())</span>
<span class="nc bnc" id="L1846" title="All 2 branches missed.">            &amp;&amp; certExt.isRequiredFlag()) {</span>
          // Required wildcard extension didn't match any OIDs in the request
<span class="nc" id="L1848">          throw new CertificateExtensionException(</span>
<span class="nc" id="L1849">              INTRES.getLocalizedMessage(</span>
                      &quot;certext.basic.incorrectvalue&quot;,
<span class="nc" id="L1851">                      Integer.valueOf(certExt.getId()),</span>
<span class="nc" id="L1852">                      certExt.getOID())</span>
                  + &quot;\nNo requested OID matched wildcard&quot;);
        }
      }
<span class="nc" id="L1856">    }</span>
<span class="pc bpc" id="L1857" title="1 of 2 branches missed.">    if (!requestOids.isEmpty()) {</span>
      // All requested OIDs must match a CCE configuration
<span class="nc" id="L1859">      throw new CertificateCreateException(</span>
          ErrorCode.CUSTOM_CERTIFICATE_EXTENSION_ERROR,
          &quot;Request contained custom certificate extensions which couldn't&quot;
              + &quot; match any configuration&quot;);
    }

    // Finally add extensions to certificate generator
<span class="fc" id="L1866">    final Extensions exts = extgen.generate();</span>
<span class="fc" id="L1867">    ASN1ObjectIdentifier[] oids = exts.getExtensionOIDs();</span>
    try {
<span class="fc bfc" id="L1869" title="All 2 branches covered.">      for (ASN1ObjectIdentifier oid : oids) {</span>
<span class="fc" id="L1870">        final Extension extension = exts.getExtension(oid);</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">        if (oid.equals(</span>
            Extension
                .subjectAlternativeName)) { // subjectAlternativeName extension
                                            // value needs special handling
<span class="pc bpc" id="L1875" title="1 of 2 branches missed.">          ExtensionsGenerator sanExtGen =</span>
<span class="fc" id="L1876">              getSubjectAltNameExtensionForCert(</span>
                  extension, precertbuilder != null);
<span class="fc" id="L1878">          Extensions sanExts = sanExtGen.generate();</span>
<span class="fc" id="L1879">          Extension eext = sanExts.getExtension(oid);</span>
<span class="fc" id="L1880">          certbuilder.addExtension(</span>
              oid,
<span class="fc" id="L1882">              eext.isCritical(),</span>
              eext
<span class="fc" id="L1884">                  .getParsedValue()); // adding subjetAlternativeName extension</span>
                                      // to certbuilder
<span class="pc bpc" id="L1886" title="1 of 2 branches missed.">          if (precertbuilder</span>
              != null) { // if a pre-certificate is to be published to a CTLog
<span class="nc" id="L1888">            eext =</span>
<span class="nc" id="L1889">                getSubjectAltNameExtensionForCTCert(extension)</span>
<span class="nc" id="L1890">                    .generate()</span>
<span class="nc" id="L1891">                    .getExtension(oid);</span>
<span class="nc" id="L1892">            precertbuilder.addExtension(</span>
                oid,
<span class="nc" id="L1894">                eext.isCritical(),</span>
                eext
<span class="nc" id="L1896">                    .getParsedValue()); // adding subjectAlternativeName</span>
                                        // extension to precertbuilder

<span class="nc" id="L1899">            eext =</span>
<span class="nc" id="L1900">                sanExts.getExtension(</span>
                    new ASN1ObjectIdentifier(CertTools.ID_CT_REDACTED_DOMAINS));
<span class="nc bnc" id="L1902" title="All 2 branches missed.">            if (eext != null) {</span>
<span class="nc" id="L1903">              certbuilder.addExtension(</span>
<span class="nc" id="L1904">                  eext.getExtnId(),</span>
<span class="nc" id="L1905">                  eext.isCritical(),</span>
                  eext
<span class="nc" id="L1907">                      .getParsedValue()); // adding nrOfRedactedLabels extension</span>
                                          // to certbuilder
            }
          }
<span class="fc" id="L1911">        } else { // if not a subjectAlternativeName extension, just add it to</span>
                 // both certbuilder and precertbuilder
<span class="fc" id="L1913">          final boolean isCritical = extension.isCritical();</span>
          // We must get the raw octets here in order to be able to create
          // invalid extensions that is not constructed from proper ASN.1
<span class="fc" id="L1916">          final byte[] value = extension.getExtnValue().getOctets();</span>
<span class="fc" id="L1917">          certbuilder.addExtension(extension.getExtnId(), isCritical, value);</span>
<span class="pc bpc" id="L1918" title="1 of 2 branches missed.">          if (precertbuilder != null) {</span>
<span class="nc" id="L1919">            precertbuilder.addExtension(</span>
<span class="nc" id="L1920">                extension.getExtnId(), isCritical, value);</span>
          }
        }
      }

      // Add Certificate Transparency extension. It needs to access the
      // certbuilder and
      // the CA key so it has to be processed here inside X509CA.
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">      if (CT != null</span>
<span class="nc bnc" id="L1929" title="All 4 branches missed.">          &amp;&amp; certProfile.isUseCertificateTransparencyInCerts()</span>
          &amp;&amp; certGenParams != null) {

        // Create pre-certificate
        // A critical extension is added to prevent this cert from being used
<span class="nc" id="L1934">        CT.addPreCertPoison(precertbuilder);</span>

        // Sign pre-certificate
        /*
         *  TODO: Should be able to use a special CT signing certificate.
         *  It should have CA=true and ExtKeyUsage=PRECERTIFICATE_SIGNING_OID,
         *  and should not have any other key usages.
         */
<span class="nc" id="L1942">        final ContentSigner signer =</span>
            new BufferingContentSigner(
                new JcaContentSignerBuilder(sigAlg)
<span class="nc" id="L1945">                    .setProvider(provider)</span>
<span class="nc" id="L1946">                    .build(caPrivateKey),</span>
                20480);
<span class="nc" id="L1948">        final X509CertificateHolder certHolder = precertbuilder.build(signer);</span>
<span class="nc" id="L1949">        final X509Certificate cert =</span>
<span class="nc" id="L1950">            CertTools.getCertfromByteArray(</span>
<span class="nc" id="L1951">                certHolder.getEncoded(), X509Certificate.class);</span>
        // ECA-6051 Re-Factor with Domain Service Layer.
<span class="nc bnc" id="L1953" title="All 2 branches missed.">        if (certGenParams.getAuthenticationToken() != null</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">            &amp;&amp; certGenParams.getCertificateValidationDomainService() != null) {</span>
          try {
<span class="nc" id="L1956">            certGenParams</span>
<span class="nc" id="L1957">                .getCertificateValidationDomainService()</span>
<span class="nc" id="L1958">                .validateCertificate(</span>
<span class="nc" id="L1959">                    certGenParams.getAuthenticationToken(),</span>
                    IssuancePhase.PRE_CERTIFICATE_VALIDATION,
                    this,
                    subject,
                    cert);
<span class="nc" id="L1964">          } catch (ValidationException e) {</span>
<span class="nc" id="L1965">            throw new CertificateCreateException(</span>
                ErrorCode.INVALID_CERTIFICATE, e);
<span class="nc" id="L1967">          }</span>
        }

<span class="nc bnc" id="L1970" title="All 2 branches missed.">        if (certGenParams.getCTSubmissionConfigParams() == null) {</span>
<span class="nc" id="L1971">          LOG.debug(</span>
              &quot;Not logging to CT. CT submission configuration parameters was&quot;
                  + &quot; null.&quot;);
<span class="nc bnc" id="L1974" title="All 2 branches missed.">        } else if (MapUtils.isEmpty(</span>
            certGenParams
<span class="nc" id="L1976">                .getCTSubmissionConfigParams()</span>
<span class="nc" id="L1977">                .getConfiguredCTLogs())) {</span>
<span class="nc" id="L1978">          LOG.debug(</span>
              &quot;Not logging to CT. There are no CT logs configured in System&quot;
                  + &quot; Configuration.&quot;);
<span class="nc bnc" id="L1981" title="All 2 branches missed.">        } else if (certGenParams.getCTAuditLogCallback() == null) {</span>
<span class="nc" id="L1982">          LOG.debug(</span>
              &quot;Not logging to CT. No CT audit logging callback was passed to&quot;
                  + &quot; X509CA.&quot;);
        } else {
          // Get certificate chain
<span class="nc" id="L1987">          final List&lt;Certificate&gt; chain = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1988">          chain.add(cert);</span>
<span class="nc" id="L1989">          chain.addAll(getCertificateChain());</span>

          // Submit to logs and get signed timestamps
<span class="nc" id="L1992">          byte[] sctlist = null;</span>
          try {
<span class="nc" id="L1994">            sctlist =</span>
<span class="nc" id="L1995">                CT.fetchSCTList(</span>
                    chain,
                    certProfile,
<span class="nc" id="L1998">                    certGenParams.getCTSubmissionConfigParams());</span>
          } finally {
            // Notify that pre-cert has been successfully or unsuccessfully
            // submitted so it can be audit logged.
<span class="nc" id="L2002">            certGenParams</span>
<span class="nc bnc" id="L2003" title="All 2 branches missed.">                .getCTAuditLogCallback()</span>
<span class="nc" id="L2004">                .logPreCertSubmission(this, subject, cert, sctlist != null);</span>
          }
<span class="nc bnc" id="L2006" title="All 2 branches missed.">          if (sctlist</span>
              != null) { // can be null if the CTLog has been deleted from the
                         // configuration
<span class="nc" id="L2009">            ASN1ObjectIdentifier sctOid =</span>
                new ASN1ObjectIdentifier(CertificateTransparency.SCTLIST_OID);
<span class="nc" id="L2011">            certbuilder.addExtension(</span>
                sctOid, false, new DEROctetString(sctlist));
          }
        }
<span class="nc" id="L2015">      } else {</span>
<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2017">          String cause = &quot;&quot;;</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">          if (CT == null) {</span>
<span class="nc" id="L2019">            cause += &quot;CT is not available in this version of EJBCA.&quot;;</span>
          } else {
<span class="nc bnc" id="L2021" title="All 2 branches missed.">            if (!certProfile.isUseCertificateTransparencyInCerts()) {</span>
<span class="nc" id="L2022">              cause += &quot;CT is not enabled in the certificate profile. &quot;;</span>
            }
<span class="nc bnc" id="L2024" title="All 2 branches missed.">            if (certGenParams == null) {</span>
<span class="nc" id="L2025">              cause += &quot;Certificate generation parameters was null.&quot;;</span>
            }
          }
<span class="nc" id="L2028">          LOG.debug(&quot;Not logging to CT. &quot; + cause);</span>
        }
      }
<span class="nc" id="L2031">    } catch (CertificateException e) {</span>
<span class="nc" id="L2032">      throw new CertificateCreateException(</span>
          &quot;Could not process CA's private key when parsing Certificate&quot;
              + &quot; Transparency extension.&quot;,
          e);
<span class="nc" id="L2036">    } catch (IOException e) {</span>
<span class="nc" id="L2037">      throw new CertificateCreateException(</span>
          &quot;IOException was caught when parsing Certificate Transparency&quot;
              + &quot; extension.&quot;,
          e);
<span class="nc" id="L2041">    } catch (CTLogException e) {</span>
<span class="nc" id="L2042">      throw new CertificateCreateException(</span>
          &quot;An exception occurred because too many CT servers were down to&quot;
              + &quot; satisfy the certificate profile.&quot;,
          e);
<span class="fc" id="L2046">    }</span>

    //
    // End of extensions
    //

<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2053">      LOG.trace(&quot;&gt;certgen.generate&quot;);</span>
    }
<span class="fc" id="L2055">    final ContentSigner signer =</span>
        new BufferingContentSigner(
            new JcaContentSignerBuilder(sigAlg)
<span class="fc" id="L2058">                .setProvider(provider)</span>
<span class="fc" id="L2059">                .build(caPrivateKey),</span>
            20480);
<span class="fc" id="L2061">    final X509CertificateHolder certHolder = certbuilder.build(signer);</span>
    X509Certificate cert;
    try {
<span class="fc" id="L2064">      cert =</span>
<span class="fc" id="L2065">          CertTools.getCertfromByteArray(</span>
<span class="fc" id="L2066">              certHolder.getEncoded(), X509Certificate.class);</span>
<span class="nc" id="L2067">    } catch (IOException e) {</span>
<span class="nc" id="L2068">      throw new IllegalStateException(</span>
          &quot;Unexpected IOException caught when parsing certificate holder.&quot;, e);
<span class="nc" id="L2070">    } catch (CertificateException e) {</span>
<span class="nc" id="L2071">      throw new CertificateCreateException(</span>
          &quot;Could not create certificate from CA's private key,&quot;, e);
<span class="fc" id="L2073">    }</span>
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2075">      LOG.trace(&quot;&lt;certgen.generate&quot;);</span>
    }

    // Verify using the CA certificate before returning
    // If we can not verify the issued certificate using the CA certificate we
    // don't want to issue this cert
    // because something is wrong...
    final PublicKey verifyKey;
    // We must use the configured public key if this is a rootCA, because then
    // we can renew our own certificate, after changing
    // the keys. In this case the _new_ key will not match the current CA
    // certificate.
<span class="pc bpc" id="L2087" title="2 of 4 branches missed.">    if ((cacert != null) &amp;&amp; (!isRootCA)) {</span>
<span class="fc" id="L2088">      verifyKey = cacert.getPublicKey();</span>
    } else {
<span class="nc" id="L2090">      verifyKey = caPublicKey;</span>
    }
    try {
<span class="fc" id="L2093">      cert.verify(verifyKey);</span>
<span class="nc" id="L2094">    } catch (InvalidKeyException e) {</span>
<span class="nc" id="L2095">      throw new CertificateCreateException(&quot;CA's public key was invalid,&quot;, e);</span>
<span class="nc" id="L2096">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2097">      throw new CertificateCreateException(e);</span>
<span class="nc" id="L2098">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L2099">      throw new IllegalStateException(&quot;Provider was unknown&quot;, e);</span>
<span class="nc" id="L2100">    } catch (CertificateException e) {</span>
<span class="nc" id="L2101">      throw new CertificateCreateException(e);</span>
<span class="fc" id="L2102">    }</span>

    // Verify any Signed Certificate Timestamps (SCTs) in the certificate before
    // returning. If one of the (embedded) SCTs does
    // not verify over the final certificate, it won't validate in the browser
    // and we don't want to issue such certificates.
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">    if (CT != null) {</span>
      Collection&lt;CTLogInfo&gt; ctLogs =
<span class="nc bnc" id="L2110" title="All 2 branches missed.">          (certGenParams == null</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">                  || certGenParams.getCTSubmissionConfigParams() == null</span>
                  || certGenParams
<span class="nc" id="L2113">                          .getCTSubmissionConfigParams()</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">                          .getConfiguredCTLogs()</span>
                      == null)
<span class="nc" id="L2116">              ? null</span>
              : certGenParams
<span class="nc" id="L2118">                  .getCTSubmissionConfigParams()</span>
<span class="nc" id="L2119">                  .getConfiguredCTLogs()</span>
<span class="nc" id="L2120">                  .values();</span>
<span class="nc" id="L2121">      CT.allSctsAreValidOrThrow(cert, getCertificateChain(), ctLogs);</span>
    }

    // Sub CA certificates check: Check AKI against parent CA SKI and IssuerDN
    // against parent CA SubjectDN
<span class="pc bpc" id="L2126" title="2 of 4 branches missed.">    if (!isRootCA &amp;&amp; !linkCertificate) {</span>
<span class="fc" id="L2127">      final byte[] aki = CertTools.getAuthorityKeyId(cert);</span>
<span class="fc" id="L2128">      final byte[] ski = CertTools.getSubjectKeyId(cacert);</span>
<span class="pc bpc" id="L2129" title="2 of 4 branches missed.">      if ((aki != null) &amp;&amp; (ski != null)) {</span>
<span class="fc" id="L2130">        final boolean eq = Arrays.equals(aki, ski);</span>
<span class="pc bpc" id="L2131" title="1 of 2 branches missed.">        if (!eq) {</span>
<span class="nc" id="L2132">          final String akistr = new String(Hex.encode(aki));</span>
<span class="nc" id="L2133">          final String skistr = new String(Hex.encode(ski));</span>
<span class="nc" id="L2134">          final String msg =</span>
<span class="nc" id="L2135">              INTRES.getLocalizedMessage(</span>
                  &quot;createcert.errorpathverifykeyid&quot;, akistr, skistr);
<span class="nc" id="L2137">          LOG.error(msg);</span>
<span class="nc" id="L2138">          throw new CertificateCreateException(msg);</span>
        }
      }
<span class="fc" id="L2141">      final Principal issuerDN = cert.getIssuerX500Principal();</span>
<span class="fc" id="L2142">      final Principal caSubjectDN = cacert.getSubjectX500Principal();</span>
<span class="pc bpc" id="L2143" title="2 of 4 branches missed.">      if ((issuerDN != null) &amp;&amp; (caSubjectDN != null)) {</span>
<span class="fc" id="L2144">        final boolean eq = issuerDN.equals(caSubjectDN);</span>
<span class="pc bpc" id="L2145" title="1 of 2 branches missed.">        if (!eq) {</span>
<span class="nc" id="L2146">          final String msg =</span>
<span class="nc" id="L2147">              INTRES.getLocalizedMessage(</span>
                  &quot;createcert.errorpathverifydn&quot;,
<span class="nc" id="L2149">                  issuerDN.getName(),</span>
<span class="nc" id="L2150">                  caSubjectDN.getName());</span>
<span class="nc" id="L2151">          LOG.error(msg);</span>
<span class="nc" id="L2152">          throw new CertificateCreateException(msg);</span>
        }
      }
    }

    // Before returning from this method, we will set the private key and
    // provider in the request message, in case the response  message needs to
    // be signed
<span class="fc bfc" id="L2160" title="All 2 branches covered.">    if (request != null) {</span>
<span class="fc" id="L2161">      request.setResponseKeyInfo(caPrivateKey, provider);</span>
    }
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2164">      LOG.debug(</span>
          &quot;X509CA: generated certificate, CA &quot;
<span class="nc" id="L2166">              + this.getCAId()</span>
              + &quot; for DN: &quot;
<span class="nc" id="L2168">              + subject.getCertificateDN());</span>
    }
<span class="fc" id="L2170">    return cert;</span>
  }

  @Override
  public X509CRLHolder generateCRL(
      final CryptoToken cryptoToken,
      final Collection&lt;RevokedCertInfo&gt; certs,
      final int crlnumber)
      throws CryptoTokenOfflineException, IllegalCryptoTokenException,
          IOException, SignatureException, NoSuchProviderException,
          InvalidKeyException, CRLException, NoSuchAlgorithmException {
<span class="fc" id="L2181">    return generateCRL(cryptoToken, certs, getCRLPeriod(), crlnumber, false, 0);</span>
  }

  @Override
  public X509CRLHolder generateDeltaCRL(
      final CryptoToken cryptoToken,
      final Collection&lt;RevokedCertInfo&gt; certs,
      final int crlnumber,
      final int basecrlnumber)
      throws CryptoTokenOfflineException, IllegalCryptoTokenException,
          IOException, SignatureException, NoSuchProviderException,
          InvalidKeyException, CRLException, NoSuchAlgorithmException {
<span class="fc" id="L2193">    return generateCRL(</span>
        cryptoToken,
        certs,
<span class="fc" id="L2196">        getDeltaCRLPeriod(),</span>
        crlnumber,
        true,
        basecrlnumber);
  }

  /**
   * Constructs the SubjectAlternativeName extension that will end up on the
   * generated certificate.
   *
   * &lt;p&gt;If the DNS values in the subjectAlternativeName extension contain
   * parentheses to specify labels that should be redacted, the parentheses are
   * removed and another extension containing the number of redacted labels is
   * added.
   *
   * @param subAltNameExt Alt Name
   * @param publishToCT boolean
   * @return An extension generator containing the SubjectAlternativeName
   *     extension and an extension holding the number of redacted labels if the
   *     certificate is to be published to a CTLog
   * @throws IOException if read fails
   */
  protected ExtensionsGenerator getSubjectAltNameExtensionForCert(
      final Extension subAltNameExt,
      final boolean publishToCT) throws IOException {
<span class="fc" id="L2221">    GeneralNames names = CertTools.getGeneralNamesFromExtension(subAltNameExt);</span>
<span class="fc" id="L2222">    GeneralName[] gns = names.getNames();</span>
<span class="fc" id="L2223">    boolean sanEdited = false;</span>
<span class="fc" id="L2224">    ASN1EncodableVector nrOfRecactedLables = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L2225" title="All 2 branches covered.">    for (int j = 0; j &lt; gns.length; j++) {</span>
<span class="fc" id="L2226">      GeneralName generalName = gns[j];</span>
      // Look for DNS name
<span class="fc bfc" id="L2228" title="All 2 branches covered.">      if (generalName.getTagNo() == 2) {</span>
<span class="fc" id="L2229">        final String str =</span>
<span class="fc" id="L2230">            CertTools.getGeneralNameString(2, generalName.getName());</span>
<span class="fc bfc" id="L2231" title="All 2 branches covered.">        if (StringUtils.contains(str, &quot;(&quot;)</span>
<span class="pc bpc" id="L2232" title="1 of 2 branches missed.">            &amp;&amp; StringUtils.contains(</span>
                str, &quot;)&quot;)) { // if it contains parts that should be redacted
          // Remove the parentheses from the SubjectAltName that will end up on
          // the certificate
<span class="fc" id="L2236">          String certBuilderDNSValue = StringUtils.remove(str, &quot;dNSName=&quot;);</span>
<span class="fc" id="L2237">          certBuilderDNSValue = StringUtils.remove(certBuilderDNSValue, '(');</span>
<span class="fc" id="L2238">          certBuilderDNSValue = StringUtils.remove(certBuilderDNSValue, ')');</span>
          // Replace the old value with the new
<span class="fc" id="L2240">          gns[j] = new GeneralName(2, new DERIA5String(certBuilderDNSValue));</span>
<span class="fc" id="L2241">          sanEdited = true;</span>
<span class="fc bfc" id="L2242" title="All 2 branches covered.">          if (publishToCT) {</span>
<span class="fc" id="L2243">            String redactedLable =</span>
<span class="fc" id="L2244">                StringUtils.substring(</span>
                    str,
<span class="fc" id="L2246">                    StringUtils.indexOf(str, &quot;(&quot;),</span>
<span class="fc" id="L2247">                    StringUtils.lastIndexOf(str, &quot;)&quot;)</span>
                        + 1); // tex. (top.secret).domain.se =&gt; redactedLable =
                              // (top.secret) aka. including the parentheses
<span class="fc" id="L2250">            nrOfRecactedLables.add(</span>
                new ASN1Integer(
<span class="fc" id="L2252">                    StringUtils.countMatches(redactedLable, &quot;.&quot;) + 1));</span>
          }
<span class="fc" id="L2254">        } else {</span>
<span class="fc" id="L2255">          nrOfRecactedLables.add(new ASN1Integer(0));</span>
        }
      }
<span class="fc bfc" id="L2258" title="All 2 branches covered.">      if (generalName.getTagNo() == 1) {</span>
<span class="fc" id="L2259">        final String str =</span>
<span class="fc" id="L2260">            CertTools.getGeneralNameString(1, generalName.getName());</span>
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">        if (StringUtils.contains(</span>
            str,
            &quot;\\+&quot;)) { // if it contains a '+' character that should be unescaped
          // Remove '\' from the email that will end up on the certificate
<span class="nc" id="L2265">          String certBuilderEmailValue = StringUtils.remove(str, &quot;rfc822name=&quot;);</span>
<span class="nc" id="L2266">          certBuilderEmailValue =</span>
<span class="nc" id="L2267">              StringUtils.remove(certBuilderEmailValue, '\\');</span>
          // Replace the old value with the new
<span class="nc" id="L2269">          gns[j] = new GeneralName(1, new DERIA5String(certBuilderEmailValue));</span>
        }
      }
    }
<span class="fc" id="L2273">    ExtensionsGenerator gen = new ExtensionsGenerator();</span>
    // Use the GeneralName from original altName in order to not re-encode
    // anything
<span class="fc" id="L2276">    gen.addExtension(</span>
        Extension.subjectAlternativeName,
<span class="fc" id="L2278">        subAltNameExt.isCritical(),</span>
        new GeneralNames(gns));
    // If there actually are redacted parts, add the extension containing the
    // number of redacted labels to the certificate
<span class="pc bpc" id="L2282" title="1 of 4 branches missed.">    if (publishToCT &amp;&amp; sanEdited) {</span>
<span class="fc" id="L2283">      ASN1Encodable seq = new DERSequence(nrOfRecactedLables);</span>
<span class="fc" id="L2284">      gen.addExtension(</span>
          new ASN1ObjectIdentifier(CertTools.ID_CT_REDACTED_DOMAINS),
          false,
          seq);
    }

<span class="fc" id="L2290">    return gen;</span>
  }

  /**
   * Constructs the SubjectAlternativeName extension that will end up on the
   * certificate published to a CTLog.
   *
   * &lt;p&gt;If the DNS values in the subjectAlternativeName extension contain
   * parentheses to specify labels that should be redacted, these labels will be
   * replaced by the string &quot;PRIVATE&quot;
   *
   * @param subAltNameExt Alt Name
   * @return An extension generator containing the SubjectAlternativeName
   *     extension
   * @throws IOException if read fails
   */
  protected ExtensionsGenerator getSubjectAltNameExtensionForCTCert(
      final Extension subAltNameExt) throws IOException {
<span class="fc" id="L2308">    Pattern parenthesesRegex =</span>
<span class="fc" id="L2309">        Pattern.compile(</span>
            &quot;\\(.*\\)&quot;); // greedy match, so against &quot;(a).(b).example.com&quot; it
                         // will match &quot;(a).(b)&quot;, like the old code did
<span class="fc" id="L2312">    GeneralNames names = CertTools.getGeneralNamesFromExtension(subAltNameExt);</span>
<span class="fc" id="L2313">    GeneralName[] gns = names.getNames();</span>
<span class="fc bfc" id="L2314" title="All 2 branches covered.">    for (int j = 0; j &lt; gns.length; j++) {</span>
<span class="fc" id="L2315">      GeneralName generalName = gns[j];</span>
      // Look for DNS name
<span class="fc bfc" id="L2317" title="All 2 branches covered.">      if (generalName.getTagNo() == 2) {</span>
<span class="fc" id="L2318">        final String value =</span>
<span class="fc" id="L2319">            DERIA5String.getInstance(generalName.getName()).getString();</span>
<span class="fc" id="L2320">        final Matcher matcher = parenthesesRegex.matcher(value);</span>
<span class="fc bfc" id="L2321" title="All 2 branches covered.">        if (matcher.find()) {</span>
<span class="fc" id="L2322">          final String newValue = matcher.replaceAll(&quot;(PRIVATE)&quot;);</span>
<span class="fc" id="L2323">          gns[j] = new GeneralName(2, new DERIA5String(newValue));</span>
        }
      }
<span class="fc bfc" id="L2326" title="All 2 branches covered.">      if (generalName.getTagNo() == 1) {</span>
<span class="fc" id="L2327">        final String str =</span>
<span class="fc" id="L2328">            CertTools.getGeneralNameString(1, generalName.getName());</span>
<span class="pc bpc" id="L2329" title="1 of 2 branches missed.">        if (StringUtils.contains(</span>
            str,
            &quot;\\+&quot;)) { // if it contains a '+' character that should be unescaped
          // Remove '\' from the email that will end up on the certificate
<span class="nc" id="L2333">          String certBuilderEmailValue = StringUtils.remove(str, &quot;rfc822name=&quot;);</span>
<span class="nc" id="L2334">          certBuilderEmailValue =</span>
<span class="nc" id="L2335">              StringUtils.remove(certBuilderEmailValue, '\\');</span>
          // Replace the old value with the new
<span class="nc" id="L2337">          gns[j] = new GeneralName(1, new DERIA5String(certBuilderEmailValue));</span>
        }
      }
    }

<span class="fc" id="L2342">    ExtensionsGenerator gen = new ExtensionsGenerator();</span>
<span class="fc" id="L2343">    gen.addExtension(</span>
        Extension.subjectAlternativeName,
<span class="fc" id="L2345">        subAltNameExt.isCritical(),</span>
        new GeneralNames(gns));
<span class="fc" id="L2347">    return gen;</span>
  }

  /**
   * Generate a CRL or a deltaCRL.
   *
   * @param cryptoToken the cryptoToken with keys used to sign the CRL
   * @param certs list of revoked certificates
   * @param crlPeriod the validity period of the generated CRL, the CRLs
   *     nextUpdate will be set to (currentTimeMillis + crlPeriod)
   * @param crlnumber CRLNumber for this CRL
   * @param isDeltaCRL true if we should generate a DeltaCRL
   * @param basecrlnumber caseCRLNumber for a delta CRL, use 0 for full CRLs
   * @return X509CRLHolder with the generated CRL
   * @throws CryptoTokenOfflineException If offline
   * @throws IllegalCryptoTokenException If token is invalid
   * @throws IOException If read/write fails
   * @throws SignatureException If signature is invalid
   * @throws NoSuchProviderException If provider cannot be found
   * @throws InvalidKeyException If key is invalid
   * @throws CRLException if CRL is invalid
   * @throws NoSuchAlgorithmException If algorithm is invalid
   */
  private X509CRLHolder generateCRL(
      final CryptoToken cryptoToken,
      final Collection&lt;RevokedCertInfo&gt; certs,
      final long crlPeriod,
      final int crlnumber,
      final boolean isDeltaCRL,
      final int basecrlnumber)
      throws CryptoTokenOfflineException, IllegalCryptoTokenException,
          IOException, SignatureException, NoSuchProviderException,
          InvalidKeyException, CRLException, NoSuchAlgorithmException {
<span class="fc" id="L2380">    final String sigAlg = getCAInfo().getCAToken().getSignatureAlgorithm();</span>

<span class="pc bpc" id="L2382" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2383">      LOG.debug(</span>
          &quot;generateCRL(&quot;
<span class="nc" id="L2385">              + certs.size()</span>
              + &quot;, &quot;
              + crlPeriod
              + &quot;, &quot;
              + crlnumber
              + &quot;, &quot;
              + isDeltaCRL
              + &quot;, &quot;
              + basecrlnumber);
    }

    // Make DNs
<span class="fc" id="L2397">    final X509Certificate cacert = (X509Certificate) getCACertificate();</span>
    final X500Name issuer;
<span class="pc bpc" id="L2399" title="1 of 2 branches missed.">    if (cacert == null) {</span>
      // This is an initial root CA, since no CA-certificate exists
      // (I don't think we can ever get here!!!)
      final X500NameStyle nameStyle;
<span class="nc bnc" id="L2403" title="All 2 branches missed.">      if (getUsePrintableStringSubjectDN()) {</span>
<span class="nc" id="L2404">        nameStyle = PrintableStringNameStyle.INSTANCE;</span>
      } else {
<span class="nc" id="L2406">        nameStyle = CeSecoreNameStyle.INSTANCE;</span>
      }
<span class="nc" id="L2408">      issuer =</span>
<span class="nc" id="L2409">          CertTools.stringToBcX500Name(</span>
<span class="nc" id="L2410">              getSubjectDN(), nameStyle, getUseLdapDNOrder());</span>
<span class="nc" id="L2411">    } else {</span>
<span class="fc" id="L2412">      issuer =</span>
<span class="fc" id="L2413">          X500Name.getInstance(cacert.getSubjectX500Principal().getEncoded());</span>
    }
<span class="fc" id="L2415">    final Date thisUpdate = new Date();</span>
<span class="fc" id="L2416">    final Date nextUpdate = new Date();</span>
<span class="fc" id="L2417">    nextUpdate.setTime(nextUpdate.getTime() + crlPeriod);</span>
<span class="fc" id="L2418">    final X509v2CRLBuilder crlgen = new X509v2CRLBuilder(issuer, thisUpdate);</span>
<span class="fc" id="L2419">    crlgen.setNextUpdate(nextUpdate);</span>
<span class="pc bpc" id="L2420" title="1 of 2 branches missed.">    if (certs != null) {</span>
<span class="pc bpc" id="L2421" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2422">        LOG.debug(</span>
            &quot;Adding &quot;
<span class="nc" id="L2424">                + certs.size()</span>
                + &quot; revoked certificates to CRL. Free memory=&quot;
<span class="nc" id="L2426">                + Runtime.getRuntime().freeMemory());</span>
      }
<span class="fc bfc" id="L2428" title="All 2 branches covered.">      for (final RevokedCertInfo certinfo : certs) {</span>
<span class="fc" id="L2429">        crlgen.addCRLEntry(</span>
<span class="fc" id="L2430">            certinfo.getUserCertificate(),</span>
<span class="fc" id="L2431">            certinfo.getRevocationDate(),</span>
<span class="fc" id="L2432">            certinfo.getReason());</span>
<span class="fc" id="L2433">      }</span>
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2435">        LOG.debug(</span>
            &quot;Finished adding &quot;
<span class="nc" id="L2437">                + certs.size()</span>
                + &quot; revoked certificates to CRL. Free memory=&quot;
<span class="nc" id="L2439">                + Runtime.getRuntime().freeMemory());</span>
      }
    }

    // Authority key identifier
<span class="pc bpc" id="L2444" title="1 of 2 branches missed.">    if (getUseAuthorityKeyIdentifier()) {</span>
      byte[] caSkid =
<span class="pc bpc" id="L2446" title="1 of 2 branches missed.">          (cacert != null ? CertTools.getSubjectKeyId(cacert) : null);</span>
<span class="pc bpc" id="L2447" title="1 of 2 branches missed.">      if (caSkid != null) {</span>
        // Use subject key id from CA certificate
<span class="fc" id="L2449">        AuthorityKeyIdentifier aki = new AuthorityKeyIdentifier(caSkid);</span>
<span class="fc" id="L2450">        crlgen.addExtension(</span>
            Extension.authorityKeyIdentifier,
<span class="fc" id="L2452">            getAuthorityKeyIdentifierCritical(),</span>
            aki);
<span class="fc" id="L2454">      } else {</span>
<span class="nc" id="L2455">        JcaX509ExtensionUtils extensionUtils =</span>
<span class="nc" id="L2456">            new JcaX509ExtensionUtils(SHA1DigestCalculator.buildSha1Instance());</span>
<span class="nc" id="L2457">        AuthorityKeyIdentifier aki =</span>
<span class="nc" id="L2458">            extensionUtils.createAuthorityKeyIdentifier(</span>
<span class="nc" id="L2459">                cryptoToken.getPublicKey(</span>
<span class="nc" id="L2460">                    getCAToken()</span>
<span class="nc" id="L2461">                        .getAliasFromPurpose(</span>
                            CATokenConstants.CAKEYPURPOSE_CRLSIGN)));
<span class="nc" id="L2463">        crlgen.addExtension(</span>
            Extension.authorityKeyIdentifier,
<span class="nc" id="L2465">            getAuthorityKeyIdentifierCritical(),</span>
            aki);
      }
    }

    // Authority Information Access
<span class="fc" id="L2471">    final ASN1EncodableVector accessList = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L2472" title="All 2 branches covered.">    if (getAuthorityInformationAccess() != null) {</span>
<span class="fc bfc" id="L2473" title="All 2 branches covered.">      for (String url : getAuthorityInformationAccess()) {</span>
<span class="pc bpc" id="L2474" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(url)) {</span>
<span class="fc" id="L2475">          GeneralName accessLocation =</span>
              new GeneralName(
                  GeneralName.uniformResourceIdentifier, new DERIA5String(url));
<span class="fc" id="L2478">          accessList.add(</span>
              new AccessDescription(
                  AccessDescription.id_ad_caIssuers, accessLocation));
        }
<span class="fc" id="L2482">      }</span>
    }
<span class="fc bfc" id="L2484" title="All 2 branches covered.">    if (accessList.size() &gt; 0) {</span>
<span class="fc" id="L2485">      AuthorityInformationAccess authorityInformationAccess =</span>
<span class="fc" id="L2486">          AuthorityInformationAccess.getInstance(new DERSequence(accessList));</span>
      // &quot;This CRL extension MUST NOT be marked critical.&quot; according to rfc4325
<span class="fc" id="L2488">      crlgen.addExtension(</span>
          Extension.authorityInfoAccess, false, authorityInformationAccess);
    }

    // CRLNumber extension
<span class="pc bpc" id="L2493" title="1 of 2 branches missed.">    if (getUseCRLNumber()) {</span>
<span class="fc" id="L2494">      CRLNumber crlnum = new CRLNumber(BigInteger.valueOf(crlnumber));</span>
<span class="fc" id="L2495">      crlgen.addExtension(</span>
<span class="fc" id="L2496">          Extension.cRLNumber, this.getCRLNumberCritical(), crlnum);</span>
    }

    // ExpiredCertsOnCRL extension (is always specified as not critical)
    // Date format to be used is: yyyyMMddHHmmss
    // https://www.itu.int/ITU-T/formal-language/itu-t/x/x509/2005/CertificateExtensions.html
    //
    // expiredCertsOnCRL EXTENSION ::= {
    //   SYNTAX         ExpiredCertsOnCRL
    //   IDENTIFIED BY  id-ce-expiredCertsOnCRL
    // }
    // ExpiredCertsOnCRL ::= GeneralizedTime
    // The ExpiredCertsOnCRL CRL extension is not specified by IETF-PKIX. It is
    // defined by the ITU-T Recommendation X.509 and
    // indicates that a CRL containing this extension will include revocation
    // status information for certificates that have
    // been already expired. When used, the ExpiredCertsOnCRL contains the date
    // on which the CRL starts to keep revocation
    // status information for expired certificates (i.e. revocation entries are
    // not removed from the CRL for any certificates
    // that expire at or after the date contained in the ExpiredCertsOnCRL
    // extension).
<span class="fc" id="L2518">    final ASN1ObjectIdentifier expiredCertsOnCRL =</span>
        new ASN1ObjectIdentifier(&quot;2.5.29.60&quot;);
<span class="fc" id="L2520">    boolean keepexpiredcertsoncrl = getKeepExpiredCertsOnCRL();</span>
<span class="pc bpc" id="L2521" title="1 of 2 branches missed.">    if (keepexpiredcertsoncrl) {</span>
<span class="nc" id="L2522">      SimpleDateFormat sdf = new SimpleDateFormat();</span>
<span class="nc" id="L2523">      final String gmtDatePattern = &quot;yyyyMMddHHmmss&quot;;</span>
<span class="nc" id="L2524">      sdf.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));</span>
<span class="nc" id="L2525">      sdf.applyPattern(gmtDatePattern);</span>
      // For now force parameter with date equals NotBefore of CA certificate,
      // or now
<span class="nc bnc" id="L2528" title="All 2 branches missed.">      final Date keepDate = cacert != null ? cacert.getNotBefore() : new Date();</span>
<span class="nc" id="L2529">      crlgen.addExtension(</span>
          expiredCertsOnCRL, false, new DERGeneralizedTime(keepDate));
<span class="nc bnc" id="L2531" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2532">        LOG.debug(</span>
            &quot;ExpiredCertsOnCRL extension added to CRL. Keep date: &quot; + keepDate);
      }
    }

<span class="fc bfc" id="L2537" title="All 2 branches covered.">    if (isDeltaCRL) {</span>
      // DeltaCRLIndicator extension
<span class="fc" id="L2539">      CRLNumber basecrlnum = new CRLNumber(BigInteger.valueOf(basecrlnumber));</span>
<span class="fc" id="L2540">      crlgen.addExtension(Extension.deltaCRLIndicator, true, basecrlnum);</span>
    }
    // CRL Distribution point URI and Freshest CRL DP
<span class="fc bfc" id="L2543" title="All 2 branches covered.">    if (getUseCrlDistributionPointOnCrl()) {</span>
<span class="fc" id="L2544">      String crldistpoint = getDefaultCRLDistPoint();</span>
<span class="fc" id="L2545">      List&lt;DistributionPoint&gt; distpoints =</span>
<span class="fc" id="L2546">          generateDistributionPoints(crldistpoint);</span>

<span class="pc bpc" id="L2548" title="1 of 2 branches missed.">      if (distpoints.size() &gt; 0) {</span>
<span class="fc" id="L2549">        IssuingDistributionPoint idp =</span>
            new IssuingDistributionPoint(
<span class="fc" id="L2551">                distpoints.get(0).getDistributionPoint(),</span>
                false,
                false,
                null,
                false,
                false);

        // According to the RFC, IDP must be a critical extension.
        // Nonetheless, at the moment, Mozilla is not able to correctly
        // handle the IDP extension and discards the CRL if it is critical.
<span class="fc" id="L2561">        crlgen.addExtension(</span>
            Extension.issuingDistributionPoint,
<span class="fc" id="L2563">            getCrlDistributionPointOnCrlCritical(),</span>
            idp);
      }

<span class="pc bpc" id="L2567" title="1 of 2 branches missed.">      if (!isDeltaCRL) {</span>
<span class="fc" id="L2568">        String crlFreshestDP = getCADefinedFreshestCRL();</span>
<span class="fc" id="L2569">        List&lt;DistributionPoint&gt; freshestDistPoints =</span>
<span class="fc" id="L2570">            generateDistributionPoints(crlFreshestDP);</span>
<span class="fc bfc" id="L2571" title="All 2 branches covered.">        if (freshestDistPoints.size() &gt; 0) {</span>
<span class="fc" id="L2572">          CRLDistPoint ext =</span>
              new CRLDistPoint(
<span class="fc" id="L2574">                  freshestDistPoints.toArray(</span>
<span class="fc" id="L2575">                      new DistributionPoint[freshestDistPoints.size()]));</span>

          // According to the RFC, the Freshest CRL extension on a
          // CRL must not be marked as critical. Therefore it is
          // hardcoded as not critical and is independent of
          // getCrlDistributionPointOnCrlCritical().
<span class="fc" id="L2581">          crlgen.addExtension(Extension.freshestCRL, false, ext);</span>
        }
      }
    }

    final X509CRLHolder crl;
<span class="pc bpc" id="L2587" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2588">      LOG.debug(</span>
<span class="nc" id="L2589">          &quot;Signing CRL. Free memory=&quot; + Runtime.getRuntime().freeMemory());</span>
    }
<span class="fc" id="L2591">    final String alias =</span>
<span class="fc" id="L2592">        getCAToken().getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CRLSIGN);</span>
    try {
<span class="fc" id="L2594">      final ContentSigner signer =</span>
          new BufferingContentSigner(
              new JcaContentSignerBuilder(sigAlg)
<span class="fc" id="L2597">                  .setProvider(cryptoToken.getSignProviderName())</span>
<span class="fc" id="L2598">                  .build(cryptoToken.getPrivateKey(alias)),</span>
              20480);
<span class="fc" id="L2600">      crl = crlgen.build(signer);</span>
<span class="nc" id="L2601">    } catch (OperatorCreationException e) {</span>
      // Very fatal error
<span class="nc" id="L2603">      throw new RuntimeException(&quot;Can not create Jca content signer: &quot;, e);</span>
<span class="fc" id="L2604">    }</span>
<span class="pc bpc" id="L2605" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2606">      LOG.debug(</span>
          &quot;Finished signing CRL. Free memory=&quot;
<span class="nc" id="L2608">              + Runtime.getRuntime().freeMemory());</span>
    }

    // Verify using the CA certificate before returning
    // If we can not verify the issued CRL using the CA certificate we don't
    // want to issue this CRL
    // because something is wrong...
    final PublicKey verifyKey;
<span class="pc bpc" id="L2616" title="1 of 2 branches missed.">    if (cacert != null) {</span>
<span class="fc" id="L2617">      verifyKey = cacert.getPublicKey();</span>
<span class="pc bpc" id="L2618" title="1 of 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2619">        LOG.trace(&quot;Got the verify key from the CA certificate.&quot;);</span>
      }
    } else {
<span class="nc" id="L2622">      verifyKey = cryptoToken.getPublicKey(alias);</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L2624">        LOG.trace(&quot;Got the verify key from the CA token.&quot;);</span>
      }
    }
    try {
<span class="fc" id="L2628">      final ContentVerifierProvider verifier =</span>
<span class="fc" id="L2629">          CertTools.genContentVerifierProvider(verifyKey);</span>
<span class="fc bfc" id="L2630" title="All 2 branches covered.">      if (!crl.isSignatureValid(verifier)) {</span>
<span class="fc" id="L2631">        throw new SignatureException(&quot;Error verifying CRL to be returned.&quot;);</span>
      }
<span class="nc" id="L2633">    } catch (OperatorCreationException e) {</span>
      // Very fatal error
<span class="nc" id="L2635">      throw new RuntimeException(&quot;Can not create Jca content signer: &quot;, e);</span>
<span class="nc" id="L2636">    } catch (CertException e) {</span>
<span class="nc" id="L2637">      throw new SignatureException(e.getMessage(), e);</span>
<span class="fc" id="L2638">    }</span>
<span class="pc bpc" id="L2639" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2640">      LOG.debug(</span>
<span class="nc" id="L2641">          &quot;Returning CRL. Free memory=&quot; + Runtime.getRuntime().freeMemory());</span>
    }
<span class="fc" id="L2643">    return crl;</span>
  }

  /**
   * Generate a list of Distribution points.
   *
   * @param distPoints distribution points as String in semi column (';')
   *     separated format.
   * @return list of distribution points.
   */
  private List&lt;DistributionPoint&gt; generateDistributionPoints(
      final String distPoints) {
    // Multiple CDPs are separated with the ';' sign
<span class="fc" id="L2656">    ArrayList&lt;DistributionPoint&gt; result = new ArrayList&lt;&gt;();</span>
    for (final String uri
<span class="fc bfc" id="L2658" title="All 2 branches covered.">        : StringTools.splitURIs(StringUtils.defaultString(distPoints))) {</span>
<span class="fc" id="L2659">      GeneralName gn =</span>
          new GeneralName(
              GeneralName.uniformResourceIdentifier, new DERIA5String(uri));
<span class="pc bpc" id="L2662" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2663">        LOG.debug(&quot;Added CRL distpoint: &quot; + uri);</span>
      }
<span class="fc" id="L2665">      ASN1EncodableVector vec = new ASN1EncodableVector();</span>
<span class="fc" id="L2666">      vec.add(gn);</span>
<span class="fc" id="L2667">      GeneralNames gns = GeneralNames.getInstance(new DERSequence(vec));</span>
<span class="fc" id="L2668">      DistributionPointName dpn = new DistributionPointName(0, gns);</span>
<span class="fc" id="L2669">      result.add(new DistributionPoint(dpn, null, null));</span>
<span class="fc" id="L2670">    }</span>
<span class="fc" id="L2671">    return result;</span>
  }

  /** Implementation of UpgradableDataHashMap function getLatestVersion. */
  @Override
  public float getLatestVersion() {
<span class="fc" id="L2677">    return LATEST_VERSION;</span>
  }

  /** Implementation of UpgradableDataHashMap function upgrade. */
  @Override
  @SuppressWarnings(&quot;deprecation&quot;)
  public void upgrade() {
<span class="nc bnc" id="L2684" title="All 2 branches missed.">    if (Float.compare(LATEST_VERSION, getVersion()) != 0) {</span>
      // New version of the class, upgrade
<span class="nc" id="L2686">      LOG.info(&quot;Upgrading X509CA with version &quot; + getVersion());</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">      if (data.get(DEFAULTOCSPSERVICELOCATOR) == null) {</span>
<span class="nc" id="L2688">        setDefaultCRLDistPoint(&quot;&quot;);</span>
<span class="nc" id="L2689">        setDefaultOCSPServiceLocator(&quot;&quot;);</span>
      }
<span class="nc bnc" id="L2691" title="All 2 branches missed.">      if (data.get(CRLISSUEINTERVAL) == null) {</span>
<span class="nc" id="L2692">        setCRLIssueInterval(0);</span>
      }
<span class="nc bnc" id="L2694" title="All 2 branches missed.">      if (data.get(CRLOVERLAPTIME) == null) {</span>
        // Default value 10 minutes
        // This used to be setting of 10, as an Integer, but was refactored to a
        // long (ms) in v18-&gt;19,
        // therefore we have to update this to reflect that as well. If's
        // probably not hurting anyone here, it's too old, but right is right.
<span class="nc" id="L2700">        setCRLOverlapTime(10 * SimpleTime.MILLISECONDS_PER_MINUTE);</span>
      }
<span class="nc" id="L2702">      boolean useprintablestring = true;</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">      if (data.get(&quot;alwaysuseutf8subjectdn&quot;) == null) {</span>
        // Default value false
<span class="nc bnc" id="L2705" title="All 2 branches missed.">        if (data.get(USEUTF8POLICYTEXT) == null) {</span>
<span class="nc" id="L2706">          setUseUTF8PolicyText(false);</span>
        }
      } else {
        // Use the same value as we had before when we had
        // alwaysuseutf8subjectdn
<span class="nc" id="L2711">        boolean useutf8 =</span>
<span class="nc" id="L2712">            ((Boolean) data.get(&quot;alwaysuseutf8subjectdn&quot;)).booleanValue();</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">        if (data.get(USEUTF8POLICYTEXT) == null) {</span>
<span class="nc" id="L2714">          setUseUTF8PolicyText(useutf8);</span>
        }
        // If we had checked to use utf8 on an old CA, we do not want to use
        // PrintableString after upgrading
<span class="nc bnc" id="L2718" title="All 2 branches missed.">        useprintablestring = !useutf8;</span>
      }
<span class="nc bnc" id="L2720" title="All 2 branches missed.">      if (data.get(USEPRINTABLESTRINGSUBJECTDN) == null) {</span>
        // Default value true (as before)
<span class="nc" id="L2722">        setUsePrintableStringSubjectDN(useprintablestring);</span>
      }
<span class="nc bnc" id="L2724" title="All 2 branches missed.">      if (data.get(DEFAULTCRLISSUER) == null) {</span>
<span class="nc" id="L2725">        setDefaultCRLIssuer(null);</span>
      }
<span class="nc bnc" id="L2727" title="All 2 branches missed.">      if (data.get(USELDAPDNORDER) == null) {</span>
<span class="nc" id="L2728">        setUseLdapDNOrder(true); // Default value</span>
      }
<span class="nc bnc" id="L2730" title="All 2 branches missed.">      if (data.get(DELTACRLPERIOD) == null) {</span>
<span class="nc" id="L2731">        setDeltaCRLPeriod(0); // v14</span>
      }
<span class="nc bnc" id="L2733" title="All 2 branches missed.">      if (data.get(USECRLDISTRIBUTIONPOINTONCRL) == null) {</span>
<span class="nc" id="L2734">        setUseCrlDistributionPointOnCrl(false); // v15</span>
      }
<span class="nc bnc" id="L2736" title="All 2 branches missed.">      if (data.get(CRLDISTRIBUTIONPOINTONCRLCRITICAL) == null) {</span>
<span class="nc" id="L2737">        setCrlDistributionPointOnCrlCritical(false); // v15</span>
      }
<span class="nc bnc" id="L2739" title="All 2 branches missed.">      if (data.get(INCLUDEINHEALTHCHECK) == null) {</span>
<span class="nc" id="L2740">        setIncludeInHealthCheck(true); // v16</span>
      }
      // v17-&gt;v18 is only an upgrade in order to upgrade CA token
      // v18-&gt;v19
<span class="nc" id="L2744">      Object o = data.get(CRLPERIOD);</span>
<span class="nc bnc" id="L2745" title="All 2 branches missed.">      if (o instanceof Integer) {</span>
<span class="nc" id="L2746">        setCRLPeriod(</span>
<span class="nc" id="L2747">            ((Integer) o).longValue()</span>
                * SimpleTime.MILLISECONDS_PER_HOUR); // h to ms
      }
<span class="nc" id="L2750">      o = data.get(CRLISSUEINTERVAL);</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">      if (o instanceof Integer) {</span>
<span class="nc" id="L2752">        setCRLIssueInterval(</span>
<span class="nc" id="L2753">            ((Integer) o).longValue()</span>
                * SimpleTime.MILLISECONDS_PER_HOUR); // h to ms
      }
<span class="nc" id="L2756">      o = data.get(CRLOVERLAPTIME);</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">      if (o instanceof Integer) {</span>
<span class="nc" id="L2758">        setCRLOverlapTime(</span>
<span class="nc" id="L2759">            ((Integer) o).longValue()</span>
                * SimpleTime.MILLISECONDS_PER_MINUTE); // min to ms
      }
<span class="nc" id="L2762">      o = data.get(DELTACRLPERIOD);</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">      if (o instanceof Integer) {</span>
<span class="nc" id="L2764">        setDeltaCRLPeriod(</span>
<span class="nc" id="L2765">            ((Integer) o).longValue()</span>
                * SimpleTime.MILLISECONDS_PER_HOUR); // h to ms
      }
      // v20, remove XKMS CA service
<span class="nc bnc" id="L2769" title="All 2 branches missed.">      if (data.get(EXTENDEDCASERVICES) != null) {</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2771">        Collection&lt;Integer&gt; types =</span>
<span class="nc" id="L2772">            (Collection&lt;Integer&gt;) data.get(EXTENDEDCASERVICES);</span>
        // Remove type 2, which is XKMS
<span class="nc" id="L2774">        types.remove(Integer.valueOf(2));</span>
<span class="nc" id="L2775">        data.put(EXTENDEDCASERVICES, types);</span>
        // Remove any data if it exists
<span class="nc" id="L2777">        data.remove(EXTENDEDCASERVICE + 2);</span>
      }
<span class="nc bnc" id="L2779" title="All 2 branches missed.">      if (data.get(NAMECHANGED) == null) {</span>
<span class="nc" id="L2780">        setNameChanged(false);</span>
      }
      // v21, AIA: Copy CA issuer URI to separated AIA field.
<span class="nc bnc" id="L2783" title="All 2 branches missed.">      if (data.get(CERTIFICATE_AIA_DEFAULT_CA_ISSUER_URI) == null) {</span>
<span class="nc bnc" id="L2784" title="All 2 branches missed.">        if (null != getAuthorityInformationAccess()) {</span>
<span class="nc" id="L2785">          setCertificateAiaDefaultCaIssuerUri(getAuthorityInformationAccess());</span>
        } else {
<span class="nc" id="L2787">          setCertificateAiaDefaultCaIssuerUri(new ArrayList&lt;String&gt;());</span>
        }
      }
      // v22, 'encodedValidity' is derived by the former long value!
<span class="nc bnc" id="L2791" title="All 4 branches missed.">      if (null == data.get(ENCODED_VALIDITY) &amp;&amp; null != data.get(VALIDITY)) {</span>
<span class="nc" id="L2792">        setEncodedValidity(getEncodedValidity());</span>
      }
      // v23 'keyValidators' new empty list.
<span class="nc bnc" id="L2795" title="All 2 branches missed.">      if (null == data.get(VALIDATORS)) {</span>
<span class="nc" id="L2796">        setValidators(new ArrayList&lt;Integer&gt;());</span>
      }
      // v24 'serial number octet size' assign configured value (or default
      // value if not configured)
<span class="nc bnc" id="L2800" title="All 2 branches missed.">      if (data.get(SERIALNUMBEROCTETSIZE) == null) {</span>
<span class="nc" id="L2801">        setCaSerialNumberOctetSize(</span>
<span class="nc" id="L2802">            CesecoreConfiguration.getSerialNumberOctetSizeForExistingCa());</span>
      }

<span class="nc" id="L2805">      data.put(VERSION, new Float(LATEST_VERSION));</span>
    }
<span class="nc" id="L2807">  }</span>

  /**
   * Method to upgrade new (or existing external caservices) This method needs
   * to be called outside the regular upgrade since the CA isn't instantiated in
   * the regular upgrade.
   */
  @SuppressWarnings({&quot;rawtypes&quot;, &quot;deprecation&quot;})
  @Override
  public boolean upgradeExtendedCAServices() {
<span class="nc" id="L2817">    boolean retval = false;</span>
    // call upgrade, if needed, on installed CA services
<span class="nc" id="L2819">    Collection&lt;Integer&gt; externalServiceTypes = getExternalCAServiceTypes();</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">    if (!CesecoreConfiguration.getCaKeepOcspExtendedService()</span>
<span class="nc bnc" id="L2821" title="All 2 branches missed.">        &amp;&amp; externalServiceTypes.contains(</span>
<span class="nc" id="L2822">            ExtendedCAServiceTypes.TYPE_OCSPEXTENDEDSERVICE)) {</span>
      // This type has been removed, so remove it from any CAs it's been added
      // to as well.
<span class="nc" id="L2825">      externalServiceTypes.remove(</span>
<span class="nc" id="L2826">          ExtendedCAServiceTypes.TYPE_OCSPEXTENDEDSERVICE);</span>
<span class="nc" id="L2827">      data.put(EXTENDEDCASERVICES, externalServiceTypes);</span>
<span class="nc" id="L2828">      retval = true;</span>
    }

<span class="nc bnc" id="L2831" title="All 2 branches missed.">    for (Integer type : externalServiceTypes) {</span>
<span class="nc" id="L2832">      ExtendedCAService service = getExtendedCAService(type);</span>
<span class="nc bnc" id="L2833" title="All 2 branches missed.">      if (service != null) {</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">        if (Float.compare(service.getLatestVersion(), service.getVersion())</span>
            != 0) {
<span class="nc" id="L2836">          retval = true;</span>
<span class="nc" id="L2837">          service.upgrade();</span>
<span class="nc" id="L2838">          setExtendedCAServiceData(</span>
<span class="nc" id="L2839">              service.getExtendedCAServiceInfo().getType(),</span>
<span class="nc" id="L2840">              (HashMap) service.saveData());</span>
<span class="nc bnc" id="L2841" title="All 2 branches missed.">        } else if (service.isUpgraded()) {</span>
          // Also return true if the service was automatically upgraded by a
          // UpgradeableDataHashMap.load, which calls upgrade automagically.
<span class="nc" id="L2844">          retval = true;</span>
<span class="nc" id="L2845">          setExtendedCAServiceData(</span>
<span class="nc" id="L2846">              service.getExtendedCAServiceInfo().getType(),</span>
<span class="nc" id="L2847">              (HashMap) service.saveData());</span>
        }
      } else {
<span class="nc" id="L2850">        LOG.error(</span>
            &quot;Extended service is null, can not upgrade service of type: &quot;
                + type);
      }
<span class="nc" id="L2854">    }</span>
<span class="nc" id="L2855">    return retval;</span>
  }

  /**
   * Encryption method used to encrypt a key pair using a CA.
   *
   * @param cryptoToken the crypto token where the encryption key is
   * @param alias the alias of the key on the crypto token to use for encryption
   * @param keypair the data to encrypt
   * @return encrypted data
   * @throws CryptoTokenOfflineException If crypto token is off-line so
   *     encryption key can not be used.
   */
  public static byte[] encryptKeys(
      final CryptoToken cryptoToken, final String alias, final KeyPair keypair)
      throws CryptoTokenOfflineException {
    try {
<span class="nc" id="L2872">      ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L2873">      ObjectOutputStream os = new ObjectOutputStream(baos);</span>
<span class="nc" id="L2874">      os.writeObject(keypair);</span>
<span class="nc" id="L2875">      CMSEnvelopedDataGenerator edGen = new CMSEnvelopedDataGenerator();</span>
      CMSEnvelopedData ed;
      // Creating the KeyId may just throw an exception, we will log this but
      // store the cert and ignore the error
<span class="nc" id="L2879">      final PublicKey pk = cryptoToken.getPublicKey(alias);</span>
<span class="nc" id="L2880">      byte[] keyId = KeyTools.createSubjectKeyId(pk).getKeyIdentifier();</span>
<span class="nc" id="L2881">      edGen.addRecipientInfoGenerator(</span>
          new JceKeyTransRecipientInfoGenerator(keyId, pk));
<span class="nc" id="L2883">      JceCMSContentEncryptorBuilder jceCMSContentEncryptorBuilder =</span>
          new JceCMSContentEncryptorBuilder(NISTObjectIdentifiers.id_aes256_CBC)
<span class="nc" id="L2885">              .setProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2886">      ed =</span>
<span class="nc" id="L2887">          edGen.generate(</span>
<span class="nc" id="L2888">              new CMSProcessableByteArray(baos.toByteArray()),</span>
<span class="nc" id="L2889">              jceCMSContentEncryptorBuilder.build());</span>
<span class="nc" id="L2890">      LOG.info(</span>
          &quot;Encrypted keys using key alias '&quot;
              + alias
              + &quot;' from Crypto Token &quot;
<span class="nc" id="L2894">              + cryptoToken.getId());</span>
<span class="nc" id="L2895">      return ed.getEncoded();</span>
<span class="nc" id="L2896">    } catch (IOException | CMSException e) {</span>
<span class="nc" id="L2897">      throw new IllegalStateException(</span>
<span class="nc" id="L2898">          &quot;Failed to encrypt keys: &quot; + e.getMessage(), e);</span>
    }
  }

  /**
   * Decryption method used to decrypt a key pair using a CA.
   *
   * @param cryptoToken the crypto token where the decryption key is
   * @param alias the alias of the key on the crypto token to use for decryption
   * @param data the data to decrypt
   * @return a KeyPair
   * @throws CryptoTokenOfflineException If crypto token is off-line so
   *     decryption key can not be used.
   * @throws IOException In case reading/writing data streams failed during
   *     decryption, or parsing decrypted data into KeyPair.
   */
  public static KeyPair decryptKeys(
      final CryptoToken cryptoToken, final String alias, final byte[] data)
      throws IOException, CryptoTokenOfflineException {
    try {
<span class="nc" id="L2918">      CMSEnvelopedData ed = new CMSEnvelopedData(data);</span>
<span class="nc" id="L2919">      RecipientInformationStore recipients = ed.getRecipientInfos();</span>
<span class="nc" id="L2920">      RecipientInformation recipient =</span>
<span class="nc" id="L2921">          recipients.getRecipients().iterator().next();</span>
<span class="nc" id="L2922">      ObjectInputStream ois = null;</span>
<span class="nc" id="L2923">      JceKeyTransEnvelopedRecipient rec =</span>
<span class="nc" id="L2924">          new JceKeyTransEnvelopedRecipient(cryptoToken.getPrivateKey(alias));</span>
<span class="nc" id="L2925">      rec.setProvider(cryptoToken.getEncProviderName());</span>
<span class="nc" id="L2926">      rec.setContentProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
      // Option we must set to prevent Java PKCS#11 provider to try to make the
      // symmetric decryption in the HSM,
      // even though we set content provider to BC. Symm decryption in HSM
      // varies between different HSMs and at least for this case is known
      // to not work in SafeNet Luna (JDK behavior changed in JDK 7_75 where
      // they introduced imho a buggy behavior)
<span class="nc" id="L2933">      rec.setMustProduceEncodableUnwrappedKey(true);</span>
<span class="nc" id="L2934">      byte[] recdata = recipient.getContent(rec);</span>
<span class="nc" id="L2935">      ois = new ObjectInputStream(new ByteArrayInputStream(recdata));</span>
<span class="nc" id="L2936">      LOG.info(</span>
          &quot;Decrypted keys using key alias '&quot;
              + alias
              + &quot;' from Crypto Token &quot;
<span class="nc" id="L2940">              + cryptoToken.getId());</span>
<span class="nc" id="L2941">      return (KeyPair) ois.readObject();</span>
<span class="nc" id="L2942">    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L2943">      throw new IOException(</span>
          &quot;Could not deserialize key pair after decrypting it due to missing&quot;
              + &quot; class: &quot;
<span class="nc" id="L2946">              + e.getMessage(),</span>
          e);
<span class="nc" id="L2948">    } catch (CMSException e) {</span>
<span class="nc" id="L2949">      throw new IOException(</span>
<span class="nc" id="L2950">          &quot;Could not parse encrypted data: &quot; + e.getMessage(), e);</span>
    }
  }

  @Override
  public byte[] decryptData(
      final CryptoToken cryptoToken, final byte[] data, final int cAKeyPurpose)
      throws CMSException, CryptoTokenOfflineException {
<span class="nc" id="L2958">    CMSEnvelopedData ed = new CMSEnvelopedData(data);</span>
<span class="nc" id="L2959">    RecipientInformationStore recipients = ed.getRecipientInfos();</span>
<span class="nc" id="L2960">    RecipientInformation recipient =</span>
<span class="nc" id="L2961">        recipients.getRecipients().iterator().next();</span>
<span class="nc" id="L2962">    final String keyAlias = getCAToken().getAliasFromPurpose(cAKeyPurpose);</span>
<span class="nc" id="L2963">    JceKeyTransEnvelopedRecipient rec =</span>
<span class="nc" id="L2964">        new JceKeyTransEnvelopedRecipient(cryptoToken.getPrivateKey(keyAlias));</span>
<span class="nc" id="L2965">    rec.setProvider(cryptoToken.getSignProviderName());</span>
<span class="nc" id="L2966">    rec.setContentProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
    // Option we must set to prevent Java PKCS#11 provider to try to make the
    // symmetric decryption in the HSM,
    // even though we set content provider to BC. Symm decryption in HSM varies
    // between different HSMs and at least for this case is known
    // to not work in SafeNet Luna (JDK behavior changed in JDK 7_75 where they
    // introduced imho a buggy behavior)
<span class="nc" id="L2973">    rec.setMustProduceEncodableUnwrappedKey(true);</span>
<span class="nc" id="L2974">    byte[] recdata = recipient.getContent(rec);</span>
<span class="nc" id="L2975">    LOG.info(</span>
        &quot;Decrypted data using key alias '&quot;
            + keyAlias
            + &quot;' from Crypto Token &quot;
<span class="nc" id="L2979">            + cryptoToken.getId());</span>
<span class="nc" id="L2980">    return recdata;</span>
  }

  @Override
  public byte[] encryptData(
      final CryptoToken cryptoToken, final byte[] data, final int keyPurpose)
      throws IOException, CMSException, CryptoTokenOfflineException,
          NoSuchAlgorithmException, NoSuchProviderException {
<span class="nc" id="L2988">    CMSEnvelopedDataGenerator edGen = new CMSEnvelopedDataGenerator();</span>
    CMSEnvelopedData ed;
<span class="nc" id="L2990">    final String keyAlias = getCAToken().getAliasFromPurpose(keyPurpose);</span>
<span class="nc" id="L2991">    final PublicKey pk = cryptoToken.getPublicKey(keyAlias);</span>
<span class="nc" id="L2992">    byte[] keyId = KeyTools.createSubjectKeyId(pk).getKeyIdentifier();</span>
<span class="nc" id="L2993">    edGen.addRecipientInfoGenerator(</span>
        new JceKeyTransRecipientInfoGenerator(keyId, pk));
<span class="nc" id="L2995">    JceCMSContentEncryptorBuilder jceCMSContentEncryptorBuilder =</span>
        new JceCMSContentEncryptorBuilder(NISTObjectIdentifiers.id_aes256_CBC)
<span class="nc" id="L2997">            .setProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2998">    ed =</span>
<span class="nc" id="L2999">        edGen.generate(</span>
            new CMSProcessableByteArray(data),
<span class="nc" id="L3001">            jceCMSContentEncryptorBuilder.build());</span>
<span class="nc" id="L3002">    LOG.info(</span>
        &quot;Encrypted data using key alias '&quot;
            + keyAlias
            + &quot;' from Crypto Token &quot;
<span class="nc" id="L3006">            + cryptoToken.getId());</span>
<span class="nc" id="L3007">    return ed.getEncoded();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>