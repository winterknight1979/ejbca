<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CA.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca</a> &gt; <span class="el_source">CA.java</span></div><h1>CA.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca;

import java.io.IOException;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.cert.X509CRLHolder;
import org.bouncycastle.cms.CMSException;
import org.bouncycastle.jce.X509KeyUsage;
import org.bouncycastle.operator.OperatorCreationException;
import org.cesecore.certificates.ca.catoken.CAToken;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAService;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceInfo;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceNotActiveException;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceRequest;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceRequestException;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceResponse;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceTypes;
import org.cesecore.certificates.ca.extendedservices.IllegalExtendedCAServiceRequestException;
import org.cesecore.certificates.certificate.CertificateCreateException;
import org.cesecore.certificates.certificate.IllegalKeyException;
import org.cesecore.certificates.certificate.certextensions.AvailableCustomCertificateExtensionsConfiguration;
import org.cesecore.certificates.certificate.certextensions.CertificateExtensionException;
import org.cesecore.certificates.certificate.request.RequestMessage;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.internal.InternalResources;
import org.cesecore.internal.UpgradeableDataHashMap;
import org.cesecore.keys.token.CryptoToken;
import org.cesecore.keys.token.CryptoTokenOfflineException;
import org.cesecore.util.Base64;
import org.cesecore.util.CertTools;
import org.cesecore.util.StringTools;
import org.cesecore.util.ValidityDate;

/**
 * CA is a base class that should be inherited by all CA types.
 *
 * @version $Id: CA.java 31725 2019-03-07 10:05:50Z tarmo_r_helmes $
 */
public abstract class CA extends UpgradeableDataHashMap
    implements Serializable {

  private static final long serialVersionUID = -8755429830955594642L;

  /** Log4j instance. */
<span class="fc" id="L84">  private static Logger log = Logger.getLogger(CA.class);</span>
  /** Internal localization of logs and errors. */
<span class="fc" id="L86">  private static final InternalResources INTRES =</span>
<span class="fc" id="L87">      InternalResources.getInstance();</span>

  // protected fields.
  /** Type. */
  public static final String CATYPE = &quot;catype&quot;;
  /** DN. */
  protected static final String SUBJECTDN = &quot;subjectdn&quot;;
  /** ID. */
  protected static final String CAID = &quot;caid&quot;;
  /** Name. */
  public static final String NAME = &quot;name&quot;;
  /** Validity. */
  @Deprecated protected static final String VALIDITY = &quot;validity&quot;;
  /** Validity. */
  protected static final String ENCODED_VALIDITY = &quot;encodedvalidity&quot;;
  /** Expiry. */
  protected static final String EXPIRETIME = &quot;expiretime&quot;;
  /** Chain. */
  protected static final String CERTIFICATECHAIN = &quot;certificatechain&quot;;
  /** Chain. */
  protected static final String RENEWEDCERTIFICATECHAIN =
      &quot;renewedcertificatechain&quot;;
  /** Chain. */
  protected static final String ROLLOVERCERTIFICATECHAIN =
      &quot;rollovercertificatechain&quot;;
  /** Token. */
  public static final String CATOKENDATA = &quot;catoken&quot;;
  /** Signer. */
  protected static final String SIGNEDBY = &quot;signedby&quot;;
  /** Desc,. * */
  protected static final String DESCRIPTION = &quot;description&quot;;
  /** Reason. */
  protected static final String REVOCATIONREASON = &quot;revokationreason&quot;;
  /** Date. */
  protected static final String REVOCATIONDATE = &quot;revokationdate&quot;;
  /** ID. */
  protected static final String CERTIFICATEPROFILEID = &quot;certificateprofileid&quot;;
  /** ID. */
  protected static final String DEFAULTCERTIFICATEPROFILEID =
      &quot;defaultcertificateprofileid&quot;;
  /** Period. */
  protected static final String CRLPERIOD = &quot;crlperiod&quot;;
  /** Period. */
  protected static final String DELTACRLPERIOD = &quot;deltacrlperiod&quot;;
  /** Interval. */
  protected static final String CRLISSUEINTERVAL = &quot;crlIssueInterval&quot;;
  /** Overlap. */
  protected static final String CRLOVERLAPTIME = &quot;crlOverlapTime&quot;;
  /** Publishers. */
  protected static final String CRLPUBLISHERS = &quot;crlpublishers&quot;;
  /** Validators. */
  protected static final String VALIDATORS = &quot;keyvalidators&quot;;
  /** Finish. */
  private static final String FINISHUSER = &quot;finishuser&quot;;
  /** Certs. */
  protected static final String REQUESTCERTCHAIN = &quot;requestcertchain&quot;;
  /** Extension. */
  protected static final String EXTENDEDCASERVICES = &quot;extendedcaservices&quot;;
  /** Extension. */
  protected static final String EXTENDEDCASERVICE = &quot;extendedcaservice&quot;;
  /** Data. */
  protected static final String USENOCONFLICTCERTIFICATEDATA =
      &quot;usenoconflictcertificatedata&quot;;
  /** SN size. */
  protected static final String SERIALNUMBEROCTETSIZE = &quot;serialnumberoctetsize&quot;;

  /**
   * @deprecated since 6.8.0, replaced by the approvals Action:ApprovalProfile
   *     mapping
   */
  @Deprecated
  protected static final String APPROVALSETTINGS = &quot;approvalsettings&quot;;
  /**
   * @deprecated since 6.6.0, use the appropriate approval profile instead
   *     Needed order to be able to upgrade from 6.5 and earlier
   */
  @Deprecated
  protected static final String NUMBEROFREQAPPROVALS = &quot;numberofreqapprovals&quot;;
  /**
   * @deprecated since 6.8.0, replaced by the approvals Action:ApprovalProfile
   *     mapping
   */
  @Deprecated protected static final String APPROVALPROFILE = &quot;approvalprofile&quot;;
  /** Health. */
  protected static final String INCLUDEINHEALTHCHECK = &quot;includeinhealthcheck&quot;;
  /** PK. */
  private static final String DO_ENFORCE_UNIQUE_PUBLIC_KEYS =
      &quot;doEnforceUniquePublicKeys&quot;;
  /** DN. */
  private static final String DO_ENFORCE_UNIQUE_DISTINGUISHED_NAME =
      &quot;doEnforceUniqueDistinguishedName&quot;;
  /** SN. */
  private static final String DO_ENFORCE_UNIQUE_SUBJECTDN_SERIALNUMBER =
      &quot;doEnforceUniqueSubjectDNSerialnumber&quot;;
  /** Hoistory. */
  private static final String USE_CERTREQ_HISTORY = &quot;useCertreqHistory&quot;;
  /** Storage. */
  private static final String USE_USER_STORAGE = &quot;useUserStorage&quot;;
  /** Storage. */
  private static final String USE_CERTIFICATE_STORAGE = &quot;useCertificateStorage&quot;;
  /** Nonexisting. */
  private static final String ACCEPT_REVOCATION_NONEXISTING_ENTRY =
      &quot;acceptRevocationNonExistingEntry&quot;;
  /** Latest. */
  private static final String LATESTLINKCERTIFICATE = &quot;latestLinkCertificate&quot;;
  /** Keep. */
  private static final String KEEPEXPIREDCERTSONCRL = &quot;keepExpiredCertsOnCRL&quot;;
  /** Approvals. */
  private static final String APPROVALS = &quot;approvals&quot;;

  /** Map. */
<span class="pc" id="L198">  private HashMap&lt;Integer, ExtendedCAService&gt; extendedcaservicemap =</span>
      new HashMap&lt;&gt;();

  /** Cert chain. */
<span class="pc" id="L202">  private ArrayList&lt;Certificate&gt; certificatechain = null;</span>
  /** Renewed chaon. */
<span class="pc" id="L204">  private ArrayList&lt;Certificate&gt; renewedcertificatechain = null;</span>
  /** Request chain. */
<span class="pc" id="L206">  private ArrayList&lt;Certificate&gt; requestcertchain = null;</span>

  /** Info. */
<span class="pc" id="L209">  private CAInfo cainfo = null;</span>
  /** Token. */
<span class="pc" id="L211">  private CAToken caToken = null;</span>

  /** No args constructor required for ServiceLocator. */
<span class="nc" id="L214">  protected CA() { }</span>

  /**
   * Creates a new instance of CA, this constructor should be used when a new CA
   * is created.
   *
   * @param info Info
   */
<span class="fc" id="L222">  public CA(final CAInfo info) {</span>
<span class="fc" id="L223">    init(info);</span>
<span class="fc" id="L224">  }</span>

  /**
   * Init.
   *
   * @param info Info
   */
  public void init(final CAInfo info) {
<span class="fc" id="L232">    data = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L234">    this.cainfo = info;</span>

<span class="fc" id="L236">    setEncodedValidity(info.getEncodedValidity());</span>
<span class="fc" id="L237">    setSignedBy(info.getSignedBy());</span>
<span class="fc" id="L238">    data.put(DESCRIPTION, info.getDescription());</span>
<span class="fc" id="L239">    data.put(REVOCATIONREASON, Integer.valueOf(-1));</span>
<span class="fc" id="L240">    data.put(</span>
<span class="fc" id="L241">        CERTIFICATEPROFILEID, Integer.valueOf(info.getCertificateProfileId()));</span>
<span class="fc" id="L242">    data.put(</span>
<span class="fc" id="L243">        USENOCONFLICTCERTIFICATEDATA, info.isUseNoConflictCertificateData());</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">    if (!info.isUseCertificateStorage()) {</span>
<span class="nc" id="L245">      data.put(</span>
          DEFAULTCERTIFICATEPROFILEID,
<span class="nc" id="L247">          Integer.valueOf(info.getDefaultCertificateProfileId()));</span>
    }
<span class="fc" id="L249">    setKeepExpiredCertsOnCRL(info.getKeepExpiredCertsOnCRL());</span>
<span class="fc" id="L250">    setCRLPeriod(info.getCRLPeriod());</span>
<span class="fc" id="L251">    setCRLIssueInterval(info.getCRLIssueInterval());</span>
<span class="fc" id="L252">    setCRLOverlapTime(info.getCRLOverlapTime());</span>
<span class="fc" id="L253">    setDeltaCRLPeriod(info.getDeltaCRLPeriod());</span>
<span class="fc" id="L254">    setCRLPublishers(info.getCRLPublishers());</span>
<span class="fc" id="L255">    setValidators(info.getValidators());</span>
<span class="fc" id="L256">    setFinishUser(info.getFinishUser());</span>
<span class="fc" id="L257">    setIncludeInHealthCheck(info.getIncludeInHealthCheck());</span>
<span class="fc" id="L258">    setDoEnforceUniquePublicKeys(info.isDoEnforceUniquePublicKeys());</span>
<span class="fc" id="L259">    setDoEnforceUniqueDistinguishedName(</span>
<span class="fc" id="L260">        info.isDoEnforceUniqueDistinguishedName());</span>
<span class="fc" id="L261">    setDoEnforceUniqueSubjectDNSerialnumber(</span>
<span class="fc" id="L262">        info.isDoEnforceUniqueSubjectDNSerialnumber());</span>
<span class="fc" id="L263">    setUseCertReqHistory(info.isUseCertReqHistory());</span>
<span class="fc" id="L264">    setUseUserStorage(info.isUseUserStorage());</span>
<span class="fc" id="L265">    setUseCertificateStorage(info.isUseCertificateStorage());</span>
<span class="fc" id="L266">    setAcceptRevocationNonExistingEntry(</span>
<span class="fc" id="L267">        info.isAcceptRevocationNonExistingEntry());</span>

<span class="fc" id="L269">    ArrayList&lt;Integer&gt; extendedservicetypes = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">    for (ExtendedCAServiceInfo next : info.getExtendedCAServiceInfos()) {</span>
<span class="nc" id="L271">      createExtendedCAService(next);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      if (log.isDebugEnabled()) {</span>
<span class="nc" id="L273">        log.debug(</span>
            &quot;Adding extended service to CA '&quot;
<span class="nc" id="L275">                + info.getName()</span>
                + &quot;': &quot;
<span class="nc" id="L277">                + next.getType()</span>
                + &quot;, &quot;
<span class="nc" id="L279">                + next.getImplClass());</span>
      }
<span class="nc" id="L281">      extendedservicetypes.add(next.getType());</span>
<span class="nc" id="L282">    }</span>
<span class="fc" id="L283">    data.put(EXTENDEDCASERVICES, extendedservicetypes);</span>
<span class="fc" id="L284">    setApprovals(info.getApprovals());</span>
<span class="fc" id="L285">  }</span>

  private void createExtendedCAService(final ExtendedCAServiceInfo info) {
    // Create implementation using reflection
    try {
<span class="fc" id="L290">      Class&lt;?&gt; implClass = Class.forName(info.getImplClass());</span>
<span class="fc" id="L291">      final ExtendedCAService service =</span>
          (ExtendedCAService)
              implClass
<span class="fc" id="L294">                  .getConstructor(ExtendedCAServiceInfo.class)</span>
<span class="fc" id="L295">                  .newInstance(new Object[] {info});</span>
<span class="fc" id="L296">      setExtendedCAService(service);</span>
<span class="nc" id="L297">    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L298">      log.warn(&quot;failed to add extended CA service: &quot;, e);</span>
<span class="nc" id="L299">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L300">      log.warn(&quot;failed to add extended CA service: &quot;, e);</span>
<span class="nc" id="L301">    } catch (SecurityException e) {</span>
<span class="nc" id="L302">      log.warn(&quot;failed to add extended CA service: &quot;, e);</span>
<span class="nc" id="L303">    } catch (InstantiationException e) {</span>
<span class="nc" id="L304">      log.warn(&quot;failed to add extended CA service: &quot;, e);</span>
<span class="nc" id="L305">    } catch (IllegalAccessException e) {</span>
<span class="nc" id="L306">      log.warn(&quot;failed to add extended CA service: &quot;, e);</span>
<span class="nc" id="L307">    } catch (InvocationTargetException e) {</span>
<span class="nc" id="L308">      log.warn(&quot;failed to add extended CA service: &quot;, e);</span>
<span class="nc" id="L309">    } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L310">      log.warn(&quot;failed to add extended CA service: &quot;, e);</span>
<span class="pc" id="L311">    }</span>
<span class="fc" id="L312">  }</span>

  /**
   * Constructor.
   *
   * @param data Data
   */
<span class="fc" id="L319">  public CA(final HashMap&lt;Object, Object&gt; data) {</span>
<span class="fc" id="L320">    init(data);</span>
<span class="fc" id="L321">  }</span>

  /**
   * Constructor used when retrieving existing CA from database.
   *
   * @param data data
   */
  public void init(final HashMap&lt;Object, Object&gt; data) {
<span class="fc" id="L329">    loadData(data);</span>
<span class="fc" id="L330">    extendedcaservicemap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L331">  }</span>

  /** @param info Info */
  public void setCAInfo(final CAInfo info) {
<span class="fc" id="L335">    this.cainfo = info;</span>
<span class="fc" id="L336">  }</span>

  /** @return Info */
  public CAInfo getCAInfo() {
<span class="fc" id="L340">    return this.cainfo;</span>
  }

  /** @return DN */
  public String getSubjectDN() {
<span class="fc" id="L345">    return cainfo.getSubjectDN();</span>
  }

  /** @param subjectDn DN */
  public void setSubjectDN(final String subjectDn) {
<span class="nc" id="L350">    cainfo.subjectdn = subjectDn;</span>
<span class="nc" id="L351">  }</span>

  /** @return ID */
  public int getCAId() {
<span class="fc" id="L355">    return cainfo.getCAId();</span>
  }

  /** @param caid ID */
  public void setCAId(final int caid) {
<span class="fc" id="L360">    cainfo.caid = caid;</span>
<span class="fc" id="L361">  }</span>

  /** @return Name */
  public String getName() {
<span class="fc" id="L365">    return cainfo.getName();</span>
  }

  /** @param caname Name */
  public void setName(final String caname) {
<span class="nc" id="L370">    cainfo.name = caname;</span>
<span class="nc" id="L371">  }</span>

  /** @return Status */
  public int getStatus() {
<span class="fc" id="L375">    return cainfo.getStatus();</span>
  }

  /** @param status status */
  public void setStatus(final int status) {
<span class="fc" id="L380">    cainfo.status = status;</span>
<span class="fc" id="L381">  }</span>

  /** @return one of CAInfo.CATYPE_CVC or CATYPE_X509 */
  public int getCAType() {
<span class="fc" id="L385">    return ((Integer) data.get(CATYPE)).intValue();</span>
  }

  /** @return validity */
  @Deprecated
  public long getValidity() {
<span class="nc" id="L391">    return ((Number) data.get(VALIDITY)).longValue();</span>
  }

  /**
   * Gets the validity.
   *
   * @return the validity as ISO8601 date or relative time.
   * @see org.cesecore.util.ValidityDate ValidityDate
   */
  @SuppressWarnings(&quot;deprecation&quot;)
  public String getEncodedValidity() {
<span class="fc" id="L402">    String result = (String) data.get(ENCODED_VALIDITY);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">    if (StringUtils.isBlank(result)) {</span>
<span class="nc" id="L404">      result = ValidityDate.getStringBeforeVersion661(getValidity());</span>
    }
<span class="fc" id="L406">    return result;</span>
  }

  /**
   * Sets the validity as relative time (format '*y *mo *d *h *m *s', i.e. '1y
   * +2mo -3d 4h 5m 6s') or as fixed end date (ISO8601 format, i.e. 'yyyy-MM-dd
   * HH:mm:ssZZ', 'yyyy-MM-dd HH:mmZZ' or 'yyyy-MM-ddZZ' with optional '+00:00'
   * appended).
   *
   * @param encodedValidity validity
   */
  public void setEncodedValidity(final String encodedValidity) {
<span class="fc" id="L418">    data.put(ENCODED_VALIDITY, encodedValidity);</span>
<span class="fc" id="L419">  }</span>

  /** @return date */
  public Date getExpireTime() {
<span class="fc" id="L423">    return ((Date) data.get(EXPIRETIME));</span>
  }

  /** @param expiretime date */
  public void setExpireTime(final Date expiretime) {
<span class="fc" id="L428">    data.put(EXPIRETIME, expiretime);</span>
<span class="fc" id="L429">  }</span>

  /** @return signer */
  public int getSignedBy() {
<span class="fc" id="L433">    return ((Integer) data.get(SIGNEDBY)).intValue();</span>
  }

  /** @param signedby signer */
  public void setSignedBy(final int signedby) {
<span class="fc" id="L438">    data.put(SIGNEDBY, Integer.valueOf(signedby));</span>
<span class="fc" id="L439">  }</span>

  /** @return Description */
  public String getDescription() {
<span class="fc" id="L443">    return ((String) data.get(DESCRIPTION));</span>
  }

  /** @param description Description */
  public void setDescription(final String description) {
<span class="nc" id="L448">    data.put(DESCRIPTION, description);</span>
<span class="nc" id="L449">  }</span>

  /** @return reason */
  public int getRevocationReason() {
<span class="fc" id="L453">    return ((Integer) data.get(REVOCATIONREASON)).intValue();</span>
  }

  /** @param reason reason */
  public void setRevocationReason(final int reason) {
<span class="nc" id="L458">    data.put(REVOCATIONREASON, Integer.valueOf(reason));</span>
<span class="nc" id="L459">  }</span>

  /** @return date */
  public Date getRevocationDate() {
<span class="fc" id="L463">    return (Date) data.get(REVOCATIONDATE);</span>
  }

  /** @param date Date */
  public void setRevocationDate(final Date date) {
<span class="nc" id="L468">    data.put(REVOCATIONDATE, date);</span>
<span class="nc" id="L469">  }</span>

  /** @return Period */
  public long getCRLPeriod() {
<span class="fc" id="L473">    return ((Long) data.get(CRLPERIOD)).longValue();</span>
  }

  /** @param crlperiod Period */
  public void setCRLPeriod(final long crlperiod) {
<span class="fc" id="L478">    data.put(CRLPERIOD, Long.valueOf(crlperiod));</span>
<span class="fc" id="L479">  }</span>

  /** @return period */
  public long getDeltaCRLPeriod() {
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (data.containsKey(DELTACRLPERIOD)) {</span>
<span class="fc" id="L484">      return ((Long) data.get(DELTACRLPERIOD)).longValue();</span>
    } else {
<span class="nc" id="L486">      return 0;</span>
    }
  }

  /** @param deltacrlperiod period */
  public void setDeltaCRLPeriod(final long deltacrlperiod) {
<span class="fc" id="L492">    data.put(DELTACRLPERIOD, Long.valueOf(deltacrlperiod));</span>
<span class="fc" id="L493">  }</span>

  /** @return interval */
  public long getCRLIssueInterval() {
<span class="fc" id="L497">    return ((Long) data.get(CRLISSUEINTERVAL)).longValue();</span>
  }
  /** @param crlIssueInterval Interval */
  public void setCRLIssueInterval(final long crlIssueInterval) {
<span class="fc" id="L501">    data.put(CRLISSUEINTERVAL, Long.valueOf(crlIssueInterval));</span>
<span class="fc" id="L502">  }</span>

  /** @return time */
  public long getCRLOverlapTime() {
<span class="fc" id="L506">    return ((Long) data.get(CRLOVERLAPTIME)).longValue();</span>
  }

  /** @param crlOverlapTime Time */
  public void setCRLOverlapTime(final long crlOverlapTime) {
<span class="fc" id="L511">    data.put(CRLOVERLAPTIME, Long.valueOf(crlOverlapTime));</span>
<span class="fc" id="L512">  }</span>

  /** @return Publishers */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Collection&lt;Integer&gt; getCRLPublishers() {
<span class="fc" id="L517">    return ((Collection&lt;Integer&gt;) data.get(CRLPUBLISHERS));</span>
  }

  /** @param crlpublishers Publishers */
  public void setCRLPublishers(final Collection&lt;Integer&gt; crlpublishers) {
<span class="fc" id="L522">    data.put(CRLPUBLISHERS, crlpublishers);</span>
<span class="fc" id="L523">  }</span>

  /** @return Validators */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Collection&lt;Integer&gt; getValidators() {
<span class="fc" id="L528">    return ((Collection&lt;Integer&gt;) data.get(VALIDATORS));</span>
  }

  /** @param validators Validators */
  public void setValidators(final Collection&lt;Integer&gt; validators) {
<span class="fc" id="L533">    data.put(VALIDATORS, validators);</span>
<span class="fc" id="L534">  }</span>

  /** @return boolean */
  public boolean getKeepExpiredCertsOnCRL() {
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">    if (data.containsKey(KEEPEXPIREDCERTSONCRL)) {</span>
<span class="fc" id="L539">      return ((Boolean) data.get(KEEPEXPIREDCERTSONCRL)).booleanValue();</span>
    } else {
<span class="nc" id="L541">      return false;</span>
    }
  }

  /** @param keepexpiredcertsoncrl boolean * */
  public void setKeepExpiredCertsOnCRL(final boolean keepexpiredcertsoncrl) {
<span class="fc" id="L547">    data.put(KEEPEXPIREDCERTSONCRL, Boolean.valueOf(keepexpiredcertsoncrl));</span>
<span class="fc" id="L548">  }</span>

  /** @return Profile ID */
  public int getCertificateProfileId() {
<span class="fc" id="L552">    return ((Integer) data.get(CERTIFICATEPROFILEID)).intValue();</span>
  }

  /** @return profile ID */
  public int getDefaultCertificateProfileId() {
<span class="fc" id="L557">    Integer defaultCertificateProfileId =</span>
<span class="fc" id="L558">        (Integer) data.get(DEFAULTCERTIFICATEPROFILEID);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">    if (defaultCertificateProfileId != null) {</span>
<span class="nc" id="L560">      return defaultCertificateProfileId.intValue();</span>
    } else {
<span class="fc" id="L562">      return 0;</span>
    }
  }

  /** @return the CAs token reference. */
  public CAToken getCAToken() {
<span class="fc bfc" id="L568" title="All 2 branches covered.">    if (caToken == null) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L570">      HashMap&lt;String, String&gt; tokendata =</span>
<span class="fc" id="L571">          (HashMap&lt;String, String&gt;) data.get(CATOKENDATA);</span>
<span class="fc" id="L572">      final CAToken ret = new CAToken(tokendata);</span>
<span class="fc" id="L573">      String signaturealg = tokendata.get(CAToken.SIGNATUREALGORITHM);</span>
<span class="fc" id="L574">      String encryptionalg = tokendata.get(CAToken.ENCRYPTIONALGORITHM);</span>
<span class="fc" id="L575">      String keysequence = CAToken.DEFAULT_KEYSEQUENCE;</span>
<span class="fc" id="L576">      Object seqo = tokendata.get(CAToken.SEQUENCE);</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">      if (seqo != null) {</span>
<span class="fc" id="L578">        keysequence = (String) seqo;</span>
      }
<span class="fc" id="L580">      int keysequenceformat = StringTools.KEY_SEQUENCE_FORMAT_NUMERIC;</span>
<span class="fc" id="L581">      Object seqfo = tokendata.get(CAToken.SEQUENCE_FORMAT);</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">      if (seqfo != null) {</span>
<span class="fc" id="L583">        keysequenceformat = (Integer) seqfo;</span>
      }
      // Set values for new CA token
<span class="fc" id="L586">      ret.setSignatureAlgorithm(signaturealg);</span>
<span class="fc" id="L587">      ret.setEncryptionAlgorithm(encryptionalg);</span>
<span class="fc" id="L588">      ret.setKeySequence(keysequence);</span>
<span class="fc" id="L589">      ret.setKeySequenceFormat(keysequenceformat);</span>
<span class="fc" id="L590">      caToken = ret;</span>
    }
<span class="fc" id="L592">    return caToken;</span>
  }

  /**
   * Sets the CA token.
   *
   * @param catoken token
   * @throws InvalidAlgorithmException if algorithm is not valid
   */
  public void setCAToken(final CAToken catoken)
      throws InvalidAlgorithmException {
    // Check that the signature algorithm is one of the a
    // llowed ones, only check if
    // there is a sigAlg though
    // things like a NulLCryptoToken does not have signature algorithms
<span class="fc" id="L607">    final String sigAlg = catoken.getSignatureAlgorithm();</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">    if (StringUtils.isNotEmpty(sigAlg)) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">      if (!StringTools.containsCaseInsensitive(</span>
          AlgorithmConstants.AVAILABLE_SIGALGS, sigAlg)) {
<span class="fc" id="L611">        final String msg =</span>
<span class="fc" id="L612">            INTRES.getLocalizedMessage(</span>
                &quot;createcert.invalidsignaturealg&quot;,
                sigAlg,
<span class="fc" id="L615">                ArrayUtils.toString(AlgorithmConstants.AVAILABLE_SIGALGS));</span>
<span class="fc" id="L616">        throw new InvalidAlgorithmException(msg);</span>
      }
    }
<span class="fc" id="L619">    final String encAlg = catoken.getEncryptionAlgorithm();</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">    if (StringUtils.isNotEmpty(encAlg)) {</span>
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">      if (!StringTools.containsCaseInsensitive(</span>
          AlgorithmConstants.AVAILABLE_SIGALGS, encAlg)) {
<span class="nc" id="L623">        final String msg =</span>
<span class="nc" id="L624">            INTRES.getLocalizedMessage(</span>
                &quot;createcert.invalidsignaturealg&quot;,
                encAlg,
<span class="nc" id="L627">                ArrayUtils.toString(AlgorithmConstants.AVAILABLE_SIGALGS));</span>
<span class="nc" id="L628">        throw new InvalidAlgorithmException(msg);</span>
      }
    }
<span class="fc" id="L631">    data.put(CATOKENDATA, catoken.saveData());</span>
<span class="fc" id="L632">    this.caToken = catoken;</span>
<span class="fc" id="L633">  }</span>

  /**
   * Returns a collection of CA certificates, or null if no request certificate
   * chain exists.
   *
   * @return certificates
   */
  public Collection&lt;Certificate&gt; getRequestCertificateChain() {
<span class="nc bnc" id="L642" title="All 2 branches missed.">    if (requestcertchain == null) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L644">      final Collection&lt;String&gt; storechain =</span>
<span class="nc" id="L645">          (Collection&lt;String&gt;) data.get(REQUESTCERTCHAIN);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">      if (storechain != null) {</span>
<span class="nc" id="L647">        this.requestcertchain = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        for (final String b64Cert : storechain) {</span>
          try {
<span class="nc" id="L650">            this.requestcertchain.add(</span>
<span class="nc" id="L651">                CertTools.getCertfromByteArray(</span>
<span class="nc" id="L652">                    Base64.decode(b64Cert.getBytes()), Certificate.class));</span>
<span class="nc" id="L653">          } catch (CertificateParsingException e) {</span>
<span class="nc" id="L654">            throw new IllegalStateException(</span>
                &quot;Database seems to contain invalid &quot;
                    + &quot;certificate information.&quot;,
                e);
<span class="nc" id="L658">          }</span>
<span class="nc" id="L659">        }</span>
      }
    }
<span class="nc" id="L662">    return requestcertchain;</span>
  }
  /** @param requestcertificatechain Chain */
  public void setRequestCertificateChain(
      final Collection&lt;Certificate&gt; requestcertificatechain) {
<span class="nc" id="L667">    final ArrayList&lt;String&gt; storechain = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">    for (final Certificate cert : requestcertificatechain) {</span>
      try {
<span class="nc" id="L670">        storechain.add(new String(Base64.encode(cert.getEncoded())));</span>
<span class="nc" id="L671">      } catch (Exception e) {</span>
<span class="nc" id="L672">        throw new RuntimeException(e);</span>
<span class="nc" id="L673">      }</span>
<span class="nc" id="L674">    }</span>
<span class="nc" id="L675">    data.put(REQUESTCERTCHAIN, storechain);</span>
<span class="nc" id="L676">    this.requestcertchain = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L677">    this.requestcertchain.addAll(requestcertificatechain);</span>
<span class="nc" id="L678">  }</span>

  /**
   * Returns a collection of CA-certificates, with this CAs cert i position 0,
   * or null if no CA-certificates exist. The root CA certificate will thus be
   * in the last position.
   *
   * @return Collection of Certificate
   */
  public List&lt;Certificate&gt; getCertificateChain() {
<span class="fc bfc" id="L688" title="All 2 branches covered.">    if (certificatechain == null) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L690">      Collection&lt;String&gt; storechain =</span>
<span class="fc" id="L691">          (Collection&lt;String&gt;) data.get(CERTIFICATECHAIN);</span>
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">      if (storechain == null) {</span>
<span class="nc" id="L693">        return null;</span>
      }
<span class="fc" id="L695">      this.certificatechain = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">      for (final String b64Cert : storechain) {</span>
        try {
<span class="fc" id="L698">          Certificate cert =</span>
<span class="fc" id="L699">              CertTools.getCertfromByteArray(</span>
<span class="fc" id="L700">                  Base64.decode(b64Cert.getBytes()), Certificate.class);</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">          if (cert != null) {</span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L703">              log.debug(</span>
                  &quot;Adding CA certificate from &quot;
                      + &quot;CERTIFICATECHAIN to certificatechain:&quot;);
<span class="nc" id="L706">              log.debug(&quot;Cert subjectDN: &quot; + CertTools.getSubjectDN(cert));</span>
<span class="nc" id="L707">              log.debug(&quot;Cert issuerDN: &quot; + CertTools.getIssuerDN(cert));</span>
            }
<span class="fc" id="L709">            this.certificatechain.add(cert);</span>
          } else {
<span class="nc" id="L711">            throw new IllegalArgumentException(</span>
                &quot;Can not create certificate object from: &quot; + b64Cert);
          }
<span class="nc" id="L714">        } catch (Exception e) {</span>
<span class="nc" id="L715">          throw new IllegalStateException(e);</span>
<span class="fc" id="L716">        }</span>
<span class="fc" id="L717">      }</span>
    }
<span class="fc" id="L719">    return certificatechain;</span>
  }

  /** @param aCertificatechain Chain */
  public void setCertificateChain(final List&lt;Certificate&gt; aCertificatechain) {
<span class="fc" id="L724">    final ArrayList&lt;String&gt; storechain = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">    for (final Certificate cert : aCertificatechain) {</span>
      try {
<span class="fc" id="L727">        storechain.add(new String(Base64.encode(cert.getEncoded())));</span>
<span class="nc" id="L728">      } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L729">        throw new IllegalArgumentException(e);</span>
<span class="fc" id="L730">      }</span>
<span class="fc" id="L731">    }</span>
<span class="fc" id="L732">    data.put(CERTIFICATECHAIN, storechain);</span>
<span class="fc" id="L733">    this.certificatechain = new ArrayList&lt;&gt;(aCertificatechain);</span>
<span class="fc" id="L734">    this.cainfo.setCertificateChain(aCertificatechain);</span>
<span class="fc" id="L735">  }</span>

  /**
   * @return the list of renewed CA certificates in order from the ol dest as
   *     first to the newest as the last one
   */
  public List&lt;Certificate&gt; getRenewedCertificateChain() {
<span class="nc bnc" id="L742" title="All 2 branches missed.">    if (renewedcertificatechain == null) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L744">      Collection&lt;String&gt; storechain =</span>
<span class="nc" id="L745">          (Collection&lt;String&gt;) data.get(RENEWEDCERTIFICATECHAIN);</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">      if (storechain == null) {</span>
<span class="nc" id="L747">        return null;</span>
      }
<span class="nc" id="L749">      renewedcertificatechain = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">      for (final String b64Cert : storechain) {</span>
        try {
<span class="nc" id="L752">          Certificate cert =</span>
<span class="nc" id="L753">              CertTools.getCertfromByteArray(</span>
<span class="nc" id="L754">                  Base64.decode(b64Cert.getBytes()), Certificate.class);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">          if (log.isDebugEnabled()) {</span>
<span class="nc" id="L756">            log.debug(</span>
                &quot;Adding CA certificate from &quot;
                    + &quot;RENEWEDCERTIFICATECHAIN to &quot;
                    + &quot;renewedcertificatechain:&quot;);
<span class="nc" id="L760">            log.debug(&quot;Cert subjectDN: &quot; + CertTools.getSubjectDN(cert));</span>
<span class="nc" id="L761">            log.debug(&quot;Cert issuerDN: &quot; + CertTools.getIssuerDN(cert));</span>
          }
<span class="nc" id="L763">          renewedcertificatechain.add(cert);</span>
<span class="nc" id="L764">        } catch (CertificateParsingException e) {</span>
<span class="nc" id="L765">          throw new IllegalStateException(</span>
              &quot;Some certificates from renewed certificate &quot;
                  + &quot;chain could not be parsed&quot;,
              e);
<span class="nc" id="L769">        }</span>
<span class="nc" id="L770">      }</span>
    }
<span class="nc" id="L772">    return renewedcertificatechain;</span>
  }

  /**
   * Make sure to respect the order of renewed CA certificates in the
   * collection: from the oldest as first to the newest as the last one.
   *
   * @param aCertificatechain collection of the renewed CA certificates to be
   *     stored
   */
  public void setRenewedCertificateChain(
      final List&lt;Certificate&gt; aCertificatechain) {
<span class="nc" id="L784">    ArrayList&lt;String&gt; storechain = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">    for (Certificate cert : aCertificatechain) {</span>
      try {
<span class="nc" id="L787">        String b64Cert = new String(Base64.encode(cert.getEncoded()));</span>
<span class="nc" id="L788">        storechain.add(b64Cert);</span>
<span class="nc" id="L789">      } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L790">        throw new IllegalStateException(</span>
            &quot;Renewed certificates could not be encoded&quot;, e);
<span class="nc" id="L792">      }</span>
<span class="nc" id="L793">    }</span>
<span class="nc" id="L794">    data.put(RENEWEDCERTIFICATECHAIN, storechain);</span>

<span class="nc" id="L796">    renewedcertificatechain = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L797">    renewedcertificatechain.addAll(aCertificatechain);</span>
<span class="nc" id="L798">    cainfo.setRenewedCertificateChain(aCertificatechain);</span>
<span class="nc" id="L799">  }</span>

  /** @param aCertificatechain Certs */
  public void setRolloverCertificateChain(
      final Collection&lt;Certificate&gt; aCertificatechain) {
<span class="nc" id="L804">    Iterator&lt;Certificate&gt; iter = aCertificatechain.iterator();</span>
<span class="nc" id="L805">    ArrayList&lt;String&gt; storechain = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">    while (iter.hasNext()) {</span>
<span class="nc" id="L807">      Certificate cert = iter.next();</span>
      try {
<span class="nc" id="L809">        String b64Cert = new String(Base64.encode(cert.getEncoded()));</span>
<span class="nc" id="L810">        storechain.add(b64Cert);</span>
<span class="nc" id="L811">      } catch (Exception e) {</span>
<span class="nc" id="L812">        throw new RuntimeException(e);</span>
<span class="nc" id="L813">      }</span>
<span class="nc" id="L814">    }</span>
<span class="nc" id="L815">    data.put(ROLLOVERCERTIFICATECHAIN, storechain);</span>
<span class="nc" id="L816">  }</span>

  /** @return Certs */
  public List&lt;Certificate&gt; getRolloverCertificateChain() {
<span class="fc" id="L820">    final List&lt;?&gt; storechain = (List&lt;?&gt;) data.get(ROLLOVERCERTIFICATECHAIN);</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">    if (storechain == null) {</span>
<span class="fc" id="L822">      return null;</span>
    }
<span class="nc" id="L824">    final List&lt;Certificate&gt; chain = new ArrayList&lt;&gt;(storechain.size());</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">    for (Object o : storechain) {</span>
<span class="nc" id="L826">      final String b64Cert = (String) o;</span>
      try {
<span class="nc" id="L828">        final byte[] decoded = Base64.decode(b64Cert.getBytes(&quot;US-ASCII&quot;));</span>
<span class="nc" id="L829">        final Certificate cert =</span>
<span class="nc" id="L830">            CertTools.getCertfromByteArray(decoded, Certificate.class);</span>
<span class="nc" id="L831">        chain.add(cert);</span>
<span class="nc" id="L832">      } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L833">        throw new IllegalStateException(e);</span>
<span class="nc" id="L834">      } catch (CertificateParsingException e) {</span>
<span class="nc" id="L835">        throw new IllegalStateException(e);</span>
<span class="nc" id="L836">      }</span>
<span class="nc" id="L837">    }</span>
<span class="nc" id="L838">    return chain;</span>
  }
  /** remove certs. */
  public void clearRolloverCertificateChain() {
<span class="nc" id="L842">    data.remove(ROLLOVERCERTIFICATECHAIN);</span>
<span class="nc" id="L843">  }</span>

  /** @return the CAs certificate, or null if no CA-certificates exist. */
  public Certificate getCACertificate() {
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">    if (certificatechain == null) {</span>
<span class="nc" id="L848">      getCertificateChain();</span>
      // if it's still null, return null
<span class="nc bnc" id="L850" title="All 2 branches missed.">      if (certificatechain == null) {</span>
<span class="nc" id="L851">        return null;</span>
      }
    }
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">    if (certificatechain.size() == 0) {</span>
<span class="nc" id="L855">      return null;</span>
    }
<span class="fc" id="L857">    Certificate ret = certificatechain.get(0);</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L859">      log.debug(</span>
          &quot;CA certificate chain is &quot;
<span class="nc" id="L861">              + certificatechain.size()</span>
              + &quot; levels deep.&quot;);
<span class="nc" id="L863">      log.debug(&quot;CA-cert subjectDN: &quot; + CertTools.getSubjectDN(ret));</span>
<span class="nc" id="L864">      log.debug(&quot;CA-cert issuerDN: &quot; + CertTools.getIssuerDN(ret));</span>
    }
<span class="fc" id="L866">    return ret;</span>
  }

  /**
   * @param request Request message
   * @return true if we should use the next CA certificate for rollover, instead
   *     of the current CA certificate.
   */
  public boolean getUseNextCACert(final RequestMessage request) {
<span class="fc" id="L875">    final Certificate currentCert = getCACertificate();</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">    if (request == null) {</span>
      // We get here when creating a new CA
<span class="fc" id="L878">      log.trace(</span>
          &quot;getUseNextCACert: request is null. &quot;
              + &quot;most likely this is a new CA&quot;);
<span class="fc" id="L881">      return false;</span>
    }

<span class="fc" id="L884">    final BigInteger requestSerNo = request.getSerialNo();</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">    if (requestSerNo == null) {</span>
<span class="fc" id="L886">      log.debug(</span>
          &quot;getUseNextCACert: No serial number in request. &quot;
              + &quot;Will use current CA cert.&quot;);
<span class="fc" id="L889">      return false;</span>
    }

<span class="nc" id="L892">    final BigInteger currentSerNo = CertTools.getSerialNumber(currentCert);</span>
<span class="nc bnc" id="L893" title="All 4 branches missed.">    if (currentSerNo == null || currentSerNo.equals(requestSerNo)) {</span>
      // Normal case
<span class="nc" id="L895">      log.trace(</span>
          &quot;getUseNextCACert: CA serial number matches &quot;
              + &quot;request serial number&quot;);
<span class="nc" id="L898">      return false;</span>
    }

<span class="nc" id="L901">    final List&lt;Certificate&gt; rolloverChain = getRolloverCertificateChain();</span>
<span class="nc bnc" id="L902" title="All 4 branches missed.">    if (rolloverChain == null || rolloverChain.isEmpty()) {</span>
<span class="nc" id="L903">      log.debug(</span>
          &quot;getUseNextCACert: Serial number in request does not &quot;
              + &quot;match CA serial number, and no roll over certificate &quot;
              + &quot;chain is present. Will use current CA cert.&quot;);
<span class="nc" id="L907">      return false;</span>
    }

<span class="nc" id="L910">    final Certificate rolloverCert = rolloverChain.get(0);</span>
<span class="nc" id="L911">    final BigInteger rolloverSerNo = CertTools.getSerialNumber(rolloverCert);</span>
<span class="nc bnc" id="L912" title="All 4 branches missed.">    if (rolloverSerNo != null &amp;&amp; rolloverSerNo.equals(requestSerNo)) {</span>
<span class="nc" id="L913">      log.debug(</span>
          &quot;getUseNextCACert: Serial number in request matches next &quot;
              + &quot;(rollover) CA cert. Using next CA cert and key.&quot;);
<span class="nc" id="L916">      return true; // this is the only case where we use the next CA cert</span>
    }

<span class="nc" id="L919">    log.debug(</span>
        &quot;getUseNextCACert: Serial number in request does not match&quot;
            + &quot; CA serial number nor next (rollover) CA cert.&quot;
            + &quot; Will use current CA cert.&quot;);
<span class="nc" id="L923">    return false;</span>
  }
  /** @return boolean */
  protected boolean getFinishUser() {
<span class="fc" id="L927">    return getBoolean(FINISHUSER, true);</span>
  }

  private void setFinishUser(final boolean finishuser) {
<span class="fc" id="L931">    putBoolean(FINISHUSER, finishuser);</span>
<span class="fc" id="L932">  }</span>
  /** @return boolean */
  protected boolean getIncludeInHealthCheck() {
<span class="fc" id="L935">    return getBoolean(INCLUDEINHEALTHCHECK, true);</span>
  }
  /** @param includeInHealthCheck boolean */
  protected void setIncludeInHealthCheck(final boolean includeInHealthCheck) {
<span class="fc" id="L939">    putBoolean(INCLUDEINHEALTHCHECK, includeInHealthCheck);</span>
<span class="fc" id="L940">  }</span>
  /** @return boolean */
  public boolean isDoEnforceUniquePublicKeys() {
<span class="fc" id="L943">    return getBoolean(DO_ENFORCE_UNIQUE_PUBLIC_KEYS, false);</span>
  }

  private void setDoEnforceUniquePublicKeys(
      final boolean doEnforceUniquePublicKeys) {
<span class="fc" id="L948">    putBoolean(DO_ENFORCE_UNIQUE_PUBLIC_KEYS, doEnforceUniquePublicKeys);</span>
<span class="fc" id="L949">  }</span>
  /** @return boolean */
  public boolean isDoEnforceUniqueDistinguishedName() {
<span class="fc" id="L952">    return getBoolean(DO_ENFORCE_UNIQUE_DISTINGUISHED_NAME, false);</span>
  }

  private void setDoEnforceUniqueDistinguishedName(
      final boolean doEnforceUniqueDistinguishedName) {
<span class="fc" id="L957">    putBoolean(</span>
        DO_ENFORCE_UNIQUE_DISTINGUISHED_NAME, doEnforceUniqueDistinguishedName);
<span class="fc" id="L959">  }</span>

  /** @return boolean */
  public boolean isDoEnforceUniqueSubjectDNSerialnumber() {
<span class="fc" id="L963">    return getBoolean(DO_ENFORCE_UNIQUE_SUBJECTDN_SERIALNUMBER, false);</span>
  }

  private void setDoEnforceUniqueSubjectDNSerialnumber(
      final boolean doEnforceUniqueSubjectDNSerialnumber) {
<span class="fc" id="L968">    putBoolean(</span>
        DO_ENFORCE_UNIQUE_SUBJECTDN_SERIALNUMBER,
        doEnforceUniqueSubjectDNSerialnumber);
<span class="fc" id="L971">  }</span>

  /**
   * Whether certificate request history should be used or not. The default
   * value here is used when the value is missing in the database, and is true
   * for compatibility with old CAs since it was not configurable and always
   * enabled before 3.10.4. For new CAs the default value is set in the web or
   * CLI code and is false since 6.0.0.
   *
   * @return true/false
   */
  public boolean isUseCertReqHistory() {
<span class="fc" id="L983">    return getBoolean(USE_CERTREQ_HISTORY, true);</span>
  }

  private void setUseCertReqHistory(final boolean useCertReqHistory) {
<span class="fc" id="L987">    putBoolean(USE_CERTREQ_HISTORY, useCertReqHistory);</span>
<span class="fc" id="L988">  }</span>

  /**
   * @return whether users should be stored or not, default true as was the case
   *     before 3.10.x
   */
  public boolean isUseUserStorage() {
<span class="fc" id="L995">    return getBoolean(USE_USER_STORAGE, true);</span>
  }

  private void setUseUserStorage(final boolean useUserStorage) {
<span class="fc" id="L999">    putBoolean(USE_USER_STORAGE, useUserStorage);</span>
<span class="fc" id="L1000">  }</span>

  /**
   * @return whether issued certificates should be stored or not, default true
   *     as was the case before 3.10.x
   */
  public boolean isUseCertificateStorage() {
<span class="fc" id="L1007">    return getBoolean(USE_CERTIFICATE_STORAGE, true);</span>
  }

  private void setUseCertificateStorage(final boolean useCertificateStorage) {
<span class="fc" id="L1011">    putBoolean(USE_CERTIFICATE_STORAGE, useCertificateStorage);</span>
<span class="fc" id="L1012">  }</span>

  private void setAcceptRevocationNonExistingEntry(
      final boolean acceptRevocationNonExistingEntry) {
<span class="fc" id="L1016">    putBoolean(</span>
        ACCEPT_REVOCATION_NONEXISTING_ENTRY, acceptRevocationNonExistingEntry);
<span class="fc" id="L1018">  }</span>

  /** @return whether revocations for non existing entry accepted */
  public boolean isAcceptRevocationNonExistingEntry() {
<span class="fc" id="L1022">    return getBoolean(ACCEPT_REVOCATION_NONEXISTING_ENTRY, false);</span>
  }

  /** @return A 1:1 mapping between Approval Action:Approval Profile ID */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Map&lt;ApprovalRequestType, Integer&gt; getApprovals() {
<span class="fc" id="L1028">    return (Map&lt;ApprovalRequestType, Integer&gt;) data.get(APPROVALS);</span>
  }

  /**
   * Set approvals.
   *
   * @param approvals Approvals
   */
  public void setApprovals(final Map&lt;ApprovalRequestType, Integer&gt; approvals) {
    // We must store this as a predictable order map in the database,
    // in order for
    // databaseprotection to work
<span class="fc" id="L1040">    data.put(</span>
        APPROVALS,
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">        approvals != null</span>
<span class="fc" id="L1043">            ? new LinkedHashMap&lt;&gt;(approvals)</span>
<span class="nc" id="L1044">            : new LinkedHashMap&lt;&gt;());</span>
<span class="fc" id="L1045">  }</span>

  /**
   * @return a collection of Integers (CAInfo.REQ_APPROVAL_ constants) of which
   *     action that requires approvals, default none and never null.
   * @deprecated since 6.8.0, see getApprovals()
   */
  @Deprecated
  @SuppressWarnings(&quot;unchecked&quot;)
  public Collection&lt;Integer&gt; getApprovalSettings() {
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">    if (data.get(APPROVALSETTINGS) == null) {</span>
<span class="fc" id="L1056">      return new ArrayList&lt;&gt;();</span>
    }
<span class="nc" id="L1058">    return (Collection&lt;Integer&gt;) data.get(APPROVALSETTINGS);</span>
  }

  /**
   * Collection of Integers (CAInfo.REQ_APPROVAL_ constants) of which action
   * that requires approvals.
   *
   * @param approvalSettings settings
   * @deprecated since 6.8.0, see setApprovals()
   */
  @Deprecated
  public void setApprovalSettings(final Collection&lt;Integer&gt; approvalSettings) {
<span class="nc" id="L1070">    data.put(APPROVALSETTINGS, approvalSettings);</span>
<span class="nc" id="L1071">  }</span>

  /**
   * @return the number of different administrators that needs to approve an
   *     action, default 1.
   * @deprecated since 6.6.0, use the appropriate approval profile instead.
   *     Needed in order to be able to upgrade from 6.5 and earlier
   */
  @Deprecated
  public int getNumOfRequiredApprovals() {
<span class="nc bnc" id="L1081" title="All 2 branches missed.">    if (data.get(NUMBEROFREQAPPROVALS) == null) {</span>
<span class="nc" id="L1082">      return 1;</span>
    }
<span class="nc" id="L1084">    return ((Integer) data.get(NUMBEROFREQAPPROVALS)).intValue();</span>
  }

  /**
   * The number of different administrators that needs to approve.
   *
   * @param numOfReqApprovals # of approvals
   * @deprecated since 6.6.0, use the appropriate approval profile instead.
   *     Needed in order to be able to upgrade from 6.5 and earlier
   */
  @Deprecated
  public void setNumOfRequiredApprovals(final int numOfReqApprovals) {
<span class="nc" id="L1096">    data.put(NUMBEROFREQAPPROVALS, Integer.valueOf(numOfReqApprovals));</span>
<span class="nc" id="L1097">  }</span>

  /**
   * @return the id of the approval profile. Defult -1 (= none)
   * @deprecated since 6.8.0, see getApprovals()
   */
  @Deprecated
  public int getApprovalProfile() {
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">    if (data.get(APPROVALPROFILE) == null) {</span>
<span class="fc" id="L1106">      return -1;</span>
    }
<span class="nc" id="L1108">    return ((Integer) data.get(APPROVALPROFILE)).intValue();</span>
  }

  /**
   * The id of the approval profile.
   *
   * @param approvalProfileID ID
   * @deprecated since 6.8.0, see setApprovals()
   */
  @Deprecated
  public void setApprovalProfile(final int approvalProfileID) {
<span class="nc" id="L1119">    data.put(APPROVALPROFILE, Integer.valueOf(approvalProfileID));</span>
<span class="nc" id="L1120">  }</span>

  /**
   * Update CA.
   *
   * @param cryptoToken Crypto Token
   * @param aCainfo CA Info
   * @param cceConfig Config
   * @throws InvalidAlgorithmException Fail
   */
  public void updateCA(
      final CryptoToken cryptoToken,
      final CAInfo aCainfo,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws InvalidAlgorithmException {
<span class="fc" id="L1135">    setEncodedValidity(aCainfo.getEncodedValidity());</span>
<span class="fc" id="L1136">    data.put(DESCRIPTION, aCainfo.getDescription());</span>
<span class="fc" id="L1137">    data.put(CRLPERIOD, Long.valueOf(aCainfo.getCRLPeriod()));</span>
<span class="fc" id="L1138">    data.put(DELTACRLPERIOD, Long.valueOf(aCainfo.getDeltaCRLPeriod()));</span>
<span class="fc" id="L1139">    data.put(CRLISSUEINTERVAL, Long.valueOf(aCainfo.getCRLIssueInterval()));</span>
<span class="fc" id="L1140">    data.put(CRLOVERLAPTIME, Long.valueOf(aCainfo.getCRLOverlapTime()));</span>
<span class="fc" id="L1141">    data.put(CRLPUBLISHERS, aCainfo.getCRLPublishers());</span>
<span class="fc" id="L1142">    data.put(VALIDATORS, aCainfo.getValidators());</span>
<span class="fc" id="L1143">    data.put(APPROVALS, aCainfo.getApprovals());</span>
<span class="fc" id="L1144">    data.put(</span>
<span class="fc" id="L1145">        USENOCONFLICTCERTIFICATEDATA, aCainfo.isUseNoConflictCertificateData());</span>
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">    if (aCainfo.getCertificateProfileId() &gt; 0) {</span>
<span class="fc" id="L1147">      data.put(</span>
          CERTIFICATEPROFILEID,
<span class="fc" id="L1149">          Integer.valueOf(aCainfo.getCertificateProfileId()));</span>
    }
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">    if (aCainfo.getDefaultCertificateProfileId() &gt; 0</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        &amp;&amp; !aCainfo.isUseCertificateStorage()) {</span>
<span class="nc" id="L1153">      data.put(</span>
          DEFAULTCERTIFICATEPROFILEID,
<span class="nc" id="L1155">          Integer.valueOf(aCainfo.getDefaultCertificateProfileId()));</span>
    }
<span class="fc" id="L1157">    setKeepExpiredCertsOnCRL(aCainfo.getKeepExpiredCertsOnCRL());</span>

<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">    if (aCainfo.getCAToken() != null) {</span>
<span class="fc" id="L1160">      setCAToken(aCainfo.getCAToken());</span>
    }
<span class="fc" id="L1162">    setFinishUser(aCainfo.getFinishUser());</span>
<span class="fc" id="L1163">    setIncludeInHealthCheck(aCainfo.getIncludeInHealthCheck());</span>
<span class="fc" id="L1164">    setDoEnforceUniquePublicKeys(aCainfo.isDoEnforceUniquePublicKeys());</span>
<span class="fc" id="L1165">    setDoEnforceUniqueDistinguishedName(</span>
<span class="fc" id="L1166">        aCainfo.isDoEnforceUniqueDistinguishedName());</span>
<span class="fc" id="L1167">    setDoEnforceUniqueSubjectDNSerialnumber(</span>
<span class="fc" id="L1168">        aCainfo.isDoEnforceUniqueSubjectDNSerialnumber());</span>
<span class="fc" id="L1169">    setUseCertReqHistory(aCainfo.isUseCertReqHistory());</span>
<span class="fc" id="L1170">    setUseUserStorage(aCainfo.isUseUserStorage());</span>
<span class="fc" id="L1171">    setUseCertificateStorage(aCainfo.isUseCertificateStorage());</span>
<span class="fc" id="L1172">    setAcceptRevocationNonExistingEntry(</span>
<span class="fc" id="L1173">        aCainfo.isAcceptRevocationNonExistingEntry());</span>
<span class="fc" id="L1174">    List&lt;Certificate&gt; newcerts = aCainfo.getCertificateChain();</span>
<span class="pc bpc" id="L1175" title="2 of 4 branches missed.">    if ((newcerts != null) &amp;&amp; (newcerts.size() &gt; 0)) {</span>
<span class="fc" id="L1176">      setCertificateChain(newcerts);</span>
<span class="fc" id="L1177">      Certificate cacert = newcerts.iterator().next();</span>
<span class="fc" id="L1178">      setExpireTime(CertTools.getNotAfter(cacert));</span>
    }
    // Update or create extended CA services
<span class="fc" id="L1181">    final Collection&lt;ExtendedCAServiceInfo&gt; infos =</span>
<span class="fc" id="L1182">        aCainfo.getExtendedCAServiceInfos();</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">    if (infos != null) {</span>
<span class="fc" id="L1184">      final Collection&lt;ExtendedCAServiceInfo&gt; newInfos = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1185">      Collection&lt;Integer&gt; extendedservicetypes =</span>
<span class="fc" id="L1186">          getExternalCAServiceTypes(); // Se we can add things to this</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">      for (ExtendedCAServiceInfo info : infos) {</span>
<span class="fc" id="L1188">        ExtendedCAService service = this.getExtendedCAService(info.getType());</span>
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">        if (service == null) {</span>
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">          if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1191">            log.debug(</span>
<span class="nc" id="L1192">                &quot;Creating new extended CA service of type: &quot; + info.getType());</span>
          }
<span class="fc" id="L1194">          createExtendedCAService(info);</span>
<span class="fc" id="L1195">          extendedservicetypes.add(info.getType());</span>
<span class="fc" id="L1196">          newInfos.add(info);</span>
        } else {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">          if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1199">            log.debug(</span>
<span class="nc" id="L1200">                &quot;Updating extended CA service of type: &quot; + info.getType());</span>
          }
<span class="nc" id="L1202">          service.update(cryptoToken, info, this, cceConfig);</span>
          // the service's signing certificate might get
          // created at this point!
<span class="nc" id="L1205">          setExtendedCAService(service);</span>

          // Now read back the info object from the service.
          // This is necessary because the service's
          // signing certificate is
          // &quot;lazy-created&quot;,
          // i.e. created when the service becomes active
          // the first time.
<span class="nc" id="L1213">          final ExtendedCAServiceInfo newInfo =</span>
<span class="nc" id="L1214">              service.getExtendedCAServiceInfo();</span>
<span class="nc" id="L1215">          newInfos.add(newInfo);</span>
        }
<span class="fc" id="L1217">      }</span>
<span class="fc" id="L1218">      aCainfo.setExtendedCAServiceInfos(newInfos);</span>
<span class="fc" id="L1219">      data.put(EXTENDEDCASERVICES, extendedservicetypes);</span>
    }

<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">    if (aCainfo.getStatus() == CAConstants.CA_UNINITIALIZED) {</span>
<span class="nc" id="L1223">      updateUninitializedCA(aCainfo);</span>
    }

<span class="fc" id="L1226">    this.cainfo = aCainfo;</span>
<span class="fc" id="L1227">  }</span>

  /**
   * Called when an uninitialized CA is updated, either from updateCA or from
   * other places in the code.
   *
   * &lt;p&gt;A few more values are also set in the overridden method in X509CA.
   *
   * @param aCainfo Info
   */
  public void updateUninitializedCA(final CAInfo aCainfo) {
<span class="nc" id="L1238">    setSignedBy(aCainfo.getSignedBy());</span>
<span class="nc" id="L1239">  }</span>

  /**
   * @param cryptoToken Token
   * @param publicKey provided public key. Will not have any precedence over
   *     subject.extendedInformation.certificateRequest
   * @param subject end entity information. If it contains certificateRequest
   *     under extendedInformation, it will be used instead of the provided
   *     RequestMessage and publicKey
   * @param onotBefore null or a custom date to use as notBefore date
   * @param keyusage BouncyCastle key usage {@link X509KeyUsage}, e.g.
   *     X509KeyUsage.digitalSignature | X509KeyUsage.keyEncipherment
   * @param encodedValidity requested validity as SimpleTime string or ISO8601
   *     date string (see ValidityDate.java).
   * @param certProfile Profile
   * @param sequence an optional requested sequence number (serial number) for
   *     the certificate, may or may not be used by the CA. Currently used by
   *     CVC CAs for sequence field. Can be set to null.
   * @param cceConfig containing a list of available custom certificate
   *     extensions
   * @return The newly created certificate
   * @throws Exception On error
   */
  public Certificate generateCertificate(
      final CryptoToken cryptoToken,
      final EndEntityInformation subject,
      final PublicKey publicKey,
      final int keyusage,
      final  Date onotBefore,
      final String encodedValidity,
      final CertificateProfile certProfile,
      final String sequence,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws Exception {

    // Calculate the notAfter date
    Date notBefore;
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">    if (onotBefore == null) {</span>
<span class="fc" id="L1277">      notBefore = new Date();</span>
    } else {
<span class="nc" id="L1279">        notBefore = onotBefore;</span>
    }
    final Date notAfter;
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">    if (StringUtils.isNotBlank(encodedValidity)) {</span>
<span class="fc" id="L1283">      notAfter = ValidityDate.getDate(encodedValidity, notBefore);</span>
    } else {
<span class="nc" id="L1285">      notAfter = null;</span>
    }
<span class="fc" id="L1287">    return generateCertificate(</span>
        cryptoToken,
        subject,
        null,
        publicKey,
        keyusage,
        notBefore,
        notAfter,
        certProfile,
        null,
        sequence,
        null,
        cceConfig);
  }

  /**
   * @param cryptoToken Token
   * @param request provided request message containing optional information,
   *     and will be set with the signing key and provider. If the certificate
   *     profile allows subject DN override this value will be used instead of
   *     the value from subject.getDN. Its public key is going to be used if
   *     publicKey == null &amp;amp;&amp;amp;
   *     subject.extendedInformation.certificateRequest == null. Can be null.
   * @param publicKey provided public key which will have precedence over public
   *     key from the provided RequestMessage but not over
   *     subject.extendedInformation.certificateRequest
   * @param subject end entity information. If it contains certificateRequest
   *     under extendedInformation, it will be used instead of the provided
   *     RequestMessage and publicKey
   * @param keyusage BouncyCastle key usage {@link X509KeyUsage}, e.g.
   *     X509KeyUsage.digitalSignature | X509KeyUsage.keyEncipherment
   * @param notBefore Start date
   * @param notAfter End date
   * @param certProfile Profile
   * @param extensions an optional set of extensions to set in the created
   *     certificate, if the profile allows extension override, null if the
   *     profile default extensions should be used.
   * @param sequence an optional requested sequence number (serial number) for
   *     the certificate, may or may not be used by the CA. Currently used by
   *     CVC CAs for sequence field. Can be set to null.
   * @param certGenParams Extra parameters for certificate generation, e.g. for
   *     the CT extension. May contain references to session beans.
   * @param cceConfig containing a list of available custom certificate
   *     extensions
   * @return the generated certificate
   * @throws CryptoTokenOfflineException if the crypto token was unavailable
   * @throws CertificateExtensionException if any of the certificate extensions
   *     were invalid
   * @throws CertificateCreateException if an error occurred when trying to
   *     create a certificate.
   * @throws OperatorCreationException if CA's private key contained an unknown
   *     algorithm or provider
   * @throws IllegalNameException if the name specified in the certificate
   *     request contains illegal characters
   * @throws IllegalValidityException if validity was invalid
   * @throws InvalidAlgorithmException if the signing algorithm in the
   *     certificate profile (or the CA Token if not found) was invalid.
   * @throws CAOfflineException if the CA wasn't active
   * @throws SignatureException if the CA's certificate's and request's
   *     certificate's and signature algorithms differ
   * @throws IllegalKeyException if the using public key is not allowed to be
   *     used by specified certProfile
   */
  public abstract Certificate generateCertificate(
      CryptoToken cryptoToken,
      EndEntityInformation subject,
      RequestMessage request,
      PublicKey publicKey,
      int keyusage,
      Date notBefore,
      Date notAfter,
      CertificateProfile certProfile,
      Extensions extensions,
      String sequence,
      CertificateGenerationParams certGenParams,
      AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws CryptoTokenOfflineException, CAOfflineException,
          InvalidAlgorithmException, IllegalValidityException,
          IllegalNameException, OperatorCreationException,
          CertificateCreateException, CertificateExtensionException,
          SignatureException, IllegalKeyException;

  /**
   * @param cryptoToken Token
   * @param request provided request message containing optional information,
   *     and will be set with the signing key and provider. If the certificate
   *     profile allows subject DN override this value will be used instead of
   *     the value from subject.getDN. Its public key is going to be used if
   *     publicKey == null &amp;amp;&amp;amp;
   *     subject.extendedInformation.certificateRequest == null. Can be null.
   * @param publicKey provided public key which will have precedence over public
   *     key from the provided RequestMessage but not over
   *     subject.extendedInformation.certificateRequest
   * @param subject end entity information. If it contains certificateRequest
   *     under extendedInformation, it will be used instead of the provided
   *     RequestMessage and publicKey
   * @param keyusage BouncyCastle key usage {@link X509KeyUsage}, e.g.
   *     X509KeyUsage.digitalSignature | X509KeyUsage.keyEncipherment
   * @param notBefore Start date
   * @param notAfter End date
   * @param certProfile Profile
   * @param extensions an optional set of extensions to set in the created
   *     certificate, if the profile allows extension override, null if the
   *     profile default extensions should be used.
   * @param sequence an optional requested sequence number (serial number) for
   *     the certificate, may or may not be used by the CA. Currently used by
   *     CVC CAs for sequence field. Can be set to null.
   * @param cceConfig containing a list of available custom certificate
   *     extensions
   * @return the generated certificate
   * @throws CryptoTokenOfflineException if the crypto token was unavailable
   * @throws CertificateExtensionException if any of the certificate extensions
   *     were invalid
   * @throws CertificateCreateException if an error occurred when trying to
   *     create a certificate.
   * @throws OperatorCreationException if CA's private key contained an unknown
   *     algorithm or provider
   * @throws IllegalNameException if the name specified in the certificate
   *     request contains illegal characters
   * @throws IllegalValidityException if validity was invalid
   * @throws InvalidAlgorithmException if the signing algorithm in the
   *     certificate profile (or the CA Token if not found) was invalid.
   * @throws CAOfflineException if the CA wasn't active
   * @throws SignatureException if the CA's certificate's and request's
   *     certificate's and signature algorithms differ
   * @throws IllegalKeyException if the using public key is not allowed to be
   *     used by specified certProfile
   */
  public final Certificate generateCertificate(
      final CryptoToken cryptoToken,
      final EndEntityInformation subject,
      final RequestMessage request,
      final PublicKey publicKey,
      final int keyusage,
      final Date notBefore,
      final Date notAfter,
      final CertificateProfile certProfile,
      final Extensions extensions,
      final String sequence,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws CryptoTokenOfflineException, CAOfflineException,
          InvalidAlgorithmException, IllegalValidityException,
          IllegalNameException, OperatorCreationException,
          CertificateCreateException, CertificateExtensionException,
          SignatureException, IllegalKeyException {
<span class="fc" id="L1432">    return generateCertificate(</span>
        cryptoToken,
        subject,
        request,
        publicKey,
        keyusage,
        notBefore,
        notAfter,
        certProfile,
        extensions,
        sequence,
        null,
        cceConfig);
  }

  /**
   * CRL holder .
   *
   * @param cryptoToken Token
   * @param certs Certificates
   * @param crlnumber CRl number
   * @return CRL holder
   * @throws Exception Fail
   */
  public abstract X509CRLHolder generateCRL(
      CryptoToken cryptoToken, Collection&lt;RevokedCertInfo&gt; certs, int crlnumber)
      throws Exception;

  /**
   * CRL holder .
   *
   * @param cryptoToken Token
   * @param certs Certificates
   * @param crlnumber CRl number
   * @param basecrlnumber Base CRL
   * @return CRL holder
   * @throws Exception Fail
   */
  public abstract X509CRLHolder generateDeltaCRL(
      CryptoToken cryptoToken,
      Collection&lt;RevokedCertInfo&gt; certs,
      int crlnumber,
      int basecrlnumber)
      throws Exception;

  /**
   * Create a signed PKCS#7 / CMS message.
   *
   * @param cryptoToken Token
   * @param cert Certificate
   * @param includeChain True to include all certs
   * @return A DER-encoded PKCS#7
   * @throws SignRequestSignatureException if the certificate doesn't seem to be
   *     signed by this CA
   * @see CertTools#createCertsOnlyCMS(List) for how to craete a certs-only
   *     PKCS7/CMS
   */
  public abstract byte[] createPKCS7(
      CryptoToken cryptoToken, X509Certificate cert, boolean includeChain)
      throws SignRequestSignatureException;

  /**
   * Creates a roll over PKCS7 for the next CA certificate, signed with the
   * current CA key. Used by ScepServlet.
   *
   * @param cryptoToken Token
   * @return Encoded signed certificate chain, suitable for use in SCEP.
   * @throws SignRequestSignatureException if the certificate doesn't seem to be
   *     signed by this CA
   */
  public abstract byte[] createPKCS7Rollover(CryptoToken cryptoToken)
      throws SignRequestSignatureException;

  /**
   * Creates a certificate signature request (CSR), that can be sent to an
   * external Root CA. Request format can vary depending on the type of CA. For
   * X509 CAs PKCS#10 requests are created, for CVC CAs CVC requests are
   * created.
   *
   * @param cryptoToken Token
   * @param attributes PKCS10 attributes to be included in the request, a
   *     Collection of ASN1Encodable objects, ready to put in the request. Can
   *     be null.
   * @param signAlg the signature algorithm used by the CA
   * @param cacert the CAcertficate the request is targeted for, may be used or
   *     ignored by implementation depending on the request type created.
   * @param signatureKeyPurpose which CA token key pair should be used to create
   *     the request, normally SecConst.CAKEYPURPOSE_CERTSIGN but can also be
   *     SecConst.CAKEYPURPOSE_CERTSIGN_NEXT.
   * @param certificateProfile Certificate profile to use for CA-type specific
   *     purposes, such as CV Certificate Extensions.
   * @param cceConfig containing a list of available custom certificate
   *     extensions
   * @return byte array with binary encoded request
   * @throws CryptoTokenOfflineException if the crypto token is offline
   * @throws CertificateExtensionException if there was a problem constructing a
   *     certificate extension.
   */
  public abstract byte[] createRequest(
      CryptoToken cryptoToken,
      Collection&lt;ASN1Encodable&gt; attributes,
      String signAlg,
      Certificate cacert,
      int signatureKeyPurpose,
      CertificateProfile certificateProfile,
      AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws CryptoTokenOfflineException, CertificateExtensionException;

  /**
   * Signing request.
   *
   * @param cryptoToken Crypyo token
   * @param request requet
   * @return Request as byte array
   * @throws CryptoTokenOfflineException On errror
   */
  public abstract byte[] createAuthCertSignRequest(
      CryptoToken cryptoToken, byte[] request)
      throws CryptoTokenOfflineException;

  /**
   * General encryption method used to encrypt using a CA.
   *
   * @param cryptoToken token
   * @param data the data to encrypt
   * @param keyPurpose should be one of the SecConst.CAKEYPURPOSE_ constants
   * @return encrypted data
   * @throws CryptoTokenOfflineException If crypto token is off-line so
   *     encryption key can not be used.
   * @throws CMSException In case parsing/encryption of CMS data fails.
   * @throws NoSuchProviderException If encryption provider is not available.
   * @throws NoSuchAlgorithmException If desired encryption algorithm is not
   *     available.
   * @throws IOException In case reading/writing data streams failed during
   *     encryption
   */
  public abstract byte[] encryptData(
      CryptoToken cryptoToken, byte[] data, int keyPurpose)
      throws CryptoTokenOfflineException, NoSuchAlgorithmException,
          NoSuchProviderException, CMSException, IOException;

  /**
   * General encryption method used to decrypt using a CA.
   *
   * @param cryptoToken Token
   * @param data the data to decrypt
   * @param cAKeyPurpose should be one of the SecConst.CAKEYPURPOSE_ constants
   * @return decrypted data
   * @throws CMSException In case parsing/decryption of CMS data fails.
   * @throws CryptoTokenOfflineException If crypto token is off-line so
   *     decryption key can not be used.
   */
  public abstract byte[] decryptData(
      CryptoToken cryptoToken, byte[] data, int cAKeyPurpose)
      throws CMSException, CryptoTokenOfflineException;

  // Methods used with extended services
  /**
   * Initializes the ExtendedCAService.
   *
   * @param cryptoToken the cryptotoken used to initiate the service
   * @param type the type of the extended key service
   * @param ca the CA used to initiate the service
   * @param cceConfig containing a list of available custom certificate
   *     extensions
   * @throws Exception On error
   */
  public void initExtendedService(
      final CryptoToken cryptoToken,
      final int type,
      final CA ca,
      final AvailableCustomCertificateExtensionsConfiguration cceConfig)
      throws Exception {
<span class="nc" id="L1605">    ExtendedCAService service = getExtendedCAService(type);</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">    if (service != null) {</span>
<span class="nc" id="L1607">      service.init(cryptoToken, ca, cceConfig);</span>
<span class="nc" id="L1608">      setExtendedCAService(service);</span>
    }
<span class="nc" id="L1610">  }</span>

  /**
   * Method used to retrieve information about the service.
   *
   * @param type type
   * @return info
   */
  public ExtendedCAServiceInfo getExtendedCAServiceInfo(final int type) {
<span class="fc" id="L1619">    ExtendedCAServiceInfo ret = null;</span>
<span class="fc" id="L1620">    ExtendedCAService service = getExtendedCAService(type);</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">    if (service != null) {</span>
<span class="fc" id="L1622">      ret = service.getExtendedCAServiceInfo();</span>
    }
<span class="fc" id="L1624">    return ret;</span>
  }

  /**
   * Method used to perform the service.
   *
   * @param cryptoToken token
   * @param request request
   * @return service response
   * @throws ExtendedCAServiceRequestException If there was a problem with the
   *     request
   * @throws IllegalExtendedCAServiceRequestException If the request is illegal
   * @throws ExtendedCAServiceNotActiveException If the service is inactive or
   *     not found
   * @throws OperatorCreationException If creation fails
   * @throws CertificateException Ig there was a problem with the certificate
   * @throws CertificateEncodingException if there was a problem constructing a
   *     certificate extension.
   */
  public ExtendedCAServiceResponse extendedService(
      final CryptoToken cryptoToken, final ExtendedCAServiceRequest request)
      throws ExtendedCAServiceRequestException,
          IllegalExtendedCAServiceRequestException,
          ExtendedCAServiceNotActiveException, CertificateEncodingException,
          CertificateException, OperatorCreationException {
<span class="fc" id="L1649">    ExtendedCAService service = getExtendedCAService(request.getServiceType());</span>
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">    if (service == null) {</span>
<span class="nc" id="L1651">      final String msg =</span>
          &quot;Extended CA service is null for service request: &quot;
<span class="nc" id="L1653">              + request.getClass().getName();</span>
<span class="nc" id="L1654">      log.error(msg);</span>
<span class="nc" id="L1655">      throw new IllegalExtendedCAServiceRequestException();</span>
    }
    // Enrich request with CA in order for the service to be
    // able to use CA keys and// certificates
<span class="fc" id="L1659">    service.setCA(this);</span>
<span class="fc" id="L1660">    return service.extendedService(cryptoToken, request);</span>
  }

  /**
   * Get extended service.
   *
   * @param type Type
   * @return Service
   */
  @SuppressWarnings(&quot;rawtypes&quot;)
  public HashMap getExtendedCAServiceData(final int type) {
<span class="fc" id="L1671">    HashMap serviceData = (HashMap) data.get(EXTENDEDCASERVICE + type);</span>
<span class="fc" id="L1672">    return serviceData;</span>
  }

  /**
   * Set extended service.
   *
   * @param type Type
   * @param serviceData Data
   */
  public void setExtendedCAServiceData(
      final int type, @SuppressWarnings(&quot;rawtypes&quot;) final HashMap serviceData) {
<span class="fc" id="L1683">    data.put(EXTENDEDCASERVICE + type, serviceData);</span>
<span class="fc" id="L1684">  }</span>

  /**
   * Get extended service.
   *
   * @param type Type
   * @return Service
   */
  protected ExtendedCAService getExtendedCAService(final int type) {
<span class="fc" id="L1693">    ExtendedCAService returnval = null;</span>
    try {
<span class="fc" id="L1695">      returnval = extendedcaservicemap.get(Integer.valueOf(type));</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">      if (returnval == null) {</span>
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L1698">        HashMap serviceData = getExtendedCAServiceData(type);</span>
<span class="fc bfc" id="L1699" title="All 2 branches covered.">        if (serviceData != null) {</span>
          // We must have run upgrade on the extended CA
          // services for this to work
<span class="fc" id="L1702">          String implClassname =</span>
              (String)
<span class="fc" id="L1704">                  serviceData.get(ExtendedCAServiceInfo.IMPLEMENTATIONCLASS);</span>
<span class="pc bpc" id="L1705" title="1 of 2 branches missed.">          if (implClassname == null) {</span>
            // We need this hardcoded implementation
            // classnames in order to be able to
            // upgrade extended services from before
            // See ECA-6341 and
            // UpgradeSessionBean.migrateDatabase500()
<span class="nc" id="L1711">            log.info(</span>
                &quot;implementation classname is null for &quot;
                    + &quot;extended service type: &quot;
                    + type
                    + &quot;. Will try our known ones.&quot;);
<span class="nc bnc" id="L1716" title="All 5 branches missed.">            switch (type) {</span>
              case 2: // Old XKMSCAService that should not be used
<span class="nc" id="L1718">                log.info(</span>
                    &quot;Found an XKMS CA service type. Will&quot;
                        + &quot; not create the deprecated service.&quot;);
<span class="nc" id="L1721">                break;</span>
              case ExtendedCAServiceTypes.TYPE_CMSEXTENDEDSERVICE:
<span class="nc" id="L1723">                implClassname =</span>
                    &quot;org.ejbca.core.model.ca.caadmin.&quot;
                        + &quot;extendedcaservices.CmsCAService&quot;;
<span class="nc" id="L1726">                break;</span>
              case ExtendedCAServiceTypes.TYPE_HARDTOKENENCEXTENDEDSERVICE:
<span class="nc" id="L1728">                implClassname =</span>
                    &quot;org.ejbca.core.model.ca.caadmin.&quot;
                        + &quot;extendedcaservices&quot;
                        + &quot;.HardTokenEncryptCAService&quot;;
<span class="nc" id="L1732">                break;</span>
              case ExtendedCAServiceTypes.TYPE_KEYRECOVERYEXTENDEDSERVICE:
<span class="nc" id="L1734">                implClassname =</span>
                    &quot;org.ejbca.core.model.ca.caadmin.&quot;
                        + &quot;extendedcaservices.KeyRecoveryCAService&quot;;
<span class="nc" id="L1737">                break;</span>
              default:
<span class="nc" id="L1739">                log.error(</span>
                    &quot;implementation classname is null for &quot;
                        + &quot;extended service type: &quot;
                        + type
                        + &quot;. Service not created.&quot;);
                break;
            }
          }
<span class="pc bpc" id="L1747" title="1 of 2 branches missed.">          if (implClassname != null) {</span>
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1749">              log.debug(</span>
                  &quot;implementation classname for extended&quot;
                      + &quot; service type: &quot;
                      + type
                      + &quot; is &quot;
                      + implClassname);
            }
<span class="fc" id="L1756">            Class&lt;?&gt; implClass = Class.forName(implClassname);</span>
<span class="fc" id="L1757">            returnval =</span>
                (ExtendedCAService)
                    implClass
<span class="fc" id="L1760">                        .getConstructor(HashMap.class)</span>
<span class="fc" id="L1761">                        .newInstance(new Object[] {serviceData});</span>
<span class="fc" id="L1762">            extendedcaservicemap.put(Integer.valueOf(type), returnval);</span>
          }
<span class="fc" id="L1764">        } else {</span>
<span class="fc" id="L1765">          log.error(</span>
              &quot;Servicedata is null for &quot;
                  + &quot;extended CA service of type: &quot;
                  + type);
        }
      }
<span class="nc" id="L1771">    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1772">      log.warn(</span>
          &quot;Extended CA service of type &quot; + type + &quot; can not get created: &quot;, e);
<span class="nc" id="L1774">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1775">      log.warn(</span>
          &quot;Extended CA service of type &quot; + type + &quot; can not get created: &quot;, e);
<span class="nc" id="L1777">    } catch (SecurityException e) {</span>
<span class="nc" id="L1778">      log.warn(</span>
          &quot;Extended CA service of type &quot; + type + &quot; can not get created: &quot;, e);
<span class="nc" id="L1780">    } catch (InstantiationException e) {</span>
<span class="nc" id="L1781">      log.warn(</span>
          &quot;Extended CA service of type &quot; + type + &quot; can not get created: &quot;, e);
<span class="nc" id="L1783">    } catch (IllegalAccessException e) {</span>
<span class="nc" id="L1784">      log.warn(</span>
          &quot;Extended CA service of type &quot; + type + &quot; can not get created: &quot;, e);
<span class="nc" id="L1786">    } catch (InvocationTargetException e) {</span>
<span class="nc" id="L1787">      log.warn(</span>
          &quot;Extended CA service of type &quot; + type + &quot; can not get created: &quot;, e);
<span class="nc" id="L1789">    } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L1790">      log.warn(</span>
          &quot;Extended CA service of type &quot; + type + &quot; can not get created: &quot;, e);
<span class="pc" id="L1792">    }</span>
<span class="fc" id="L1793">    return returnval;</span>
  }

  /**
   * Set extended service.
   *
   * @param extendedcaservice Service.
   */
  @SuppressWarnings(&quot;rawtypes&quot;)
  public void setExtendedCAService(final ExtendedCAService extendedcaservice) {
<span class="fc" id="L1803">    ExtendedCAServiceInfo info = extendedcaservice.getExtendedCAServiceInfo();</span>
<span class="fc" id="L1804">    setExtendedCAServiceData(</span>
<span class="fc" id="L1805">        info.getType(), (HashMap) extendedcaservice.saveData());</span>
<span class="fc" id="L1806">    extendedcaservicemap.put(</span>
<span class="fc" id="L1807">        Integer.valueOf(info.getType()), extendedcaservice);</span>
<span class="fc" id="L1808">  }</span>

  /**
   * Returns a Collection of ExternalCAServices (int) added to this CA.
   *
   * @return types
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Collection&lt;Integer&gt; getExternalCAServiceTypes() {
<span class="pc bpc" id="L1817" title="1 of 2 branches missed.">    if (data.get(EXTENDEDCASERVICES) == null) {</span>
<span class="nc" id="L1818">      return new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L1820">    return (Collection&lt;Integer&gt;) data.get(EXTENDEDCASERVICES);</span>
  }

  /**
   * Method to upgrade new (or existing externacaservices). This method needs to
   * be called outside the regular upgrade since the CA isn't instantiated in
   * the regular upgrade.
   *
   * @return true/false
   */
  public abstract boolean upgradeExtendedCAServices();

  /**
   * Create a certificate with all the current CA certificate info, but signed
   * by the old issuer.
   *
   * @param cryptoToken token
   * @param createLinkCertificate create?
   * @param certProfile profile
   * @param cceConfig config
   * @param oldCaCert old cert
   * @throws CryptoTokenOfflineException on error
   */
  public abstract void createOrRemoveLinkCertificate(
      CryptoToken cryptoToken,
      boolean createLinkCertificate,
      CertificateProfile certProfile,
      AvailableCustomCertificateExtensionsConfiguration cceConfig,
      Certificate oldCaCert)
      throws CryptoTokenOfflineException;

  /**
   * Store the latest link certificate in this object.
   *
   * @param encodedLinkCertificate certificate
   */
  protected void updateLatestLinkCertificate(
      final byte[] encodedLinkCertificate) {
<span class="nc bnc" id="L1858" title="All 2 branches missed.">    if (encodedLinkCertificate == null) {</span>
<span class="nc" id="L1859">      data.remove(LATESTLINKCERTIFICATE);</span>
    } else {
      try {
<span class="nc" id="L1862">        data.put(</span>
            LATESTLINKCERTIFICATE,
<span class="nc" id="L1864">            new String(Base64.encode(encodedLinkCertificate), &quot;UTF8&quot;));</span>
<span class="nc" id="L1865">      } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L1866">        throw new RuntimeException(e); // Lack of UTF8 would be fatal.</span>
<span class="nc" id="L1867">      }</span>
    }
<span class="nc" id="L1869">  }</span>

  /** @return the CA latest link certificate or null */
  public byte[] getLatestLinkCertificate() {
<span class="nc bnc" id="L1873" title="All 2 branches missed.">    if (data.get(LATESTLINKCERTIFICATE) == null) {</span>
<span class="nc" id="L1874">      return null;</span>
    }
    try {
<span class="nc" id="L1877">      return Base64.decode(</span>
<span class="nc" id="L1878">          ((String) data.get(LATESTLINKCERTIFICATE)).getBytes(&quot;UTF8&quot;));</span>
<span class="nc" id="L1879">    } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L1880">      throw new RuntimeException(e); // Lack of UTF8 would be fatal.</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>