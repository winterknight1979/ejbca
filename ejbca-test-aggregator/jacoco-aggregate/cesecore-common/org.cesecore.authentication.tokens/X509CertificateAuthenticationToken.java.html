<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>X509CertificateAuthenticationToken.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.authentication.tokens</a> &gt; <span class="el_source">X509CertificateAuthenticationToken.java</span></div><h1>X509CertificateAuthenticationToken.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.authentication.tokens;

import java.io.ByteArrayInputStream;
import java.math.BigInteger;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import javax.security.auth.x500.X500Principal;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.authorization.user.AccessUserAspect;
import org.cesecore.authorization.user.matchvalues.X500PrincipalAccessMatchValue;
import org.cesecore.certificates.util.DNFieldExtractor;
import org.cesecore.util.CertTools;

/**
 * This is an implementation of the AuthenticationToken concept, based on using
 * an {@link X509Certificate} as it's single credential, and that certificate's
 * {@link X500Principal} as its principle, but as the X500Principle is contained
 * in the X509Certificate, this remains little more than a formality. This
 * AuthenticationToken is the default used in EJBCA.
 *
 * &lt;p&gt;The implementation of the &lt;code&gt;matches(...)&lt;/code&gt; method is based on
 * &lt;code&gt;AdminEntity.java 10832 2010-12-13 13:54:25Z
 *     anatom&lt;/code&gt; from EJBCA.
 *
 * @version $Id: X509CertificateAuthenticationToken.java 31393 2019-02-05
 *     11:07:23Z samuellb $
 */
public class X509CertificateAuthenticationToken
    extends NestableAuthenticationToken {
  /** Metadata. */
<span class="fc" id="L50">  public static final X509CertificateAuthenticationTokenMetaData METADATA =</span>
      new X509CertificateAuthenticationTokenMetaData();
  /** Logger. */
<span class="fc" id="L53">  private static final Logger LOG =</span>
<span class="fc" id="L54">      Logger.getLogger(X509CertificateAuthenticationToken.class);</span>

  private static final long serialVersionUID = 1097165653913865515L;
  /** Pattern to extract SN from certificate. */
<span class="fc" id="L58">  private static final Pattern SERIAL_PATTERN =</span>
<span class="fc" id="L59">      Pattern.compile(&quot;\\bSERIALNUMBER=&quot;, Pattern.CASE_INSENSITIVE);</span>
  /** Certificate. */
  private final X509Certificate certificate;
  // get the subjectDN from the certificate and keep it for caching (speed
  // optimization)
  /** Subject DN. */
  private transient String adminSubjectDN;
  /** CA ID. */
  private final int adminCaId;
  /** Extractor for D-name. */
  private final DNFieldExtractor dnExtractor;
  /** Extractor for A-Name. */
  private final DNFieldExtractor anExtractor;

  /**
   * Standard constructor for X509CertificateAuthenticationToken.
   *
   * @param principals A set of X500Principals. Should contain one and only one
   *     value.
   * @param credentials A set of X509Certificates. As with the principals, this
   *     set should contain one and only one value, anything else will result in
   *     a {@link InvalidAuthenticationTokenException} being thrown.
   */
  public X509CertificateAuthenticationToken(
      final Set&lt;X500Principal&gt; principals,
      final Set&lt;X509Certificate&gt; credentials) {
<span class="fc" id="L85">    super(principals, credentials);</span>
    /*
     * In order to save having to verify the credentials set every time the
     *&lt;code&gt;matches(...)&lt;/code&gt; method is called, it's checked here, and the
     * resulting credential is stored locally.
     */
<span class="fc" id="L91">    final X509Certificate[] certificateArray =</span>
<span class="fc" id="L92">        getCredentials().toArray(new X509Certificate[0]);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">    if (certificateArray.length != 1) {</span>
<span class="fc" id="L94">      throw new InvalidAuthenticationTokenException(</span>
          &quot;X509CertificateAuthenticationToken was containing &quot;
              + certificateArray.length
              + &quot; credentials instead of 1.&quot;);
    } else {
      // Speed optimization, make it into a BC class, since
      // we will want that many times later on
<span class="fc" id="L101">      final String clazz = certificateArray[0].getClass().getName();</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">      if (clazz.contains(&quot;org.bouncycastle&quot;)) {</span>
<span class="fc" id="L103">        certificate = certificateArray[0];</span>
      } else {
<span class="nc" id="L105">        final CertificateFactory cf = CertTools.getCertificateFactory();</span>
        X509Certificate cert;
        try {
<span class="nc" id="L108">          cert =</span>
              (X509Certificate)
<span class="nc" id="L110">                  cf.generateCertificate(</span>
                      new ByteArrayInputStream(
<span class="nc" id="L112">                          certificateArray[0].getEncoded()));</span>
<span class="nc" id="L113">        } catch (CertificateException e) {</span>
<span class="nc" id="L114">          LOG.warn(</span>
              &quot;Error encoding/decoding client TLS certificate &quot;
                  + &quot;in BC, just passing instead of optimizing: &quot;,
              e);
<span class="nc" id="L118">          cert = certificateArray[0];</span>
<span class="nc" id="L119">        }</span>
<span class="nc" id="L120">        certificate = cert;</span>
      }
    }
<span class="fc" id="L123">    String certstring = CertTools.getSubjectDN(certificate).toString();</span>
<span class="fc" id="L124">    adminCaId = CertTools.getIssuerDN(certificate).hashCode();</span>
<span class="fc" id="L125">    adminSubjectDN = CertTools.getSubjectDN(certificate);</span>
<span class="fc" id="L126">    certstring = SERIAL_PATTERN.matcher(certstring).replaceAll(&quot;SN=&quot;);</span>
<span class="fc" id="L127">    final String altNameString =</span>
<span class="fc" id="L128">        CertTools.getSubjectAlternativeName(certificate);</span>
<span class="fc" id="L129">    dnExtractor =</span>
        new DNFieldExtractor(certstring, DNFieldExtractor.TYPE_SUBJECTDN);
<span class="fc" id="L131">    anExtractor =</span>
        new DNFieldExtractor(
            altNameString, DNFieldExtractor.TYPE_SUBJECTALTNAME);
<span class="fc" id="L134">  }</span>

  /**
   * Standard simplified constructor for X509CertificateAuthenticationToken.
   *
   * @param aCertificate A X509Certificate that will be used as principal and
   *     credential.
   * @throws NullPointerException if the provided certificate is null
   */
  public X509CertificateAuthenticationToken(
      final X509Certificate aCertificate) {
<span class="fc" id="L145">    this(</span>
<span class="fc" id="L146">        new HashSet&lt;&gt;(Arrays.asList(aCertificate.getSubjectX500Principal())),</span>
<span class="fc" id="L147">        new HashSet&lt;&gt;(Arrays.asList(aCertificate)));</span>
<span class="fc" id="L148">  }</span>

  @SuppressWarnings(&quot;deprecation&quot;)
  @Override
  public boolean matches(final AccessUserAspect accessUser) {
    // Protect against spoofing by checking if this
    // token was created locally
<span class="fc bfc" id="L155" title="All 2 branches covered.">    if (!super.isCreatedInThisJvm()) {</span>
<span class="fc" id="L156">      return false;</span>
    }
<span class="fc" id="L158">    boolean returnvalue = false;</span>
    int parameter;
<span class="fc" id="L160">    int size = 0;</span>
<span class="fc" id="L161">    String[] clientstrings = null;</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">    if (StringUtils.equals(</span>
<span class="fc" id="L163">        getMetaData().getTokenType(), accessUser.getTokenType())) {</span>
      // First check that issuers match.
<span class="fc bfc" id="L165" title="All 2 branches covered.">      if (accessUser.getCaId() == adminCaId) {</span>
        // Check if we actually have some value to match against,
        // null is not an allowed match value
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (accessUser.getMatchValue() != null) {</span>
          // Determine part of certificate to match with.
<span class="fc" id="L170">          DNFieldExtractor usedExtractor = dnExtractor;</span>
<span class="fc" id="L171">          X500PrincipalAccessMatchValue matchValue =</span>
              (X500PrincipalAccessMatchValue)
<span class="fc" id="L173">                  getMatchValueFromDatabaseValue(accessUser.getMatchWith());</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">          if (matchValue == X500PrincipalAccessMatchValue.WITH_SERIALNUMBER) {</span>
            try {
<span class="fc" id="L176">              BigInteger matchValueAsBigInteger =</span>
<span class="fc" id="L177">                  new BigInteger(accessUser.getMatchValue(), 16);</span>
<span class="pc bpc" id="L178" title="1 of 3 branches missed.">              switch (accessUser.getMatchTypeAsType()) {</span>
                case TYPE_EQUALCASE:
                case TYPE_EQUALCASEINS:
<span class="fc" id="L181">                  returnvalue =</span>
<span class="fc" id="L182">                      matchValueAsBigInteger.equals(</span>
<span class="fc" id="L183">                          certificate.getSerialNumber());</span>
<span class="fc" id="L184">                  break;</span>
                case TYPE_NOT_EQUALCASE:
                case TYPE_NOT_EQUALCASEINS:
<span class="fc" id="L187">                  returnvalue =</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                      !matchValueAsBigInteger.equals(</span>
<span class="fc" id="L189">                          certificate.getSerialNumber());</span>
<span class="fc" id="L190">                  break;</span>
                default:
              }
<span class="fc" id="L193">            } catch (NumberFormatException nfe) {</span>
<span class="fc" id="L194">              LOG.info(</span>
                  &quot;Invalid matchValue for accessUser &quot;
                      + &quot;when expecting a hex serialNumber: &quot;
<span class="fc" id="L197">                      + accessUser.getMatchValue());</span>
<span class="fc" id="L198">            }</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">          } else if (matchValue == X500PrincipalAccessMatchValue.WITH_FULLDN) {</span>
<span class="fc" id="L200">            String value = accessUser.getMatchValue();</span>
<span class="pc bpc" id="L201" title="4 of 5 branches missed.">            switch (accessUser.getMatchTypeAsType()) {</span>
              case TYPE_EQUALCASE:
<span class="nc" id="L203">                returnvalue = value.equals(CertTools.getSubjectDN(certificate));</span>
<span class="nc" id="L204">                break;</span>
              case TYPE_EQUALCASEINS:
<span class="fc" id="L206">                returnvalue =</span>
<span class="fc" id="L207">                    value.equalsIgnoreCase(CertTools.getSubjectDN(certificate));</span>
<span class="fc" id="L208">                break;</span>
              case TYPE_NOT_EQUALCASE:
<span class="nc" id="L210">                returnvalue =</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                    !value.equals(CertTools.getSubjectDN(certificate));</span>
              case TYPE_NOT_EQUALCASEINS:
<span class="nc" id="L213">                returnvalue =</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                    !value.equalsIgnoreCase(</span>
<span class="nc" id="L215">                        CertTools.getSubjectDN(certificate));</span>
<span class="nc" id="L216">                break;</span>
              default:
            }
<span class="fc" id="L219">          } else {</span>
<span class="fc" id="L220">            parameter = DNFieldExtractor.CN;</span>
<span class="pc bpc" id="L221" title="2 of 14 branches missed.">            switch (matchValue) {</span>
              case WITH_COUNTRY:
<span class="fc" id="L223">                parameter = DNFieldExtractor.C;</span>
<span class="fc" id="L224">                break;</span>
              case WITH_DOMAINCOMPONENT:
<span class="fc" id="L226">                parameter = DNFieldExtractor.DC;</span>
<span class="fc" id="L227">                break;</span>
              case WITH_STATEORPROVINCE:
<span class="fc" id="L229">                parameter = DNFieldExtractor.ST;</span>
<span class="fc" id="L230">                break;</span>
              case WITH_LOCALITY:
<span class="fc" id="L232">                parameter = DNFieldExtractor.L;</span>
<span class="fc" id="L233">                break;</span>
              case WITH_ORGANIZATION:
<span class="fc" id="L235">                parameter = DNFieldExtractor.O;</span>
<span class="fc" id="L236">                break;</span>
              case WITH_ORGANIZATIONALUNIT:
<span class="fc" id="L238">                parameter = DNFieldExtractor.OU;</span>
<span class="fc" id="L239">                break;</span>
              case WITH_TITLE:
<span class="fc" id="L241">                parameter = DNFieldExtractor.T;</span>
<span class="fc" id="L242">                break;</span>
              case WITH_DNSERIALNUMBER:
<span class="fc" id="L244">                parameter = DNFieldExtractor.SN;</span>
<span class="fc" id="L245">                break;</span>
              case WITH_COMMONNAME:
<span class="fc" id="L247">                parameter = DNFieldExtractor.CN;</span>
<span class="fc" id="L248">                break;</span>
              case WITH_UID:
<span class="fc" id="L250">                parameter = DNFieldExtractor.UID;</span>
<span class="fc" id="L251">                break;</span>
              case WITH_DNEMAILADDRESS:
<span class="fc" id="L253">                parameter = DNFieldExtractor.E;</span>
<span class="fc" id="L254">                break;</span>
              case WITH_RFC822NAME:
<span class="nc" id="L256">                parameter = DNFieldExtractor.RFC822NAME;</span>
<span class="nc" id="L257">                usedExtractor = anExtractor;</span>
<span class="nc" id="L258">                break;</span>
              case WITH_UPN:
<span class="nc" id="L260">                parameter = DNFieldExtractor.UPN;</span>
<span class="nc" id="L261">                usedExtractor = anExtractor;</span>
<span class="nc" id="L262">                break;</span>
              default:
            }
<span class="fc" id="L265">            size = usedExtractor.getNumberOfFields(parameter);</span>
<span class="fc" id="L266">            clientstrings = new String[size];</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L268">              clientstrings[i] = usedExtractor.getField(parameter, i);</span>
            }

            // Determine how to match.
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">            if (clientstrings != null) {</span>
<span class="pc bpc" id="L273" title="1 of 5 branches missed.">              switch (accessUser.getMatchTypeAsType()) {</span>
                case TYPE_EQUALCASE:
<span class="fc" id="L275">                  String accessUserMatchValue = accessUser.getMatchValue();</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">                  for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L277">                    returnvalue = clientstrings[i].equals(accessUserMatchValue);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">                    if (returnvalue) {</span>
<span class="fc" id="L279">                      break;</span>
                    }
                  }
<span class="fc" id="L282">                  break;</span>
                case TYPE_EQUALCASEINS:
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                  for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L285">                    returnvalue =</span>
<span class="fc" id="L286">                        clientstrings[i].equalsIgnoreCase(</span>
<span class="fc" id="L287">                            accessUser.getMatchValue());</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">                    if (returnvalue) {</span>
<span class="fc" id="L289">                      break;</span>
                    }
                  }
<span class="fc" id="L292">                  break;</span>
                case TYPE_NOT_EQUALCASE:
<span class="fc bfc" id="L294" title="All 2 branches covered.">                  for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L295">                    returnvalue =</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                        !clientstrings[i].equals(accessUser.getMatchValue());</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">                    if (returnvalue) {</span>
<span class="nc" id="L298">                      break;</span>
                    }
                  }
<span class="fc" id="L301">                  break;</span>
                case TYPE_NOT_EQUALCASEINS:
<span class="fc bfc" id="L303" title="All 2 branches covered.">                  for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L304">                    returnvalue =</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                        !clientstrings[i].equalsIgnoreCase(</span>
<span class="fc" id="L306">                            accessUser.getMatchValue());</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">                    if (returnvalue) {</span>
<span class="nc" id="L308">                      break;</span>
                    }
                  }
<span class="fc" id="L311">                  break;</span>
                default:
              }
            }
          }
<span class="fc" id="L316">        } else {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">          if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L318">            LOG.trace(</span>
                &quot;Match value is null and could not &quot;
                    + &quot;be matched. A value is required.&quot;);
          }
        }
      } else {
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L325">          LOG.trace(</span>
              &quot;Caid does not match. Required=&quot;
                  + adminCaId
                  + &quot;, actual was &quot;
<span class="nc" id="L329">                  + accessUser.getCaId());</span>
        }
      }
    } else {
<span class="nc bnc" id="L333" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L334">        LOG.trace(</span>
            &quot;Token type does not match. Required=&quot;
<span class="nc" id="L336">                + getMetaData().getTokenType()</span>
                + &quot;, actual was &quot;
<span class="nc" id="L338">                + accessUser.getTokenType());</span>
      }
    }

<span class="fc" id="L342">    return returnvalue;</span>
  }

  @Override
  public int getPreferredMatchKey() {
<span class="nc" id="L347">    return X500PrincipalAccessMatchValue.WITH_SERIALNUMBER.getNumericValue();</span>
  }

  /** Returns the serial number as a decimal string. */
  @Override
  public String getPreferredMatchValue() {
<span class="nc" id="L353">    return CertTools.getSerialNumberAsString(certificate);</span>
  }

  /**
   * Returns user information of the user this authentication token belongs to.
   */
  @Override
  public String toString() {
<span class="nc" id="L361">    return super.toString();</span>
  }

  /**
   * Override the default X500Principal.getName() when doing toString on this
   * object.
   */
  @Override
  protected String toStringOverride() {
    // Return cached value to optimize, because this can be
    // called multiple times during the tokens lifetime
<span class="nc bnc" id="L372" title="All 2 branches missed.">    if (adminSubjectDN == null) {</span>
<span class="nc" id="L373">      adminSubjectDN = CertTools.getSubjectDN(certificate);</span>
    }
<span class="nc" id="L375">    return adminSubjectDN;</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L380">    final int prime = 4711;</span>
<span class="nc" id="L381">    int result = 1;</span>
<span class="nc" id="L382">    result =</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        prime * result + ((certificate == null) ? 0 : certificate.hashCode());</span>
<span class="nc" id="L384">    return result;</span>
  }

  @Override
  public boolean equals(final Object obj) {
<span class="fc bfc" id="L389" title="All 2 branches covered.">    if (this == obj) {</span>
<span class="fc" id="L390">      return true;</span>
    }
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L393">      return false;</span>
    }
<span class="fc bfc" id="L395" title="All 2 branches covered.">    if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L396">      return false;</span>
    }
<span class="fc" id="L398">    X509CertificateAuthenticationToken other =</span>
        (X509CertificateAuthenticationToken) obj;
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">    if (certificate == null) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">      if (other.certificate != null) {</span>
<span class="nc" id="L402">        return false;</span>
      }
<span class="fc bfc" id="L404" title="All 2 branches covered.">    } else if (!certificate.equals(other.certificate)) {</span>
<span class="fc" id="L405">      return false;</span>
    }
<span class="fc" id="L407">    return true;</span>
  }

  /** @return the certificate */
  public X509Certificate getCertificate() {
<span class="fc" id="L412">    return certificate;</span>
  }

  @Override
  protected String generateUniqueId() {
<span class="nc" id="L417">    byte[] encodedCertificate = null;</span>
    try {
<span class="nc" id="L419">      encodedCertificate = certificate.getEncoded();</span>
<span class="nc" id="L420">    } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L421">      throw new IllegalStateException(e);</span>
<span class="nc" id="L422">    }</span>
<span class="nc" id="L423">    return generateUniqueId(super.isCreatedInThisJvm(), encodedCertificate)</span>
        + &quot;;&quot;
<span class="nc" id="L425">        + super.generateUniqueId();</span>
  }

  @Override
  public X509CertificateAuthenticationTokenMetaData getMetaData() {
<span class="fc" id="L430">    return METADATA;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>