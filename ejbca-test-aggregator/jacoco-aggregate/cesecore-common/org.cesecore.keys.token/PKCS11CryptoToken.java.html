<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PKCS11CryptoToken.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.token</a> &gt; <span class="el_source">PKCS11CryptoToken.java</span></div><h1>PKCS11CryptoToken.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.token;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Provider;
import java.security.cert.CertificateException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Properties;
import org.apache.commons.lang.BooleanUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.internal.InternalResources;
import org.cesecore.keys.token.p11.P11Slot;
import org.cesecore.keys.token.p11.P11SlotUser;
import org.cesecore.keys.token.p11.Pkcs11SlotLabel;
import org.cesecore.keys.token.p11.Pkcs11SlotLabelType;
import org.cesecore.keys.token.p11.exception.NoSuchSlotException;
import org.cesecore.keys.util.KeyStoreTools;

/**
 * Class implementing a keystore on PKCS11 tokens.
 *
 * @version $Id: PKCS11CryptoToken.java 30548 2018-11-19 16:04:50Z anatom $
 */
public class PKCS11CryptoToken extends BaseCryptoToken implements P11SlotUser {

  private static final long serialVersionUID = 7719014139640717867L;

  /** Log4j instance. */
<span class="fc" id="L48">  private static final Logger LOG = Logger.getLogger(PKCS11CryptoToken.class);</span>
  /** Internal localization of logs and errors. */
<span class="fc" id="L50">  private static final InternalResources INTRES =</span>
<span class="fc" id="L51">      InternalResources.getInstance();</span>

  /** Keys, specific to PKCS#11, that can be defined in CA token properties. */
  public static final String SLOT_LABEL_VALUE = &quot;slotLabelValue&quot;;
  /** Type. */
  public static final String SLOT_LABEL_TYPE = &quot;slotLabelType&quot;;
  /** Library. */
  public static final String SHLIB_LABEL_KEY = &quot;sharedLibrary&quot;;
  /** File. */
  public static final String ATTRIB_LABEL_KEY = &quot;attributesFile&quot;;
  /** Pin. */
  public static final String PASSWORD_LABEL_KEY = &quot;pin&quot;;
  /**
   * Flag that if set, prevent adding the P11 provider with
   * Security.addProvider. Can be used to create a crypto token without actually
   * installing it in Java Security, so it can be created temporarily
   */
  public static final String DO_NOT_ADD_P11_PROVIDER = &quot;doNotAddP11Provider&quot;;

  /** Key. */
  @Deprecated // Remove once upgrading from 5.0-&gt;6.0 is no longer supported
  public static final String SLOT_LIST_INDEX_KEY = &quot;slotListIndex&quot;;
  /** Label. */
  @Deprecated // Remove once upgrading from 5.0-&gt;6.0 is no longer supported
  public static final String SLOT_LABEL_KEY = &quot;slot&quot;;

  /**
   * A user defined name of the slot provider. Used in order to be able to have
   * two different providers (with different PKCS#11 attributes) for the same
   * slot. If this is not set (null), the default java provider name is used
   * (SunPKCS11-pkcs11LibName-slotNr for example
   * SunPKCS11-libcryptoki.so-slot1).
   */
  public static final String TOKEN_FRIENDLY_NAME = &quot;tokenFriendlyName&quot;;

  /** Slot. */
  private transient P11Slot p11slot;

  /** Label. */
<span class="fc" id="L90">  private String sSlotLabel = null;</span>

  /** @throws InstantiationException on error */
  public PKCS11CryptoToken() throws InstantiationException {
<span class="fc" id="L94">    super();</span>
    try {
<span class="fc" id="L96">      Thread.currentThread()</span>
<span class="fc" id="L97">          .getContextClassLoader()</span>
<span class="fc" id="L98">          .loadClass(Pkcs11SlotLabel.SUN_PKCS11_CLASS);</span>
<span class="nc" id="L99">    } catch (ClassNotFoundException t) {</span>
<span class="nc" id="L100">      throw new InstantiationException(</span>
          &quot;PKCS11 provider class &quot;
              + Pkcs11SlotLabel.SUN_PKCS11_CLASS
              + &quot; not found.&quot;);
<span class="fc" id="L104">    }</span>
<span class="fc" id="L105">  }</span>

  @Override
  public void init(final Properties properties, final byte[] data, final int id)
      throws CryptoTokenOfflineException, NoSuchSlotException {
<span class="nc bnc" id="L110" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L111">      LOG.debug(&quot;&gt;init: id=&quot; + id);</span>
    }
    // Don't autoactivate this right away, we must dynamically create the
    // auth-provider with a slot
<span class="nc" id="L115">    setProperties(properties);</span>
<span class="nc" id="L116">    init(properties, false, id);</span>
<span class="nc" id="L117">    sSlotLabel = getSlotLabel(SLOT_LABEL_VALUE, properties);</span>
<span class="nc" id="L118">    Pkcs11SlotLabelType type =</span>
<span class="nc" id="L119">        Pkcs11SlotLabelType.getFromKey(</span>
<span class="nc" id="L120">            getSlotLabel(SLOT_LABEL_TYPE, properties));</span>
<span class="nc" id="L121">    String sharedLibrary =</span>
<span class="nc" id="L122">        properties.getProperty(PKCS11CryptoToken.SHLIB_LABEL_KEY);</span>
<span class="nc" id="L123">    String attributesFile =</span>
<span class="nc" id="L124">        properties.getProperty(PKCS11CryptoToken.ATTRIB_LABEL_KEY);</span>
<span class="nc" id="L125">    Boolean addProvider =</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        !BooleanUtils.toBoolean(</span>
<span class="nc" id="L127">            properties.getProperty(PKCS11CryptoToken.DO_NOT_ADD_P11_PROVIDER));</span>

<span class="nc" id="L129">    String friendlyName = properties.getProperty(TOKEN_FRIENDLY_NAME);</span>

<span class="nc bnc" id="L131" title="All 2 branches missed.">    if (friendlyName != null) {</span>
<span class="nc" id="L132">      p11slot =</span>
<span class="nc" id="L133">          P11Slot.getInstance(</span>
              friendlyName,
              sSlotLabel,
              sharedLibrary,
              type,
              attributesFile,
              this,
              id,
<span class="nc" id="L141">              addProvider);</span>
    } else {
      // getInstance will run autoActivate()
<span class="nc" id="L144">      p11slot =</span>
<span class="nc" id="L145">          P11Slot.getInstance(</span>
              sSlotLabel,
              sharedLibrary,
              type,
              attributesFile,
              this,
              id,
<span class="nc" id="L152">              addProvider);</span>
    }
<span class="nc" id="L154">    final Provider provider = p11slot.getProvider();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">    if (addProvider) {</span>
<span class="nc" id="L156">      setJCAProvider(provider);</span>
    } else {
<span class="nc" id="L158">      setJCAProviderName(provider.getName());</span>
<span class="nc" id="L159">      LOG.info(&quot;Configured to not add PKCS#11 Provider: &quot; + provider.getName());</span>
    }
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L162">      LOG.debug(&quot;&lt;init: id=&quot; + id);</span>
    }
<span class="nc" id="L164">  }</span>

  @Override
  public boolean isActive() {
<span class="nc bnc" id="L168" title="All 2 branches missed.">    return getTokenStatus() == CryptoToken.STATUS_ACTIVE;</span>
  }

  @Override
  public void activate(final char[] authCode)
      throws CryptoTokenOfflineException,
          CryptoTokenAuthenticationFailedException {
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (this.p11slot == null) {</span>
<span class="nc" id="L176">      throw new CryptoTokenOfflineException(&quot;Slot not initialized.&quot;);</span>
    }
    try {
<span class="nc" id="L179">      final KeyStore keyStore = createKeyStore(authCode);</span>
<span class="nc" id="L180">      setKeyStore(keyStore);</span>
<span class="nc" id="L181">    } catch (</span>
        Throwable
            t) { // NOPMD: when dealing with HSMs we need to catch everything
<span class="nc" id="L184">      LOG.warn(</span>
          &quot;Failed to initialize PKCS11 provider slot '&quot;
              + this.sSlotLabel
              + &quot;'.&quot;,
          t);
<span class="nc" id="L189">      CryptoTokenAuthenticationFailedException authfe =</span>
          new CryptoTokenAuthenticationFailedException(
              &quot;Failed to initialize PKCS11 provider slot '&quot;
                  + this.sSlotLabel
                  + &quot;'.&quot;);
<span class="nc" id="L194">      authfe.initCause(t);</span>
<span class="nc" id="L195">      throw authfe;</span>
<span class="nc" id="L196">    }</span>
<span class="nc" id="L197">    String msg = INTRES.getLocalizedMessage(&quot;token.activated&quot;, getId());</span>
<span class="nc" id="L198">    LOG.info(msg);</span>
<span class="nc" id="L199">  }</span>

  private KeyStore createKeyStore(final char[] authCode)
      throws NoSuchAlgorithmException, CertificateException,
          UnsupportedEncodingException, IOException, KeyStoreException {
<span class="nc" id="L204">    final Provider provider = this.p11slot.getProvider();</span>
<span class="nc" id="L205">    final KeyStore keyStore = KeyStore.getInstance(&quot;PKCS11&quot;, provider);</span>
<span class="nc" id="L206">    LOG.debug(&quot;Loading key from slot '&quot; + this.sSlotLabel + &quot;' using pin.&quot;);</span>
    // See ECA-1395 for an explanation of this special handling for the IAIK
    // provider.
    // If the application uses several instances of the IAIKPkcs11 provider, it
    // has two options to get an initialized key store. First, it can get
    // the initialized key store directly from the provider instance. This looks
    // like this
    // KeyStore tokenKeyStore = pkcs11Provider_.getTokenManager().getKeyStore();
    // where pkcs11Provider_ is the instance of the IAIKPkcs11 provider. Second,
    // the application can instantiate the key store as usual and then
    // initialize it. For initialization, the application must provide the name
    // of the instance that this key store shall operate with. Just
    // instantiating the key store is not enough, and if the application calls
    // tokenKeyStore.load(null, null), it always(!) binds the key store to
    // the first instance of the IAIKPkcs11 provider. This is the case, because
    // there is no means for the KeyStoreSPI class to get the instance of
    // the provider that was used to instantiate it. This means, it does not
    // help to provide the provider name and calling
    // KeyStore.getInstance(&quot;PKCS11KeyStore&quot;, providerName), the call to the
    // load(InputStream, char[]) method with appropriate arguments is
    // required nevertheless. The correct usage will look like this
    // KeyStore cardKeyStore = KeyStore.getInstance(&quot;PKCS11KeyStore&quot;);
    // String providerName = pkcs11Provider_.getName();
    // ByteArrayInputStream providerNameInpustStream =
    // new ByteArrayInputStream(providerName.getBytes(&quot;UTF-8&quot;));
    // cardKeyStore.load(providerNameInpustStream, null);
    // The password parameter of the load method (this is the second parameter,
    // which is null here) will be used if provided (i.e. if it is not
    // null). If it is null, the default login manager will use the configured
    // method for prompting the PIN on demand. If the application just
    // provides the instance number as a string instead of the complete provider
    // name, the key store will also accept it.
<span class="nc" id="L238">    if (provider</span>
<span class="nc" id="L239">        .getClass()</span>
<span class="nc" id="L240">        .getName()</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        .equals(Pkcs11SlotLabel.IAIK_PKCS11_CLASS)) {</span>
<span class="nc" id="L242">      keyStore.load(</span>
<span class="nc" id="L243">          new ByteArrayInputStream(getSignProviderName().getBytes(&quot;UTF-8&quot;)),</span>
          authCode);
    } else {
      // For the Sun provider no provider name is used.
<span class="nc" id="L247">      keyStore.load(null, authCode);</span>
    }
<span class="nc" id="L249">    return keyStore;</span>
  }

  @Override
  public void deactivate() {
    try {
<span class="nc" id="L255">      setKeyStore(null);</span>
<span class="nc" id="L256">    } catch (KeyStoreException e) {</span>
      // Exception should only be thrown if loading a non-null KeyStore fails
<span class="nc" id="L258">      throw new IllegalStateException(&quot;This should never happen.&quot;);</span>
<span class="nc" id="L259">    }</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (this.p11slot != null) {</span>
<span class="nc" id="L261">      this.p11slot.logoutFromSlotIfNoTokensActive();</span>
    } else {
<span class="nc" id="L263">      LOG.debug(&quot;p11slot was null, token was not active trying to deactivate.&quot;);</span>
    }
<span class="nc" id="L265">    final String msg = INTRES.getLocalizedMessage(&quot;token.deactivate&quot;, getId());</span>
<span class="nc" id="L266">    LOG.info(msg);</span>
<span class="nc" id="L267">  }</span>

  @Override
  public void reset() {
<span class="nc bnc" id="L271" title="All 2 branches missed.">    if (this.p11slot != null) {</span>
<span class="nc" id="L272">      this.p11slot.reset();</span>
    }
<span class="nc" id="L274">  }</span>

  @Override
  public void deleteEntry(final String alias)
      throws KeyStoreException, NoSuchAlgorithmException, CertificateException,
          IOException, CryptoTokenOfflineException {
<span class="nc bnc" id="L280" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(alias)) {</span>
<span class="nc" id="L281">      KeyStoreTools cont =</span>
<span class="nc" id="L282">          new KeyStoreTools(getKeyStore(), getSignProviderName());</span>
<span class="nc" id="L283">      cont.deleteEntry(alias);</span>
<span class="nc" id="L284">      String msg =</span>
<span class="nc" id="L285">          INTRES.getLocalizedMessage(&quot;token.deleteentry&quot;, alias, getId());</span>
<span class="nc" id="L286">      LOG.info(msg);</span>
<span class="nc" id="L287">    } else {</span>
<span class="nc" id="L288">      LOG.debug(&quot;Trying to delete keystore entry with empty alias.&quot;);</span>
    }
<span class="nc" id="L290">  }</span>

  @Override
  public void generateKeyPair(final String keySpec, final String alias)
      throws InvalidAlgorithmParameterException, CryptoTokenOfflineException {
<span class="nc bnc" id="L295" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(alias)) {</span>
<span class="nc" id="L296">      KeyStoreTools cont =</span>
<span class="nc" id="L297">          new KeyStoreTools(getKeyStore(), getSignProviderName());</span>
<span class="nc" id="L298">      cont.generateKeyPair(keySpec, alias);</span>
<span class="nc" id="L299">    } else {</span>
<span class="nc" id="L300">      LOG.debug(&quot;Trying to generate keys with empty alias.&quot;);</span>
    }
<span class="nc" id="L302">  }</span>

  @Override
  public void generateKeyPair(
      final AlgorithmParameterSpec spec, final String alias)
      throws InvalidAlgorithmParameterException, CertificateException,
          IOException, CryptoTokenOfflineException {
<span class="nc bnc" id="L309" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(alias)) {</span>
<span class="nc" id="L310">      KeyStoreTools cont =</span>
<span class="nc" id="L311">          new KeyStoreTools(getKeyStore(), getSignProviderName());</span>
<span class="nc" id="L312">      cont.generateKeyPair(spec, alias);</span>
<span class="nc" id="L313">    } else {</span>
<span class="nc" id="L314">      LOG.debug(&quot;Trying to generate keys with empty alias.&quot;);</span>
    }
<span class="nc" id="L316">  }</span>

  @Override
  public void generateKey(
      final String algorithm, final int keysize, final String alias)
      throws NoSuchAlgorithmException, NoSuchProviderException,
          KeyStoreException, CryptoTokenOfflineException {
<span class="nc bnc" id="L323" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L324">      LOG.debug(&quot;Generate key, &quot; + algorithm + &quot;, &quot; + keysize + &quot;, &quot; + alias);</span>
    }
<span class="nc bnc" id="L326" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(alias)) {</span>
<span class="nc" id="L327">      KeyStoreTools cont =</span>
<span class="nc" id="L328">          new KeyStoreTools(getKeyStore(), getSignProviderName());</span>
<span class="nc" id="L329">      cont.generateKey(algorithm, keysize, alias);</span>
<span class="nc" id="L330">    } else {</span>
<span class="nc" id="L331">      LOG.debug(&quot;Trying to generate keys with empty alias.&quot;);</span>
    }
<span class="nc" id="L333">  }</span>

  @Override
  public byte[] getTokenData() {
<span class="nc" id="L337">    return null;</span>
  }

  /**
   * Used for testing.
   *
   * @return slot
   */
  protected P11Slot getP11slot() {
<span class="nc" id="L346">    return p11slot;</span>
  }

  /**
   * Extracts the slotLabel that is used for many tokens in construction of the
   * provider.
   *
   * @param sSlotLabelKey which key in the properties that gives us the label
   * @param properties CA token properties
   * @return String with the slot label, trimmed from whitespace
   */
  private static String getSlotLabel(
      final String sSlotLabelKey, final Properties properties) {
<span class="nc" id="L359">    String ret = null;</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">    if (sSlotLabelKey != null &amp;&amp; properties != null) {</span>
<span class="nc" id="L361">      ret = properties.getProperty(sSlotLabelKey);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">      if (ret != null) {</span>
<span class="nc" id="L363">        ret = ret.trim();</span>
      }
    }
<span class="nc" id="L366">    return ret;</span>
  }

  /**
   * Will replace deprecated properties values with the new ones.
   *
   * @param properties a properties file of the old format.
   * @return a defensive copy of the submitted properties
   */
  @Deprecated
  // Remove when we no longer support upgrading from 5.0.x -&gt; 6.0.x
  public static Properties upgradePropertiesFileFrom50x(
      final Properties properties) {
<span class="nc" id="L379">    Properties returnValue = new Properties();</span>

<span class="nc bnc" id="L381" title="All 2 branches missed.">    for (Object key : properties.keySet()) {</span>
<span class="nc" id="L382">      final String keyString = (String) key;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L384">        LOG.debug(&quot;&gt;upgradePropertiesFileFrom5_0_x, keyString: &quot; + key);</span>
      }
<span class="nc bnc" id="L386" title="All 2 branches missed.">      if (keyString.equalsIgnoreCase(SLOT_LABEL_KEY)) {</span>
<span class="nc" id="L387">        String keyValue = properties.getProperty(keyString);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L389">          LOG.debug(&quot;&gt;upgradePropertiesFileFrom5_0_x, keyValue: &quot; + keyValue);</span>
        }
        // In 5.0.11, the &quot;slot&quot; value may contain just an integer, but may also
        // encode an integer, an index
        // a token label or a config file.
<span class="nc" id="L394">        final String oldLabelPrefix = &quot;TOKEN_LABEL:&quot;;</span>
<span class="nc" id="L395">        final String oldIndexPrefix = &quot;SLOT_LIST_IX:&quot;;</span>
<span class="nc" id="L396">        final String oldSlotNumberPrefix = &quot;SLOT_ID:&quot;;</span>
<span class="nc" id="L397">        final String oldSunFilePrefix = &quot;SUN_FILE:&quot;;</span>
<span class="nc" id="L398">        final String delimiter = &quot;:&quot;;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (Pkcs11SlotLabelType.SLOT_NUMBER.validate(keyValue)) {</span>
          // If it was a straight integer, then save as is
<span class="nc" id="L401">          returnValue.setProperty(SLOT_LABEL_VALUE, keyValue);</span>
<span class="nc" id="L402">          returnValue.setProperty(</span>
<span class="nc" id="L403">              SLOT_LABEL_TYPE, Pkcs11SlotLabelType.SLOT_NUMBER.getKey());</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        } else if (keyValue.startsWith(oldSlotNumberPrefix)) {</span>
          // If not, check with the rest of the values
<span class="nc" id="L406">          returnValue.setProperty(</span>
<span class="nc" id="L407">              SLOT_LABEL_VALUE, keyValue.split(delimiter, 2)[1]);</span>
<span class="nc" id="L408">          returnValue.setProperty(</span>
<span class="nc" id="L409">              SLOT_LABEL_TYPE, Pkcs11SlotLabelType.SLOT_NUMBER.getKey());</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        } else if (keyValue.startsWith(oldIndexPrefix)) {</span>
<span class="nc" id="L411">          returnValue.setProperty(</span>
<span class="nc" id="L412">              SLOT_LABEL_VALUE, keyValue.split(delimiter, 2)[1]);</span>
<span class="nc" id="L413">          returnValue.setProperty(</span>
<span class="nc" id="L414">              SLOT_LABEL_TYPE, Pkcs11SlotLabelType.SLOT_INDEX.getKey());</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        } else if (keyValue.startsWith(oldLabelPrefix)) {</span>
<span class="nc" id="L416">          returnValue.setProperty(</span>
<span class="nc" id="L417">              SLOT_LABEL_VALUE, keyValue.split(delimiter, 2)[1]);</span>
<span class="nc" id="L418">          returnValue.setProperty(</span>
<span class="nc" id="L419">              SLOT_LABEL_TYPE, Pkcs11SlotLabelType.SLOT_LABEL.getKey());</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        } else if (keyValue.startsWith(oldSunFilePrefix)) {</span>
<span class="nc" id="L421">          returnValue.setProperty(</span>
<span class="nc" id="L422">              SLOT_LABEL_TYPE, Pkcs11SlotLabelType.SUN_FILE.getKey());</span>
        }

<span class="nc bnc" id="L425" title="All 2 branches missed.">      } else if (keyString.equalsIgnoreCase(SLOT_LIST_INDEX_KEY)) {</span>
<span class="nc" id="L426">        String indexValue = properties.getProperty(keyString);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (indexValue.charAt(0) != 'i') {</span>
<span class="nc" id="L428">          indexValue = &quot;i&quot; + indexValue;</span>
        }
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L431">          LOG.debug(</span>
              &quot;&gt;upgradePropertiesFileFrom5_0_x, indexValue: &quot; + indexValue);
        }
<span class="nc" id="L434">        returnValue.setProperty(SLOT_LABEL_VALUE, indexValue);</span>
<span class="nc" id="L435">        returnValue.setProperty(</span>
<span class="nc" id="L436">            SLOT_LABEL_TYPE, Pkcs11SlotLabelType.SLOT_INDEX.getKey());</span>
<span class="nc" id="L437">      } else {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L439">          LOG.debug(</span>
              &quot;&gt;upgradePropertiesFileFrom5_0_x, keyString is neither &quot;
                  + SLOT_LABEL_KEY
                  + &quot; or &quot;
                  + SLOT_LIST_INDEX_KEY
                  + &quot;, just setting the property without SLOT_LABEL_TYPE.&quot;);
        }
<span class="nc" id="L446">        returnValue.setProperty(keyString, properties.getProperty(keyString));</span>
      }
<span class="nc" id="L448">    }</span>
<span class="nc" id="L449">    return returnValue;</span>
  }

  @Override
  public boolean permitExtractablePrivateKeyForTest() {
<span class="nc" id="L454">    return doPermitExtractablePrivateKey();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>