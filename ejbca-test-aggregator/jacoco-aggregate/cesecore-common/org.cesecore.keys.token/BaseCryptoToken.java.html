<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BaseCryptoToken.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.token</a> &gt; <span class="el_source">BaseCryptoToken.java</span></div><h1>BaseCryptoToken.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.token;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.ProviderException;
import java.security.PublicKey;
import java.security.Security;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Properties;
import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.jce.ECKeyUtil;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.util.StringTools;

/**
 * Base class for crypto tokens handling things that are common for all crypto
 * tokens, hard or soft.
 *
 * @version $Id: BaseCryptoToken.java 30502 2018-11-14 13:44:43Z anatom $
 */
public abstract class BaseCryptoToken implements CryptoToken {

  private static final long serialVersionUID = 2133644669863292622L;

  /** Log4j instance. */
<span class="fc" id="L58">  private static final Logger LOG = Logger.getLogger(BaseCryptoToken.class);</span>
  /** Internal localization of logs and errors. */
<span class="fc" id="L60">  private static final InternalResources INTRES =</span>
<span class="fc" id="L61">      InternalResources.getInstance();</span>

  /** Used for signatures. */
<span class="fc" id="L64">  private String mJcaProviderName = null;</span>
  /**
   * Used for encrypt/decrypt, can be same as for signatures for example for
   * pkcs#11.
   */
<span class="fc" id="L69">  private String mJceProviderName = null;</span>
/** Authentication. */
  private char[] mAuthCode;
 /** Props. */
  private Properties properties;
  /** Id. */
  private int id;

  /** The java KeyStore backing the Crypto Token. */
  protected transient CachingKeyStoreWrapper keyStore;

  /** public constructor. */
  public BaseCryptoToken() {
<span class="fc" id="L82">    super();</span>
<span class="fc" id="L83">  }</span>

  /**
   * @param keystore store
   * @throws KeyStoreException fail
   */
  protected void setKeyStore(final KeyStore keystore)
          throws KeyStoreException {
<span class="fc bfc" id="L91" title="All 2 branches covered.">    if (keystore == null) {</span>
<span class="fc" id="L92">      this.keyStore = null;</span>
    } else {
<span class="fc" id="L94">      this.keyStore =</span>
          new CachingKeyStoreWrapper(
<span class="fc" id="L96">              keystore, CesecoreConfiguration.isKeyStoreCacheEnabled());</span>
    }
<span class="fc" id="L98">  }</span>

  /**
   * Return the key store for this crypto token.
   *
   * @return the keystore.
   * @throws CryptoTokenOfflineException if Crypto Token is not available or
   *     connected.
   */
  protected CachingKeyStoreWrapper getKeyStore()
      throws CryptoTokenOfflineException {
<span class="fc" id="L109">    autoActivate();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (this.keyStore == null) {</span>
<span class="fc" id="L111">      final String msg =</span>
<span class="fc" id="L112">          INTRES.getLocalizedMessage(</span>
              &quot;token.errorinstansiate&quot;,
              mJcaProviderName,
              &quot;keyStore (&quot; + id + &quot;) == null&quot;);
<span class="fc" id="L116">      throw new CryptoTokenOfflineException(msg);</span>
    }
<span class="fc" id="L118">    return this.keyStore;</span>
  }

  /**
   * TODO: This structure is confusing, with exceptions being thrown, caught,
   * ignored and then rethrown at a later stage. Please fix.
   */
  protected void autoActivate() {
<span class="fc bfc" id="L126" title="All 4 branches covered.">    if ((this.mAuthCode != null) &amp;&amp; (this.keyStore == null)) {</span>
      try {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L129">          LOG.debug(&quot;Trying to autoactivate CryptoToken&quot;);</span>
        }
<span class="fc" id="L131">        activate(this.mAuthCode);</span>
<span class="nc" id="L132">      } catch (Exception e) {</span>
<span class="nc" id="L133">        LOG.debug(e);</span>
<span class="fc" id="L134">      }</span>
    }
<span class="fc" id="L136">  }</span>

  /**
   * Do we permit extractable private keys? Only SW keys should be permitted to
   * be extractable, an overriding crypto token class can override this value.
   *
   * @return false if the key must not be extractable
   */
  public boolean doPermitExtractablePrivateKey() {
<span class="nc" id="L145">    return getProperties()</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            .containsKey(CryptoToken.ALLOW_EXTRACTABLE_PRIVATE_KEY)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        &amp;&amp; Boolean.parseBoolean(</span>
<span class="nc" id="L148">            getProperties()</span>
<span class="nc" id="L149">                .getProperty(CryptoToken.ALLOW_EXTRACTABLE_PRIVATE_KEY));</span>
  }

  /**
   * Similar to the method above, but only applies for internal testing of keys.
   * This method is called during testKeyPair to verify that a key that is
   * extractable can never be used, unless we allow extractable private keys.
   * Used for PKCS#11 (HSMs) to ensure that they are configured correctly. On a
   * PKCS11 Crypto Token, this should return the same as
   * doPermitExtractablePrivateKey(), on a Soft Crypto Token this should always
   * return true.
   *
   * @return false if the key must not be extractable, this will throw an error
   *     if the key is extractable when crypto token tries to test it.
   */
  public abstract boolean permitExtractablePrivateKeyForTest();

  @Override
  public void testKeyPair(final String alias)
      throws InvalidKeyException,
          CryptoTokenOfflineException { // NOPMD:this is not a junit test
<span class="fc" id="L170">    final PrivateKey privateKey = getPrivateKey(alias);</span>
<span class="fc" id="L171">    final PublicKey publicKey = getPublicKey(alias);</span>
<span class="fc" id="L172">    testKeyPair(alias, publicKey, privateKey);</span>
<span class="fc" id="L173">  }</span>

  @Override
  public void testKeyPair(
      final String alias,
      final PublicKey publicKey,
      final PrivateKey privateKey)
      throws InvalidKeyException { // NOPMD:this is not a junit test
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L182">      final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L183">      final PrintStream ps = new PrintStream(baos);</span>
<span class="nc" id="L184">      KeyTools.printPublicKeyInfo(publicKey, ps);</span>
<span class="nc" id="L185">      ps.flush();</span>
<span class="nc" id="L186">      LOG.debug(&quot;Testing key of type &quot; + baos.toString());</span>
    }
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    if (!permitExtractablePrivateKeyForTest()</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        &amp;&amp; KeyTools.isPrivateKeyExtractable(privateKey)) {</span>
<span class="nc" id="L190">      String msg =</span>
<span class="nc" id="L191">          INTRES.getLocalizedMessage(</span>
              &quot;token.extractablekey&quot;,
<span class="nc" id="L193">              CesecoreConfiguration.isPermitExtractablePrivateKeys());</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      if (!CesecoreConfiguration.isPermitExtractablePrivateKeys()) {</span>
<span class="nc" id="L195">        throw new InvalidKeyException(msg);</span>
      }
<span class="nc" id="L197">      LOG.info(msg);</span>
    }
<span class="fc" id="L199">    KeyTools.testKey(privateKey, publicKey, getSignProviderName());</span>
<span class="fc" id="L200">  }</span>

  /**
   * Reads the public key object, does so from the certificate retrieved from
   * the alias from the KeyStore.
   *
   * @param alias alias the key alias to retrieve from the token
   * @param warn if we should log a warning if the key does not exist
   * @return the public key for the certificate represented by the given alias.
   * @throws KeyStoreException if the keystore has not been initialized.
   * @throws CryptoTokenOfflineException if Crypto Token is not available or
   *     connected.
   */
  protected PublicKey readPublicKey(final String alias, final boolean warn)
      throws KeyStoreException, CryptoTokenOfflineException {
    try {
<span class="fc" id="L216">      Certificate cert = getKeyStore().getCertificate(alias);</span>
<span class="fc" id="L217">      PublicKey pubk = null;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">      if (cert != null) {</span>
<span class="fc" id="L219">        pubk = cert.getPublicKey();</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">      } else if (warn) {</span>
<span class="fc" id="L221">        LOG.warn(INTRES.getLocalizedMessage(&quot;token.nopublic&quot;, alias));</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L223">          Enumeration&lt;String&gt; en = getKeyStore().aliases();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">          while (en.hasMoreElements()) {</span>
<span class="nc" id="L225">            LOG.debug(&quot;Existing alias: &quot; + en.nextElement());</span>
          }
        }
      }
<span class="fc" id="L229">      return pubk;</span>
<span class="nc" id="L230">    } catch (ProviderException e) {</span>
<span class="nc" id="L231">      throw new CryptoTokenOfflineException(e);</span>
    }
  }

  /**
   * Initiates the class members of this crypto token.
   *
   * @param aProperties A Properties object containing
   *     properties for this token.
   * @param doAutoActivate Set true if activation of this crypto token should
   *     happen in this method.
   * @param anId ID of this crypto token.
   */
  protected void init(
          final Properties aProperties,
          final boolean doAutoActivate,
          final int anId) {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L249">      LOG.debug(&quot;&gt;init: doAutoActivate=&quot; + doAutoActivate);</span>
    }
<span class="fc" id="L251">    this.id = anId;</span>
    // Set basic properties that are of dynamic nature
<span class="fc" id="L253">    setProperties(aProperties);</span>
    // Set properties that can not change dynamically

<span class="fc bfc" id="L256" title="All 2 branches covered.">    if (doAutoActivate) {</span>
<span class="fc" id="L257">      autoActivate();</span>
    }
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L260">      LOG.debug(&quot;&lt;init: doAutoActivate=&quot; + doAutoActivate);</span>
    }
<span class="fc" id="L262">  }</span>

  @Override
  public int getId() {
<span class="fc" id="L266">    return this.id;</span>
  }

  /**
   * @param anId ID
   */
  public void setId(final int anId) {
<span class="nc" id="L273">    this.id = anId;</span>
<span class="nc" id="L274">  }</span>

  @Override
  public String getTokenName() {
<span class="nc" id="L278">    return properties.getProperty(CryptoToken.TOKENNAME_PROPERTY);</span>
  }

  @Override
  public void setTokenName(final String tokenName) {
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">    if (properties == null) {</span>
<span class="nc" id="L284">      this.properties = new Properties();</span>
    }
<span class="fc" id="L286">    properties.setProperty(CryptoToken.TOKENNAME_PROPERTY, tokenName);</span>
<span class="fc" id="L287">  }</span>

  @Override
  public Properties getProperties() {
<span class="fc" id="L291">    return properties;</span>
  }

  @Override
  public void setProperties(final Properties aProperties) {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">    if (aProperties == null) {</span>
<span class="nc" id="L297">      this.properties = new Properties();</span>
    } else {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
        // This is only a sections for debug logging. If we have enabled debug
        // logging we don't want to display any password in the log.
        // These properties may contain autoactivation PIN codes and we will,
        // only when debug logging, replace this with &quot;hidden&quot;.
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (aProperties.containsKey(CryptoToken.AUTOACTIVATE_PIN_PROPERTY)</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            || aProperties.containsKey(&quot;PIN&quot;)) {</span>
<span class="nc" id="L306">          Properties prop = new Properties();</span>
<span class="nc" id="L307">          prop.putAll(aProperties);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">          if (aProperties.containsKey(CryptoToken.AUTOACTIVATE_PIN_PROPERTY)) {</span>
<span class="nc" id="L309">            prop.setProperty(CryptoToken.AUTOACTIVATE_PIN_PROPERTY, &quot;hidden&quot;);</span>
          }
<span class="nc bnc" id="L311" title="All 2 branches missed.">          if (aProperties.containsKey(&quot;PIN&quot;)) {</span>
<span class="nc" id="L312">            prop.setProperty(&quot;PIN&quot;, &quot;hidden&quot;);</span>
          }
<span class="nc bnc" id="L314" title="All 2 branches missed.">          LOG.debug(&quot;Prop: &quot; + (prop != null ? prop.toString() : &quot;null&quot;));</span>
<span class="nc" id="L315">        } else {</span>
          // If no autoactivation PIN codes exists we can debug log everything
          // as original.
<span class="nc" id="L318">          LOG.debug(</span>
              &quot;Properties: &quot;
<span class="nc bnc" id="L320" title="All 2 branches missed.">                  + (aProperties != null ? aProperties.toString() : &quot;null&quot;));</span>
        }
      } // if (log.isDebugEnabled())
<span class="fc" id="L323">      this.properties = aProperties;</span>
<span class="fc" id="L324">      String authCode = BaseCryptoToken.getAutoActivatePin(aProperties);</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">      this.mAuthCode = authCode == null ? null : authCode.toCharArray();</span>
    }
<span class="fc" id="L327">  } // setProperties</span>

  /**
   * Retrieves the auto activation PIN code, if it has been set for this crypto
   * token. With an auto activation PIN the token does not have to be manually
   * activated.
   *
   * @param aProperties the crypto token properties that may contain auto
   *     activation PIN code
   * @return String or null
   */
  public static String getAutoActivatePin(final Properties aProperties) {
<span class="fc" id="L339">    final String pin =</span>
<span class="fc" id="L340">        aProperties.getProperty(CryptoToken.AUTOACTIVATE_PIN_PROPERTY);</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">    if (pin != null) {</span>
<span class="fc" id="L342">      return StringTools.passwordDecryption(pin, &quot;autoactivation pin&quot;);</span>
    }
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L345">      LOG.debug(&quot;Not using autoactivation pin&quot;);</span>
    }
<span class="fc" id="L347">    return null;</span>
  }

  /**
   * Sets auto activation pin in passed in properties. Also returns the string
   * format of the autoactivation properties: pin mypassword
   *
   * @param properties a Properties bag where to set the auto activation pin,
   *     can be null if you only want to create the return string, does not set
   *     a null or empty password
   * @param pin the activation password
   * @param encrypt if the PIN should be encrypted with the configured password
   *     encryption key
   * @return A string that can be used to &quot;setProperties&quot; of a CryptoToken or
   *     null if pin is null or an empty string, this can safely be ignored if
   *     you don't know what to do with it
   */
  public static String setAutoActivatePin(
      final Properties properties,
      final String pin,
      final boolean encrypt) {
<span class="fc" id="L368">    String ret = null;</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">    if (StringUtils.isNotEmpty(pin)) {</span>
<span class="fc" id="L370">      String authcode = pin;</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">      if (encrypt) {</span>
        try {
<span class="fc" id="L373">          authcode = StringTools.pbeEncryptStringWithSha256Aes192(pin);</span>
<span class="nc" id="L374">        } catch (Exception e) {</span>
<span class="nc" id="L375">          LOG.error(INTRES.getLocalizedMessage(&quot;token.nopinencrypt&quot;), e);</span>
<span class="nc" id="L376">          authcode = pin;</span>
<span class="fc" id="L377">        }</span>
      }
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">      if (properties != null) {</span>
<span class="fc" id="L380">        properties.setProperty(CryptoToken.AUTOACTIVATE_PIN_PROPERTY, authcode);</span>
      }
<span class="fc" id="L382">      ret = CryptoToken.AUTOACTIVATE_PIN_PROPERTY + &quot; &quot; + authcode;</span>
    }
<span class="fc" id="L384">    return ret;</span>
  }

  /**
   * Sets both signature and encryption providers. If encryption provider is the
   * same as signature provider this class name can be null.
   *
   * @param jcaProviderClassName signature provider class name
   * @param jceProviderClassName encryption provider class name, can be null
   * @throws ClassNotFoundException if the class specified by
   *     jcaProviderClassName could not be found.
   * @throws IllegalAccessException if the default constructor for the class
   *     specified by jcaProviderClassName was not public
   * @throws InstantiationException if the class specified by
   *     jcaProviderClassName was an abstract class, an interface, an array
   *     class, a primitive type, or void; or if it has no nullary constructor;
   *     or if the instantiation fails for some other reason.
   * @throws NoSuchMethodException in constructor not found
   * @throws InvocationTargetException If the underlying constructor throws an
   *     exception
   * @see #setJCAProvider(Provider)
   */
  protected void setProviders(
      final String jcaProviderClassName, final String jceProviderClassName)
      throws InstantiationException, IllegalAccessException,
          ClassNotFoundException, InvocationTargetException,
          NoSuchMethodException {
<span class="nc" id="L411">    Provider jcaProvider =</span>
        (Provider)
<span class="nc" id="L413">            Class.forName(jcaProviderClassName).getConstructor().newInstance();</span>
<span class="nc" id="L414">    setProvider(jcaProvider);</span>
<span class="nc" id="L415">    this.mJcaProviderName = jcaProvider.getName();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">    if (jceProviderClassName != null) {</span>
      try {
<span class="nc" id="L418">        Provider jceProvider =</span>
            (Provider)
<span class="nc" id="L420">                Class.forName(jceProviderClassName)</span>
<span class="nc" id="L421">                    .getConstructor()</span>
<span class="nc" id="L422">                    .newInstance();</span>
<span class="nc" id="L423">        setProvider(jceProvider);</span>
<span class="nc" id="L424">        this.mJceProviderName = jceProvider.getName();</span>
<span class="nc" id="L425">      } catch (Exception e) {</span>
<span class="nc" id="L426">        LOG.error(INTRES.getLocalizedMessage(&quot;token.jceinitfail&quot;), e);</span>
<span class="nc" id="L427">      }</span>
    } else {
<span class="nc" id="L429">      this.mJceProviderName = null;</span>
    }
<span class="nc" id="L431">  }</span>

  @Override
  public void storeKey(
      final String alias,
      final Key key,
      final Certificate[] chain,
      final char[] password)
      throws KeyStoreException {
    // Removal of old key is only needed for sun-p11 with none ASCII chars in
    // the alias.
    // But it makes no harm to always do it and it should be fast.
    // If not done the entry will not be stored correctly in the p11 KeyStore.
<span class="nc" id="L444">    this.keyStore.deleteEntry(alias);</span>
<span class="nc" id="L445">    this.keyStore.setKeyEntry(alias, key, password, chain);</span>
<span class="nc" id="L446">  }</span>

  /**
   * If we only have one provider to handle both JCA and JCE, and perhaps it is
   * not so straightforward to create the provider (for example PKCS#11
   * provider), we can create the provider in sub class and set it here, instead
   * of calling setProviders.
   *
   * @param prov the fully constructed Provider
   * @see #setProviders(String, String)
   */
  protected void setJCAProvider(final Provider prov) {
<span class="nc" id="L458">    setProvider(prov);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">    this.mJcaProviderName = prov != null ? prov.getName() : null;</span>
<span class="nc" id="L460">  }</span>

  /**
   * If we don't use any of the methods to set a specific provider, but use some
   * already existing provider we should set the name of that provider at least.
   *
   * @param pName the provider name as retriever from Provider.getName()
   */
  protected void setJCAProviderName(final String pName) {
<span class="fc" id="L469">    this.mJcaProviderName = pName;</span>
<span class="fc" id="L470">  }</span>

  private void setProvider(final Provider prov) {
<span class="nc bnc" id="L473" title="All 2 branches missed.">    if (prov != null) {</span>
<span class="nc" id="L474">      String pName = prov.getName();</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">      if (pName.startsWith(&quot;LunaJCA&quot;)) {</span>
        // Luna Java provider does not contain support for RSA/ECB/PKCS1Padding
        // but this is
        // the same as the alias below on small amounts of data
<span class="nc" id="L479">        prov.put(&quot;Alg.Alias.Cipher.RSA/NONE/NoPadding&quot;, &quot;RSA//NoPadding&quot;);</span>
<span class="nc" id="L480">        prov.put(&quot;Alg.Alias.Cipher.1.2.840.113549.1.1.1&quot;, &quot;RSA//NoPadding&quot;);</span>
<span class="nc" id="L481">        prov.put(&quot;Alg.Alias.Cipher.RSA/ECB/PKCS1Padding&quot;, &quot;RSA//PKCS1v1_5&quot;);</span>
<span class="nc" id="L482">        prov.put(</span>
            &quot;Alg.Alias.Cipher.1.2.840.113549.3.7&quot;, &quot;DES3/CBC/PKCS5Padding&quot;);
      }
      // The provider will typically not be installed here. The BC provider (for
      // soft crypto tokens)
      // is installed during startup, as a generally used provider,
      // and the P11 provider for a specific slot is installed in #P11Slot
<span class="nc bnc" id="L489" title="All 2 branches missed.">      if (Security.getProvider(pName) == null) {</span>
<span class="nc" id="L490">        LOG.info(&quot;Adding Provider from BaseCryptoToken: &quot; + pName);</span>
<span class="nc" id="L491">        Security.addProvider(prov);</span>
      }
<span class="nc bnc" id="L493" title="All 2 branches missed.">      if (Security.getProvider(pName) == null) {</span>
<span class="nc" id="L494">        throw new ProviderException(</span>
            &quot;Not possible to install provider from BaseCryptoToken: &quot; + pName);
      }
<span class="nc" id="L497">    } else {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L499">        LOG.debug(&quot;No provider passed to setProvider()&quot;);</span>
      }
    }
<span class="nc" id="L502">  }</span>

  @Override
  public String getSignProviderName() {
<span class="fc" id="L506">    return this.mJcaProviderName;</span>
  }

  @Override
  public String getEncProviderName() {
    // If we don't have a specific JCE provider, it is most likely the same
    // as the JCA provider
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">    if (this.mJceProviderName == null) {</span>
<span class="fc" id="L514">      return this.mJcaProviderName;</span>
    }
<span class="nc" id="L516">    return this.mJceProviderName;</span>
  }

  @Override
  public boolean isAliasUsed(final String alias) {
<span class="nc" id="L521">    boolean aliasInUse = false;</span>
    try {
<span class="nc" id="L523">      getPublicKey(alias, false);</span>
<span class="nc" id="L524">      aliasInUse = true;</span>
<span class="nc" id="L525">    } catch (CryptoTokenOfflineException e) {</span>
      try {
<span class="nc" id="L527">        getPrivateKey(alias, false);</span>
<span class="nc" id="L528">        aliasInUse = true;</span>
<span class="nc" id="L529">      } catch (CryptoTokenOfflineException e2) {</span>
        try {
<span class="nc" id="L531">          getKey(alias, false);</span>
<span class="nc" id="L532">          aliasInUse = true;</span>
<span class="nc" id="L533">        } catch (CryptoTokenOfflineException e3) {</span>
<span class="nc" id="L534">        }</span>
<span class="nc" id="L535">      }</span>
<span class="nc" id="L536">    }</span>
<span class="nc" id="L537">    return aliasInUse;</span>
  }

  @Override
  public PrivateKey getPrivateKey(final String alias)
      throws CryptoTokenOfflineException {
<span class="fc" id="L543">    return getPrivateKey(alias, true);</span>
  }

  /**
   * @param alias Alias
   * @see #getPrivateKey(String)
   * @param warn if we should log a warning if the key does not exist
   * @return Private key
   * @throws CryptoTokenOfflineException if offline
   */
  private PrivateKey getPrivateKey(final String alias, final boolean warn)
      throws CryptoTokenOfflineException {
    // Auto activate is done in the call to getKeyStore below
    try {
<span class="fc" id="L557">      final PrivateKey privateK =</span>
          (PrivateKey)
<span class="fc" id="L559">              getKeyStore()</span>
<span class="fc" id="L560">                  .getKey(</span>
                      alias,
<span class="pc bpc" id="L562" title="1 of 4 branches missed.">                      (mAuthCode != null &amp;&amp; mAuthCode.length &gt; 0)</span>
<span class="fc" id="L563">                          ? mAuthCode</span>
<span class="fc" id="L564">                          : null);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">      if (privateK == null) {</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if (warn) {</span>
<span class="fc" id="L567">          LOG.warn(INTRES.getLocalizedMessage(&quot;token.noprivate&quot;, alias));</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
            final Enumeration&lt;String&gt; aliases;
<span class="nc" id="L570">            aliases = getKeyStore().aliases();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            while (aliases.hasMoreElements()) {</span>
<span class="nc" id="L572">              LOG.debug(&quot;Existing alias: &quot; + aliases.nextElement());</span>
            }
          }
        }
<span class="fc" id="L576">        final String msg =</span>
<span class="fc" id="L577">            INTRES.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias);</span>
<span class="fc" id="L578">        throw new CryptoTokenOfflineException(msg);</span>
      }
<span class="fc" id="L580">      return privateK;</span>
<span class="nc" id="L581">    } catch (KeyStoreException e) {</span>
<span class="nc" id="L582">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L583">    } catch (UnrecoverableKeyException e) {</span>
<span class="nc" id="L584">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L585">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L586">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L587">    } catch (ProviderException e) {</span>
<span class="nc" id="L588">      throw new CryptoTokenOfflineException(e);</span>
    }
  }

  @Override
  public PublicKey getPublicKey(final String alias)
      throws CryptoTokenOfflineException {
<span class="fc" id="L595">    return getPublicKey(alias, true);</span>
  }

  /**
   * @param alias alias
   * @see #getPublicKey(String)
   * @param warn if we should log a warning if the key does not exist
   * @return Public key
   * @throws CryptoTokenOfflineException if offline
   */
  private PublicKey getPublicKey(final String alias, final boolean warn)
      throws CryptoTokenOfflineException {
    // Auto activate is done in the call to getKeyStore below (from
    // readPublicKey)
    try {
<span class="fc" id="L610">      PublicKey publicK = readPublicKey(alias, warn);</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">      if (publicK == null) {</span>
<span class="fc" id="L612">        final String msg =</span>
<span class="fc" id="L613">            INTRES.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias);</span>
<span class="fc" id="L614">        throw new CryptoTokenOfflineException(msg);</span>
      }
<span class="fc" id="L616">      final String str =</span>
<span class="fc" id="L617">          getProperties()</span>
<span class="fc" id="L618">              .getProperty(CryptoToken.EXPLICIT_ECC_PUBLICKEY_PARAMETERS);</span>
<span class="fc" id="L619">      final boolean explicitEccParameters = Boolean.parseBoolean(str);</span>
<span class="pc bpc" id="L620" title="3 of 4 branches missed.">      if (explicitEccParameters &amp;&amp; publicK.getAlgorithm().equals(&quot;EC&quot;)) {</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L622">          LOG.debug(&quot;Using explicit parameter encoding for ECC key.&quot;);</span>
        }
<span class="nc" id="L624">        publicK =</span>
<span class="nc" id="L625">            ECKeyUtil.publicToExplicitParameters(</span>
                publicK, BouncyCastleProvider.PROVIDER_NAME);
      }
<span class="fc" id="L628">      return publicK;</span>
<span class="nc" id="L629">    } catch (KeyStoreException e) {</span>
<span class="nc" id="L630">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L631">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L632">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L633">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L634">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L635">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L636">      throw new CryptoTokenOfflineException(e);</span>
    }
  }

  @Override
  public Key getKey(final String alias) throws CryptoTokenOfflineException {
<span class="fc" id="L642">    return getKey(alias, true);</span>
  }

  /**
   * see {@link #getKey(String)}.
   *
   * @param alias alias
   * @param warn if we should log a warning if the key does not exist
   * @return key
   * @throws CryptoTokenOfflineException if offline
   */
  private Key getKey(final String alias, final boolean warn)
      throws CryptoTokenOfflineException {
    // Auto activate is done in the call to getKeyStore below
    try {
<span class="fc" id="L657">      Key key =</span>
<span class="fc" id="L658">          getKeyStore()</span>
<span class="fc" id="L659">              .getKey(</span>
                  alias,
<span class="pc bpc" id="L661" title="3 of 4 branches missed.">                  (mAuthCode != null &amp;&amp; mAuthCode.length &gt; 0)</span>
<span class="nc" id="L662">                      ? mAuthCode</span>
<span class="fc" id="L663">                      : null);</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">      if (key == null) {</span>
        // Do we have it stored as a soft key in properties?
<span class="fc" id="L666">        key = getKeyFromProperties(alias);</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">          if (warn) {</span>
<span class="nc" id="L669">            LOG.warn(INTRES.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias));</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
              Enumeration&lt;String&gt; aliases;
<span class="nc" id="L672">              aliases = getKeyStore().aliases();</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">              while (aliases.hasMoreElements()) {</span>
<span class="nc" id="L674">                LOG.debug(&quot;Existing alias: &quot; + aliases.nextElement());</span>
              }
            }
          }
<span class="nc" id="L678">          final String msg =</span>
<span class="nc" id="L679">              INTRES.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias);</span>
<span class="nc" id="L680">          throw new CryptoTokenOfflineException(msg);</span>
        }
      }
<span class="fc" id="L683">      return key;</span>
<span class="nc" id="L684">    } catch (KeyStoreException e) {</span>
<span class="nc" id="L685">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L686">    } catch (UnrecoverableKeyException e) {</span>
<span class="nc" id="L687">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L688">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L689">      throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L690">    } catch (ProviderException e) {</span>
<span class="nc" id="L691">      throw new CryptoTokenOfflineException(e);</span>
    }
  }

  private Key getKeyFromProperties(final String alias) {
<span class="fc" id="L696">    Key key = null;</span>
<span class="fc" id="L697">    Properties prop = getProperties();</span>
<span class="fc" id="L698">    String str = prop.getProperty(alias);</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">    if (StringUtils.isNotEmpty(str)) {</span>
      // TODO: unwrapping with rsa key is also needed later on
      try {
<span class="fc" id="L702">        PrivateKey privK = getPrivateKey(&quot;symwrap&quot;);</span>
<span class="fc" id="L703">        Cipher cipher =</span>
<span class="fc" id="L704">            Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;, getEncProviderName());</span>
<span class="fc" id="L705">        cipher.init(Cipher.UNWRAP_MODE, privK);</span>
<span class="fc" id="L706">        byte[] bytes = Hex.decode(str);</span>
        // TODO: hardcoded AES for now
<span class="fc" id="L708">        key = cipher.unwrap(bytes, &quot;AES&quot;, Cipher.SECRET_KEY);</span>
<span class="nc" id="L709">      } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L710">        LOG.debug(e);</span>
<span class="nc" id="L711">      } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L712">        LOG.debug(e);</span>
<span class="nc" id="L713">      } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L714">        LOG.debug(e);</span>
<span class="nc" id="L715">      } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L716">        LOG.debug(e);</span>
<span class="nc" id="L717">      } catch (InvalidKeyException e) {</span>
<span class="nc" id="L718">        LOG.debug(e);</span>
<span class="pc" id="L719">      }</span>
    }
<span class="fc" id="L721">    return key;</span>
  }

  @Override
  public void reset() {
    // do nothing. the implementing class decides whether something could be
    // done to get the HSM working after a failure.
<span class="nc" id="L728">  }</span>

  @Override
  public int getTokenStatus() {
    // Auto activate is done in the call to getKeyStore below
<span class="fc" id="L733">    int ret = CryptoToken.STATUS_OFFLINE;</span>
    try {
<span class="fc" id="L735">      getKeyStore();</span>
<span class="fc" id="L736">      ret = CryptoToken.STATUS_ACTIVE;</span>
<span class="fc" id="L737">    } catch (CryptoTokenOfflineException e) {</span>
      // NOPMD, ignore status is offline
<span class="fc" id="L739">    }</span>
<span class="fc" id="L740">    return ret;</span>
  }

  @Override
  public List&lt;String&gt; getAliases()
      throws KeyStoreException, CryptoTokenOfflineException {
<span class="nc" id="L746">    return Collections.list(getKeyStore().aliases());</span>
  }

  @Override
  public boolean isAutoActivationPinPresent() {
<span class="nc bnc" id="L751" title="All 2 branches missed.">    return getAutoActivatePin(getProperties()) != null;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>