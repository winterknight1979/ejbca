<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>BaseCryptoToken.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">ejbca-test-aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.token</a> &gt; <span class="el_source">BaseCryptoToken.java</span></div><h1>BaseCryptoToken.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.token;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.ProviderException;
import java.security.PublicKey;
import java.security.Security;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Properties;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.jce.ECKeyUtil;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.util.StringTools;

/**
 * Base class for crypto tokens handling things that are common for all crypto tokens, hard or soft.
 *
 * @version $Id: BaseCryptoToken.java 30502 2018-11-14 13:44:43Z anatom $
 */
public abstract class BaseCryptoToken implements CryptoToken {

    private static final long serialVersionUID = 2133644669863292622L;

    /** Log4j instance */
<span class="fc" id="L59">    private static final Logger log = Logger.getLogger(BaseCryptoToken.class);</span>
    /** Internal localization of logs and errors */
<span class="fc" id="L61">    private static final InternalResources intres = InternalResources.getInstance();</span>

    /** Used for signatures */
<span class="fc" id="L64">    private String mJcaProviderName = null;</span>
    /** Used for encrypt/decrypt, can be same as for signatures for example for pkcs#11 */
<span class="fc" id="L66">    private String mJceProviderName = null;</span>
    
    private char[] mAuthCode;

    private Properties properties;

    private int id;

    /** The java KeyStore backing the Crypto Token */
    protected transient CachingKeyStoreWrapper keyStore;

    /** public constructor */
    public BaseCryptoToken() {
<span class="fc" id="L79">        super();</span>
<span class="fc" id="L80">    }</span>

    protected void setKeyStore(KeyStore keystore) throws KeyStoreException {
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (keystore==null) {</span>
<span class="fc" id="L84">            this.keyStore = null;</span>
        } else {
<span class="fc" id="L86">            this.keyStore = new CachingKeyStoreWrapper(keystore, CesecoreConfiguration.isKeyStoreCacheEnabled());</span>
        }
<span class="fc" id="L88">    }</span>

    /**
     * Return the key store for this crypto token.
     *
     * @return the keystore.
     * @throws CryptoTokenOfflineException if Crypto Token is not available or connected.
     */
    protected CachingKeyStoreWrapper getKeyStore() throws CryptoTokenOfflineException {
<span class="fc" id="L97">        autoActivate();</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (this.keyStore == null) {</span>
<span class="fc" id="L99">            final String msg = intres.getLocalizedMessage(&quot;token.errorinstansiate&quot;, mJcaProviderName, &quot;keyStore (&quot;+id+&quot;) == null&quot;);</span>
<span class="fc" id="L100">            throw new CryptoTokenOfflineException(msg);</span>
        }
<span class="fc" id="L102">        return this.keyStore;</span>
    }

    /**
     * TODO: This structure is confusing, with exceptions being thrown, caught, ignored and then rethrown at a later stage. Please fix.
     *
     */
    protected void autoActivate() {
<span class="fc bfc" id="L110" title="All 4 branches covered.">        if ((this.mAuthCode != null) &amp;&amp; (this.keyStore == null)) {</span>
            try {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L113">                    log.debug(&quot;Trying to autoactivate CryptoToken&quot;);</span>
                }
<span class="fc" id="L115">                activate(this.mAuthCode);</span>
<span class="nc" id="L116">            } catch (Exception e) {</span>
<span class="nc" id="L117">                log.debug(e);</span>
<span class="fc" id="L118">            }</span>
        }
<span class="fc" id="L120">    }</span>

    /**
     * Do we permit extractable private keys? Only SW keys should be permitted to be extractable, an overriding crypto token class can override this
     * value.
     *
     * @return false if the key must not be extractable
     */
    public boolean doPermitExtractablePrivateKey() {
<span class="nc bnc" id="L129" title="All 2 branches missed.">        return getProperties().containsKey(CryptoToken.ALLOW_EXTRACTABLE_PRIVATE_KEY) &amp;&amp;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">               Boolean.parseBoolean(getProperties().getProperty(CryptoToken.ALLOW_EXTRACTABLE_PRIVATE_KEY));</span>
    }
    
    /** Similar to the method above, but only applies for internal testing of keys. This method is called during testKeyPair to verify that a key
     * that is extractable can never be used, unless we allow extractable private keys. Used for PKCS#11 (HSMs) to ensure that they are configured
     * correctly. On a PKCS11 Crypto Token, this should return the same as doPermitExtractablePrivateKey(), on a Soft Crypto Token this should always return true.
     *
     * @return false if the key must not be extractable, this will throw an error if the key is extractable when crypto token tries to test it.
     */
    public abstract boolean permitExtractablePrivateKeyForTest();
    
    @Override
    public void testKeyPair(final String alias) throws InvalidKeyException, CryptoTokenOfflineException { // NOPMD:this is not a junit test
<span class="fc" id="L143">        final PrivateKey privateKey = getPrivateKey(alias);</span>
<span class="fc" id="L144">        final PublicKey publicKey = getPublicKey(alias);</span>
<span class="fc" id="L145">        testKeyPair(alias, publicKey, privateKey);</span>
<span class="fc" id="L146">    }</span>

    @Override
    public void testKeyPair(final String alias, PublicKey publicKey, PrivateKey privateKey) throws InvalidKeyException { // NOPMD:this is not a junit test
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L151">            final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L152">            final PrintStream ps = new PrintStream(baos);</span>
<span class="nc" id="L153">            KeyTools.printPublicKeyInfo(publicKey, ps);</span>
<span class="nc" id="L154">            ps.flush();</span>
<span class="nc" id="L155">            log.debug(&quot;Testing key of type &quot; + baos.toString());</span>
        }
<span class="pc bpc" id="L157" title="3 of 4 branches missed.">        if (!permitExtractablePrivateKeyForTest() &amp;&amp; KeyTools.isPrivateKeyExtractable(privateKey)) {</span>
<span class="nc" id="L158">            String msg = intres.getLocalizedMessage(&quot;token.extractablekey&quot;, CesecoreConfiguration.isPermitExtractablePrivateKeys());</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (!CesecoreConfiguration.isPermitExtractablePrivateKeys()) {</span>
<span class="nc" id="L160">                throw new InvalidKeyException(msg);</span>
            }
<span class="nc" id="L162">            log.info(msg);</span>
        }
<span class="fc" id="L164">        KeyTools.testKey(privateKey, publicKey, getSignProviderName());</span>
<span class="fc" id="L165">    }</span>

    /**
     * Reads the public key object, does so from the certificate retrieved from the alias from the KeyStore.
     *
     * @param alias alias the key alias to retrieve from the token
     * @param warn if we should log a warning if the key does not exist
     * @return the public key for the certificate represented by the given alias.
     * @throws KeyStoreException if the keystore has not been initialized.
     * @throws CryptoTokenOfflineException if Crypto Token is not available or connected.
     */
    protected PublicKey readPublicKey(String alias, boolean warn) throws KeyStoreException, CryptoTokenOfflineException {
        try {
<span class="fc" id="L178">            Certificate cert = getKeyStore().getCertificate(alias);</span>
<span class="fc" id="L179">            PublicKey pubk = null;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (cert != null) {</span>
<span class="fc" id="L181">                pubk = cert.getPublicKey();</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">            } else if (warn) {</span>
<span class="fc" id="L183">                log.warn(intres.getLocalizedMessage(&quot;token.nopublic&quot;, alias));</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L185">                    Enumeration&lt;String&gt; en = getKeyStore().aliases();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                    while (en.hasMoreElements()) {</span>
<span class="nc" id="L187">                        log.debug(&quot;Existing alias: &quot; + en.nextElement());</span>
                    }
                }
            }
<span class="fc" id="L191">            return pubk;</span>
<span class="nc" id="L192">        } catch (ProviderException e) {</span>
<span class="nc" id="L193">            throw new CryptoTokenOfflineException(e);</span>
        }
    }

    /**
     * Initiates the class members of this crypto token.
     *
     * @param properties A Properties object containing properties for this token.
     * @param doAutoActivate Set true if activation of this crypto token should happen in this method.
     * @param id ID of this crypto token.
     */
    protected void init(Properties properties, boolean doAutoActivate, int id) {
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L206">            log.debug(&quot;&gt;init: doAutoActivate=&quot; + doAutoActivate);</span>
        }
<span class="fc" id="L208">        this.id = id;</span>
        // Set basic properties that are of dynamic nature
<span class="fc" id="L210">        setProperties(properties);</span>
        // Set properties that can not change dynamically
        
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (doAutoActivate) {</span>
<span class="fc" id="L214">            autoActivate();</span>
        }
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L217">            log.debug(&quot;&lt;init: doAutoActivate=&quot; + doAutoActivate);</span>
        }
<span class="fc" id="L219">    }</span>

    @Override
    public int getId() {
<span class="fc" id="L223">        return this.id;</span>
    }

    public void setId(final int id) {
<span class="nc" id="L227">        this.id = id;</span>
<span class="nc" id="L228">    }</span>

    @Override
    public String getTokenName() {
<span class="nc" id="L232">        return properties.getProperty(CryptoToken.TOKENNAME_PROPERTY);</span>
    }

    @Override
    public void setTokenName(final String tokenName) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (properties == null) {</span>
<span class="nc" id="L238">            this.properties = new Properties();</span>
        }
<span class="fc" id="L240">        properties.setProperty(CryptoToken.TOKENNAME_PROPERTY, tokenName);</span>
<span class="fc" id="L241">    }</span>
    
    @Override
    public Properties getProperties() {
<span class="fc" id="L245">        return properties;</span>
    }

    @Override
    public void setProperties(Properties properties) {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (properties == null) {</span>
<span class="nc" id="L251">            this.properties = new Properties();</span>
        } else {
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
                // This is only a sections for debug logging. If we have enabled debug logging we don't want to display any password in the log.
                // These properties may contain autoactivation PIN codes and we will, only when debug logging, replace this with &quot;hidden&quot;.
<span class="nc bnc" id="L256" title="All 4 branches missed.">                if (properties.containsKey(CryptoToken.AUTOACTIVATE_PIN_PROPERTY) || properties.containsKey(&quot;PIN&quot;)) {</span>
<span class="nc" id="L257">                    Properties prop = new Properties();</span>
<span class="nc" id="L258">                    prop.putAll(properties);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                    if (properties.containsKey(CryptoToken.AUTOACTIVATE_PIN_PROPERTY)) {</span>
<span class="nc" id="L260">                        prop.setProperty(CryptoToken.AUTOACTIVATE_PIN_PROPERTY, &quot;hidden&quot;);</span>
                    }
<span class="nc bnc" id="L262" title="All 2 branches missed.">                    if (properties.containsKey(&quot;PIN&quot;)) {</span>
<span class="nc" id="L263">                        prop.setProperty(&quot;PIN&quot;, &quot;hidden&quot;);</span>
                    }
<span class="nc bnc" id="L265" title="All 2 branches missed.">                    log.debug(&quot;Prop: &quot; + (prop != null ? prop.toString() : &quot;null&quot;));</span>
<span class="nc" id="L266">                } else {</span>
                    // If no autoactivation PIN codes exists we can debug log everything as original.
<span class="nc bnc" id="L268" title="All 2 branches missed.">                    log.debug(&quot;Properties: &quot; + (properties != null ? properties.toString() : &quot;null&quot;));</span>
                }
            } // if (log.isDebugEnabled())
<span class="fc" id="L271">            this.properties = properties;</span>
<span class="fc" id="L272">            String authCode = BaseCryptoToken.getAutoActivatePin(properties);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">            this.mAuthCode = authCode == null ? null : authCode.toCharArray();</span>
        }
<span class="fc" id="L275">    } // setProperties</span>

    /**
     * Retrieves the auto activation PIN code, if it has been set for this crypto token. With an auto activation PIN the token does not have to be
     * manually activated.
     *
     * @param properties the crypto token properties that may contain auto activation PIN code
     * @return String or null
     */
    public static String getAutoActivatePin(Properties properties) {
<span class="fc" id="L285">        final String pin = properties.getProperty(CryptoToken.AUTOACTIVATE_PIN_PROPERTY);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (pin != null) {</span>
<span class="fc" id="L287">            return StringTools.passwordDecryption(pin, &quot;autoactivation pin&quot;);</span>
        }
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L290">            log.debug(&quot;Not using autoactivation pin&quot;);</span>
        }
<span class="fc" id="L292">        return null;</span>
    }

    /**
     * Sets auto activation pin in passed in properties. Also returns the string format of the autoactivation properties: pin mypassword
     *
     * @param properties a Properties bag where to set the auto activation pin, can be null if you only want to create the return string, does not set
     *            a null or empty password
     * @param pin the activation password
     * @param encrypt if the PIN should be encrypted with the configured password encryption key
     * @return A string that can be used to &quot;setProperties&quot; of a CryptoToken or null if pin is null or an empty string, this can safely be ignored if
     *         you don't know what to do with it
     */
    public static String setAutoActivatePin(Properties properties, String pin, boolean encrypt) {
<span class="fc" id="L306">        String ret = null;</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(pin)) {</span>
<span class="fc" id="L308">            String authcode = pin;</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">            if (encrypt) {</span>
                try {
<span class="fc" id="L311">                    authcode = StringTools.pbeEncryptStringWithSha256Aes192(pin);</span>
<span class="nc" id="L312">                } catch (Exception e) {</span>
<span class="nc" id="L313">                    log.error(intres.getLocalizedMessage(&quot;token.nopinencrypt&quot;), e);</span>
<span class="nc" id="L314">                    authcode = pin;</span>
<span class="fc" id="L315">                }</span>
            }
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if (properties != null) {</span>
<span class="fc" id="L318">                properties.setProperty(CryptoToken.AUTOACTIVATE_PIN_PROPERTY, authcode);</span>
            }
<span class="fc" id="L320">            ret = CryptoToken.AUTOACTIVATE_PIN_PROPERTY + &quot; &quot; + authcode;</span>
        }
<span class="fc" id="L322">        return ret;</span>
    }

    /**
     * Sets both signature and encryption providers. If encryption provider is the same as signature provider this class name can be null.
     *
     * @param jcaProviderClassName signature provider class name
     * @param jceProviderClassName encryption provider class name, can be null
     * @throws ClassNotFoundException if the class specified by jcaProviderClassName could not be found.
     * @throws IllegalAccessException if the default constructor for the class specified by jcaProviderClassName was not public
     * @throws InstantiationException if the class specified by jcaProviderClassName was an abstract class, an interface, an array class, a primitive
     *             type, or void; or if it has no nullary constructor; or if the instantiation fails for some other reason.
     * 
     * @throws NoSuchMethodException in constructor not found
     * @throws InvocationTargetException If the underlying constructor throws an exception
     * @see #setJCAProvider(Provider)
     */
    protected void setProviders(String jcaProviderClassName, String jceProviderClassName) throws InstantiationException, IllegalAccessException,
            ClassNotFoundException, InvocationTargetException, NoSuchMethodException {
<span class="nc" id="L341">        Provider jcaProvider = (Provider) Class.forName(jcaProviderClassName).getConstructor().newInstance();</span>
<span class="nc" id="L342">        setProvider(jcaProvider);</span>
<span class="nc" id="L343">        this.mJcaProviderName = jcaProvider.getName();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (jceProviderClassName != null) {</span>
            try {
<span class="nc" id="L346">                Provider jceProvider = (Provider) Class.forName(jceProviderClassName).getConstructor().newInstance();</span>
<span class="nc" id="L347">                setProvider(jceProvider);</span>
<span class="nc" id="L348">                this.mJceProviderName = jceProvider.getName();</span>
<span class="nc" id="L349">            } catch (Exception e) {</span>
<span class="nc" id="L350">                log.error(intres.getLocalizedMessage(&quot;token.jceinitfail&quot;), e);</span>
<span class="nc" id="L351">            }</span>
        } else {
<span class="nc" id="L353">            this.mJceProviderName = null;</span>
        }
<span class="nc" id="L355">    }</span>
    
    @Override
    public void storeKey(String alias, Key key, Certificate[] chain, char[] password) throws KeyStoreException {
        // Removal of old key is only needed for sun-p11 with none ASCII chars in the alias.
        // But it makes no harm to always do it and it should be fast.
        // If not done the entry will not be stored correctly in the p11 KeyStore.
<span class="nc" id="L362">        this.keyStore.deleteEntry(alias);</span>
<span class="nc" id="L363">        this.keyStore.setKeyEntry(alias, key, password, chain);</span>
<span class="nc" id="L364">    }</span>

    /**
     * If we only have one provider to handle both JCA and JCE, and perhaps it is not so straightforward to create the provider (for example PKCS#11
     * provider), we can create the provider in sub class and set it here, instead of calling setProviders.
     *
     * @param prov the fully constructed Provider
     * @see #setProviders(String, String)
     */
    protected void setJCAProvider(Provider prov) {
<span class="nc" id="L374">        setProvider(prov);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        this.mJcaProviderName = prov != null ? prov.getName() : null;</span>
<span class="nc" id="L376">    }</span>

    /**
     * If we don't use any of the methods to set a specific provider, but use some already existing provider we should set the name of that provider
     * at least.
     *
     * @param pName the provider name as retriever from Provider.getName()
     */
    protected void setJCAProviderName(String pName) {
<span class="fc" id="L385">        this.mJcaProviderName = pName;</span>
<span class="fc" id="L386">    }</span>

    private void setProvider(Provider prov) {
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (prov != null) {</span>
<span class="nc" id="L390">            String pName = prov.getName();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (pName.startsWith(&quot;LunaJCA&quot;)) {</span>
                // Luna Java provider does not contain support for RSA/ECB/PKCS1Padding but this is
                // the same as the alias below on small amounts of data
<span class="nc" id="L394">                prov.put(&quot;Alg.Alias.Cipher.RSA/NONE/NoPadding&quot;, &quot;RSA//NoPadding&quot;);</span>
<span class="nc" id="L395">                prov.put(&quot;Alg.Alias.Cipher.1.2.840.113549.1.1.1&quot;, &quot;RSA//NoPadding&quot;);</span>
<span class="nc" id="L396">                prov.put(&quot;Alg.Alias.Cipher.RSA/ECB/PKCS1Padding&quot;, &quot;RSA//PKCS1v1_5&quot;);</span>
<span class="nc" id="L397">                prov.put(&quot;Alg.Alias.Cipher.1.2.840.113549.3.7&quot;, &quot;DES3/CBC/PKCS5Padding&quot;);</span>
            }
            // The provider will typically not be installed here. The BC provider (for soft crypto tokens)
            // is installed during startup, as a generally used provider, 
            // and the P11 provider for a specific slot is installed in #P11Slot
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (Security.getProvider(pName) == null) {</span>
<span class="nc" id="L403">                log.info(&quot;Adding Provider from BaseCryptoToken: &quot;+pName);</span>
<span class="nc" id="L404">                Security.addProvider(prov);</span>
            }
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (Security.getProvider(pName) == null) {</span>
<span class="nc" id="L407">                throw new ProviderException(&quot;Not possible to install provider from BaseCryptoToken: &quot; + pName);</span>
            }
<span class="nc" id="L409">        } else {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L411">                log.debug(&quot;No provider passed to setProvider()&quot;);</span>
            }
        }
<span class="nc" id="L414">    }</span>

    @Override
    public String getSignProviderName() {
<span class="fc" id="L418">        return this.mJcaProviderName;</span>
    }

    @Override
    public String getEncProviderName() {
        // If we don't have a specific JCE provider, it is most likely the same
        // as the JCA provider
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (this.mJceProviderName == null) {</span>
<span class="fc" id="L426">            return this.mJcaProviderName;</span>
        }
<span class="nc" id="L428">        return this.mJceProviderName;</span>
    }

    @Override
    public boolean isAliasUsed(final String alias) {
<span class="nc" id="L433">        boolean aliasInUse = false;</span>
        try {
<span class="nc" id="L435">            getPublicKey(alias, false);</span>
<span class="nc" id="L436">            aliasInUse = true;</span>
<span class="nc" id="L437">        } catch (CryptoTokenOfflineException e) {</span>
            try {
<span class="nc" id="L439">                getPrivateKey(alias, false);</span>
<span class="nc" id="L440">                aliasInUse = true;</span>
<span class="nc" id="L441">            } catch (CryptoTokenOfflineException e2) {</span>
                try {
<span class="nc" id="L443">                    getKey(alias, false);</span>
<span class="nc" id="L444">                    aliasInUse = true;</span>
<span class="nc" id="L445">                } catch (CryptoTokenOfflineException e3) {</span>
<span class="nc" id="L446">                }</span>
<span class="nc" id="L447">            }</span>
<span class="nc" id="L448">        }</span>
<span class="nc" id="L449">        return aliasInUse;</span>
    }
    
    @Override
    public PrivateKey getPrivateKey(final String alias) throws CryptoTokenOfflineException {
<span class="fc" id="L454">        return getPrivateKey(alias, true);</span>
    }

    /** @param alias Alias
     * @see #getPrivateKey(String) 
     * @param warn if we should log a warning if the key does not exist
     * @return Private key
     * @throws CryptoTokenOfflineException if offline 
     */
    private PrivateKey getPrivateKey(final String alias, boolean warn) throws CryptoTokenOfflineException {
        // Auto activate is done in the call to getKeyStore below
        try {
<span class="pc bpc" id="L466" title="1 of 4 branches missed.">            final PrivateKey privateK = (PrivateKey) getKeyStore().getKey(alias, (mAuthCode != null &amp;&amp; mAuthCode.length &gt; 0) ? mAuthCode : null);</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            if (privateK == null) {</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                if (warn) {</span>
<span class="fc" id="L469">                    log.warn(intres.getLocalizedMessage(&quot;token.noprivate&quot;, alias));</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
                        final Enumeration&lt;String&gt; aliases;
<span class="nc" id="L472">                        aliases = getKeyStore().aliases();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                        while (aliases.hasMoreElements()) {</span>
<span class="nc" id="L474">                            log.debug(&quot;Existing alias: &quot; + aliases.nextElement());</span>
                        }
                    }
                }
<span class="fc" id="L478">                final String msg = intres.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias);</span>
<span class="fc" id="L479">                throw new CryptoTokenOfflineException(msg);</span>
            }
<span class="fc" id="L481">            return privateK;</span>
<span class="nc" id="L482">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L483">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L484">        } catch (UnrecoverableKeyException e) {</span>
<span class="nc" id="L485">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L486">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L487">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L488">        } catch (ProviderException e) {</span>
<span class="nc" id="L489">            throw new CryptoTokenOfflineException(e);</span>
        }
    }

    @Override
    public PublicKey getPublicKey(final String alias) throws CryptoTokenOfflineException {
<span class="fc" id="L495">        return getPublicKey(alias, true);</span>
    }
    
    /** @param alias alias
     * @see #getPublicKey(String)
     * @param warn if we should log a warning if the key does not exist 
     * @return Public key
     * @throws CryptoTokenOfflineException if offline 
     */
    private PublicKey getPublicKey(final String alias, boolean warn) throws CryptoTokenOfflineException {
        // Auto activate is done in the call to getKeyStore below (from readPublicKey)
        try {
<span class="fc" id="L507">            PublicKey publicK = readPublicKey(alias, warn);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            if (publicK == null) {</span>
<span class="fc" id="L509">                final String msg = intres.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias);</span>
<span class="fc" id="L510">                throw new CryptoTokenOfflineException(msg);</span>
            }
<span class="fc" id="L512">            final String str = getProperties().getProperty(CryptoToken.EXPLICIT_ECC_PUBLICKEY_PARAMETERS);</span>
<span class="fc" id="L513">            final boolean explicitEccParameters = Boolean.parseBoolean(str);</span>
<span class="pc bpc" id="L514" title="3 of 4 branches missed.">            if (explicitEccParameters &amp;&amp; publicK.getAlgorithm().equals(&quot;EC&quot;)) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L516">                    log.debug(&quot;Using explicit parameter encoding for ECC key.&quot;);</span>
                }
<span class="nc" id="L518">                publicK = ECKeyUtil.publicToExplicitParameters(publicK, BouncyCastleProvider.PROVIDER_NAME);</span>
            }
<span class="fc" id="L520">            return publicK;</span>
<span class="nc" id="L521">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L522">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L523">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L524">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L525">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L526">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L527">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L528">            throw new CryptoTokenOfflineException(e);</span>
        }
    }

    @Override
    public Key getKey(final String alias) throws CryptoTokenOfflineException {
<span class="fc" id="L534">        return getKey(alias, true);</span>
    }

    /** see {@link #getKey(String)}
     * @param alias alias
     * @param warn if we should log a warning if the key does not exist 
     * @return key
     * @throws CryptoTokenOfflineException if offline
     */
    private Key getKey(final String alias, final boolean warn) throws CryptoTokenOfflineException {
        // Auto activate is done in the call to getKeyStore below
        try {
<span class="pc bpc" id="L546" title="3 of 4 branches missed.">            Key key = getKeyStore().getKey(alias, (mAuthCode != null &amp;&amp; mAuthCode.length &gt; 0) ? mAuthCode : null);</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">            if (key == null) {</span>
                // Do we have it stored as a soft key in properties?
<span class="fc" id="L549">                key = getKeyFromProperties(alias);</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">                if (key == null) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                    if (warn) {</span>
<span class="nc" id="L552">                        log.warn(intres.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias));</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                        if (log.isDebugEnabled()) {</span>
                            Enumeration&lt;String&gt; aliases;
<span class="nc" id="L555">                            aliases = getKeyStore().aliases();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                            while (aliases.hasMoreElements()) {</span>
<span class="nc" id="L557">                                log.debug(&quot;Existing alias: &quot; + aliases.nextElement());</span>
                            }
                        }
                    }
<span class="nc" id="L561">                    final String msg = intres.getLocalizedMessage(&quot;token.errornosuchkey&quot;, alias);</span>
<span class="nc" id="L562">                    throw new CryptoTokenOfflineException(msg);</span>
                }
            }
<span class="fc" id="L565">            return key;</span>
<span class="nc" id="L566">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L567">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L568">        } catch (UnrecoverableKeyException e) {</span>
<span class="nc" id="L569">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L570">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L571">            throw new CryptoTokenOfflineException(e);</span>
<span class="nc" id="L572">        } catch (ProviderException e) {</span>
<span class="nc" id="L573">            throw new CryptoTokenOfflineException(e);</span>
        }
    }

    private Key getKeyFromProperties(String alias) {
<span class="fc" id="L578">        Key key = null;</span>
<span class="fc" id="L579">        Properties prop = getProperties();</span>
<span class="fc" id="L580">        String str = prop.getProperty(alias);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(str)) {</span>
            // TODO: unwrapping with rsa key is also needed later on
            try {
<span class="fc" id="L584">                PrivateKey privK = getPrivateKey(&quot;symwrap&quot;);</span>
<span class="fc" id="L585">                Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;, getEncProviderName());</span>
<span class="fc" id="L586">                cipher.init(Cipher.UNWRAP_MODE, privK);</span>
<span class="fc" id="L587">                byte[] bytes = Hex.decode(str);</span>
                // TODO: hardcoded AES for now
<span class="fc" id="L589">                key = cipher.unwrap(bytes, &quot;AES&quot;, Cipher.SECRET_KEY);</span>
<span class="nc" id="L590">            } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L591">                log.debug(e);</span>
<span class="nc" id="L592">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L593">                log.debug(e);</span>
<span class="nc" id="L594">            } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L595">                log.debug(e);</span>
<span class="nc" id="L596">            } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L597">                log.debug(e);</span>
<span class="nc" id="L598">            } catch (InvalidKeyException e) {</span>
<span class="nc" id="L599">                log.debug(e);</span>
<span class="pc" id="L600">            }</span>
        }
<span class="fc" id="L602">        return key;</span>
    }

    @Override
    public void reset() {
        // do nothing. the implementing class decides whether something could be done to get the HSM working after a failure.
<span class="nc" id="L608">    }</span>

    @Override
    public int getTokenStatus() {
        // Auto activate is done in the call to getKeyStore below
<span class="fc" id="L613">        int ret = CryptoToken.STATUS_OFFLINE;</span>
        try {
<span class="fc" id="L615">            getKeyStore();</span>
<span class="fc" id="L616">            ret = CryptoToken.STATUS_ACTIVE;</span>
<span class="fc" id="L617">        } catch (CryptoTokenOfflineException e) {</span>
            // NOPMD, ignore status is offline
<span class="fc" id="L619">        }</span>
<span class="fc" id="L620">        return ret;</span>
    }    

    @Override
    public List&lt;String&gt; getAliases() throws KeyStoreException, CryptoTokenOfflineException {
<span class="nc" id="L625">        return Collections.list(getKeyStore().aliases());</span>
    }

    @Override
    public boolean isAutoActivationPinPresent() {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        return getAutoActivatePin(getProperties()) != null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>