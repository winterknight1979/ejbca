<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DNFieldExtractor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.util</a> &gt; <span class="el_source">DNFieldExtractor.java</span></div><h1>DNFieldExtractor.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.certificates.util;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import org.apache.log4j.Logger;
import org.cesecore.util.CertTools;
import org.ietf.ldap.LDAPDN;

/**
 * A class used to retrieve different fields from a Distinguished Name or
 * Subject Alternate Name or Subject Directory Attributes strings.
 *
 * @version $Id: DNFieldExtractor.java 28678 2018-04-12 10:06:36Z anatom $
 */
public class DNFieldExtractor implements java.io.Serializable {

  private static final long serialVersionUID = -1313839342568999844L;

  /** Logger. */
<span class="fc" id="L35">  private static final Logger LOG = Logger.getLogger(DNFieldExtractor.class);</span>
  // Public constants
  /** DN. */
  public static final int TYPE_SUBJECTDN = 0;
  /** Name.*/
  public static final int TYPE_SUBJECTALTNAME = 1;
  /** Attrs. */
  public static final int TYPE_SUBJECTDIRATTR = 2;

  // Note, these IDs duplicate values in profilemappings.properties

  // Subject DN Fields.
  /** E.*/
  public static final int E = 0;
  /** UID. */
  public static final int UID = 1;
  /** CN. */
  public static final int CN = 2;
  /** SN. */
  public static final int SN = 3;
  /** Name. */
  public static final int GIVENNAME = 4;
  /** Name. */
  public static final int INITIALS = 5;
  /** Name. */
  public static final int SURNAME = 6;
  /** T. */
  public static final int T = 7;
  /** OU. */
  public static final int OU = 8;
  /** O. */
  public static final int O = 9;
  /** L. */
  public static final int L = 10;
  /** ST. */
  public static final int ST = 11;
  /** DC. */
  public static final int DC = 12;
  /** C. */
  public static final int C = 13;
  /** Addr.*/
  public static final int UNSTRUCTUREDADDRESS = 14;
  /** Name. */
  public static final int UNSTRUCTUREDNAME = 15;
  /** Postcode. */
  public static final int POSTALCODE = 32;
  /** Cat. */
  public static final int BUSINESSCATEGORY = 33;
  /** DN. */
  public static final int DN = 34;
  /** Address. */
  public static final int POSTALADDRESS = 35;
  /** Tele.*/
  public static final int TELEPHONENUMBER = 36;
  /** Pseud. */
  public static final int PSEUDONYM = 37;
  /** Street. */
  public static final int STREET = 38;
  /** Name. */
  public static final int NAME = 55;
  /** Desc. */
  public static final int DESCRIPTION = 60;
  /** OID. */
  public static final int ORGANIZATIONIDENTIFIER = 106;

  // Subject Alternative Names.
  /** Other. */
  public static final int OTHERNAME = 16;
  /** Email. */
  public static final int RFC822NAME = 17;
  /** DNS. */
  public static final int DNSNAME = 18;
  /** IP. */
  public static final int IPADDRESS = 19;
  /** Address. */
  public static final int X400ADDRESS = 20;
  /** Name. */
  public static final int DIRECTORYNAME = 21;
  /** Name. */
  public static final int EDIPARTYNAME = 22;
  /** URI. */
  public static final int URI = 23;
  /** ID. */
  public static final int REGISTEREDID = 24;
  /** UPN. */
  public static final int UPN = 25;
  /** GUID. */
  public static final int GUID = 26;
  /** Kerberos. */
  public static final int KRB5PRINCIPAL = 52;
  /** ID. */
  public static final int PERMANTIDENTIFIER = 56;
  /** Method. */
  public static final int SUBJECTIDENTIFICATIONMETHOD = 59;

  // Subject Directory Attributes
  /** DOB. */
  public static final int DATEOFBIRTH = 27;
  /** POB. */
  public static final int PLACEOFBIRTH = 28;
  /** Gender. */
  public static final int GENDER = 29;
  /** Country. */
  public static final int COUNTRYOFCITIZENSHIP = 30;
  /** Country. */
  public static final int COUNTRYOFRESIDENCE = 31;
  /** Boundary. */
  private static final int BOUNDRARY = 100;
  /** Mapping dnid to number of occurrences in this DN. */
  private HashMap&lt;Integer, Integer&gt; fieldnumbers;
  /**
   * mapping dn (or altname or subject dir attrs) numerical ids with the value
   * of the components.
   */
  private HashMap&lt;Integer, String&gt; dnfields;

  /** Exists. */
<span class="fc" id="L152">  private boolean existsother = false;</span>
  /** Illegal. */
<span class="fc" id="L154">  private boolean illegal = false;</span>
  /** Type. */
  private int type;

  /**
   * @return type.
   */
  public int getType() {
<span class="nc" id="L162">    return type;</span>
  }

  /**
   * Creates a new instance of DNFieldExtractor.
   *
   * @param dn DOCUMENT ME!
   * @param aType DOCUMENT ME!
   */
<span class="fc" id="L171">  public DNFieldExtractor(final String dn, final int aType) {</span>
<span class="fc" id="L172">    dnfields = new HashMap&lt;&gt;();</span>
<span class="fc" id="L173">    setDN(dn, aType);</span>
<span class="fc" id="L174">  }</span>

  /**
   * Fields that can be selected in Certificate profile and Publisher.
   *
   * @param type Type
   * @return fields
   */
  public static List&lt;Integer&gt; getUseFields(final int type) {
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (type == DNFieldExtractor.TYPE_SUBJECTDN) {</span>
<span class="fc" id="L184">      return DnComponents.getDnDnIds();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">    } else if (type == DNFieldExtractor.TYPE_SUBJECTALTNAME) {</span>
<span class="fc" id="L186">      return DnComponents.getAltNameDnIds();</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">    } else if (type == DNFieldExtractor.TYPE_SUBJECTDIRATTR) {</span>
<span class="fc" id="L188">      return DnComponents.getDirAttrDnIds();</span>
    } else {
<span class="nc" id="L190">      return new ArrayList&lt;Integer&gt;();</span>
    }
  }

  /**
   * Returns the valid components for the given DN type (Subject DN, Subject
   * Alternative Name or Subject Directory Attributes).
   *
   * @param dnType DNFieldExtractor.TYPE_*
   * @return List of valid components from DnComponents.*
   */
  public static List&lt;String&gt; getValidFieldComponents(final int dnType) {
<span class="nc bnc" id="L202" title="All 4 branches missed.">    switch (dnType) {</span>
      case DNFieldExtractor.TYPE_SUBJECTDN:
<span class="nc" id="L204">        return DnComponents.getDnProfileFields();</span>
      case DNFieldExtractor.TYPE_SUBJECTALTNAME:
<span class="nc" id="L206">        return DnComponents.getAltNameFields();</span>
      case DNFieldExtractor.TYPE_SUBJECTDIRATTR:
<span class="nc" id="L208">        return DnComponents.getDirAttrFields();</span>
      default:
<span class="nc" id="L210">        throw new IllegalStateException(&quot;Invalid DN type&quot;);</span>
    }
  }

  /**
   * @param field field
   * @param type type
   * @return string
   */
  public static String getFieldComponent(final int field, final int type) {
    final String ret;
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">    if (type == DNFieldExtractor.TYPE_SUBJECTDN) {</span>
<span class="fc" id="L222">      ret = DnComponents.getDnExtractorFieldFromDnId(field);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">    } else if (type == DNFieldExtractor.TYPE_SUBJECTALTNAME) {</span>
<span class="nc" id="L224">      ret = DnComponents.getAltNameExtractorFieldFromDnId(field);</span>
    } else {
<span class="nc" id="L226">      ret = DnComponents.getDirAttrExtractorFieldFromDnId(field);</span>
    }
<span class="fc" id="L228">    return ret;</span>
  }

  /**
   * Looks up a DN Id (for use with DnComponents functions etc.) from a DN
   * component.
   *
   * @param dnComponent Component, e.g. &quot;CN&quot;. Not case sensitive.
   * @param dnType DN type, e.g. DNFieldExtractor.TYPE_SUBJECTDN
   * @return DN Id, or null if no such component exists for the given DN type.
   */
  public static Integer getDnIdFromComponent(
      final String dnComponent, final int dnType) {
<span class="nc bnc" id="L241" title="All 4 branches missed.">    switch (dnType) {</span>
      case DNFieldExtractor.TYPE_SUBJECTDN:
<span class="nc" id="L243">        return DnComponents.getDnIdFromDnName(dnComponent);</span>
      case DNFieldExtractor.TYPE_SUBJECTALTNAME:
<span class="nc" id="L245">        return DnComponents.getDnIdFromAltName(dnComponent);</span>
      case DNFieldExtractor.TYPE_SUBJECTDIRATTR:
<span class="nc" id="L247">        DnComponents.getDnIdFromDirAttr(dnComponent);</span>
      default:
<span class="nc" id="L249">        throw new IllegalStateException(&quot;Invalid DN type&quot;);</span>
    }
  }

  /**
   * Fills the dnfields variable with dn (or altname or subject dir attrs)
   * numerical ids and the value of the components (i.e. the value of CN). Also
   * populates fieldnumbers with number of occurances in dn
   *
   * @param dn DOCUMENT ME!
   * @param aType DOCUMENT ME!
   */
  public final void setDN(final String dn, final int aType) {

<span class="fc" id="L263">    this.type = aType;</span>
    final ArrayList&lt;Integer&gt; ids;
<span class="fc bfc" id="L265" title="All 2 branches covered.">    if (aType == TYPE_SUBJECTDN) {</span>
<span class="fc" id="L266">      ids = DnComponents.getDnDnIds();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">    } else if (aType == TYPE_SUBJECTALTNAME) {</span>
<span class="fc" id="L268">      ids = DnComponents.getAltNameDnIds();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    } else if (aType == TYPE_SUBJECTDIRATTR) {</span>
<span class="fc" id="L270">      ids = DnComponents.getDirAttrDnIds();</span>
    } else {
<span class="nc" id="L272">      ids = new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L274">    fieldnumbers = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">    for (Integer id : ids) {</span>
<span class="fc" id="L276">      fieldnumbers.put(id, 0);</span>
<span class="fc" id="L277">    }</span>

<span class="fc bfc" id="L279" title="All 4 branches covered.">    if ((dn != null) &amp;&amp; !dn.equalsIgnoreCase(&quot;null&quot;)) {</span>
<span class="fc" id="L280">      dnfields = new HashMap&lt;&gt;();</span>
      try {
<span class="fc" id="L282">        final String[] dnexploded = LDAPDN.explodeDN(dn, false);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (int i = 0; i &lt; dnexploded.length; i++) {</span>
<span class="fc" id="L284">          boolean exists = false;</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">          for (Integer id : ids) {</span>
<span class="fc" id="L287">            Integer number = fieldnumbers.get(id);</span>
            String field;
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (aType == TYPE_SUBJECTDN) {</span>
<span class="fc" id="L290">              field = DnComponents.getDnExtractorFieldFromDnId(id.intValue());</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            } else if (aType == TYPE_SUBJECTALTNAME) {</span>
<span class="fc" id="L292">              field =</span>
<span class="fc" id="L293">                  DnComponents.getAltNameExtractorFieldFromDnId(id.intValue());</span>
            } else {
<span class="fc" id="L295">              field =</span>
<span class="fc" id="L296">                  DnComponents.getDirAttrExtractorFieldFromDnId(id.intValue());</span>
            }
<span class="fc" id="L298">            final String dnex = dnexploded[i].toUpperCase();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (id.intValue() == DNFieldExtractor.URI) {</span>
              // Fix up URI, which can have several forms
<span class="fc bfc" id="L301" title="All 2 branches covered.">              if (dnex.indexOf(CertTools.URI.toUpperCase(Locale.ENGLISH) + &quot;=&quot;)</span>
                  &gt; -1) {
<span class="fc" id="L303">                field = CertTools.URI.toUpperCase(Locale.ENGLISH) + &quot;=&quot;;</span>
              }
<span class="fc bfc" id="L305" title="All 2 branches covered.">              if (dnex.indexOf(CertTools.URI1.toUpperCase(Locale.ENGLISH) + &quot;=&quot;)</span>
                  &gt; -1) {
<span class="fc" id="L307">                field = CertTools.URI1.toUpperCase(Locale.ENGLISH) + &quot;=&quot;;</span>
              }
            }

<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (dnex.startsWith(field)) {</span>

<span class="fc" id="L313">              exists = true;</span>
              final String rdn;
              final String tmp;
              // LDAPDN.unescapeRDN don't like fields with just a key but no
              // contents. Example: 'OU='
<span class="fc bfc" id="L318" title="All 2 branches covered.">              if (dnexploded[i].charAt(dnexploded[i].length() - 1) != '=') {</span>
<span class="fc" id="L319">                tmp = LDAPDN.unescapeRDN(dnexploded[i]);</span>
              } else {
<span class="fc" id="L321">                tmp = dnexploded[i];</span>
              }
              // We don't want the CN= (or whatever) part of the RDN
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">              if (tmp.toUpperCase().startsWith(field)) {</span>
<span class="fc" id="L325">                rdn = tmp.substring(field.length(), tmp.length());</span>
              } else {
<span class="nc" id="L327">                rdn = tmp;</span>
              }

              // Same code for TYPE_SUBJECTDN, TYPE_SUBJECTALTNAME and
              // TYPE_SUBJECTDIRATTR and we will never get here
              // if it is not one of those types
<span class="fc" id="L333">              dnfields.put(</span>
<span class="fc" id="L334">                  Integer.valueOf(</span>
<span class="fc" id="L335">                      (id.intValue() * BOUNDRARY) + number.intValue()),</span>
                  rdn);

<span class="fc" id="L338">              number = Integer.valueOf(number.intValue() + 1);</span>
<span class="fc" id="L339">              fieldnumbers.put(id, number);</span>
            }
<span class="fc" id="L341">          }</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">          if (!exists) {</span>
<span class="fc" id="L343">            existsother = true;</span>
          }
        }
<span class="fc" id="L346">      } catch (Exception e) {</span>
<span class="fc" id="L347">        LOG.warn(&quot;setDN: &quot;, e);</span>
<span class="fc" id="L348">        illegal = true;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (aType == TYPE_SUBJECTDN) {</span>
<span class="fc" id="L350">          dnfields.put(Integer.valueOf((CN * BOUNDRARY)), &quot;Illegal DN : &quot; + dn);</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        } else if (aType == TYPE_SUBJECTALTNAME) {</span>
<span class="fc" id="L352">          dnfields.put(</span>
<span class="fc" id="L353">              Integer.valueOf((RFC822NAME * BOUNDRARY)),</span>
              &quot;Illegal Subjectaltname : &quot; + dn);
<span class="nc bnc" id="L355" title="All 2 branches missed.">        } else if (aType == TYPE_SUBJECTDIRATTR) {</span>
<span class="nc" id="L356">          dnfields.put(</span>
<span class="nc" id="L357">              Integer.valueOf((PLACEOFBIRTH * BOUNDRARY)),</span>
              &quot;Illegal Subjectdirectory attribute : &quot; + dn);
        }
<span class="fc" id="L360">      }</span>
    }
<span class="fc" id="L362">  }</span>

  /**
   * Returns the value of a certain DN component.
   *
   * @param field the DN component, one of the constants DNFieldExtractor.CN,
   *     ...
   * @param number the number of the component if several entries for this
   *     component exists, normally 0 fir the first
   * @return A String for example &quot;PrimeKey&quot; if DNFieldExtractor.O and 0 was
   *     passed, &quot;PrimeKey&quot; if DNFieldExtractor.DC and 0 was passed or &quot;com&quot; if
   *     DNFieldExtractor.DC and 1 was passed. Returns an empty String &quot;&quot;, if no
   *     such field with the number exists.
   */
  public String getField(final int field, final int number) {
<span class="fc" id="L377">    String returnval =</span>
<span class="fc" id="L378">        dnfields.get(Integer.valueOf((field * BOUNDRARY) + number));</span>

<span class="fc bfc" id="L380" title="All 2 branches covered.">    if (returnval == null) {</span>
<span class="fc" id="L381">      returnval = &quot;&quot;;</span>
    }

<span class="fc" id="L384">    return returnval;</span>
  }

  /**
   * Returns a string representation of a certain DN component.
   *
   * @param field the DN component, one of the constants DNFieldExtractor.CN,
   *     ...
   * @return A String for example &quot;CN=Tomas Gustavsson&quot; if DNFieldExtractor.CN
   *     was passed, &quot;DC=PrimeKey,DC=com&quot; if DNFieldExtractor.DC was passed.
   *     This string is escaped so it can be used in a DN string.
   */
  public String getFieldString(final int field) {
<span class="fc" id="L397">    String retval = &quot;&quot;;</span>
<span class="fc" id="L398">    String fieldname = DnComponents.getDnExtractorFieldFromDnId(field);</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">    if (type != TYPE_SUBJECTDN) {</span>
<span class="fc" id="L400">      fieldname = DnComponents.getAltNameExtractorFieldFromDnId(field);</span>
    }
<span class="fc" id="L402">    final int num = getNumberOfFields(field);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">    for (int i = 0; i &lt; num; i++) {</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">      if (retval.length() == 0) {</span>
<span class="fc" id="L405">        retval += LDAPDN.escapeRDN(fieldname + getField(field, i));</span>
      } else {
<span class="fc" id="L407">        retval += &quot;,&quot; + LDAPDN.escapeRDN(fieldname + getField(field, i));</span>
      }
    }
<span class="fc" id="L410">    return retval;</span>
  }

  /**
   * Function that returns true if non standard DN field exists in dn string.
   *
   * @return true if non standard DN field exists, false otherwise
   */
  public boolean existsOther() {
<span class="fc" id="L419">    return existsother;</span>
  }

  /**
   * Returns the number of one kind of dn field.
   *
   * @param field the DN component, one of the constants DNFieldExtractor.CN,
   *     ...
   * @return number of components available for a field, for example 1 if DN is
   *     &quot;dc=primekey&quot; and 2 if DN is &quot;dc=primekey,dc=com&quot;
   */
  public int getNumberOfFields(final int field) {
<span class="fc" id="L431">    Integer ret = fieldnumbers.get(Integer.valueOf(field));</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">    if (ret == null) {</span>
<span class="fc" id="L433">      LOG.error(&quot;Not finding fieldnumber value for &quot; + field);</span>
<span class="fc" id="L434">      ret = Integer.valueOf(0);</span>
    }
<span class="fc" id="L436">    return ret.intValue();</span>
  }

  /**
   * Returns the complete array determining the number of DN components of the
   * various types (i.e. if there are two CNs but 0 Ls etc)
   *
   * &lt;p&gt;TODO: DOCUMENT
   *
   * @return DOCUMENT ME!
   */
  public HashMap&lt;Integer, Integer&gt; getNumberOfFields() {
<span class="fc" id="L448">    return fieldnumbers;</span>
  }

  /**
   * @return bool
   */
  public boolean isIllegal() {
<span class="fc" id="L455">    return illegal;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>