<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SernoGeneratorRandom.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca.internal</a> &gt; <span class="el_source">SernoGeneratorRandom.java</span></div><h1>SernoGeneratorRandom.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca.internal;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;

/**
 * Implements a singleton serial number generator using SecureRandom. This
 * generator generates random 8 octec (64 bits) serial numbers.
 *
 * &lt;p&gt;RFC3280 defines serialNumber be positive INTEGER, and X.690 defines
 * INTEGER consist of one or more octets. X.690 also defines as follows:
 *
 * &lt;p&gt;If the contents octets of an integer value encoding consist of more than
 * one octet, then the bits of the first octet and bit 8 of the second octet: a)
 * shall not all be ones; and b) shall not all be zero.
 *
 * &lt;p&gt;Therefore, minimum 8 octets value is 0080000000000000 and maximum value is
 * 7FFFFFFFFFFFFFFF.&quot;
 *
 * &lt;p&gt;Therefore, minimum 4 octets value is 00800000 and maximum value is
 * 7FFFFFFF.&quot;
 *
 * &lt;p&gt;X.690:
 *
 * &lt;p&gt;8.3 Encoding of an integer value 8.3.1 The encoding of an integer value
 * shall be primitive. The contents octets shall consist of one or more octets.
 * 8.3.2 If the contents octets of an integer value encoding consist of more
 * than one octet, then the bits of the first octet and bit 8 of the second
 * octet: a) shall not all be ones; and b) shall not all be zero. NOTE – These
 * rules ensure that an integer value is always encoded in the smallest possible
 * number of octets. 8.3.3 The contents octets shall be a two's complement
 * binary number equal to the integer value, and consisting of bits 8 to 1 of
 * the first octet, followed by bits 8 to 1 of the second octet, followed by
 * bits 8 to 1 of each octet in turn up to and including the last octet of the
 * contents octets. NOTE – The value of a two's complement binary number is
 * derived by numbering the bits in the contents octets, starting with bit 1 of
 * the last octet as bit zero and ending the numbering with bit 8 of the first
 * octet. Each bit is assigned a numerical value of 2N, where N is its position
 * in the above numbering sequence. The value of the two's complement binary
 * number is obtained by summing the numerical values assigned to each bit for
 * those bits which are set to one, excluding bit 8 of the first octet, and then
 * reducing this value by the numerical value assigned to bit 8 of the first
 * octet if that bit is set to one.
 *
 * @version $Id: SernoGeneratorRandom.java 31966 2019-03-25 10:19:57Z anatom $
 */
public class SernoGeneratorRandom implements SernoGenerator {
  /** Log4j instance. */
<span class="fc" id="L71">  private static final Logger LOG =</span>
<span class="fc" id="L72">      Logger.getLogger(SernoGeneratorRandom.class);</span>
  /** Internal localization of logs and errors. */
  private static final InternalResources INTRES =
<span class="fc" id="L75">      InternalResources.getInstance();</span>

  /**
   * RFC5280, section 4.1.2.2, specifies using max 20 octets for serial number.
   */
  private static final int SERNO_MAX_LENGTH = 20;

  /**
   * random generator algorithm, defaults to FIPS approve SHA1PRNG in
   * constructor The algorithm is specified globally in
   * CesecoreConfiguration.getCaSerialNumberAlgorithm().
   */
  private String algorithm;

  /** number of bytes to generate, fixed size serial numbers. */
  private int noOctets;

  /** random generator. */
  private SecureRandom random;

  /**
   * A registry of Singleton instances, to handle multiple octet sizes
   * simultaneously.
   */
<span class="fc" id="L99">  private static Map&lt;Integer, SernoGeneratorRandom&gt; instances = new HashMap&lt;&gt;();</span>
  /**
   * Creates (if needed) a serial number generator and returns the object.
   *
   * @param noOctets size
   * @return An instance of the serial number generator.
   */
  public static synchronized SernoGenerator instance(final Integer noOctets) {
<span class="fc" id="L107">    SernoGeneratorRandom instance = instances.get(noOctets);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">    if (instance == null) {</span>
<span class="fc" id="L109">      instance = new SernoGeneratorRandom(noOctets);</span>
<span class="fc" id="L110">      instances.put(noOctets, instance);</span>
    }
<span class="fc" id="L112">    return instance;</span>
  }

  /**
   * DO NOT USE: Protected only to do testing of this implementation use {@link
   * #instance(Integer)} instead.
   *
   * @param aNoOctets size
   */
<span class="fc" id="L121">  protected SernoGeneratorRandom(final Integer aNoOctets) {</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L123">      LOG.trace(&quot;&gt;SernoGenerator()&quot;);</span>
    }
<span class="fc" id="L125">    this.algorithm = CesecoreConfiguration.getCaSerialNumberAlgorithm();</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">    if (this.algorithm == null) {</span>
<span class="nc" id="L127">      this.algorithm = &quot;SHA1PRNG&quot;;</span>
    }
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    if ((aNoOctets &gt; SERNO_MAX_LENGTH</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        || aNoOctets &lt; 0)) { // We allow 0 octets for testing</span>
<span class="nc" id="L131">      throw new IllegalArgumentException(</span>
          &quot;ca.serialnumberoctetsize must be between 0 and &quot;
              + SERNO_MAX_LENGTH
              + &quot; bytes for this serial number generator.&quot;);
    }
<span class="fc" id="L136">    this.noOctets = aNoOctets;</span>
<span class="fc" id="L137">    init();</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L139">      LOG.trace(&quot;&lt;SernoGenerator()&quot;);</span>
    }
<span class="fc" id="L141">  }</span>

  private void init() {
    // Init random number generator for random serial numbers.
    // SecureRandom provides a cryptographically strong random number generator
    // (CSPRNG).
    try {
      // Use a specified algorithm if ca.rngalgorithm is provided and it's not
      // set to default
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">      if (!StringUtils.isEmpty(algorithm)</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">          &amp;&amp; !StringUtils.containsIgnoreCase(algorithm, &quot;default&quot;)) {</span>
<span class="fc" id="L152">        random = SecureRandom.getInstance(algorithm);</span>
<span class="fc" id="L153">        LOG.info(&quot;Using &quot; + algorithm + &quot; serialNumber RNG algorithm.&quot;);</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">      } else if (!StringUtils.isEmpty(algorithm)</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">          &amp;&amp; StringUtils.equalsIgnoreCase(algorithm, &quot;defaultstrong&quot;)) {</span>
        // If defaultstrong is specified and we use &gt;=JDK8 try the
        // getInstanceStrong to get a guaranteed strong random number generator.
        // Note that this may give you a generator that takes &gt;30 seconds to
        // create a single random number.
        // On JDK8/Linux this gives you a NativePRNGBlocking, while
        // SecureRandom.getInstance() gives a NativePRNG.
        try {
<span class="fc" id="L163">          final Method methodGetInstanceStrong =</span>
<span class="fc" id="L164">              SecureRandom.class.getDeclaredMethod(&quot;getInstanceStrong&quot;);</span>
<span class="fc" id="L165">          random = (SecureRandom) methodGetInstanceStrong.invoke(null);</span>
<span class="fc" id="L166">          LOG.info(</span>
              &quot;Using SecureRandom.getInstanceStrong() with &quot;
<span class="fc" id="L168">                  + random.getAlgorithm()</span>
                  + &quot; for serialNumber RNG algorithm.&quot;);
<span class="nc" id="L170">        } catch (NoSuchMethodException</span>
            | SecurityException
            | IllegalAccessException
            | IllegalArgumentException
            | InvocationTargetException e) {
<span class="nc" id="L175">          throw new IllegalStateException(</span>
              &quot;SecureRandom.getInstanceStrong() is not available or failed&quot;
                  + &quot; invocation. (This method was added in Java 8.)&quot;);
<span class="fc" id="L178">        }</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">      } else if (!StringUtils.isEmpty(algorithm)</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">          &amp;&amp; StringUtils.equalsIgnoreCase(algorithm, &quot;default&quot;)) {</span>
        // We entered &quot;default&quot; so let's use a good default SecureRandom this
        // should be good enough for just about everyone (on Linux at least)
        // On Linux the default Java implementation uses the (secure)
        // /dev/(u)random, but on windows something else
        // On JDK8/Linux this gives you a NativePRNG, while
        // SecureRandom.getInstanceStrong() gives a NativePRNGBlocking.
<span class="fc" id="L187">        random = new SecureRandom();</span>
<span class="fc" id="L188">        LOG.info(</span>
            &quot;Using default &quot;
<span class="fc" id="L190">                + random.getAlgorithm()</span>
                + &quot; serialNumber RNG algorithm.&quot;);
      }
<span class="nc" id="L193">    } catch (NoSuchAlgorithmException e) {</span>
      // This state is unrecoverable, and since algorithm is set in
      // configuration requires a redeploy to handle
<span class="nc" id="L196">      throw new IllegalStateException(</span>
          &quot;Algorithm &quot; + algorithm + &quot; was not a valid algorithm.&quot;, e);
<span class="fc" id="L198">    }</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">    if (random == null) {</span>
      // This state is unrecoverable, and since algorithm is set in
      // configuration requires a redeploy to handle
<span class="nc" id="L202">      throw new IllegalStateException(</span>
          &quot;Algorithm &quot; + algorithm + &quot; was not a valid algorithm.&quot;);
    }
    // Call nextBytes directly after in order to force seeding if not already
    // done. SecureRandom typically seeds on first call.
<span class="fc" id="L207">    random.nextBytes(new byte[0]);</span>
<span class="fc" id="L208">  }</span>

  @Override
  public BigInteger getSerno() {
    // This is only for testing, if size is set to 0 we will generate random
    // number
    // between 1 and 5, this will give collisions often...
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">    if (noOctets == 0) {</span>
<span class="nc" id="L216">      final Random rand = new Random();</span>
<span class="nc" id="L217">      return BigInteger.valueOf(rand.nextInt(4) + 1); // value 1-5</span>
    }
    while (true) {
      /*
      Note that initBitsOfEntropy are not left intact by the
       following subsequent filtering operations:
      - Values discarded to avoid encoding in less
      than noOctets (including zero value).
      - Serial numbers previously assigned to other
      certificates (filtered later, not here).
      So the real entropy provided for generated
       serial numbers is always less than initBitsOfEntropy.
       */
      // initBitsOfEntropy is 1 less than octet size, because we always use
      // positive integers, which in
      // two complements representation always has the most significant bit 0,
      // making 63 bits random
<span class="fc" id="L234">      int initBitsOfEntropy = noOctets * 8 - 1;</span>
      // SecureRanom is thread safe. This will generate from (0 to
      // 2^initBitsOfEntropy -1)
<span class="fc" id="L237">      final BigInteger serno = new BigInteger(initBitsOfEntropy, random);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">      if (checkSernoValidity(serno)) {</span>
<span class="fc" id="L239">        return serno;</span>
      } else {
<span class="fc" id="L241">        String msg = INTRES.getLocalizedMessage(&quot;sernogenerator.discarding&quot;);</span>
<span class="fc" id="L242">        LOG.info(msg);</span>
      }
<span class="fc" id="L244">    }</span>
  }


  /**
   * This validates that the argument is a non-zero number to be encoded
   * (according to X.690, &quot;8.3 Encoding of an integer value&quot;) exactly in
   * 'noOctets' bytes. For example, for an 8 bytes serial number it will
   * validate that it falls within the range 0080000000000000 - 7FFFFFFFFFFFFFFF
   * (both inclusive).
   *
   * @param serno serial
   * @return bool
   */
  protected boolean checkSernoValidity(final BigInteger serno) {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">    return serno.compareTo(BigInteger.ZERO) != 0</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        &amp;&amp; serno.bitLength() / 8 + 1 == noOctets;</span>
  }

  @Override
  public int getNoSernoBytes() {
<span class="nc" id="L265">    return noOctets;</span>
  }

  @Override
  public void setSeed(final long seed) {
<span class="nc" id="L270">    random.setSeed(seed);</span>
<span class="nc" id="L271">  }</span>

  @Override
  public void setAlgorithm(final String algo) throws NoSuchAlgorithmException {
    // Since re-initialization is expensive, we only do it if we changed the
    // algo
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">    if (this.algorithm == null || !this.algorithm.equals(algo)) {</span>
<span class="fc" id="L278">      this.algorithm = algo;</span>
      // We must force re-init after choosing a new algorithm
<span class="fc" id="L280">      this.random = null;</span>
<span class="fc" id="L281">      init();</span>
    }
<span class="fc" id="L283">  }</span>

  /**
   * Available for testing so we can compare that we actually use what we think.
   *
   * @return the random generator algorithm as reported by the underlying Java
   *     random number generator.
   */
  protected String getAlgorithm() {
<span class="fc" id="L292">    return random.getAlgorithm();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>