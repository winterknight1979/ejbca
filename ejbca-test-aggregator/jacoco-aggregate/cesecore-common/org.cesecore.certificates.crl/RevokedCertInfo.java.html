<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RevokedCertInfo.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.crl</a> &gt; <span class="el_source">RevokedCertInfo.java</span></div><h1>RevokedCertInfo.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/ 
package org.cesecore.certificates.crl;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.cesecore.util.CompressedCollection;

/**
 * Holds information about a revoked certificate. The information kept here is the
 * information that goes into a CRLEntry.
 *
 * @version $Id: RevokedCertInfo.java 34193 2020-01-07 15:18:15Z samuellb $
 * 
 **/
public class RevokedCertInfo implements Serializable {

	/** Version number for serialization */
	private static final long serialVersionUID = 1L;
	
<span class="fc" id="L37">	private static final Logger log = Logger.getLogger(RevokedCertInfo.class);</span>

	/** Constants defining different revocation reasons. */
<span class="fc" id="L40">    public static final int NOT_REVOKED                            = RevocationReasons.NOT_REVOKED.getDatabaseValue();</span>
<span class="fc" id="L41">    public static final int REVOCATION_REASON_UNSPECIFIED          = RevocationReasons.UNSPECIFIED.getDatabaseValue();</span>
<span class="fc" id="L42">    public static final int REVOCATION_REASON_KEYCOMPROMISE        = RevocationReasons.KEYCOMPROMISE.getDatabaseValue();</span>
<span class="fc" id="L43">    public static final int REVOCATION_REASON_CACOMPROMISE         = RevocationReasons.CACOMPROMISE.getDatabaseValue();</span>
<span class="fc" id="L44">    public static final int REVOCATION_REASON_AFFILIATIONCHANGED   = RevocationReasons.AFFILIATIONCHANGED.getDatabaseValue();</span>
<span class="fc" id="L45">    public static final int REVOCATION_REASON_SUPERSEDED           = RevocationReasons.SUPERSEDED.getDatabaseValue();</span>
<span class="fc" id="L46">    public static final int REVOCATION_REASON_CESSATIONOFOPERATION = RevocationReasons.CESSATIONOFOPERATION.getDatabaseValue();</span>
<span class="fc" id="L47">    public static final int REVOCATION_REASON_CERTIFICATEHOLD      = RevocationReasons.CERTIFICATEHOLD.getDatabaseValue();</span>
    // Value 7 is not used, see RFC5280
<span class="fc" id="L49">    public static final int REVOCATION_REASON_REMOVEFROMCRL        = RevocationReasons.REMOVEFROMCRL.getDatabaseValue();</span>
<span class="fc" id="L50">    public static final int REVOCATION_REASON_PRIVILEGESWITHDRAWN  = RevocationReasons.PRIVILEGESWITHDRAWN.getDatabaseValue();</span>
<span class="fc" id="L51">    public static final int REVOCATION_REASON_AACOMPROMISE         = RevocationReasons.AACOMPROMISE.getDatabaseValue();</span>
    
    /** BigInteger (serialNumber) in byte format, BigInteger.toByteArray() */
    private byte[]      userCertificate;
    private long        revocationDate;
    private long        expireDate;
    private int         reason;
    /** Fingerprint in byte format, String.getBytes() */    
    private byte[] 		fingerprint;

    /**
     * A default constructor is needed to instantiate
     * RevokedCertInfo objects using &amp;lt;jsp:useBean&amp;gt; by Tomcat 5. 
     */
<span class="nc" id="L65">    public RevokedCertInfo() {</span>
<span class="nc" id="L66">    	fingerprint = null;</span>
<span class="nc" id="L67">    	userCertificate = null;</span>
<span class="nc" id="L68">    	revocationDate = 0;</span>
<span class="nc" id="L69">    	expireDate = 0;</span>
<span class="nc" id="L70">    	reason = REVOCATION_REASON_UNSPECIFIED;</span>
<span class="nc" id="L71">    }</span>

    /**
     * Constructor filling in the whole object.
     * @param fingerprint print
     * @param sernoBigIntegerArray serials 
     * @param revdate date
     * 
     * @param reason {@link RevokedCertInfo#REVOCATION_REASON_UNSPECIFIED}
     * @param expdate date
     *
     **/
<span class="fc" id="L83">    public RevokedCertInfo(final byte[] fingerprint, final byte[] sernoBigIntegerArray, final long revdate, final int reason, final long expdate) {</span>
<span class="fc" id="L84">        this.fingerprint = fingerprint;</span>
<span class="fc" id="L85">        this.userCertificate = sernoBigIntegerArray;</span>
<span class="fc" id="L86">        this.revocationDate = revdate;</span>
<span class="fc" id="L87">        this.reason = reason;</span>
<span class="fc" id="L88">        this.expireDate = expdate;</span>
<span class="fc" id="L89">    }</span>

    /**
     * @return Certificate fingerprint
     **/
    public String getCertificateFingerprint() {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        return fingerprint == null ? null : new String(fingerprint);</span>
    }

    /**
     * @param fp Certificate fingerprint
     **/
    public void setCertificateFingerprint(final String fp) {
<span class="nc bnc" id="L102" title="All 2 branches missed.">        this.fingerprint = fp == null ? null : fp.getBytes();</span>
<span class="nc" id="L103">    }</span>
    
    /**
     * @return Certificate serial number
     **/
    public BigInteger getUserCertificate() {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        return userCertificate == null ? null : new BigInteger(userCertificate);</span>
    }

    /**
     * @param serno Certificate serial number
     **/
    public void setUserCertificate(final BigInteger serno) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        this.userCertificate = serno==null ? null : serno.toByteArray();</span>
<span class="nc" id="L117">    }</span>

    /** 
     * @return true is there is a revocationDate set (getRevocationDate() != null), false otherwise
     */
    public boolean isRevocationDateSet() {
<span class="nc bnc" id="L123" title="All 2 branches missed.">        return revocationDate != 0;</span>
    }

    /**
     * @return Date when the certificate was revoked.
     **/
    public Date getRevocationDate() {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        return revocationDate == 0 ? null : new Date(revocationDate);</span>
    }

    /**
     * @param date Date when the certificate was revoked.
     **/
    public void setRevocationDate(final Date date) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        this.revocationDate = date == null ? 0 : date.getTime();</span>
<span class="nc" id="L138">    }</span>

    /**
     * @return Date when the certificate expires.
     **/
    public Date getExpireDate() {
<span class="nc bnc" id="L144" title="All 2 branches missed.">        return expireDate == 0 ? null : new Date(expireDate);</span>
    }

    /**
     * @param date Date when the certificate expires.
     **/
    public void setExpireDate(final Date date) {
<span class="nc bnc" id="L151" title="All 2 branches missed.">        this.expireDate = date==null ? 0 : date.getTime();</span>
<span class="nc" id="L152">    }</span>

    /**
     * The reason the certificate was revoked.
     * &lt;pre&gt;
     * ReasonFlags ::= BIT STRING {
     *    unspecified(0),
     *    keyCompromise(1),
     *    cACompromise(2),
     *    affiliationChanged(3),
     *    superseded(4),
     *    cessationOfOperation(5),
     *    certficateHold(6)
     *    removeFromCRL(8)
     *    privilegeWithdrawn(9)
     *    aACompromise(10)
     * }
     * &lt;/pre&gt;
     * @return reason
     * @see #REVOCATION_REASON_UNSPECIFIED
     **/
    public int getReason() {
<span class="fc" id="L174">        return this.reason;</span>
    }

    /**
     * The reason the certificate was revoked.
     * @param reason {@link RevokedCertInfo#REVOCATION_REASON_UNSPECIFIED}
     **/
    public void setReason(final int reason) {
<span class="nc" id="L182">        this.reason = reason;</span>
<span class="nc" id="L183">    }</span>

    @Override
    public String toString() {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        return this.userCertificate == null ? &quot;null&quot; : new BigInteger(userCertificate).toString();</span>
    }
    
    /**
     * A quick way to tell if the certificate has been revoked. 
     * @return true if the certificate has been revoked, otherwise false.
     */
    public boolean isRevoked() {
<span class="fc" id="L195">    	return isRevoked(reason);</span>
    }
    
    /**
     * @return true if the certificate is permanently revoked (i.e. revoked and not just &quot;on hold&quot;)
     */
    public boolean isPermanentlyRevoked() {
<span class="fc" id="L202">        return isPermanentlyRevoked(reason);</span>
    }
    
    public static boolean isRevoked(int revocationReason) {
<span class="fc bfc" id="L206" title="All 4 branches covered.">        return revocationReason != NOT_REVOKED &amp;&amp; revocationReason != REVOCATION_REASON_REMOVEFROMCRL;</span>
    }
    
    public static boolean isPermanentlyRevoked(int revocationReason) {
<span class="fc bfc" id="L210" title="All 4 branches covered.">        return isRevoked(revocationReason) &amp;&amp; revocationReason != REVOCATION_REASON_CERTIFICATEHOLD;</span>
    }
    
    /**
     * This method returns the revocation reason as a text string that is understandable.
     * TODO: The strings in the enum should be easier for users to change, used from &quot;publicweb/retrieve/check_status_result.jsp&quot;
     * 
     * @return A string describing the reason for revocation.
     */
    public String getHumanReadableReason() {
<span class="nc" id="L220">        RevocationReasons revocationReason = RevocationReasons.getFromDatabaseValue(reason);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (revocationReason != null) {</span>
<span class="nc" id="L222">            return revocationReason.getHumanReadable();</span>

        } else {
<span class="nc" id="L225">            return &quot;unknown&quot;;</span>
        }
    }
    
    /**
     * Merges two collections of RevokedCertInfo. Note that the parameters are slightly different. Duplicates are removed according to these rules:
     * &lt;ul&gt;
     * &lt;li&gt;Older permanent status changes win over newer ones
     * &lt;li&gt;Permanent status changes always win over temporary ones (&quot;on hold&quot; / &quot;re-activate&quot;)
     * &lt;li&gt;More recent temporary status changes win over older ones
     * &lt;/ul&gt;
     * 
     * @param a First collection of RevokedCertInfo. May &lt;b&gt;not&lt;/b&gt; contain duplicates for the same serial number.
     * @param b Second collection of RevokedCertInfo. May contain duplicates
     * @param lastBaseCrlDate Entries in unrevoked state will only be included if they are more recent than this date. (&amp;lt;= 0 means never include them)
     * @return CompressionCollection of certificates. May simply be a reference to &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is empty, or a new merged CompressedCollection with any duplicates removed.
     */
    public static Collection&lt;RevokedCertInfo&gt; mergeByDateAndStatus(final Collection&lt;RevokedCertInfo&gt; a, final Collection&lt;RevokedCertInfo&gt; b, final long lastBaseCrlDate) {
        // We can optimize this case, but not the reverse, since b can contain duplicates that should be filtered.
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (b.isEmpty()) {</span>
<span class="fc" id="L245">            return a;</span>
        }
        // Merge revocation information
<span class="fc" id="L248">        final Map&lt;BigInteger,RevokedCertInfo&gt; permRevoked = new HashMap&lt;&gt;();</span>
<span class="fc" id="L249">        final Map&lt;BigInteger,RevokedCertInfo&gt; tempRevoked = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">        for (final RevokedCertInfo revoked : a) {</span>
<span class="fc" id="L251">            final BigInteger serial = revoked.getUserCertificate();</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (revoked.isPermanentlyRevoked()) {</span>
<span class="fc" id="L253">                permRevoked.put(serial, revoked);</span>
            } else {
<span class="nc" id="L255">                tempRevoked.put(serial, revoked);</span>
            }
<span class="fc" id="L257">        }</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        for (final RevokedCertInfo revoked : b) {</span>
<span class="fc" id="L259">            final BigInteger serial = revoked.getUserCertificate();</span>
<span class="fc" id="L260">            final Date revdate = revoked.getRevocationDate();</span>
<span class="fc" id="L261">            final RevokedCertInfo permDate = permRevoked.get(serial);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (permDate != null) {</span>
                // Older permanent status changes win over newer ones
<span class="fc bfc" id="L264" title="All 4 branches covered.">                if (permDate.getRevocationDate().after(revdate) &amp;&amp; revoked.isPermanentlyRevoked()) {</span>
<span class="fc" id="L265">                    permRevoked.put(serial, revoked);</span>
<span class="fc" id="L266">                    tempRevoked.remove(serial);</span>
                }
                continue;
            }
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (revoked.isPermanentlyRevoked()) {</span>
                // Permanently revoked wins over temporary revoked/re-activated
<span class="fc" id="L272">                permRevoked.put(serial, revoked);</span>
<span class="fc" id="L273">                tempRevoked.remove(serial);</span>
<span class="fc" id="L274">                continue;</span>
            }
<span class="fc" id="L276">            final RevokedCertInfo tempDate = tempRevoked.get(serial);</span>
            // More recent temporary status changes win over older ones 
<span class="pc bpc" id="L278" title="1 of 4 branches missed.">            if (tempDate == null || tempDate.getRevocationDate().before(revdate)) {</span>
<span class="fc" id="L279">                tempRevoked.put(serial, revoked);</span>
            }
<span class="fc" id="L281">        }</span>
<span class="fc" id="L282">        final CompressedCollection&lt;RevokedCertInfo&gt; mergedRevokedData = new CompressedCollection&lt;&gt;(RevokedCertInfo.class);</span>
<span class="fc" id="L283">        mergedRevokedData.addAll(permRevoked.values()); // Permanently revoked entries are always added</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        for (final RevokedCertInfo revoked : tempRevoked.values()) {</span>
<span class="fc bfc" id="L285" title="All 6 branches covered.">            if (!revoked.isRevoked() &amp;&amp; (lastBaseCrlDate &lt;= 0 || revoked.getRevocationDate().getTime() &lt;= lastBaseCrlDate)) {</span>
<span class="fc" id="L286">                continue; // REMOVEFROMCRL entries are not added in Base CRLs (lastBaseCrlDate=0) or if already removed from the latest Base CRL</span>
            }
<span class="fc" id="L288">            mergedRevokedData.add(revoked);</span>
<span class="fc" id="L289">        }</span>
<span class="fc" id="L290">        mergedRevokedData.closeForWrite();</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L292">            log.debug(&quot;mergeByDateAndStatus: Merged to &quot; + mergedRevokedData.size() + &quot; entries&quot;);</span>
        }
<span class="fc" id="L294">        return mergedRevokedData;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>