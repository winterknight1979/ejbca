<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PurposeMapping.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca.catoken</a> &gt; <span class="el_source">PurposeMapping.java</span></div><h1>PurposeMapping.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca.catoken;

import java.util.HashSet;
import java.util.Hashtable;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * Class wraps keystring properties. The properties passed in to it can contain
 * fields as the constants:
 *
 * &lt;p&gt;The values of the properties consists of purposeproperty and keyalias
 *
 * &lt;pre&gt;
 *    certSignKey fooalias02
 *    crlSignKey fooalias02
 *    keyEncryptKey fooencalias
 *    hardTokenEncrypt fooencalias
 *    previousCertSignKey fooalias01
 *    nextCertSignKey fooalias03
 *    testKey testalias
 *    defaultKey defaultalias
 * &lt;/pre&gt;
 *
 * When the strings are added they are mapped to different key purposes,
 * CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN etc. When the method getString is
 * called with CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN it will return
 * fooalias, if getString is called with a key purpose that was not specified,
 * for example CryptoTokenConstants.CAKEYPURPOSE_KEYENCRYPT it will return
 * defaultalias.
 *
 * &lt;p&gt;The returned values are supposed to be used to get keys for different
 * aliases from a keystore.
 *
 * @version $Id: PurposeMapping.java 22852 2016-02-23 17:37:16Z jeklund $
 */
public final class PurposeMapping {

  /** Map. */
  private final Map&lt;Integer, String&gt; map;
  /** Map. */
  private final Map&lt;Integer, String&gt; keymap;
  /** Alias. */
  private final String defaultKeyAlias;

  /**
   * Key string properties with entries consisting of one of the fixed key
   * strings mapping to a key alias. The key alias is user defined.
   *
   * &lt;pre&gt;
   *    certSignKey fooalias02
   *    crlSignKey fooalias02
   *    keyEncryptKey fooencalias
   *    hardTokenEncrypt fooencalias
   *    previousCertSignKey fooalias01
   *    nextCertSignKey fooalias03
   *    testKey testalias
   *    defaultKey defaultalias
   * &lt;/pre&gt;
   *
   * @param properties key string properties
   */
<span class="fc" id="L76">  public PurposeMapping(final Properties properties) {</span>
    /*
     * Map of keypurpose integer (CATokenConstants.CAKEYPURPOSE_CERTSIGN) and
     * alias string as defined in Properties
     */
<span class="fc" id="L81">    map = new Hashtable&lt;Integer, String&gt;();</span>
    /*
     * Map of keypurpose integer (CATokenConstants.CAKEYPURPOSE_CERTSIGN) and
     * key purpose string (CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING) for
     * the properties defined in Properties
     */
<span class="fc" id="L87">    keymap = new Hashtable&lt;Integer, String&gt;();</span>
<span class="fc" id="L88">    String defaultKeyAliasTmp = null;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">    if (properties != null) {</span>
<span class="fc" id="L90">      defaultKeyAliasTmp =</span>
<span class="fc" id="L91">          properties.getProperty(CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING);</span>
<span class="fc" id="L92">      addKey(</span>
          CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING,
          CATokenConstants.CAKEYPURPOSE_CERTSIGN,
          properties);
<span class="fc" id="L96">      addKey(</span>
          CATokenConstants.CAKEYPURPOSE_CRLSIGN_STRING,
          CATokenConstants.CAKEYPURPOSE_CRLSIGN,
          properties);
<span class="fc" id="L100">      addKey(</span>
          CATokenConstants.CAKEYPURPOSE_KEYENCRYPT_STRING,
          CATokenConstants.CAKEYPURPOSE_KEYENCRYPT,
          properties);
<span class="fc" id="L104">      addKey(</span>
          CATokenConstants.CAKEYPURPOSE_TESTKEY_STRING,
          CATokenConstants.CAKEYPURPOSE_KEYTEST,
          properties);
<span class="fc" id="L108">      addKey(</span>
          CATokenConstants.CAKEYPURPOSE_HARDTOKENENCRYPT_STRING,
          CATokenConstants.CAKEYPURPOSE_HARDTOKENENCRYPT,
          properties);
<span class="fc" id="L112">      addKey(</span>
          CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING_PREVIOUS,
          CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS,
          properties);
<span class="fc" id="L116">      addKey(</span>
          CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING_NEXT,
          CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT,
          properties);
    }
<span class="fc" id="L121">    defaultKeyAlias =</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        defaultKeyAliasTmp != null ? defaultKeyAliasTmp.trim() : null;</span>
<span class="fc" id="L123">  }</span>

  private void addKey(
      final String keyPurposeString,
      final int purpose,
      final Properties properties) {
<span class="fc" id="L129">    String alias = properties.getProperty(keyPurposeString);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (alias != null) {</span>
<span class="fc" id="L131">      alias = alias.trim();</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">      if (!alias.isEmpty()) {</span>
<span class="fc" id="L133">        map.put(Integer.valueOf(purpose), alias);</span>
<span class="fc" id="L134">        keymap.put(Integer.valueOf(purpose), keyPurposeString);</span>
      }
    }
<span class="fc" id="L137">  }</span>
  /**
   * Returns which key alias string is used for a certain key purpose. For
   * example for CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN would either a key
   * alias as defined by the property &quot;CAKEYPURPOSE_CERTSIGN_STRING
   * myCertSignKey&quot; (myCertSignKey) or null be returned. null is returned if no
   * CAKEYPURPOSE_CERTSIGN_STRING (certSignKey) property was specified by the
   * user.
   *
   * @param purpose purpose
   * @return alias
   */
  public String getAlias(final int purpose) {
    String alias;
    try {
<span class="fc" id="L152">      alias = map.get(Integer.valueOf(purpose));</span>
<span class="nc" id="L153">    } catch (Exception e) {</span>
<span class="nc" id="L154">      alias = null;</span>
<span class="fc" id="L155">    }</span>
<span class="pc bpc" id="L156" title="1 of 4 branches missed.">    if (alias != null &amp;&amp; !alias.isEmpty()) {</span>
<span class="fc" id="L157">      return alias;</span>
    }
    // Special handling of these two key purposes, because if they do not exist,
    // very strange things can happen
    // if we claim that our &quot;defaultKey&quot; is the previous or next signing key,
    // when it in fact is not.
<span class="fc bfc" id="L163" title="All 4 branches covered.">    if (purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS</span>
        &amp;&amp; purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT) {
<span class="fc" id="L165">      return defaultKeyAlias;</span>
    }
<span class="fc" id="L167">    return null;</span>
  }
  /**
   * Returns which property key is used for a certain key purpose. For example
   * for CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN would either
   * CAKEYPURPOSE_CERTSIGN_STRING (certSignKey) or CAKEYPURPOSE_DEFAULT_STRING
   * (defaultKey) be returned. Special handling is for CERTSIGN_PREVIOUS and
   * CERTSIGN_NEXT. If they can not be found, the defaultKey is _not_ returned.
   *
   * @param purpose purpose
   * @return property
   */
  public String getPurposeProperty(final int purpose) {
    String s;
    try {
<span class="fc" id="L182">      s = keymap.get(Integer.valueOf(purpose));</span>
<span class="nc" id="L183">    } catch (Exception e) {</span>
<span class="nc" id="L184">      s = null;</span>
<span class="fc" id="L185">    }</span>
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">    if (s != null &amp;&amp; s.length() &gt; 0) {</span>
<span class="fc" id="L187">      return s;</span>
    }
    // Special handling of these two key purposes, because if they do not exist,
    // very strange things can happen
    // if we claim that our &quot;defaultKey&quot; is the previous or next signing key,
    // when it in fact is not.
<span class="fc bfc" id="L193" title="All 4 branches covered.">    if ((purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS)</span>
        &amp;&amp; (purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT)) {
<span class="fc" id="L195">      return CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING;</span>
    }
<span class="fc" id="L197">    return null;</span>
  }

  /**
   * Returns an array with all key aliases that have been registered in this
   * mapping.
   *
   * @return String[] with key aliases
   */
  public String[] getAliases() {
<span class="fc" id="L207">    final Set&lt;String&gt; set = new HashSet&lt;&gt;(map.values());</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (defaultKeyAlias != null) {</span>
<span class="fc" id="L209">      set.add(defaultKeyAlias);</span>
    }
<span class="fc" id="L211">    return set.toArray(new String[set.size()]);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L216">    return map.toString();</span>
  }

  /**
   * @param alias alias
   * @return true if the provided alias is mapped exactly once
   */
  public boolean isAliasMappedForSinglePurpose(final String alias) {
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">    if (alias == null) {</span>
<span class="nc" id="L225">      return false;</span>
    }
<span class="fc" id="L227">    boolean mappedOnce = false;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">    for (final int keyPupose : CATokenConstants.ALL_KEY_PURPOSES) {</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">      if (alias.equals(getAlias(keyPupose))) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (mappedOnce) {</span>
<span class="fc" id="L231">          return false;</span>
        }
<span class="fc" id="L233">        mappedOnce = true;</span>
      }
    }
<span class="fc" id="L236">    return mappedOnce;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>