<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CAAdminSessionBean.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">ejbca-ejb</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.ejb.ca.caadmin</a> &gt; <span class="el_source">CAAdminSessionBean.java</span></div><h1>CAAdminSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.ejbca.core.ejb.ca.caadmin;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CertPathValidatorException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TimeZone;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.EJBException;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.jce.X509KeyUsage;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.pkcs.PKCS10CertificationRequest;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.CesecoreException;
import org.cesecore.ErrorCode;
import org.cesecore.audit.enums.EventStatus;
import org.cesecore.audit.enums.EventType;
import org.cesecore.audit.enums.EventTypes;
import org.cesecore.audit.enums.ModuleTypes;
import org.cesecore.audit.enums.ServiceTypes;
import org.cesecore.audit.log.SecurityEventsLoggerSessionLocal;
import org.cesecore.authentication.tokens.AlwaysAllowLocalAuthenticationToken;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authentication.tokens.UsernamePrincipal;
import org.cesecore.authentication.tokens.X509CertificateAuthenticationToken;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.authorization.AuthorizationSessionLocal;
import org.cesecore.authorization.control.AuditLogRules;
import org.cesecore.authorization.control.StandardRules;
import org.cesecore.certificates.ca.ApprovalRequestType;
import org.cesecore.certificates.ca.CA;
import org.cesecore.certificates.ca.CAConstants;
import org.cesecore.certificates.ca.CAData;
import org.cesecore.certificates.ca.CADoesntExistsException;
import org.cesecore.certificates.ca.CAExistsException;
import org.cesecore.certificates.ca.CAInfo;
import org.cesecore.certificates.ca.CANameChangeRenewalException;
import org.cesecore.certificates.ca.CAOfflineException;
import org.cesecore.certificates.ca.CVCCAInfo;
import org.cesecore.certificates.ca.CaSessionLocal;
import org.cesecore.certificates.ca.CvcCA;
import org.cesecore.certificates.ca.InvalidAlgorithmException;
import org.cesecore.certificates.ca.X509CA;
import org.cesecore.certificates.ca.X509CAInfo;
import org.cesecore.certificates.ca.catoken.CAToken;
import org.cesecore.certificates.ca.catoken.CATokenConstants;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceInfo;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceNotActiveException;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceRequest;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceRequestException;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceResponse;
import org.cesecore.certificates.ca.extendedservices.ExtendedCAServiceTypes;
import org.cesecore.certificates.ca.extendedservices.IllegalExtendedCAServiceRequestException;
import org.cesecore.certificates.certificate.CertificateConstants;
import org.cesecore.certificates.certificate.CertificateDataWrapper;
import org.cesecore.certificates.certificate.CertificateRevokeException;
import org.cesecore.certificates.certificate.CertificateStoreSessionLocal;
import org.cesecore.certificates.certificate.CertificateWrapper;
import org.cesecore.certificates.certificate.IllegalKeyException;
import org.cesecore.certificates.certificate.certextensions.AvailableCustomCertificateExtensionsConfiguration;
import org.cesecore.certificates.certificate.request.CertificateResponseMessage;
import org.cesecore.certificates.certificate.request.PKCS10RequestMessage;
import org.cesecore.certificates.certificate.request.RequestMessage;
import org.cesecore.certificates.certificate.request.ResponseMessage;
import org.cesecore.certificates.certificate.request.X509ResponseMessage;
import org.cesecore.certificates.certificateprofile.CertificatePolicy;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificateprofile.CertificateProfileConstants;
import org.cesecore.certificates.certificateprofile.CertificateProfileSessionLocal;
import org.cesecore.certificates.crl.CrlStoreSessionLocal;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.certificates.endentity.EndEntityConstants;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.certificates.endentity.EndEntityType;
import org.cesecore.certificates.endentity.EndEntityTypes;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.cesecore.certificates.ocsp.exception.NotSupportedException;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.certificates.util.dn.DNFieldsUtil;
import org.cesecore.configuration.GlobalConfigurationSessionLocal;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.keybind.CertificateImportException;
import org.cesecore.keybind.InternalKeyBinding;
import org.cesecore.keybind.InternalKeyBindingMgmtSessionLocal;
import org.cesecore.keybind.InternalKeyBindingNameInUseException;
import org.cesecore.keys.token.CryptoToken;
import org.cesecore.keys.token.CryptoTokenAuthenticationFailedException;
import org.cesecore.keys.token.CryptoTokenManagementSessionLocal;
import org.cesecore.keys.token.CryptoTokenNameInUseException;
import org.cesecore.keys.token.CryptoTokenOfflineException;
import org.cesecore.keys.token.CryptoTokenSessionLocal;
import org.cesecore.keys.token.IllegalCryptoTokenException;
import org.cesecore.keys.token.NullCryptoToken;
import org.cesecore.keys.token.PKCS11CryptoToken;
import org.cesecore.keys.token.SoftCryptoToken;
import org.cesecore.keys.token.p11.exception.NoSuchSlotException;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.keys.validation.KeyValidatorSessionLocal;
import org.cesecore.keys.validation.Validator;
import org.cesecore.roles.management.RoleSessionLocal;
import org.cesecore.util.Base64;
import org.cesecore.util.CertTools;
import org.cesecore.util.CryptoProviderTools;
import org.cesecore.util.EJBTools;
import org.cesecore.util.StringTools;
import org.cesecore.util.ValidityDate;
import org.cesecore.util.ui.DynamicUiProperty;
import org.ejbca.config.CmpConfiguration;
import org.ejbca.config.EjbcaConfiguration;
import org.ejbca.config.GlobalConfiguration;
import org.ejbca.core.EjbcaException;
import org.ejbca.core.ejb.approval.ApprovalProfileSessionLocal;
import org.ejbca.core.ejb.approval.ApprovalSessionLocal;
import org.ejbca.core.ejb.audit.enums.EjbcaEventTypes;
import org.ejbca.core.ejb.audit.enums.EjbcaModuleTypes;
import org.ejbca.core.ejb.audit.enums.EjbcaServiceTypes;
import org.ejbca.core.ejb.ca.publisher.PublisherSessionLocal;
import org.ejbca.core.ejb.ca.revoke.RevocationSessionLocal;
import org.ejbca.core.ejb.crl.PublishingCrlSessionLocal;
import org.ejbca.core.ejb.ra.EndEntityAccessSessionLocal;
import org.ejbca.core.ejb.ra.EndEntityManagementSessionLocal;
import org.ejbca.core.ejb.ra.NoSuchEndEntityException;
import org.ejbca.core.ejb.ra.raadmin.EndEntityProfileSessionLocal;
import org.ejbca.core.ejb.ra.userdatasource.UserDataSourceSessionLocal;
import org.ejbca.core.ejb.services.ServiceSessionLocal;
import org.ejbca.core.model.InternalEjbcaResources;
import org.ejbca.core.model.approval.ApprovalDataVO;
import org.ejbca.core.model.approval.ApprovalException;
import org.ejbca.core.model.approval.ApprovalExecutorUtil;
import org.ejbca.core.model.approval.ApprovalOveradableClassName;
import org.ejbca.core.model.approval.WaitingForApprovalException;
import org.ejbca.core.model.approval.approvalrequests.ActivateCATokenApprovalRequest;
import org.ejbca.core.model.approval.profile.ApprovalProfile;
import org.ejbca.core.model.authorization.AccessRulesConstants;
import org.ejbca.core.model.ca.caadmin.extendedcaservices.BaseSigningCAServiceInfo;
import org.ejbca.core.model.ca.caadmin.extendedcaservices.CmsCAServiceInfo;
import org.ejbca.core.model.ca.caadmin.extendedcaservices.KeyRecoveryCAServiceInfo;
import org.ejbca.core.model.ca.publisher.BasePublisher;
import org.ejbca.core.model.ca.publisher.CustomPublisherContainer;
import org.ejbca.core.model.ra.ExtendedInformationFields;
import org.ejbca.core.model.ra.raadmin.EndEntityProfile;
import org.ejbca.core.model.ra.raadmin.EndEntityProfileNotFoundException;
import org.ejbca.core.model.ra.userdatasource.BaseUserDataSource;
import org.ejbca.core.model.services.ServiceConfiguration;
import org.ejbca.cvc.CardVerifiableCertificate;
import org.ejbca.util.CAIdTools;

/**
 * Manages CAs in EJBCA.
 *
 * @version $Id: CAAdminSessionBean.java 34064 2019-12-10 16:00:29Z andrey_s_helmes $
 */
@Stateless(mappedName = JndiConstants.APP_JNDI_PREFIX + &quot;CAAdminSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
<span class="nc" id="L213">public class CAAdminSessionBean implements CAAdminSessionLocal, CAAdminSessionRemote {</span>

<span class="nc" id="L215">    private static final Logger log = Logger.getLogger(CAAdminSessionBean.class);</span>

    @PersistenceContext(unitName = &quot;ejbca&quot;)
    private EntityManager entityManager;

    @EJB
    private AuthorizationSessionLocal authorizationSession;
    @EJB
    private ApprovalSessionLocal approvalSession;
    @EJB
    private ApprovalProfileSessionLocal approvalProfileSession;
    @EJB
    private CaSessionLocal caSession;
    @EJB
    private CertificateProfileSessionLocal certificateProfileSession;
    @EJB
    private CertificateStoreSessionLocal certificateStoreSession;
    @EJB
    private CrlStoreSessionLocal crlStoreSession;
    @EJB
    private CryptoTokenManagementSessionLocal cryptoTokenManagementSession;
    @EJB
    private CryptoTokenSessionLocal cryptoTokenSession;
    @EJB
    private EndEntityAccessSessionLocal endEntityAccessSession;
    @EJB
    private EndEntityManagementSessionLocal endEntityManagementSession;
    @EJB
    private EndEntityProfileSessionLocal endEntityProfileSession;
    @EJB
    private GlobalConfigurationSessionLocal globalConfigurationSession;
    @EJB
    private InternalKeyBindingMgmtSessionLocal keyBindMgmtSession;
    @EJB
    private PublisherSessionLocal publisherSession;
    @EJB
    private PublishingCrlSessionLocal publishingCrlSession;
    @EJB
    private KeyValidatorSessionLocal keyValidatorSession;
    @EJB
    private RevocationSessionLocal revocationSession;
    @EJB
    private RoleSessionLocal roleSession;
    @EJB
    private SecurityEventsLoggerSessionLocal auditSession;
    @EJB
    private ServiceSessionLocal serviceSession;
    @EJB
    private UserDataSourceSessionLocal userDataSourceSession;

    @Resource
    private SessionContext sessionContext;
    // Myself needs to be looked up in postConstruct
    private CAAdminSessionLocal caAdminSession;

    /** Internal localization of logs and errors */
<span class="nc" id="L271">    private static final InternalEjbcaResources intres = InternalEjbcaResources.getInstance();</span>

    @PostConstruct
    public void postConstruct() {
<span class="nc" id="L275">        CryptoProviderTools.installBCProviderIfNotAvailable();</span>
        // We lookup the reference to our-self in PostConstruct, since we cannot inject this.
        // We can not inject ourself, JBoss will not start then therefore we use this to get a reference to this session bean
        // to call initializeCa we want to do it on the real bean in order to get the transaction setting (REQUIRES_NEW).
<span class="nc" id="L279">        caAdminSession = sessionContext.getBusinessObject(CAAdminSessionLocal.class);</span>
<span class="nc" id="L280">    }</span>

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    @Override
    public void initializeAndUpgradeCAs() {
<span class="nc" id="L285">        final List&lt;CAData&gt; caDatas = caSession.findAll();</span>
        // Sort CAs by name (to produce pretty table in log)
<span class="nc" id="L287">        Collections.sort(caDatas, new Comparator&lt;CAData&gt;() {</span>
            @Override
            public int compare(final CAData arg0, final CAData arg1) {
<span class="nc" id="L290">                return arg0.getName().compareTo(arg1.getName());</span>
            }
        });
        // Figure out the longest CA name (to produce pretty table in log)
<span class="nc" id="L294">        int maxNameLenght = 0;</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (final CAData caData : caDatas) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">            if (caData.getName().length() &gt; maxNameLenght) {</span>
<span class="nc" id="L297">                maxNameLenght = caData.getName().length();</span>
            }
<span class="nc" id="L299">        }</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        for (final CAData caData : caDatas) {</span>
<span class="nc" id="L301">            final String caName = caData.getName();</span>
            try {
<span class="nc" id="L303">                caAdminSession.initializeAndUpgradeCA(caData.getCaId());</span>
<span class="nc" id="L304">                final String expires = ValidityDate.formatAsISO8601ServerTZ(caData.getExpireTime(), ValidityDate.TIMEZONE_SERVER);</span>
<span class="nc" id="L305">                log.info(&quot;Initialized CA: &quot; + String.format(&quot;%-&quot; + maxNameLenght + &quot;s&quot;, caName) + &quot; with expire time: &quot; + expires);</span>
<span class="nc" id="L306">            } catch (CADoesntExistsException e) {</span>
<span class="nc" id="L307">                log.error(&quot;CADoesntExistsException trying to load CA with name: &quot; + caName, e);</span>
<span class="nc" id="L308">            } catch (Throwable e) {</span>
<span class="nc" id="L309">                log.error(&quot;Exception trying to load CA, possible upgrade not performed: &quot; + caName, e);</span>
<span class="nc" id="L310">            }</span>
<span class="nc" id="L311">        }</span>
<span class="nc" id="L312">    }</span>

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public void initializeAndUpgradeCA(Integer caid) throws CADoesntExistsException {
<span class="nc" id="L317">        caSession.getCAInfoInternal(caid, null, false);</span>
<span class="nc" id="L318">    }</span>

    @Override
    public void initializeCa(final AuthenticationToken authenticationToken, final CAInfo caInfo)
            throws AuthorizationDeniedException, CryptoTokenOfflineException, InvalidAlgorithmException {

<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (caInfo.getStatus() != CAConstants.CA_UNINITIALIZED) {</span>
<span class="nc" id="L325">            throw new IllegalArgumentException(&quot;CA Status was not CA_UNINITIALIZED (&quot; + CAConstants.CA_UNINITIALIZED + &quot;)&quot;);</span>
        }
        //Find the intended status
<span class="nc" id="L328">        caInfo.setStatus(getCaStatus(caInfo));</span>

        // Since it's acceptable that SubjectDN (and CAId) changes, in initializing we'll simply kill the old uninitialized CA and then recreate it if anything has changed.
<span class="nc" id="L331">        int calculatedCAId = CertTools.stringToBCDNString(caInfo.getSubjectDN()).hashCode();</span>
<span class="nc" id="L332">        int currentCAId = caInfo.getCAId();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (calculatedCAId != currentCAId) {</span>
<span class="nc" id="L334">            caSession.removeCA(authenticationToken, currentCAId);</span>
<span class="nc" id="L335">            caInfo.setCAId(calculatedCAId);</span>
<span class="nc" id="L336">            updateCAIds(authenticationToken, currentCAId, calculatedCAId, caInfo.getSubjectDN());</span>
<span class="nc" id="L337">            CAIdTools.rebuildExtendedServices(caInfo);</span>
            try {
<span class="nc" id="L339">                createCA(authenticationToken, caInfo);</span>
<span class="nc" id="L340">            } catch (CAExistsException e) {</span>
<span class="nc" id="L341">                throw new IllegalStateException(e);</span>
<span class="nc" id="L342">            }</span>
        } else {
            // No Subject DN change
<span class="nc" id="L345">            CAToken caToken = caInfo.getCAToken();</span>
<span class="nc" id="L346">            CertificateProfile certprofile = certificateProfileSession.getCertificateProfile(caInfo.getCertificateProfileId());</span>
<span class="nc" id="L347">            CryptoToken cryptoToken = cryptoTokenManagementSession.getCryptoToken(caToken.getCryptoTokenId());</span>
            // See if CA token is OK before generating keys
            try {
<span class="nc" id="L350">                cryptoToken.testKeyPair(caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_KEYTEST));</span>
<span class="nc" id="L351">            } catch (InvalidKeyException e1) {</span>
<span class="nc" id="L352">                throw new IllegalStateException(&quot;The CA's test key alias points to an invalid key.&quot;, e1);</span>
<span class="nc" id="L353">            }</span>

            try {
<span class="nc" id="L356">                mergeCertificatePoliciesFromCAAndProfile(caInfo, certprofile);</span>
<span class="nc" id="L357">                caSession.editCA(authenticationToken, caInfo);</span>
<span class="nc" id="L358">                CA ca = caSession.getCA(authenticationToken, caInfo.getCAId());</span>
<span class="nc" id="L359">                ca.updateUninitializedCA(caInfo);</span>
<span class="nc" id="L360">                ca.setCAToken(caToken);</span>
<span class="nc" id="L361">                ca.setCAInfo(caInfo);</span>
                //Store the chain and new status.
<span class="nc" id="L363">                caSession.editCA(authenticationToken, ca, false);</span>

                // Finish up and create certificate chain, CRL, etc.
<span class="nc" id="L366">                finalizeInitializedCA(authenticationToken, ca, caInfo, cryptoToken, certprofile);</span>
<span class="nc" id="L367">            } catch (CADoesntExistsException e) {</span>
                // getCAInfo should have thrown this exception already
<span class="nc" id="L369">                throw new IllegalStateException(e);</span>
<span class="nc" id="L370">            }</span>
        }

<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (caInfo.getSignedBy() != CAInfo.SIGNEDBYEXTERNALCA) {</span>
            try {
<span class="nc" id="L375">                renewAndRevokeCmsCertificate(authenticationToken, caInfo.getCAId());</span>
<span class="nc" id="L376">            } catch (CADoesntExistsException e) {</span>
                // getCAInfo should have thrown this exception already
<span class="nc" id="L378">                throw new IllegalStateException(e);</span>
<span class="nc" id="L379">            } catch (CAOfflineException e) {</span>
                // This should not happen.
                // The user can ignore these errors if he/she does not use CMS
<span class="nc" id="L382">                log.error(&quot;Failed to renew extended service (CMS) certificates for ca '&quot; + caInfo.getName() + &quot;'.&quot;, e);</span>
<span class="nc" id="L383">            } catch (CertificateRevokeException e) {</span>
                // ditto
<span class="nc" id="L385">                log.error(&quot;Failed to renew extended service (CMS) certificates for ca '&quot; + caInfo.getName() + &quot;'.&quot;, e);</span>
<span class="nc" id="L386">            }</span>
        }
<span class="nc" id="L388">    }</span>

    @Override
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void updateCAIds(AuthenticationToken authenticationToken, int fromId, int toId, String toDN) throws AuthorizationDeniedException {
<span class="nc" id="L393">        log.info(&quot;Updating CAIds in relations from &quot; + fromId + &quot; to &quot; + toId + &quot;\n&quot;);</span>

        // Update Certificate Profiles
<span class="nc" id="L396">        final Map&lt;Integer, String&gt; certProfiles = certificateProfileSession.getCertificateProfileIdToNameMap();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        for (Integer certProfId : certProfiles.keySet()) {</span>
<span class="nc" id="L398">            final CertificateProfile certProfile = certificateProfileSession.getCertificateProfile(certProfId);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (CAIdTools.updateCAIds(certProfile, fromId, toId, toDN)) {</span>
<span class="nc" id="L400">                String name = certProfiles.get(certProfId);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L402">                    log.debug(&quot;Changing CA Ids in Certificate Profile &quot; + name);</span>
                }
<span class="nc" id="L404">                certificateProfileSession.changeCertificateProfile(authenticationToken, name, certProfile);</span>
            }
<span class="nc" id="L406">        }</span>

        // Update End-Entity Profiles
<span class="nc" id="L409">        final Map&lt;Integer, String&gt; endEntityProfiles = endEntityProfileSession.getEndEntityProfileIdToNameMap();</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (Integer endEntityProfId : endEntityProfiles.keySet()) {</span>
<span class="nc" id="L411">            final EndEntityProfile endEntityProfile = endEntityProfileSession.getEndEntityProfile(endEntityProfId);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (CAIdTools.updateCAIds(endEntityProfile, fromId, toId, toDN)) {</span>
<span class="nc" id="L413">                String name = endEntityProfiles.get(endEntityProfId);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L415">                    log.debug(&quot;Changing CA Ids in End Entity Profile &quot; + name);</span>
                }
                try {
<span class="nc" id="L418">                    endEntityProfileSession.changeEndEntityProfile(authenticationToken, name, endEntityProfile);</span>
<span class="nc" id="L419">                } catch (EndEntityProfileNotFoundException e) {</span>
<span class="nc" id="L420">                    log.error(&quot;End-entity profile &quot; + name + &quot; could no longer be found&quot;, e);</span>
<span class="nc" id="L421">                }</span>
            }
<span class="nc" id="L423">        }</span>

        // Update Approval Profiles
<span class="nc" id="L426">        final Map&lt;Integer, String&gt; approvalProfiles = approvalProfileSession.getApprovalProfileIdToNameMap();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (int appProfId : approvalProfiles.keySet()) {</span>
<span class="nc" id="L428">            final ApprovalProfile approvalProfile = approvalProfileSession.getApprovalProfile(appProfId);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (approvalProfile.updateCAIds(fromId, toId, toDN)) {</span>
<span class="nc" id="L430">                String name = approvalProfile.getProfileName();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L432">                    log.debug(&quot;Changing CA Ids in Approval Profile &quot; + name);</span>
                }
<span class="nc" id="L434">                approvalProfileSession.changeApprovalProfile(authenticationToken, approvalProfile);</span>
            }
<span class="nc" id="L436">        }</span>

        // Update End-Entities
<span class="nc" id="L439">        final Collection&lt;EndEntityInformation&gt; endEntities = endEntityAccessSession.findAllUsersByCaIdNoAuth(fromId);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        for (EndEntityInformation endEntityInfo : endEntities) {</span>
            try {
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L443">                    log.debug(&quot;Changing CA Id of End Entity &quot; + endEntityInfo.getUsername());</span>
                }
<span class="nc" id="L445">                endEntityManagementSession.updateCAId(authenticationToken, endEntityInfo.getUsername(), toId);</span>
<span class="nc" id="L446">            } catch (NoSuchEndEntityException e) {</span>
<span class="nc" id="L447">                log.error(&quot;End entity &quot; + endEntityInfo.getUsername() + &quot; could no longer be found&quot;, e);</span>
<span class="nc" id="L448">            }</span>
<span class="nc" id="L449">        }</span>

        // Update Data Sources
<span class="nc" id="L452">        final Map&lt;Integer, String&gt; dataSources = userDataSourceSession.getUserDataSourceIdToNameMap(authenticationToken);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        for (Integer dataSourceId : dataSources.keySet()) {</span>
<span class="nc" id="L454">            final BaseUserDataSource dataSource = userDataSourceSession.getUserDataSource(authenticationToken, dataSourceId);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (CAIdTools.updateCAIds(dataSource, fromId, toId, toDN)) {</span>
<span class="nc" id="L456">                String name = dataSources.get(dataSourceId);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L458">                    log.debug(&quot;Changing CA Ids in User Data Source &quot; + name);</span>
                }
<span class="nc" id="L460">                userDataSourceSession.changeUserDataSource(authenticationToken, name, dataSource);</span>
            }
<span class="nc" id="L462">        }</span>

        // Update Services
<span class="nc" id="L465">        final Map&lt;Integer, String&gt; services = serviceSession.getServiceIdToNameMap();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        for (String serviceName : services.values()) {</span>
<span class="nc" id="L467">            final ServiceConfiguration serviceConf = serviceSession.getService(serviceName);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (CAIdTools.updateCAIds(serviceConf, fromId, toId, toDN)) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L470">                    log.debug(&quot;Changing CA Ids in Service &quot; + serviceName);</span>
                }
<span class="nc" id="L472">                serviceSession.changeService(authenticationToken, serviceName, serviceConf, false);</span>
            }
<span class="nc" id="L474">        }</span>

        // Update Internal Key Bindings
<span class="nc" id="L477">        Map&lt;String, Map&lt;String, DynamicUiProperty&lt;?&gt;&gt;&gt; keyBindTypes = keyBindMgmtSession.getAvailableTypesAndProperties();</span>
<span class="nc" id="L478">        Map&lt;String, List&lt;Integer&gt;&gt; typesKeybindings = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        for (String type : keyBindTypes.keySet()) {</span>
<span class="nc" id="L480">            typesKeybindings.put(type, keyBindMgmtSession.getInternalKeyBindingIds(authenticationToken, type));</span>
<span class="nc" id="L481">        }</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (Map.Entry&lt;String, List&lt;Integer&gt;&gt; entry : typesKeybindings.entrySet()) {</span>
<span class="nc" id="L483">            final List&lt;Integer&gt; keybindIds = entry.getValue();</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            for (int keybindId : keybindIds) {</span>
<span class="nc" id="L485">                final InternalKeyBinding keybind = keyBindMgmtSession.getInternalKeyBinding(authenticationToken, keybindId);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (CAIdTools.updateCAIds(keybind, fromId, toId, toDN)) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L488">                        log.debug(&quot;Changing CA Ids in Internal Key Binding &quot; + keybind.getName());</span>
                    }
                    try {
<span class="nc" id="L491">                        keyBindMgmtSession.persistInternalKeyBinding(authenticationToken, keybind);</span>
<span class="nc" id="L492">                    } catch (InternalKeyBindingNameInUseException e) {</span>
                        // Should never happen
<span class="nc" id="L494">                        log.error(&quot;Name existed when trying to update keybinding&quot;, e);</span>
<span class="nc" id="L495">                    }</span>
                }
<span class="nc" id="L497">            }</span>
<span class="nc" id="L498">        }</span>

        // Update System Configuration
<span class="nc" id="L501">        GlobalConfiguration globalConfig = (GlobalConfiguration) globalConfigurationSession</span>
<span class="nc" id="L502">                .getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (globalConfig != null) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (CAIdTools.updateCAIds(globalConfig, fromId, toId, toDN)) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L506">                    log.debug(&quot;Changing CA Ids in System Configuration&quot;);</span>
                }
<span class="nc" id="L508">                globalConfigurationSession.saveConfiguration(authenticationToken, globalConfig);</span>
            }
        }

        // Update CMP Configuration
        // Only &quot;Default CA&quot; contains a reference to the Subject DN. All other fields reference the CAs by CA name.
<span class="nc" id="L514">        CmpConfiguration cmpConfig = (CmpConfiguration) globalConfigurationSession.getCachedConfiguration(CmpConfiguration.CMP_CONFIGURATION_ID);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (cmpConfig != null) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (CAIdTools.updateCAIds(cmpConfig, fromId, toId, toDN)) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L518">                    log.debug(&quot;Changing CA Ids in CMP configuration&quot;);</span>
                }
<span class="nc" id="L520">                globalConfigurationSession.saveConfiguration(authenticationToken, cmpConfig);</span>
            }
        }

        // Update Roles
<span class="nc" id="L525">        roleSession.updateCaId(fromId, toId, false, true);</span>
<span class="nc" id="L526">        log.debug(&quot;Done updating CA Ids&quot;);</span>
<span class="nc" id="L527">        final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.updatedcaid&quot;, fromId, toId, toDN);</span>
<span class="nc" id="L528">        auditSession.log(EventTypes.CA_EDITING, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L529">                String.valueOf(toId), null, null, detailsMsg);</span>
<span class="nc" id="L530">    }</span>

    @Override
    public void renewAndRevokeCmsCertificate(final AuthenticationToken admin, int caid)
            throws AuthorizationDeniedException, CADoesntExistsException, CAOfflineException, CertificateRevokeException {
<span class="nc" id="L535">        CAInfo cainfo = caSession.getCAInfo(admin, caid);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        for (final ExtendedCAServiceInfo next : cainfo.getExtendedCAServiceInfos()) {</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if (next instanceof CmsCAServiceInfo) {</span>
<span class="nc" id="L538">                List&lt;Certificate&gt; cmscerts = ((CmsCAServiceInfo) next).getCertificatePath();</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (cmscerts != null) {</span>
<span class="nc" id="L540">                    X509Certificate cmscert = (X509Certificate) cmscerts.get(0);</span>
<span class="nc" id="L541">                    final CertificateDataWrapper cdw = certificateStoreSession.getCertificateData(CertTools.getFingerprintAsString(cmscert));</span>
<span class="nc" id="L542">                    revocationSession.revokeCertificate(admin, cdw, cainfo.getCRLPublishers(), new Date(),</span>
<span class="nc" id="L543">                            RevokedCertInfo.REVOCATION_REASON_UNSPECIFIED, cainfo.getSubjectDN());</span>
                }
<span class="nc" id="L545">                initExternalCAService(admin, caid, next);</span>
            }
<span class="nc" id="L547">        }</span>
<span class="nc" id="L548">    }</span>

    private CA createCAObject(CAInfo cainfo, CAToken catoken, CertificateProfile certprofile) throws InvalidAlgorithmException {
<span class="nc" id="L551">        CA ca = null;</span>
        // X509 CA is the most normal type of CA
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (cainfo instanceof X509CAInfo) {</span>
<span class="nc" id="L554">            log.info(&quot;Creating an X509 CA: &quot; + cainfo.getName());</span>
<span class="nc" id="L555">            X509CAInfo x509cainfo = (X509CAInfo) cainfo;</span>
            // Create X509CA
<span class="nc" id="L557">            ca = new X509CA(x509cainfo);</span>
<span class="nc" id="L558">            ca.setCAToken(catoken);</span>
            // Set certificate policies in profile object
<span class="nc" id="L560">            mergeCertificatePoliciesFromCAAndProfile(x509cainfo, certprofile);</span>
<span class="nc" id="L561">        } else {</span>
            // CVC CA is a special type of CA for EAC electronic passports
<span class="nc" id="L563">            log.info(&quot;Creating a CVC CA: &quot; + cainfo.getName());</span>
<span class="nc" id="L564">            CVCCAInfo cvccainfo = (CVCCAInfo) cainfo;</span>
            // Create CVCCA
<span class="nc" id="L566">            ca = CvcCA.getInstance(cvccainfo);</span>
<span class="nc" id="L567">            ca.setCAToken(catoken);</span>
        }
<span class="nc" id="L569">        return ca;</span>
    }

    /** When creating, or renewing a CA we will merge the certificate policies from the CAInfo and the CertificateProfile.
     * Since  Certificate generation uses the CertificateProfile, we merge them into the CertificateProfile object.
     *
     * @param cainfo cainfo that may contain certificate policies, or not
     * @param certprofile CertificateProfile that may contain certificate policies or not, this object is modified
     */
    private void mergeCertificatePoliciesFromCAAndProfile(CAInfo cainfo, CertificateProfile certprofile) {
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (cainfo instanceof X509CAInfo) {</span>
<span class="nc" id="L580">            X509CAInfo x509cainfo = (X509CAInfo) cainfo;</span>
            // getCertificateProfile
<span class="nc bnc" id="L582" title="All 4 branches missed.">            if ((x509cainfo.getPolicies() != null) &amp;&amp; (x509cainfo.getPolicies().size() &gt; 0)) {</span>
<span class="nc" id="L583">                List&lt;CertificatePolicy&gt; policies = certprofile.getCertificatePolicies();</span>
<span class="nc" id="L584">                policies.addAll(x509cainfo.getPolicies());</span>
                // If the profile did not say to use the extensions before, add it.
<span class="nc" id="L586">                certprofile.setUseCertificatePolicies(true);</span>
            }
        }
        // If not an X509CA, we will not do anything, because there are only certificate policies for X509CAs
<span class="nc" id="L590">    }</span>

    @Override
    public void createCA(final AuthenticationToken admin, final CAInfo cainfo)
            throws AuthorizationDeniedException, CAExistsException, CryptoTokenOfflineException, InvalidAlgorithmException {
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L596">            log.trace(&quot;&gt;createCA: &quot; + cainfo.getName());</span>
        }
<span class="nc" id="L598">        final int caid = cainfo.getCAId();</span>
        // Check that administrator has superadminstrator rights.
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(admin, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L601">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtocreateca&quot;, cainfo.getName());</span>
<span class="nc" id="L602">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L603">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L604">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
        // Check that CA doesn't already exists
<span class="nc bnc" id="L607" title="All 4 branches missed.">        if (caid &gt;= 0 &amp;&amp; caid &lt;= CAInfo.SPECIALCAIDBORDER) {</span>
<span class="nc" id="L608">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.wrongcaid&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L609">            auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, detailsMsg);
<span class="nc" id="L611">            throw new CAExistsException(detailsMsg);</span>
        }
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (caSession.findById(Integer.valueOf(caid)) != null) {</span>
<span class="nc" id="L614">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.caexistsid&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L615">            auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, detailsMsg);
<span class="nc" id="L617">            throw new CAExistsException(detailsMsg);</span>
        }
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (caSession.findByName(cainfo.getName()) != null) {</span>
<span class="nc" id="L620">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.caexistsname&quot;, cainfo.getName());</span>
<span class="nc" id="L621">            auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, detailsMsg);
<span class="nc" id="L623">            throw new CAExistsException(detailsMsg);</span>
        }
        // Check if we are creating a CVC CA, and in case we have a unique (issuerDN,serialNumber) index in the database, then fail fast.
<span class="nc bnc" id="L626" title="All 4 branches missed.">        if ((cainfo.getCAType() == CAInfo.CATYPE_CVC) &amp;&amp; certificateStoreSession.isUniqueCertificateSerialNumberIndex()) {</span>
<span class="nc" id="L627">            throw new IllegalArgumentException(</span>
                    &quot;Not possible to create CVC CA when there is a unique (issuerDN, serialNumber) index in the database.&quot;);
        }
        // Create CAToken
<span class="nc" id="L631">        final CAToken caToken = cainfo.getCAToken();</span>
<span class="nc" id="L632">        int cryptoTokenId = caToken.getCryptoTokenId();</span>
<span class="nc" id="L633">        final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(cryptoTokenId);</span>
        // The certificate profile used for the CAs certificate
<span class="nc" id="L635">        CertificateProfile certprofile = certificateProfileSession.getCertificateProfile(cainfo.getCertificateProfileId());</span>
        // Create CA
<span class="nc" id="L637">        CA ca = createCAObject(cainfo, caToken, certprofile);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (cainfo.getStatus() != CAConstants.CA_UNINITIALIZED) {</span>
            // See if CA token is OK before storing CA, but skip if no keys can be guaranteed to exist.
            try {
<span class="nc" id="L641">                cryptoToken.testKeyPair(caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_KEYTEST));</span>
<span class="nc" id="L642">            } catch (InvalidKeyException e1) {</span>
<span class="nc" id="L643">                throw new RuntimeException(&quot;The CA's test key alias points to an invalid key.&quot;, e1);</span>
<span class="nc" id="L644">            }</span>
        }
        // Store CA in database, so we can generate keys using the ca token session.
        try {
<span class="nc" id="L648">            caSession.addCA(admin, ca);</span>
<span class="nc" id="L649">        } catch (CAExistsException e) {</span>
<span class="nc" id="L650">            String msg = intres.getLocalizedMessage(&quot;caadmin.caexistsid&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L651">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L652">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L653">            auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, details);
<span class="nc" id="L655">            sessionContext.setRollbackOnly(); // This is an application exception so it wont trigger a roll-back automatically</span>
<span class="nc" id="L656">            throw e;</span>
<span class="nc" id="L657">        }</span>

        // Finish up and create certificate chain etc.
        // Both code paths will audit log.
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (cainfo.getStatus() != CAConstants.CA_UNINITIALIZED) {</span>
<span class="nc" id="L662">            finalizeInitializedCA(admin, ca, cainfo, cryptoToken, certprofile);</span>
        } else {
            // Special handling for uninitialized CAs
<span class="nc" id="L665">            ca.setCertificateChain(new ArrayList&lt;Certificate&gt;());</span>
<span class="nc" id="L666">            ca.setStatus(CAConstants.CA_UNINITIALIZED);</span>

<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L669">                log.debug(&quot;Setting CA status to: &quot; + CAConstants.CA_UNINITIALIZED);</span>
            }
            try {
<span class="nc" id="L672">                caSession.editCA(admin, ca, true);</span>
<span class="nc" id="L673">            } catch (CADoesntExistsException e) {</span>
<span class="nc" id="L674">                final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.canotexistsid&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L675">                auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L676">                        String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L677">                throw new EJBException(e);</span>
<span class="nc" id="L678">            }</span>
        }
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L681">            log.trace(&quot;&lt;createCA: &quot; + cainfo.getName());</span>
        }
<span class="nc" id="L683">    }</span>

    /**
     * The final steps of creating a CA, which are not performed for uninitialized CAs until
     * they are initialized.
     *
     * It creates a certificate chain and publishes certificate, services, CRLs, etc.
     * This method also performs audit logging.
     * @param admin Admin
     * @param ca CA
     * @param cainfo Info 
     * @param cryptoToken Token 
     * @param certprofile Profile
     * @throws CryptoTokenOfflineException If offline 
     * @throws AuthorizationDeniedException  If access denied
     */
    private void finalizeInitializedCA(final AuthenticationToken admin, final CA ca, final CAInfo cainfo, final CryptoToken cryptoToken,
            final CertificateProfile certprofile) throws CryptoTokenOfflineException, AuthorizationDeniedException {

<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (cainfo.getStatus() == CAConstants.CA_UNINITIALIZED) {</span>
<span class="nc" id="L703">            throw new IllegalStateException(&quot;This method should never be called on uninitialized CAs&quot;);</span>
        }

<span class="nc" id="L706">        final int caid = cainfo.getCAId();</span>
<span class="nc" id="L707">        List&lt;Certificate&gt; certificatechain = createCertificateChain(admin, ca, cryptoToken, certprofile);</span>
<span class="nc" id="L708">        int castatus = getCaStatus(cainfo);</span>
<span class="nc" id="L709">        ca.setCertificateChain(certificatechain);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L711">            log.debug(&quot;Setting CA status to: &quot; + castatus);</span>
        }
<span class="nc" id="L713">        ca.setStatus(castatus);</span>
        try {
<span class="nc" id="L715">            caSession.editCA(admin, ca, true);</span>
<span class="nc" id="L716">        } catch (CADoesntExistsException e) {</span>
<span class="nc" id="L717">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.canotexistsid&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L718">            auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, detailsMsg);
<span class="nc" id="L720">            throw new EJBException(e);</span>
<span class="nc" id="L721">        }</span>
        // Publish CA certificates if CA is initialized
<span class="nc" id="L723">        publishCACertificate(admin, ca.getCertificateChain(), ca.getCRLPublishers(), ca.getSubjectDN());</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        switch (castatus) {</span>
        case CAConstants.CA_ACTIVE:
            // activate External CA Services
<span class="nc" id="L727">            activateAndPublishExternalCAServices(admin, cainfo.getExtendedCAServiceInfos(), ca);</span>
            try {
<span class="nc" id="L729">                caSession.editCA(admin, ca, false); // store any activates CA services</span>
                // create initial CRLs
<span class="nc" id="L731">                publishingCrlSession.forceCRL(admin, ca.getCAId());</span>
<span class="nc" id="L732">                publishingCrlSession.forceDeltaCRL(admin, ca.getCAId());</span>
<span class="nc" id="L733">            } catch (CADoesntExistsException e) {</span>
<span class="nc" id="L734">                String msg = intres.getLocalizedMessage(&quot;caadmin.errorcreateca&quot;, cainfo.getName());</span>
<span class="nc" id="L735">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L736">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L737">                details.put(&quot;error&quot;, e.getMessage());</span>
<span class="nc" id="L738">                auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L739">                        String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L740">                throw new EJBException(e);</span>
<span class="nc" id="L741">            } catch (CAOfflineException e) {</span>
<span class="nc" id="L742">                String msg = intres.getLocalizedMessage(&quot;caadmin.errorcreateca&quot;, cainfo.getName());</span>
<span class="nc" id="L743">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L744">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L745">                details.put(&quot;error&quot;, e.getMessage());</span>
<span class="nc" id="L746">                auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L747">                        String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L748">                throw new EJBException(e);</span>
<span class="nc" id="L749">            }</span>
            break;
        default:
<span class="nc" id="L752">            log.error(&quot;CA status not active when creating CA, extended services not created. CA status: &quot; + castatus);</span>
            break;
        }

        // Update local OCSP's CA certificate cache
<span class="nc" id="L757">        certificateStoreSession.reloadCaCertificateCache();</span>
<span class="nc" id="L758">    }</span>

    private int getCaStatus(CAInfo cainfo) {
<span class="nc" id="L761">        int castatus = CAConstants.CA_OFFLINE;</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (cainfo.getSignedBy() == CAInfo.SELFSIGNED) {</span>
<span class="nc" id="L763">            castatus = CAConstants.CA_ACTIVE;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        } else if (cainfo.getSignedBy() == CAInfo.SIGNEDBYEXTERNALCA) {</span>
            // set status to waiting certificate response.
<span class="nc" id="L766">            castatus = CAConstants.CA_WAITING_CERTIFICATE_RESPONSE;</span>
<span class="nc bnc" id="L767" title="All 4 branches missed.">        } else if (cainfo.getSignedBy() &gt; CAInfo.SPECIALCAIDBORDER || cainfo.getSignedBy() &lt; 0) {</span>
<span class="nc" id="L768">            castatus = CAConstants.CA_ACTIVE;</span>
        }
<span class="nc" id="L770">        return castatus;</span>
    }

    private List&lt;Certificate&gt; createCertificateChain(AuthenticationToken authenticationToken, CA ca, CryptoToken cryptoToken,
            CertificateProfile certprofile) throws CryptoTokenOfflineException {
<span class="nc" id="L775">        final CAInfo cainfo = ca.getCAInfo();</span>
<span class="nc" id="L776">        final CAToken caToken = cainfo.getCAToken();</span>
<span class="nc" id="L777">        List&lt;Certificate&gt; certificatechain = null;</span>
<span class="nc" id="L778">        final String sequence = caToken.getKeySequence(); // get from CAtoken to make sure it is fresh</span>
<span class="nc" id="L779">        final String aliasCertSign = caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN);</span>
<span class="nc" id="L780">        int caid = cainfo.getCAId();</span>
<span class="nc" id="L781">        final AvailableCustomCertificateExtensionsConfiguration cceConfig = (AvailableCustomCertificateExtensionsConfiguration) globalConfigurationSession</span>
<span class="nc" id="L782">                .getCachedConfiguration(AvailableCustomCertificateExtensionsConfiguration.CONFIGURATION_ID);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        if (cainfo.getSignedBy() == CAInfo.SELFSIGNED) {</span>
            try {
                // create selfsigned certificate
<span class="nc" id="L786">                Certificate cacertificate = null;</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L788">                    log.debug(&quot;CAAdminSessionBean : &quot; + cainfo.getSubjectDN());</span>
                }
<span class="nc" id="L790">                EndEntityInformation cadata = makeEndEntityInformation(cainfo);</span>
<span class="nc" id="L791">                cacertificate = ca.generateCertificate(cryptoToken, cadata, cryptoToken.getPublicKey(aliasCertSign), -1, null,</span>
<span class="nc" id="L792">                        cainfo.getEncodedValidity(), certprofile, sequence, cceConfig);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L794">                    log.debug(&quot;CAAdminSessionBean : &quot; + CertTools.getSubjectDN(cacertificate));</span>
                }
                // Build Certificate Chain
<span class="nc" id="L797">                certificatechain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L798">                certificatechain.add(cacertificate);</span>
                // set status to active

<span class="nc" id="L801">            } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L802">                final String detailsMsg = intres.getLocalizedMessage(&quot;error.catokenoffline&quot;, cainfo.getName());</span>
<span class="nc" id="L803">                auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L804">                        String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L805">                sessionContext.setRollbackOnly(); // This is an application exception so it wont trigger a roll-back automatically</span>
<span class="nc" id="L806">                throw e;</span>
<span class="nc" id="L807">            } catch (Exception fe) {</span>
<span class="nc" id="L808">                String msg = intres.getLocalizedMessage(&quot;caadmin.errorcreateca&quot;, cainfo.getName());</span>
<span class="nc" id="L809">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L810">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L811">                details.put(&quot;error&quot;, fe.getMessage());</span>
<span class="nc" id="L812">                auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L813">                        String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L814">                throw new EJBException(fe);</span>
<span class="nc" id="L815">            }</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        } else if (cainfo.getSignedBy() == CAInfo.SIGNEDBYEXTERNALCA) {</span>
<span class="nc" id="L817">            certificatechain = new ArrayList&lt;Certificate&gt;();</span>

<span class="nc bnc" id="L819" title="All 4 branches missed.">        } else if (cainfo.getSignedBy() &gt; CAInfo.SPECIALCAIDBORDER || cainfo.getSignedBy() &lt; 0) {</span>
            // Create CA signed by other internal CA.
            try {
<span class="nc" id="L822">                final CA signca = caSession.getCAForEdit(authenticationToken, Integer.valueOf(cainfo.getSignedBy()));</span>
                // Check that the signer is valid
<span class="nc" id="L824">                assertSignerValidity(authenticationToken, signca);</span>
                // Create CA certificate
<span class="nc" id="L826">                EndEntityInformation cadata = makeEndEntityInformation(cainfo);</span>
<span class="nc" id="L827">                CryptoToken signCryptoToken = cryptoTokenSession.getCryptoToken(signca.getCAToken().getCryptoTokenId());</span>
<span class="nc" id="L828">                final Certificate cacertificate = signca.generateCertificate(signCryptoToken, cadata, cryptoToken.getPublicKey(aliasCertSign), -1,</span>
<span class="nc" id="L829">                        null, cainfo.getEncodedValidity(), certprofile, sequence, cceConfig);</span>
                // Build Certificate Chain
<span class="nc" id="L831">                List&lt;Certificate&gt; rootcachain = signca.getCertificateChain();</span>
<span class="nc" id="L832">                certificatechain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L833">                certificatechain.add(cacertificate);</span>
<span class="nc" id="L834">                certificatechain.addAll(rootcachain);</span>
                // set status to active

<span class="nc" id="L837">            } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L838">                final String detailsMsg = intres.getLocalizedMessage(&quot;error.catokenoffline&quot;, cainfo.getName());</span>
<span class="nc" id="L839">                auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L840">                        String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L841">                sessionContext.setRollbackOnly(); // This is an application exception so it wont trigger a roll-back automatically</span>
<span class="nc" id="L842">                throw e;</span>
<span class="nc" id="L843">            } catch (Exception fe) {</span>
<span class="nc" id="L844">                String msg = intres.getLocalizedMessage(&quot;caadmin.errorcreateca&quot;, cainfo.getName());</span>
<span class="nc" id="L845">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L846">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L847">                details.put(&quot;error&quot;, fe.getMessage());</span>
<span class="nc" id="L848">                auditSession.log(EventTypes.CA_CREATION, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L849">                        String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L850">                throw new EJBException(fe);</span>
<span class="nc" id="L851">            }</span>
        }
<span class="nc" id="L853">        return certificatechain;</span>

    }

    private EndEntityInformation makeEndEntityInformation(final CAInfo cainfo) {
<span class="nc" id="L858">        String caAltName = null;</span>
<span class="nc" id="L859">        ExtendedInformation extendedinfo = null;</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (cainfo instanceof X509CAInfo) {</span>
<span class="nc" id="L861">            final X509CAInfo x509cainfo = (X509CAInfo) cainfo;</span>
<span class="nc" id="L862">            caAltName = x509cainfo.getSubjectAltName();</span>
<span class="nc" id="L863">            extendedinfo = new ExtendedInformation();</span>
<span class="nc" id="L864">            extendedinfo.setNameConstraintsPermitted(x509cainfo.getNameConstraintsPermitted());</span>
<span class="nc" id="L865">            extendedinfo.setNameConstraintsExcluded(x509cainfo.getNameConstraintsExcluded());</span>
        }

<span class="nc" id="L868">        return new EndEntityInformation(&quot;nobody&quot;, cainfo.getSubjectDN(), cainfo.getSubjectDN().hashCode(), caAltName, null, 0,</span>
<span class="nc" id="L869">                new EndEntityType(EndEntityTypes.INVALID), 0, cainfo.getCertificateProfileId(), null, null, 0, 0, extendedinfo);</span>
    }

    @Override
    public void editCA(AuthenticationToken admin, CAInfo cainfo) throws AuthorizationDeniedException {
<span class="nc" id="L874">        boolean cmsrenewcert = false;</span>
<span class="nc" id="L875">        final int caid = cainfo.getCAId();</span>

        // In uninitialized CAs, the Subject DN might change, and then
        // we need to update the CA ID as well.
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (cainfo.getStatus() == CAConstants.CA_UNINITIALIZED) {</span>
<span class="nc" id="L880">            int calculatedCAId = CertTools.stringToBCDNString(cainfo.getSubjectDN()).hashCode();</span>
<span class="nc" id="L881">            int currentCAId = cainfo.getCAId();</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">            if (calculatedCAId != currentCAId) {</span>
<span class="nc" id="L883">                caSession.removeCA(admin, currentCAId);</span>
<span class="nc" id="L884">                cainfo.setCAId(calculatedCAId);</span>
<span class="nc" id="L885">                updateCAIds(admin, currentCAId, calculatedCAId, cainfo.getSubjectDN());</span>
<span class="nc" id="L886">                CAIdTools.rebuildExtendedServices(cainfo);</span>
                try {
<span class="nc" id="L888">                    createCA(admin, cainfo);</span>
<span class="nc" id="L889">                } catch (CAExistsException e) {</span>
<span class="nc" id="L890">                    throw new IllegalStateException(e);</span>
<span class="nc" id="L891">                } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L892">                    throw new IllegalStateException(e);</span>
<span class="nc" id="L893">                } catch (InvalidAlgorithmException e) {</span>
<span class="nc" id="L894">                    throw new IllegalStateException(e);</span>
<span class="nc" id="L895">                }</span>
            }
        }

        // Check if extended service certificates are about to be renewed.
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (cainfo.getStatus() != CAConstants.CA_UNINITIALIZED) {</span>
<span class="nc" id="L901">            final Collection&lt;ExtendedCAServiceInfo&gt; extendedCAServiceInfos = cainfo.getExtendedCAServiceInfos();</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if (extendedCAServiceInfos != null) {</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                for (final ExtendedCAServiceInfo extendedCAServiceInfo : extendedCAServiceInfos) {</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                    if (extendedCAServiceInfo instanceof CmsCAServiceInfo) {</span>
<span class="nc" id="L905">                        final BaseSigningCAServiceInfo signingInfo = (BaseSigningCAServiceInfo) extendedCAServiceInfo;</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                        cmsrenewcert = signingInfo.getRenewFlag()</span>
<span class="nc bnc" id="L907" title="All 4 branches missed.">                                || (signingInfo.getCertificatePath() == null &amp;&amp; signingInfo.getStatus() == ExtendedCAServiceInfo.STATUS_ACTIVE);</span>
                    }
<span class="nc" id="L909">                }</span>
            }
        }

        // Get CA from database
        try {
<span class="nc" id="L915">            caSession.editCA(admin, cainfo);</span>
<span class="nc" id="L916">            CA ca = caSession.getCA(admin, cainfo.getCAId());</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">            if (cainfo.getStatus() != CAConstants.CA_UNINITIALIZED) {</span>
                // No OCSP Certificate exists that can be renewed.
<span class="nc bnc" id="L919" title="All 2 branches missed.">                if (cmsrenewcert) {</span>
<span class="nc" id="L920">                    CmsCAServiceInfo info = (CmsCAServiceInfo) ca.getExtendedCAServiceInfo(ExtendedCAServiceTypes.TYPE_CMSEXTENDEDSERVICE);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                    if (info.getStatus() == ExtendedCAServiceInfo.STATUS_ACTIVE) {</span>
<span class="nc" id="L922">                        final ArrayList&lt;Certificate&gt; cmscertificate = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L923">                        cmscertificate.add(info.getCertificatePath().get(0));</span>
                        // Publish the extended service certificate, but only for active services
<span class="nc" id="L925">                        publishCACertificate(admin, cmscertificate, ca.getCRLPublishers(), ca.getSubjectDN());</span>
                    }
                }
            }
            // Log Action was done by caSession
<span class="nc" id="L930">        } catch (AuthorizationDeniedException e) {</span>
<span class="nc" id="L931">            String msg = intres.getLocalizedMessage(&quot;caadmin.erroreditca&quot;, cainfo.getName());</span>
<span class="nc" id="L932">            log.error(msg, e);</span>
<span class="nc" id="L933">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L934">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L935">            auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, details);
<span class="nc" id="L937">            throw e;</span>
<span class="nc" id="L938">        } catch (CADoesntExistsException e) {</span>
<span class="nc" id="L939">            throw new IllegalArgumentException(e);</span>
<span class="nc" id="L940">        }</span>
<span class="nc" id="L941">    }</span>

    @Override
    public byte[] makeRequest(AuthenticationToken authenticationToken, int caid, Collection&lt;?&gt; certChain, String nextSignKeyAlias)
            throws AuthorizationDeniedException, CertPathValidatorException, CryptoTokenOfflineException {
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L947">            log.trace(&quot;&gt;makeRequest: &quot; + caid + &quot;, certChain=&quot; + certChain + &quot;, nextSignKeyAlias=&quot; + nextSignKeyAlias);</span>
        }
<span class="nc" id="L949">        byte[] returnval = null;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CARENEW.resource())) {</span>
<span class="nc" id="L951">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtocertreq&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L952">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L953">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L954">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
        try {
<span class="nc" id="L957">            final AvailableCustomCertificateExtensionsConfiguration cceConfig = (AvailableCustomCertificateExtensionsConfiguration) globalConfigurationSession</span>
<span class="nc" id="L958">                .getCachedConfiguration(AvailableCustomCertificateExtensionsConfiguration.CONFIGURATION_ID);</span>
<span class="nc" id="L959">            final CA ca = caSession.getCAForEdit(authenticationToken, caid);</span>
<span class="nc" id="L960">            final List&lt;Certificate&gt; chain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc bnc" id="L961" title="All 4 branches missed.">            if (certChain != null &amp;&amp; certChain.size() &gt; 0) {</span>
<span class="nc" id="L962">                chain.addAll(CertTools.createCertChain(certChain));</span>
<span class="nc" id="L963">                log.debug(&quot;Setting request certificate chain of size: &quot; + chain.size());</span>
<span class="nc" id="L964">                ca.setRequestCertificateChain(chain);</span>
            }
            // AR+ patch to make SPOC independent of external CVCA certificates for automatic renewals
            // i.e. if we don't pass a CA certificate as parameter we try to find a suitable CA certificate in the database, among existing CAs
            // (can be a simple imported CA-certificate of external CA)
<span class="nc bnc" id="L969" title="All 6 branches missed.">            if (chain.isEmpty() &amp;&amp; ca.getCAType() == CAInfo.CATYPE_CVC &amp;&amp; ca.getSignedBy() == CAInfo.SIGNEDBYEXTERNALCA</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">                    &amp;&amp; ca.getStatus() == CAConstants.CA_ACTIVE) {</span>
<span class="nc" id="L971">                final CardVerifiableCertificate dvcert = (CardVerifiableCertificate) ca.getCACertificate();</span>
<span class="nc" id="L972">                final String ca_ref = dvcert.getCVCertificate().getCertificateBody().getAuthorityReference().getConcatenated();</span>
<span class="nc" id="L973">                log.debug(&quot;DV renewal missing CVCA cert, try finding CA for:&quot; + ca_ref);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">                for (final Integer availableCaId : caSession.getAuthorizedCaIds(authenticationToken)) {</span>
<span class="nc" id="L975">                    final CA cvca = caSession.getCA(authenticationToken, availableCaId);</span>
<span class="nc bnc" id="L976" title="All 4 branches missed.">                    if (cvca.getCAType() == CAInfo.CATYPE_CVC &amp;&amp; cvca.getSignedBy() == CAInfo.SELFSIGNED) {</span>
<span class="nc" id="L977">                        final CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cvca.getCACertificate();</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">                        if (ca_ref.equals(cvccert.getCVCertificate().getCertificateBody().getHolderReference().getConcatenated())) {</span>
<span class="nc" id="L979">                            log.debug(&quot;Added missing CVCA to rewnewal request: &quot; + cvca.getName());</span>
<span class="nc" id="L980">                            chain.add(cvccert);</span>
<span class="nc" id="L981">                            break;</span>
                        }
                    }
<span class="nc" id="L984">                }</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                if (chain.isEmpty()) {</span>
<span class="nc" id="L986">                    log.info(&quot;Failed finding suitable CVCA, forgot to import it?&quot;);</span>
                }
            }
            // AR-

            // Generate new certificate signing request.
<span class="nc" id="L992">            final CAToken caToken = ca.getCAToken();</span>
<span class="nc" id="L993">            final String signatureAlgorithm = caToken.getSignatureAlgorithm();</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L995">                log.debug(&quot;Using signing algorithm: &quot; + signatureAlgorithm + &quot; for the CSR.&quot;);</span>
            }
<span class="nc" id="L997">            final Properties oldprop = caToken.getProperties();</span>
<span class="nc" id="L998">            final String oldsequence = caToken.getKeySequence();</span>
            // If no alias is supplied we use the CAs current signature key and the KeySequence to generate a new one
<span class="nc bnc" id="L1000" title="All 4 branches missed.">            if (nextSignKeyAlias == null || nextSignKeyAlias.length() == 0) {</span>
<span class="nc" id="L1001">                nextSignKeyAlias = caToken.generateNextSignKeyAlias();</span>
            }
<span class="nc" id="L1003">            caToken.setNextCertSignKey(nextSignKeyAlias);</span>
<span class="nc" id="L1004">            final int cryptoTokenId = caToken.getCryptoTokenId();</span>
            try {
                // Test if key already exists
<span class="nc" id="L1007">                cryptoTokenManagementSession.testKeyPair(authenticationToken, cryptoTokenId, nextSignKeyAlias);</span>
<span class="nc" id="L1008">            } catch (Exception e) {</span>
                try {
<span class="nc" id="L1010">                    final String currentSignKeyAlias = caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN);</span>
<span class="nc" id="L1011">                    cryptoTokenManagementSession.createKeyPairWithSameKeySpec(authenticationToken, cryptoTokenId, currentSignKeyAlias,</span>
                            nextSignKeyAlias);
                    // Audit log CA key generation
<span class="nc" id="L1014">                    final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1015">                    details.put(&quot;msg&quot;, intres.getLocalizedMessage(&quot;catoken.generatedkeys&quot;, caid, true, false));</span>
<span class="nc" id="L1016">                    details.put(&quot;oldproperties&quot;, oldprop);</span>
<span class="nc" id="L1017">                    details.put(&quot;oldsequence&quot;, oldsequence);</span>
<span class="nc" id="L1018">                    details.put(&quot;properties&quot;, caToken.getProperties());</span>
<span class="nc" id="L1019">                    details.put(&quot;sequence&quot;, caToken.getKeySequence());</span>
<span class="nc" id="L1020">                    auditSession.log(EventTypes.CA_KEYGEN, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1021">                            String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L1022">                } catch (AuthorizationDeniedException | CryptoTokenOfflineException e2) {</span>
<span class="nc" id="L1023">                    throw e2;</span>
<span class="nc" id="L1024">                } catch (Exception e2) {</span>
<span class="nc" id="L1025">                    throw new RuntimeException(e2);</span>
<span class="nc" id="L1026">                }</span>
<span class="nc" id="L1027">            }</span>
<span class="nc" id="L1028">            ca.setCAToken(caToken);</span>
            // The CA certificate signing this request is the first in the certificate chain
<span class="nc bnc" id="L1030" title="All 2 branches missed.">            final Certificate caCert = chain.size() == 0 ? null : chain.get(0);</span>
<span class="nc" id="L1031">            final CryptoToken cryptoToken = cryptoTokenManagementSession.getCryptoToken(cryptoTokenId);</span>
<span class="nc" id="L1032">            final CertificateProfile certificateProfile = certificateProfileSession.getCertificateProfile(ca.getCertificateProfileId());</span>
<span class="nc" id="L1033">            byte[] request = ca.createRequest(cryptoToken, null, signatureAlgorithm, caCert, CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT, certificateProfile, cceConfig);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            if (ca.getCAType() == CAInfo.CATYPE_CVC) {</span>
                /*
                 * If this is a CVC CA renewal request, we need to sign it to make an authenticated
                 * request. The CVC CAs current signing certificate will always be the right one,
                 * because it is the &quot;previous&quot; signing certificate until we have imported a new
                 * one as response to the request we create here.
                 */
                // Sign the request with the current sign key making it an CVCAuthenticatedRequest
<span class="nc" id="L1042">                final byte[] authCertSignRequest = ca.createAuthCertSignRequest(cryptoToken, request);</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                if (authCertSignRequest != null) {</span>
<span class="nc" id="L1044">                    returnval = authCertSignRequest;</span>
                } else {
                    // This is expected if we try to generate another CSR from a CA which has not yet received a response.
<span class="nc" id="L1047">                    log.debug(&quot;Unable to create authorization signature on CSR. Returning a regular request.&quot;);</span>
<span class="nc" id="L1048">                    returnval = request;</span>
                }
<span class="nc" id="L1050">            } else {</span>
<span class="nc" id="L1051">                returnval = request;</span>
            }
<span class="nc" id="L1053">            caSession.editCA(authenticationToken, ca, true);</span>
            // Log information about the event
<span class="nc" id="L1055">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.certreqcreated&quot;, ca.getName(), Integer.valueOf(caid));</span>
<span class="nc" id="L1056">            auditSession.log(EventTypes.CA_EDITING, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1057">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1058">        } catch (CertPathValidatorException e) {</span>
<span class="nc" id="L1059">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorcertreq&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1060">            auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1061">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1062">            throw e;</span>
<span class="nc" id="L1063">        } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L1064">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorcertreq&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1065">            auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1066">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1067">            throw e;</span>
<span class="nc" id="L1068">        } catch (Exception e) {</span>
<span class="nc" id="L1069">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorcertreq&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1070">            auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1071">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1072">            throw new EJBException(e);</span>
<span class="nc" id="L1073">        }</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1075">            log.trace(&quot;&lt;makeRequest: &quot; + caid);</span>
        }
<span class="nc" id="L1077">        return returnval;</span>
    }

    @Override
    public byte[] createAuthCertSignRequest(AuthenticationToken authenticationToken, int caid, byte[] certSignRequest)
            throws AuthorizationDeniedException, CADoesntExistsException, CryptoTokenOfflineException {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L1084">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtocertreq&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1085">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1086">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1087">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
<span class="nc" id="L1089">        final CA signedbyCA = caSession.getCA(authenticationToken, caid);</span>
<span class="nc" id="L1090">        final String caname = signedbyCA.getName();</span>
<span class="nc" id="L1091">        final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(signedbyCA.getCAToken().getCryptoTokenId());</span>
<span class="nc" id="L1092">        final byte[] returnval = signedbyCA.createAuthCertSignRequest(cryptoToken, certSignRequest);</span>
<span class="nc" id="L1093">        final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.certreqsigned&quot;, caname);</span>
<span class="nc" id="L1094">        auditSession.log(EjbcaEventTypes.CA_SIGNREQUEST, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1095">                String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1096">        return returnval;</span>
    }

    @Override
    public void receiveResponse(AuthenticationToken authenticationToken, int caid, ResponseMessage responsemessage, Collection&lt;?&gt; cachain,
            String nextKeyAlias) throws AuthorizationDeniedException, CertPathValidatorException, EjbcaException, CesecoreException {
<span class="nc" id="L1102">        receiveResponse(authenticationToken, caid, responsemessage, cachain, nextKeyAlias, false);</span>
<span class="nc" id="L1103">    }</span>

    @Override
    public void receiveResponse(AuthenticationToken authenticationToken, int caid, ResponseMessage responsemessage, Collection&lt;?&gt; cachain,
            String nextKeyAlias, boolean futureRollover)
            throws AuthorizationDeniedException, CertPathValidatorException, EjbcaException, CesecoreException {
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1110">            log.trace(&quot;&gt;receiveResponse: &quot; + caid);</span>
        }
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CARENEW.resource())) {</span>
<span class="nc" id="L1113">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtocertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1114">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1115">                    String.valueOf(caid), null, null, detailsMsg);</span>
        }
        try {
<span class="nc" id="L1118">            final CA ca = caSession.getCAForEdit(authenticationToken, caid);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (ca == null) {</span>
<span class="nc" id="L1120">                throw new CADoesntExistsException(&quot;CA with ID &quot; + caid + &quot; does not exist.&quot;);</span>
            } else {
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                if (!(responsemessage instanceof X509ResponseMessage)) {</span>
<span class="nc" id="L1123">                    String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertrespillegalmsg&quot;,</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">                            responsemessage != null ? responsemessage.getClass().getName() : &quot;null&quot;);</span>
<span class="nc" id="L1125">                    log.info(msg);</span>
<span class="nc" id="L1126">                    throw new EjbcaException(msg);</span>
                }
<span class="nc" id="L1128">                final Certificate cacert = ((X509ResponseMessage) responsemessage).getCertificate();</span>
                // Receiving a certificate for an internal CA will transform it into an externally signed CA
<span class="nc bnc" id="L1130" title="All 2 branches missed.">                if (ca.getSignedBy() != CAInfo.SIGNEDBYEXTERNALCA) {</span>
<span class="nc" id="L1131">                    ca.setSignedBy(CAInfo.SIGNEDBYEXTERNALCA);</span>
                }
                // Check that CA DN is equal to the certificate response.
<span class="nc bnc" id="L1134" title="All 2 branches missed.">                if (!CertTools.getSubjectDN(cacert).equals(CertTools.stringToBCDNString(ca.getSubjectDN()))) {</span>
<span class="nc" id="L1135">                    String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertrespwrongdn&quot;, CertTools.getSubjectDN(cacert), ca.getSubjectDN());</span>
<span class="nc" id="L1136">                    log.info(msg);</span>
<span class="nc" id="L1137">                    throw new EjbcaException(msg);</span>
                }
<span class="nc" id="L1139">                List&lt;Certificate&gt; tmpchain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L1140">                tmpchain.add(cacert);</span>

<span class="nc" id="L1142">                Date verifydate = new Date();</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">                if (futureRollover) {</span>
<span class="nc" id="L1144">                    log.debug(&quot;Certificate will only be used for key rollover until it becomes valid.&quot;);</span>

<span class="nc" id="L1146">                    final Date rolloverdate = CertTools.getNotBefore(cacert);</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                    if (rolloverdate.after(new Date())) {</span>
<span class="nc" id="L1148">                        verifydate = rolloverdate;</span>
                    } else {
                        // Validate using today's date, in case something has expired
<span class="nc" id="L1151">                        log.info(&quot;Expected to receive a certificate to use in the future, but received an already valid certificate.&quot;);</span>
                    }
                }

<span class="nc" id="L1155">                Collection&lt;Certificate&gt; reqchain = null;</span>
<span class="nc bnc" id="L1156" title="All 4 branches missed.">                if (cachain != null &amp;&amp; cachain.size() &gt; 0) {</span>
                    //  1. If we have a chain given as parameter, we will use that.
<span class="nc" id="L1158">                    reqchain = CertTools.createCertChain(cachain, verifydate);</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1160">                        log.debug(&quot;Using CA certificate chain from parameter of size: &quot; + reqchain.size());</span>
                    }
                } else {
                    // 2. If no parameter is given we assume that the request chain was stored when the request was created.
<span class="nc" id="L1164">                    reqchain = ca.getRequestCertificateChain();</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">                    if (reqchain == null) {</span>
                        // 3. Lastly, if that failed we'll check if the certificate chain in it's entirety already exists in the database.
<span class="nc" id="L1167">                        reqchain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L1168">                        Certificate issuer = certificateStoreSession.findLatestX509CertificateBySubject(CertTools.getIssuerDN(cacert));</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">                        if (issuer != null) {</span>
<span class="nc" id="L1170">                            reqchain.add(issuer);</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">                            while (!CertTools.isSelfSigned(issuer)) {</span>
<span class="nc" id="L1172">                                issuer = certificateStoreSession.findLatestX509CertificateBySubject(CertTools.getIssuerDN(issuer));</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                                if (issuer != null) {</span>
<span class="nc" id="L1174">                                    reqchain.add(issuer);</span>
                                } else {
<span class="nc" id="L1176">                                    String msg = intres.getLocalizedMessage(&quot;caadmin.errorincompleterequestchain&quot;, caid, ca.getSubjectDN());</span>
<span class="nc" id="L1177">                                    log.info(msg);</span>
<span class="nc" id="L1178">                                    throw new CertPathValidatorException(msg);</span>
                                }
                            }
                        }
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                        if (reqchain.size() == 0) {</span>
<span class="nc" id="L1183">                            String msg = intres.getLocalizedMessage(&quot;caadmin.errornorequestchain&quot;, caid, ca.getSubjectDN());</span>
<span class="nc" id="L1184">                            log.info(msg);</span>
<span class="nc" id="L1185">                            throw new CertPathValidatorException(msg);</span>
                        }

<span class="nc" id="L1188">                    } else {</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">                        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1190">                            log.debug(&quot;Using pre-stored CA certificate chain.&quot;);</span>
                        }
                    }
                }

<span class="nc bnc" id="L1195" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1196">                    log.debug(&quot;Picked up request certificate chain of size: &quot; + reqchain.size());</span>
                }
<span class="nc" id="L1198">                tmpchain.addAll(reqchain);</span>
<span class="nc" id="L1199">                final List&lt;Certificate&gt; chain = CertTools.createCertChain(tmpchain, verifydate);</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1201">                    log.debug(&quot;Storing certificate chain of size: &quot; + chain.size());</span>
                }
                // Before importing the certificate we want to make sure that the public key matches the CAs private key
<span class="nc" id="L1204">                PublicKey caCertPublicKey = cacert.getPublicKey();</span>
                // If it is a DV certificate signed by a CVCA, enrich the public key for EC parameters from the CVCA's certificate
<span class="nc bnc" id="L1206" title="All 2 branches missed.">                if (StringUtils.equals(cacert.getType(), &quot;CVC&quot;)) {</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                    if (caCertPublicKey.getAlgorithm().equals(&quot;ECDSA&quot;)) {</span>
<span class="nc" id="L1208">                        CardVerifiableCertificate cvccert = (CardVerifiableCertificate) cacert;</span>
                        try {
<span class="nc" id="L1210">                            if (cvccert.getCVCertificate().getCertificateBody().getAuthorizationTemplate().getAuthorizationField().getAuthRole()</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                                    .isDV()) {</span>
<span class="nc" id="L1212">                                log.debug(&quot;Enriching DV public key with EC parameters from CVCA&quot;);</span>
<span class="nc" id="L1213">                                Certificate cvcacert = reqchain.iterator().next();</span>
<span class="nc" id="L1214">                                caCertPublicKey = KeyTools.getECPublicKeyWithParams(caCertPublicKey, cvcacert.getPublicKey());</span>
                            }
<span class="nc" id="L1216">                        } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L1217">                            log.debug(&quot;Strange CVCA certificate that we can't get the key from, continuing anyway...&quot;, e);</span>
<span class="nc" id="L1218">                        } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L1219">                            log.debug(&quot;Strange DV certificate with no AutheorizationRole, continuing anyway...&quot;, e);</span>
<span class="nc" id="L1220">                        }</span>
<span class="nc" id="L1221">                    } else {</span>
<span class="nc" id="L1222">                        log.debug(&quot;Key is not ECDSA, don't try to enrich with EC parameters.&quot;);</span>
                    }
                } else {
<span class="nc" id="L1225">                    log.debug(&quot;Cert is not CVC, no need to enrich with EC parameters.&quot;);</span>
                }

<span class="nc bnc" id="L1228" title="All 2 branches missed.">                if (futureRollover) {</span>
<span class="nc" id="L1229">                    testNextKey(authenticationToken, ca, cacert, chain, caCertPublicKey, nextKeyAlias);</span>
<span class="nc" id="L1230">                    final CAToken catoken = ca.getCAToken();</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                    if (nextKeyAlias != null) {</span>
<span class="nc" id="L1232">                        catoken.setNextCertSignKey(nextKeyAlias);</span>
                    }
<span class="nc" id="L1234">                    ca.setCAToken(catoken);</span>
<span class="nc" id="L1235">                    ca.setRolloverCertificateChain(chain);</span>
                    // Save CA
<span class="nc" id="L1237">                    caSession.editCA(authenticationToken, ca, true);</span>
                    // Store certificate, but don't publish it yet (usedpublishers=null)
<span class="nc" id="L1239">                    publishCACertificate(authenticationToken, chain, null, ca.getSubjectDN(), true);</span>
<span class="nc" id="L1240">                } else {</span>
                    // Test and activate new key, publish certificate and generate CRL.
<span class="nc" id="L1242">                    activateNextKeyAndCert(authenticationToken, caid, nextKeyAlias, ca, cacert, chain, caCertPublicKey);</span>
                }

                // All OK
<span class="nc" id="L1246">                String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.certrespreceived&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1247">                auditSession.log(EventTypes.CA_EDITING, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1248">                        String.valueOf(caid), null, null, detailsMsg);</span>
            }
<span class="nc" id="L1250">        } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L1251">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1252">            log.info(msg);</span>
<span class="nc" id="L1253">            sessionContext.setRollbackOnly(); // This is an application exception so it wont trigger a roll-back automatically</span>
<span class="nc" id="L1254">            throw e;</span>
<span class="nc" id="L1255">        } catch (CADoesntExistsException e) {</span>
<span class="nc" id="L1256">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1257">            log.info(msg);</span>
<span class="nc" id="L1258">            sessionContext.setRollbackOnly(); // This is an application exception so it wont trigger a roll-back automatically</span>
<span class="nc" id="L1259">            throw e;</span>
<span class="nc" id="L1260">        } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L1261">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1262">            log.info(msg);</span>
<span class="nc" id="L1263">            throw new EjbcaException(e.getMessage());</span>
<span class="nc" id="L1264">        } catch (CertificateException e) {</span>
<span class="nc" id="L1265">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1266">            log.info(msg);</span>
<span class="nc" id="L1267">            throw new EjbcaException(e.getMessage());</span>
<span class="nc" id="L1268">        } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L1269">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1270">            log.info(msg);</span>
<span class="nc" id="L1271">            throw new EjbcaException(e.getMessage());</span>
<span class="nc" id="L1272">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1273">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1274">            log.info(msg);</span>
<span class="nc" id="L1275">            throw new EjbcaException(e.getMessage());</span>
<span class="nc" id="L1276">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L1277">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcertresp&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1278">            log.info(msg);</span>
<span class="nc" id="L1279">            throw new EjbcaException(e.getMessage());</span>
<span class="nc" id="L1280">        }</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1282">            log.trace(&quot;&lt;receiveResponse: &quot; + caid);</span>
        }
<span class="nc" id="L1284">    }</span>

    /**
     * Verifies that the next signing key of the given CA is working. This is checked with {@link KeyTools#testKey}.
     *
     * @param authenticationToken Admin performing the test.
     * @param ca CA to test the key of.
     * @param cacert CA certificate from the request.
     * @param chain Certificate chain including the newly issued certificate.
     * @param caCertPublicKey Public key of CA. Must be fully usable, i.e. CVC DVCA keys must be have the full parameters from the CVCA.
     * @param nextKeyAlias Key alias to test, or null to test the current key alias given by the CA Token (or the next signing key as a fallback).
     * @throws CryptoTokenOfflineException if offline
     * @throws IllegalKeyException on key fail
     */
    private void testNextKey(AuthenticationToken authenticationToken, final CA ca, final Certificate cacert, final List&lt;Certificate&gt; chain,
            PublicKey caCertPublicKey, String nextKeyAlias) throws CryptoTokenOfflineException, IllegalKeyException {
<span class="nc" id="L1300">        final CAToken catoken = ca.getCAToken();</span>
<span class="nc" id="L1301">        final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(catoken.getCryptoTokenId());</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (nextKeyAlias != null) {</span>
            try {
<span class="nc bnc" id="L1304" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1305">                    log.debug(&quot;SubjectKeyId for CA cert public key: &quot;</span>
<span class="nc" id="L1306">                            + new String(Hex.encode(KeyTools.createSubjectKeyId(caCertPublicKey).getKeyIdentifier())));</span>
<span class="nc" id="L1307">                    log.debug(&quot;SubjectKeyId for CA next public key: &quot;</span>
<span class="nc" id="L1308">                            + new String(Hex.encode(KeyTools.createSubjectKeyId(cryptoToken.getPublicKey(nextKeyAlias)).getKeyIdentifier())));</span>
                }
<span class="nc" id="L1310">                KeyTools.testKey(cryptoToken.getPrivateKey(nextKeyAlias), caCertPublicKey, cryptoToken.getSignProviderName());</span>
<span class="nc" id="L1311">            } catch (InvalidKeyException e) { // java exception</span>
<span class="nc" id="L1312">                throw new IllegalKeyException(e); // cesecore exception</span>
<span class="nc" id="L1313">            }</span>
        } else {
            // Since we don't specified the nextSignKey, we will just try the current or next CA sign key
            try {
<span class="nc" id="L1317">                KeyTools.testKey(cryptoToken.getPrivateKey(catoken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN)), caCertPublicKey,</span>
<span class="nc" id="L1318">                        cryptoToken.getSignProviderName());</span>
<span class="nc" id="L1319">            } catch (Exception e1) {</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1321">                    log.debug(</span>
                            &quot;The received certificate response does not match the CAs private signing key for purpose CAKEYPURPOSE_CERTSIGN, trying CAKEYPURPOSE_CERTSIGN_NEXT...&quot;);
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                    if (e1 instanceof InvalidKeyException) {</span>
<span class="nc" id="L1324">                        log.trace(e1);</span>
                    } else {
                        // If it's not invalid key, we want to see more of the error
<span class="nc" id="L1327">                        log.debug(&quot;Error: &quot;, e1);</span>
                    }
                }
                try {
<span class="nc" id="L1331">                    KeyTools.testKey(cryptoToken.getPrivateKey(catoken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT)),</span>
<span class="nc" id="L1332">                            caCertPublicKey, cryptoToken.getSignProviderName());</span>
<span class="nc" id="L1333">                } catch (Exception e2) {</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1335">                        log.debug(</span>
                                &quot;The received certificate response does not match the CAs private signing key for purpose CAKEYPURPOSE_CERTSIGN_NEXT either, giving up.&quot;);
<span class="nc bnc" id="L1337" title="All 4 branches missed.">                        if ((e2 instanceof InvalidKeyException) || (e2 instanceof IllegalArgumentException)) {</span>
<span class="nc" id="L1338">                            log.trace(e2);</span>
                        } else {
                            // If it's not invalid key or missing authentication code, we want to see more of the error
<span class="nc" id="L1341">                            log.debug(&quot;Error: &quot;, e2);</span>
                        }
                    }
<span class="nc" id="L1344">                    throw new IllegalKeyException(e2);</span>
<span class="nc" id="L1345">                }</span>
<span class="nc" id="L1346">            }</span>
        }
<span class="nc" id="L1348">    }</span>

    private void activateNextKeyAndCert(AuthenticationToken authenticationToken, int caid, String nextKeyAlias, final CA ca, final Certificate cacert,
            final List&lt;Certificate&gt; chain, PublicKey caCertPublicKey) throws CryptoTokenOfflineException, EjbcaException, InvalidAlgorithmException,
            CADoesntExistsException, AuthorizationDeniedException, CAOfflineException {
<span class="nc" id="L1353">        final CAToken catoken = ca.getCAToken();</span>
<span class="nc" id="L1354">        final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(catoken.getCryptoTokenId());</span>
<span class="nc" id="L1355">        boolean activatedNextSignKey = false;</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        if (nextKeyAlias != null) {</span>
            try {
<span class="nc bnc" id="L1358" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1359">                    log.debug(&quot;SubjectKeyId for CA cert public key: &quot;</span>
<span class="nc" id="L1360">                            + new String(Hex.encode(KeyTools.createSubjectKeyId(caCertPublicKey).getKeyIdentifier())));</span>
<span class="nc" id="L1361">                    log.debug(&quot;SubjectKeyId for CA next public key: &quot;</span>
<span class="nc" id="L1362">                            + new String(Hex.encode(KeyTools.createSubjectKeyId(cryptoToken.getPublicKey(nextKeyAlias)).getKeyIdentifier())));</span>
                }
<span class="nc" id="L1364">                KeyTools.testKey(cryptoToken.getPrivateKey(nextKeyAlias), caCertPublicKey, cryptoToken.getSignProviderName());</span>
<span class="nc" id="L1365">            } catch (InvalidKeyException e) {</span>
<span class="nc" id="L1366">                throw new EjbcaException(ErrorCode.INVALID_KEY, e);</span>
<span class="nc" id="L1367">            }</span>
<span class="nc" id="L1368">            catoken.setNextCertSignKey(nextKeyAlias);</span>
<span class="nc" id="L1369">            catoken.activateNextSignKey();</span>
<span class="nc" id="L1370">            activatedNextSignKey = true;</span>
        } else {
            // Since we don't specified the nextSignKey, we will just try the current or next CA sign key
            try {
<span class="nc" id="L1374">                KeyTools.testKey(cryptoToken.getPrivateKey(catoken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN)), caCertPublicKey,</span>
<span class="nc" id="L1375">                        cryptoToken.getSignProviderName());</span>
<span class="nc" id="L1376">            } catch (Exception e1) {</span>
<span class="nc" id="L1377">                log.debug(</span>
                        &quot;The received certificate response does not match the CAs private signing key for purpose CAKEYPURPOSE_CERTSIGN, trying CAKEYPURPOSE_CERTSIGN_NEXT...&quot;);
<span class="nc bnc" id="L1379" title="All 2 branches missed.">                if (e1 instanceof InvalidKeyException) {</span>
<span class="nc" id="L1380">                    log.trace(e1);</span>
                } else {
                    // If it's not invalid key, we want to see more of the error
<span class="nc" id="L1383">                    log.debug(&quot;Error: &quot;, e1);</span>
                }
                try {
<span class="nc" id="L1386">                    KeyTools.testKey(cryptoToken.getPrivateKey(catoken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT)),</span>
<span class="nc" id="L1387">                            caCertPublicKey, cryptoToken.getSignProviderName());</span>
                    // This was OK, so we must also activate the next signing key when importing this certificate
<span class="nc" id="L1389">                    catoken.activateNextSignKey();</span>
<span class="nc" id="L1390">                    activatedNextSignKey = true;</span>
<span class="nc" id="L1391">                } catch (Exception e2) {</span>
<span class="nc" id="L1392">                    log.debug(</span>
                            &quot;The received certificate response does not match the CAs private signing key for purpose CAKEYPURPOSE_CERTSIGN_NEXT either, giving up.&quot;);
<span class="nc bnc" id="L1394" title="All 4 branches missed.">                    if ((e2 instanceof InvalidKeyException) || (e2 instanceof IllegalArgumentException)) {</span>
<span class="nc" id="L1395">                        log.trace(e2);</span>
                    } else {
                        // If it's not invalid key or missing authentication code, we want to see more of the error
<span class="nc" id="L1398">                        log.debug(&quot;Error: &quot;, e2);</span>
                    }
<span class="nc" id="L1400">                    throw new EjbcaException(ErrorCode.INVALID_KEY, e2);</span>
<span class="nc" id="L1401">                }</span>
<span class="nc" id="L1402">            }</span>
        }
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        if (activatedNextSignKey) {</span>
            // Activated the next signing key(s) so generate audit log
<span class="nc" id="L1406">            final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1407">            details.put(&quot;msg&quot;, intres.getLocalizedMessage(&quot;catoken.activatednextkey&quot;, caid));</span>
<span class="nc" id="L1408">            details.put(&quot;certSignKey&quot;, catoken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN));</span>
<span class="nc" id="L1409">            details.put(&quot;crlSignKey&quot;, catoken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CRLSIGN));</span>
<span class="nc" id="L1410">            details.put(&quot;sequence&quot;, catoken.getKeySequence());</span>
<span class="nc" id="L1411">            auditSession.log(EventTypes.CA_KEYACTIVATE, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1412">                    String.valueOf(caid), null, null, details);</span>
        }
<span class="nc" id="L1414">        ca.setCAToken(catoken);</span>
<span class="nc" id="L1415">        ca.setCertificateChain(chain);</span>

        // Set status to active, so we can sign certificates for the external services below.
<span class="nc" id="L1418">        ca.setStatus(CAConstants.CA_ACTIVE);</span>

<span class="nc" id="L1420">        final AvailableCustomCertificateExtensionsConfiguration cceConfig = (AvailableCustomCertificateExtensionsConfiguration) globalConfigurationSession</span>
<span class="nc" id="L1421">                .getCachedConfiguration(AvailableCustomCertificateExtensionsConfiguration.CONFIGURATION_ID);</span>

        // activate External CA Services
<span class="nc bnc" id="L1424" title="All 2 branches missed.">        for (int type : ca.getExternalCAServiceTypes()) {</span>
            try {
<span class="nc" id="L1426">                ca.initExtendedService(cryptoToken, type, ca, cceConfig);</span>
<span class="nc" id="L1427">                final ExtendedCAServiceInfo info = ca.getExtendedCAServiceInfo(type);</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                if (info instanceof BaseSigningCAServiceInfo) {</span>
                    // Publish the extended service certificate, but only for active services
<span class="nc bnc" id="L1430" title="All 2 branches missed.">                    if (info.getStatus() == ExtendedCAServiceInfo.STATUS_ACTIVE) {</span>
<span class="nc" id="L1431">                        final List&lt;Certificate&gt; extcacertificate = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L1432">                        extcacertificate.add(((BaseSigningCAServiceInfo) info).getCertificatePath().get(0));</span>
<span class="nc" id="L1433">                        publishCACertificate(authenticationToken, extcacertificate, ca.getCRLPublishers(), ca.getSubjectDN());</span>
                    }
                }
<span class="nc" id="L1436">            } catch (Exception fe) {</span>
<span class="nc" id="L1437">                final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorcreatecaservice&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1438">                auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1439">                        String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1440">                throw new EJBException(fe);</span>
<span class="nc" id="L1441">            }</span>
<span class="nc" id="L1442">        }</span>
        // Set expire time
<span class="nc" id="L1444">        ca.setExpireTime(CertTools.getNotAfter(cacert));</span>
        // Save CA
<span class="nc" id="L1446">        caSession.editCA(authenticationToken, ca, true);</span>
        // Publish CA Certificate
<span class="nc" id="L1448">        publishCACertificate(authenticationToken, chain, ca.getCRLPublishers(), ca.getSubjectDN());</span>
        // Create initial CRL
<span class="nc" id="L1450">        publishingCrlSession.forceCRL(authenticationToken, caid);</span>
<span class="nc" id="L1451">        publishingCrlSession.forceDeltaCRL(authenticationToken, caid);</span>
<span class="nc" id="L1452">    }</span>

    @Override
    public ResponseMessage processRequest(AuthenticationToken admin, CAInfo cainfo, RequestMessage requestmessage)
            throws CAExistsException, CADoesntExistsException, AuthorizationDeniedException, CryptoTokenOfflineException {
        final CA ca;
<span class="nc" id="L1458">        List&lt;Certificate&gt; certchain = null;</span>
<span class="nc" id="L1459">        CertificateResponseMessage returnval = null;</span>
<span class="nc" id="L1460">        int caid = cainfo.getCAId();</span>
        // check authorization
<span class="nc bnc" id="L1462" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(admin, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L1463">            String msg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtocertresp&quot;, cainfo.getName());</span>
<span class="nc" id="L1464">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1465">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L1466">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L1467">                    String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L1468">            throw new AuthorizationDeniedException(msg);</span>
        }

        // Check that CA doesn't already exists
<span class="nc" id="L1472">        CAData oldcadata = null;</span>
<span class="nc bnc" id="L1473" title="All 4 branches missed.">        if (caid &gt;= 0 &amp;&amp; caid &lt;= CAInfo.SPECIALCAIDBORDER) {</span>
<span class="nc" id="L1474">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorcaexists&quot;, cainfo.getName());</span>
<span class="nc" id="L1475">            log.info(msg);</span>
<span class="nc" id="L1476">            throw new CAExistsException(msg);</span>
        }
<span class="nc" id="L1478">        oldcadata = caSession.findById(Integer.valueOf(caid));</span>
        // If it did not exist with a certain DN (caid) perhaps a CA with the
        // same CA name exists?
<span class="nc bnc" id="L1481" title="All 2 branches missed.">        if (oldcadata == null) {</span>
<span class="nc" id="L1482">            oldcadata = caSession.findByName(cainfo.getName());</span>
        }
<span class="nc" id="L1484">        boolean processinternalca = false;</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">        if (oldcadata != null) {</span>
            // If we find an already existing CA, there is a good chance that we
            // should throw an exception
            // Saying that the CA already exists.
            // However, if we have the same DN, and give the same name, we
            // simply assume that the admin actually wants
            // to treat an internal CA as an external CA, perhaps there is
            // different HSMs connected for root CA and sub CA?
<span class="nc bnc" id="L1493" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1494">                log.debug(&quot;Old castatus=&quot; + oldcadata.getStatus() + &quot;, oldcaid=&quot; + oldcadata.getCaId().intValue() + &quot;, caid=&quot; + cainfo.getCAId()</span>
<span class="nc" id="L1495">                        + &quot;, oldcaname=&quot; + oldcadata.getName() + &quot;, name=&quot; + cainfo.getName());</span>
            }
<span class="nc bnc" id="L1497" title="All 4 branches missed.">            if (((oldcadata.getStatus() == CAConstants.CA_WAITING_CERTIFICATE_RESPONSE) || (oldcadata.getStatus() == CAConstants.CA_ACTIVE)</span>
<span class="nc bnc" id="L1498" title="All 4 branches missed.">                    || (oldcadata.getStatus() == CAConstants.CA_EXTERNAL)) &amp;&amp; (oldcadata.getCaId().intValue() == cainfo.getCAId())</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">                    &amp;&amp; (oldcadata.getName().equals(cainfo.getName()))) {</span>
                // Yes, we have all the same DN, CAName and the old CA is either
                // waiting for a certificate response or is active
                // (new CA or active CA that we want to renew)
                // or it is an external CA that we want to issue a new
                // certificate to
<span class="nc" id="L1505">                processinternalca = true;</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">                if (oldcadata.getStatus() == CAConstants.CA_EXTERNAL) {</span>
<span class="nc" id="L1507">                    log.debug(&quot;Renewing an external CA.&quot;);</span>
                } else {
<span class="nc" id="L1509">                    log.debug(&quot;Processing an internal CA, as an external.&quot;);</span>
                }
            } else {
<span class="nc" id="L1512">                String msg = intres.getLocalizedMessage(&quot;caadmin.errorcaexists&quot;, cainfo.getName());</span>
<span class="nc" id="L1513">                log.info(msg);</span>
<span class="nc" id="L1514">                throw new CAExistsException(msg);</span>
            }
        }

        // get signing CA
<span class="nc bnc" id="L1519" title="All 4 branches missed.">        if (cainfo.getSignedBy() &gt; CAInfo.SPECIALCAIDBORDER || cainfo.getSignedBy() &lt; 0) {</span>
            try {
<span class="nc" id="L1521">                final CA signca = caSession.getCAForEdit(admin, Integer.valueOf(cainfo.getSignedBy()));</span>
                try {
                    // Check that the signer is valid
<span class="nc" id="L1524">                    assertSignerValidity(admin, signca);</span>

                    // Get public key from request
<span class="nc" id="L1527">                    PublicKey publickey = requestmessage.getRequestPublicKey();</span>

                    // Create cacertificate
<span class="nc" id="L1530">                    Certificate cacertificate = null;</span>
<span class="nc" id="L1531">                    EndEntityInformation cadata = makeEndEntityInformation(cainfo);</span>
                    // We can pass the PKCS10 request message as extra
                    // parameters
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                    if (requestmessage instanceof PKCS10RequestMessage) {</span>
<span class="nc" id="L1535">                        ExtendedInformation extInfo = new ExtendedInformation();</span>
<span class="nc" id="L1536">                        PKCS10CertificationRequest pkcs10 = ((PKCS10RequestMessage) requestmessage).getCertificationRequest();</span>
<span class="nc" id="L1537">                        extInfo.setCustomData(ExtendedInformationFields.CUSTOM_PKCS10, new String(Base64.encode(pkcs10.getEncoded())));</span>
<span class="nc" id="L1538">                        cadata.setExtendedInformation(extInfo);</span>
                    }
<span class="nc" id="L1540">                    CertificateProfile certprofile = certificateProfileSession.getCertificateProfile(cainfo.getCertificateProfileId());</span>
<span class="nc" id="L1541">                    String sequence = null;</span>
<span class="nc" id="L1542">                    byte[] ki = requestmessage.getRequestKeyInfo();</span>
<span class="nc bnc" id="L1543" title="All 4 branches missed.">                    if ((ki != null) &amp;&amp; (ki.length &gt; 0)) {</span>
<span class="nc" id="L1544">                        sequence = new String(ki);</span>
                    }
<span class="nc" id="L1546">                    final CryptoToken signCryptoToken = cryptoTokenSession.getCryptoToken(signca.getCAToken().getCryptoTokenId());</span>
<span class="nc" id="L1547">                    final AvailableCustomCertificateExtensionsConfiguration cceConfig = (AvailableCustomCertificateExtensionsConfiguration) globalConfigurationSession</span>
<span class="nc" id="L1548">                            .getCachedConfiguration(AvailableCustomCertificateExtensionsConfiguration.CONFIGURATION_ID);</span>
<span class="nc" id="L1549">                    cacertificate = signca.generateCertificate(signCryptoToken, cadata, publickey, -1, null, cainfo.getEncodedValidity(), certprofile,</span>
                            sequence, cceConfig);
                    // X509ResponseMessage works for both X509 CAs and CVC CAs, should really be called CertificateResponsMessage
<span class="nc" id="L1552">                    returnval = new X509ResponseMessage();</span>
<span class="nc" id="L1553">                    returnval.setCertificate(cacertificate);</span>

                    // Build Certificate Chain
<span class="nc" id="L1556">                    List&lt;Certificate&gt; rootcachain = signca.getCertificateChain();</span>
<span class="nc" id="L1557">                    certchain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L1558">                    certchain.add(cacertificate);</span>
<span class="nc" id="L1559">                    certchain.addAll(rootcachain);</span>

<span class="nc bnc" id="L1561" title="All 2 branches missed.">                    if (!processinternalca) {</span>
                        // If this is an internal CA, we don't create it and set
                        // a NULL token, since the CA is already created
<span class="nc bnc" id="L1564" title="All 2 branches missed.">                        if (cainfo instanceof X509CAInfo) {</span>
<span class="nc" id="L1565">                            log.info(&quot;Creating a X509 CA (process request)&quot;);</span>
<span class="nc" id="L1566">                            ca = new X509CA((X509CAInfo) cainfo);</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                        } else if (cainfo instanceof CVCCAInfo) {</span>
                            // CVC CA is a special type of CA for EAC electronic
                            // passports
<span class="nc" id="L1570">                            log.info(&quot;Creating a CVC CA (process request)&quot;);</span>
<span class="nc" id="L1571">                            CVCCAInfo cvccainfo = (CVCCAInfo) cainfo;</span>
                            // Create CVCCA
<span class="nc" id="L1573">                            ca = CvcCA.getInstance(cvccainfo);</span>
<span class="nc" id="L1574">                        } else {</span>
<span class="nc" id="L1575">                            ca = null;</span>
                        }
<span class="nc" id="L1577">                        ca.setCertificateChain(certchain);</span>
<span class="nc" id="L1578">                        CAToken token = new CAToken(ca.getCAId(), new NullCryptoToken().getProperties());</span>
<span class="nc" id="L1579">                        ca.setCAToken(token);</span>

                        // set status to active
<span class="nc" id="L1582">                        entityManager.persist(new CAData(cainfo.getSubjectDN(), cainfo.getName(), CAConstants.CA_EXTERNAL, ca));</span>
                        // cadatahome.create(cainfo.getSubjectDN(), cainfo.getName(), SecConst.CA_EXTERNAL, ca);
<span class="nc" id="L1584">                    } else {</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                        if (oldcadata.getStatus() == CAConstants.CA_EXTERNAL) {</span>
                            // If it is an external CA we will not import the
                            // certificate later on here, so we want to
                            // update the CA in this instance with the new
                            // certificate so it is visible
<span class="nc" id="L1590">                            ca = caSession.getCAForEdit(admin, oldcadata.getCaId());//getCAFromDatabase(oldcadata.getCaId());</span>
<span class="nc" id="L1591">                            ca.setCertificateChain(certchain);</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">                            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1593">                                log.debug(&quot;Storing new certificate chain for external CA &quot; + cainfo.getName() + &quot;, CA token type: &quot;</span>
<span class="nc" id="L1594">                                        + ca.getCAToken().getClass().getName());</span>
                            }
<span class="nc" id="L1596">                            caSession.editCA(admin, ca, true);</span>
                        } else {
                            // If it is an internal CA so we are &quot;simulating&quot;
                            // signing a real external CA we don't do anything
                            // because that CA is waiting to import a
                            // certificate
<span class="nc bnc" id="L1602" title="All 2 branches missed.">                            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1603">                                log.debug(</span>
<span class="nc" id="L1604">                                        &quot;Not storing new certificate chain or updating CA for internal CA, simulating external: &quot; + cainfo.getName());</span>
                            }
<span class="nc" id="L1606">                            ca = null;</span>
                        }
                    }
                    // Publish CA certificates.
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                    publishCACertificate(admin, certchain, signca.getCRLPublishers(), ca != null ? ca.getSubjectDN() : null);</span>
                    // External CAs will not have any CRLs in this system, so we don't have to try to publish any CRLs
<span class="nc" id="L1612">                } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L1613">                    String msg = intres.getLocalizedMessage(&quot;caadmin.errorprocess&quot;, cainfo.getName());</span>
<span class="nc" id="L1614">                    log.error(msg, e);</span>
<span class="nc" id="L1615">                    throw e;</span>
<span class="nc" id="L1616">                }</span>
<span class="nc" id="L1617">            } catch (Exception e) {</span>
<span class="nc" id="L1618">                String msg = intres.getLocalizedMessage(&quot;caadmin.errorprocess&quot;, cainfo.getName());</span>
<span class="nc" id="L1619">                log.error(msg, e);</span>
<span class="nc" id="L1620">                throw new EJBException(e);</span>
<span class="nc" id="L1621">            }</span>

        }

<span class="nc bnc" id="L1625" title="All 2 branches missed.">        if (certchain != null) {</span>
<span class="nc" id="L1626">            String msg = intres.getLocalizedMessage(&quot;caadmin.processedca&quot;, cainfo.getName());</span>
<span class="nc" id="L1627">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1628">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L1629">            auditSession.log(EventTypes.CA_EDITING, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, details);
<span class="nc" id="L1631">        } else {</span>
<span class="nc" id="L1632">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorprocess&quot;, cainfo.getName());</span>
<span class="nc" id="L1633">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1634">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L1635">            auditSession.log(EventTypes.CA_EDITING, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), String.valueOf(caid),</span>
                    null, null, details);
        }
<span class="nc" id="L1638">        return returnval;</span>
    }

    @Override
    public void importCACertificate(AuthenticationToken admin, String caname, Collection&lt;CertificateWrapper&gt; wrappedCerts)
            throws AuthorizationDeniedException, CAExistsException, IllegalCryptoTokenException, CertificateImportException {
<span class="nc" id="L1644">        List&lt;Certificate&gt; certificates = EJBTools.unwrapCertCollection(wrappedCerts);</span>
        // Re-order if needed and validate chain
<span class="nc bnc" id="L1646" title="All 2 branches missed.">        if (certificates.size() != 1) {</span>
            // In the case there is a chain, we require a full chain leading up to a root
            try {
<span class="nc" id="L1649">                certificates = CertTools.createCertChain(certificates);</span>
<span class="nc" id="L1650">            } catch (CertPathValidatorException e) {</span>
<span class="nc" id="L1651">                throw new CertificateImportException(&quot;The provided certificates does not form a full certificate chain.&quot;);</span>
<span class="nc" id="L1652">            } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L1653">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1654">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1655">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1656">            } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L1657">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1658">            } catch (CertificateException e) {</span>
<span class="nc" id="L1659">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1660">            }</span>
        }
<span class="nc" id="L1662">        final Certificate caCertificate = certificates.iterator().next();</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">        if (!CertTools.isCA(caCertificate)) {</span>
<span class="nc" id="L1664">            throw new CertificateImportException(&quot;Only CA certificates can be imported using this function.&quot;);</span>
        }
<span class="nc" id="L1666">        CA ca = null;</span>
<span class="nc" id="L1667">        CAInfo cainfo = null;</span>

        // Parameters common for both X509 and CVC CAs
<span class="nc bnc" id="L1670" title="All 2 branches missed.">        int certprofileid = CertTools.isSelfSigned(caCertificate) ? CertificateProfileConstants.CERTPROFILE_FIXED_ROOTCA</span>
<span class="nc" id="L1671">                : CertificateProfileConstants.CERTPROFILE_FIXED_SUBCA;</span>
<span class="nc" id="L1672">        String subjectdn = CertTools.getSubjectDN(caCertificate);</span>
<span class="nc" id="L1673">        String validityString = &quot;0d&quot;;</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">        int signedby = CertTools.isSelfSigned(caCertificate) ? CAInfo.SELFSIGNED : CAInfo.SIGNEDBYEXTERNALCA;</span>
<span class="nc" id="L1675">        log.info(&quot;Preparing to import of CA with Subject DN &quot; + subjectdn);</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">        if (caCertificate instanceof X509Certificate) {</span>
<span class="nc" id="L1677">            X509Certificate x509CaCertificate = (X509Certificate) caCertificate;</span>
<span class="nc" id="L1678">            String subjectaltname = CertTools.getSubjectAlternativeName(x509CaCertificate);</span>

            // Process certificate policies.
<span class="nc" id="L1681">            ArrayList&lt;CertificatePolicy&gt; policies = new ArrayList&lt;CertificatePolicy&gt;();</span>
<span class="nc" id="L1682">            CertificateProfile certprof = certificateProfileSession.getCertificateProfile(certprofileid);</span>
<span class="nc bnc" id="L1683" title="All 4 branches missed.">            if (certprof.getCertificatePolicies() != null &amp;&amp; certprof.getCertificatePolicies().size() &gt; 0) {</span>
<span class="nc" id="L1684">                policies.addAll(certprof.getCertificatePolicies());</span>
            }
<span class="nc" id="L1686">            final X509CAInfo x509cainfo = new X509CAInfo(subjectdn, caname, CAConstants.CA_EXTERNAL, certprofileid, validityString, signedby, null,</span>
                    null);
<span class="nc" id="L1688">            x509cainfo.setSubjectAltName(subjectaltname);</span>
<span class="nc" id="L1689">            x509cainfo.setPolicies(policies);</span>
<span class="nc" id="L1690">            cainfo = x509cainfo;</span>
<span class="nc bnc" id="L1691" title="All 2 branches missed.">        } else if (StringUtils.equals(caCertificate.getType(), &quot;CVC&quot;)) {</span>
<span class="nc" id="L1692">            cainfo = new CVCCAInfo(subjectdn, caname, CAConstants.CA_EXTERNAL, certprofileid, validityString, signedby, null, null);</span>
        } else {
<span class="nc" id="L1694">            throw new CertificateImportException(&quot;Certificate was of an unknown type: &quot; + caCertificate.getType());</span>
        }
<span class="nc" id="L1696">        cainfo.setExpireTime(CertTools.getNotAfter(caCertificate));</span>
<span class="nc" id="L1697">        cainfo.setDescription(&quot;CA created by certificate import.&quot;);</span>

<span class="nc bnc" id="L1699" title="All 2 branches missed.">        if (cainfo instanceof X509CAInfo) {</span>
<span class="nc" id="L1700">            log.info(&quot;Creating a X509 CA (process request)&quot;);</span>
<span class="nc" id="L1701">            ca = new X509CA((X509CAInfo) cainfo);</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">        } else if (cainfo instanceof CVCCAInfo) {</span>
            // CVC CA is a special type of CA for EAC electronic passports
<span class="nc" id="L1704">            log.info(&quot;Creating a CVC CA (process request)&quot;);</span>
<span class="nc" id="L1705">            CVCCAInfo cvccainfo = (CVCCAInfo) cainfo;</span>
<span class="nc" id="L1706">            ca = CvcCA.getInstance(cvccainfo);</span>
<span class="nc" id="L1707">        } else {</span>
<span class="nc" id="L1708">            throw new IllegalStateException(&quot;CAInfo object was of an unknown type: &quot; + cainfo.getCAType());</span>
        }
<span class="nc" id="L1710">        ca.setCertificateChain(certificates);</span>
<span class="nc" id="L1711">        CAToken token = new CAToken(ca.getCAId(), new NullCryptoToken().getProperties());</span>
        try {
<span class="nc" id="L1713">            ca.setCAToken(token);</span>
<span class="nc" id="L1714">        } catch (InvalidAlgorithmException e) {</span>
<span class="nc" id="L1715">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L1716">        }</span>
        // Add CA
<span class="nc" id="L1718">        caSession.addCA(admin, ca);</span>
        // Persist (&quot;Publish&quot;) the CA certificates to the local CertificateData database.
<span class="nc" id="L1720">        publishCACertificate(admin, certificates, null, ca.getSubjectDN());</span>
<span class="nc" id="L1721">    }</span>

    @Override
    public void updateCACertificate(final AuthenticationToken authenticationToken, final int caId, Collection&lt;CertificateWrapper&gt; wrappedCerts)
            throws CADoesntExistsException, AuthorizationDeniedException, CertificateImportException {
<span class="nc" id="L1726">        List&lt;Certificate&gt; certificates = EJBTools.unwrapCertCollection(wrappedCerts);</span>
        // Re-order if needed and validate chain
<span class="nc bnc" id="L1728" title="All 2 branches missed.">        if (certificates.size() != 1) {</span>
            // In the case there is a chain, we require a full chain leading up to a root
            try {
<span class="nc" id="L1731">                certificates = CertTools.createCertChain(certificates);</span>
<span class="nc" id="L1732">            } catch (CertPathValidatorException e) {</span>
<span class="nc" id="L1733">                throw new CertificateImportException(&quot;The provided certificates does not form a full certificate chain.&quot;);</span>
<span class="nc" id="L1734">            } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L1735">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1736">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1737">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1738">            } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L1739">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1740">            } catch (CertificateException e) {</span>
<span class="nc" id="L1741">                throw new CertificateImportException(e);</span>
<span class="nc" id="L1742">            }</span>
        }
<span class="nc" id="L1744">        final Certificate newCaCertificate = certificates.iterator().next();</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">        if (!CertTools.isCA(newCaCertificate)) {</span>
<span class="nc" id="L1746">            throw new CertificateImportException(&quot;Only CA certificates can be imported using this function.&quot;);</span>
        }
<span class="nc" id="L1748">        final String newSubjectDn = CertTools.getSubjectDN(newCaCertificate);</span>
<span class="nc" id="L1749">        log.info(&quot;Preparing to import of update for CA with Subject DN &quot; + newSubjectDn);</span>
<span class="nc" id="L1750">        final CA ca = caSession.getCAForEdit(authenticationToken, caId);</span>
<span class="nc" id="L1751">        final CAInfo caInfo = ca.getCAInfo();</span>
<span class="nc" id="L1752">        final Certificate oldCaCertificate = ca.getCACertificate();</span>
<span class="nc bnc" id="L1753" title="All 2 branches missed.">        if (ca.getStatus() != CAConstants.CA_EXTERNAL) {</span>
<span class="nc" id="L1754">            throw new CertificateImportException(&quot;Only able to update imported CA certificate of external CAs.&quot;);</span>
        }
<span class="nc bnc" id="L1756" title="All 2 branches missed.">        if (CertTools.getFingerprintAsString(oldCaCertificate).equals(CertTools.getFingerprintAsString(newCaCertificate))) {</span>
            // The admin might want to update the chain even if the leaf CA cert is the same
<span class="nc" id="L1758">            boolean sameAsExisting = true;</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">            if (caInfo.getCertificateChain().size() == certificates.size()) {</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">                for (int i = 1; i &lt; certificates.size(); i++) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">                    if (!CertTools.getFingerprintAsString(oldCaCertificate).equals(CertTools.getFingerprintAsString(newCaCertificate))) {</span>
<span class="nc" id="L1762">                        sameAsExisting = false;</span>
                    }
                }
            } else {
<span class="nc" id="L1766">                sameAsExisting = false;</span>
            }
<span class="nc bnc" id="L1768" title="All 2 branches missed.">            if (sameAsExisting) {</span>
<span class="nc" id="L1769">                throw new CertificateImportException(&quot;The CA certificate chain is already imported.&quot;);</span>
            }
        }

<span class="nc" id="L1773">        final String oldSubjectDn = CertTools.getSubjectDN(oldCaCertificate);</span>
<span class="nc" id="L1774">        boolean storeCscaWithChangedSubjectDn = false;</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">        if (!oldSubjectDn.equals(newSubjectDn)) {</span>
            // Could be a CSCA certificate with other SubjectDN SN (C and CN attribute must match).
            // This is only for X.509 CAs (serialNumber in CVC certificates is the key sequence).
            // For example the German CSCA has same subjectDN except a SN (serialNumber) element after rollover.
<span class="nc" id="L1779">            boolean sameCsca = true;</span>
<span class="nc" id="L1780">            final Map&lt;String, String&gt; oldSubjectDnMap = DNFieldsUtil.dnStringToMap(oldSubjectDn);</span>
<span class="nc" id="L1781">            final Map&lt;String, String&gt; newSubjectDnMap = DNFieldsUtil.dnStringToMap(newSubjectDn);</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">            if (!DNFieldsUtil.mapContainsCountryAndCN(oldSubjectDnMap)) {</span>
<span class="nc" id="L1783">                sameCsca = false;</span>
            }
<span class="nc bnc" id="L1785" title="All 2 branches missed.">            if (!DNFieldsUtil.mapContainsCountryAndCN(newSubjectDnMap)) {</span>
<span class="nc" id="L1786">                sameCsca = false;</span>
            }
<span class="nc bnc" id="L1788" title="All 2 branches missed.">            if (!DNFieldsUtil.dnEqualsWithOtherSerialNumber(oldSubjectDnMap, newSubjectDnMap)) {</span>
<span class="nc" id="L1789">                sameCsca = false;</span>
            }
<span class="nc bnc" id="L1791" title="All 2 branches missed.">            if (!sameCsca) {</span>
<span class="nc" id="L1792">                throw new CertificateImportException(</span>
                        &quot;Only able to update imported CA certificate if Subject DN of the leaf CA certificate is the same.&quot;);
            }
<span class="nc bnc" id="L1795" title="All 2 branches missed.">            if (caInfo instanceof X509CAInfo) {</span>
<span class="nc" id="L1796">                caInfo.setSubjectDN(newSubjectDn);</span>
<span class="nc" id="L1797">                caInfo.setCertificateChain(certificates); // required for storing!</span>
<span class="nc" id="L1798">                storeCscaWithChangedSubjectDn = true;</span>
            }
        }

        // Check that update is newer if information is present
<span class="nc" id="L1803">        final Date newValidFrom = CertTools.getNotBefore(newCaCertificate);</span>
<span class="nc" id="L1804">        final Date oldValidFrom = CertTools.getNotBefore(oldCaCertificate);</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1806">            log.debug(&quot;Current valid from: &quot; + ValidityDate.formatAsISO8601(oldValidFrom, TimeZone.getDefault()) + &quot; Import valid from: &quot;</span>
<span class="nc" id="L1807">                    + ValidityDate.formatAsISO8601(newValidFrom, TimeZone.getDefault()));</span>
        }
<span class="nc bnc" id="L1809" title="All 6 branches missed.">        if (newValidFrom != null &amp;&amp; oldValidFrom != null &amp;&amp; newValidFrom.before(oldValidFrom)) {</span>
<span class="nc" id="L1810">            throw new CertificateImportException(</span>
                    &quot;Only able to update imported CA certificate if new certificate is issued after the currently used.&quot;);
        }
<span class="nc" id="L1813">        ca.setExpireTime(CertTools.getNotAfter(newCaCertificate));</span>
        // Could be signed by an external CA now or vice versa
<span class="nc bnc" id="L1815" title="All 2 branches missed.">        if (CertTools.isSelfSigned(newCaCertificate)) {</span>
<span class="nc" id="L1816">            caInfo.setCertificateProfileId(CertificateProfileConstants.CERTPROFILE_FIXED_ROOTCA);</span>
<span class="nc" id="L1817">            caInfo.setSignedBy(CAInfo.SELFSIGNED);</span>
        } else {
<span class="nc" id="L1819">            caInfo.setCertificateProfileId(CertificateProfileConstants.CERTPROFILE_FIXED_SUBCA);</span>
<span class="nc" id="L1820">            caInfo.setSignedBy(CAInfo.SIGNEDBYEXTERNALCA);</span>
        }
<span class="nc" id="L1822">        ca.setCertificateChain(certificates);</span>

        // Only for CSCAs: Set state to CAConstants.CA_UNINITIALIZED to store the CA with a new subject-DN and CA-ID.
<span class="nc bnc" id="L1825" title="All 2 branches missed.">        if (storeCscaWithChangedSubjectDn) {</span>
<span class="nc" id="L1826">            final int currentCaState = caInfo.getStatus();</span>
<span class="nc" id="L1827">            caInfo.setCertificateChain(certificates);</span>
            // Don't set CA-ID here, it is derived later by the CA certificates subject DN in editCA(), if we set state to UNINITIALIZED.
            // caInfo.setCAId(CAData.calculateCAId(ca.getSubjectDN()));
<span class="nc" id="L1830">            caInfo.setStatus(CAConstants.CA_UNINITIALIZED);</span>
<span class="nc" id="L1831">            editCA(authenticationToken, caInfo);</span>
<span class="nc" id="L1832">            caInfo.setStatus(currentCaState);</span>
            // Add CA certificate chain again, because it is removed in createCA() for CAs with state CAConstants.CA_UNINITIALIZED.
<span class="nc" id="L1834">            caInfo.setCertificateChain(certificates);</span>
        }

        // Update CA in database
<span class="nc" id="L1838">        editCA(authenticationToken, caInfo);</span>
        // Update the CA certificate in the local database
<span class="nc" id="L1840">        publishCACertificate(authenticationToken, certificates, null, ca.getSubjectDN());</span>
<span class="nc" id="L1841">    }</span>

    @Override
    public void initExternalCAService(AuthenticationToken admin, int caid, ExtendedCAServiceInfo info)
            throws CADoesntExistsException, AuthorizationDeniedException, CAOfflineException {
        // check authorization
<span class="nc bnc" id="L1847" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(admin, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L1848">            String msg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtoeditca&quot;, admin.toString(), caSession.getCAInfoInternal(caid));</span>
<span class="nc" id="L1849">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1850">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L1851">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L1852">                    String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L1853">            throw new AuthorizationDeniedException(msg);</span>
        }

        // Get CA info.
<span class="nc" id="L1857">        CA ca = caSession.getCAForEdit(admin, caid);</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        if (ca.getStatus() == CAConstants.CA_OFFLINE) {</span>
<span class="nc" id="L1859">            String msg = intres.getLocalizedMessage(&quot;error.catokenoffline&quot;, ca.getName());</span>
<span class="nc" id="L1860">            throw new CAOfflineException(msg);</span>
        }
<span class="nc" id="L1862">        ArrayList&lt;ExtendedCAServiceInfo&gt; infos = new ArrayList&lt;ExtendedCAServiceInfo&gt;();</span>
<span class="nc" id="L1863">        infos.add(info);</span>
<span class="nc" id="L1864">        activateAndPublishExternalCAServices(admin, infos, ca);</span>
        // Update CA in database
<span class="nc" id="L1866">        caSession.editCA(admin, ca, true);</span>
<span class="nc" id="L1867">    }</span>

    @Override
    public void renewCA(AuthenticationToken authenticationToken, int caid, boolean regenerateKeys, Date customNotBefore,
            final boolean createLinkCertificate) throws CADoesntExistsException, AuthorizationDeniedException, CryptoTokenOfflineException {
        try {
<span class="nc" id="L1873">            renewCAInternal(authenticationToken, caid, regenerateKeys, customNotBefore, createLinkCertificate, /*newSubjectDN=*/null);</span>
<span class="nc" id="L1874">        } catch (CANameChangeRenewalException e) {</span>
<span class="nc" id="L1875">            throw new IllegalStateException(e);</span>
<span class="nc" id="L1876">        }</span>
<span class="nc" id="L1877">    }</span>

    private void renewCAInternal(AuthenticationToken authenticationToken, int caid, boolean regenerateKeys, Date customNotBefore,
            final boolean createLinkCertificate, String newSubjectDn)
            throws CADoesntExistsException, AuthorizationDeniedException, CryptoTokenOfflineException, CANameChangeRenewalException {
<span class="nc" id="L1882">        final CA ca = caSession.getCAForEdit(authenticationToken, caid);</span>
<span class="nc" id="L1883">        final CAToken caToken = ca.getCAToken();</span>
<span class="nc" id="L1884">        final Properties oldProperties = caToken.getProperties();</span>
<span class="nc" id="L1885">        final String oldSequence = caToken.getKeySequence();</span>
<span class="nc" id="L1886">        final String currentSignKeyAlias = caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN);</span>
<span class="nc" id="L1887">        String nextSignKeyAlias = currentSignKeyAlias;</span>
<span class="nc" id="L1888">        final int cryptoTokenId = caToken.getCryptoTokenId();</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">        if (regenerateKeys) {</span>
<span class="nc" id="L1890">            nextSignKeyAlias = caToken.generateNextSignKeyAlias();</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">            if (cryptoTokenManagementSession.getKeyPairInfo(authenticationToken, cryptoTokenId, nextSignKeyAlias) == null) {</span>
                // Ok.. No such key..
                try {
<span class="nc" id="L1894">                    cryptoTokenManagementSession.createKeyPairWithSameKeySpec(authenticationToken, cryptoTokenId, currentSignKeyAlias,</span>
                            nextSignKeyAlias);
                    // Audit log CA key generation
<span class="nc" id="L1897">                    final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1898">                    details.put(&quot;msg&quot;, intres.getLocalizedMessage(&quot;catoken.generatedkeys&quot;, caid, true, false));</span>
<span class="nc" id="L1899">                    details.put(&quot;oldproperties&quot;, oldProperties);</span>
<span class="nc" id="L1900">                    details.put(&quot;oldsequence&quot;, oldSequence);</span>
<span class="nc" id="L1901">                    details.put(&quot;properties&quot;, caToken.getProperties());</span>
<span class="nc" id="L1902">                    details.put(&quot;sequence&quot;, caToken.getKeySequence());</span>
<span class="nc" id="L1903">                    auditSession.log(EventTypes.CA_KEYGEN, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1904">                            String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L1905">                    ca.setCAToken(caToken);</span>
<span class="nc" id="L1906">                    caSession.editCA(authenticationToken, ca, true);</span>
<span class="nc" id="L1907">                } catch (AuthorizationDeniedException | CryptoTokenOfflineException e2) {</span>
<span class="nc" id="L1908">                    throw e2;</span>
<span class="nc" id="L1909">                } catch (Exception e2) {</span>
<span class="nc" id="L1910">                    throw new RuntimeException(e2);</span>
<span class="nc" id="L1911">                }</span>
            } else {
<span class="nc" id="L1913">                log.warn(&quot;Key generation request for existing key alias ignored for CA=&quot; + ca.getCAId() + &quot;, CryptoToken=&quot; + cryptoTokenId</span>
                        + &quot; and alias=&quot; + nextSignKeyAlias);
            }
        }
<span class="nc" id="L1917">        renewCAInternal(authenticationToken, caid, nextSignKeyAlias, customNotBefore, createLinkCertificate, newSubjectDn);</span>
<span class="nc" id="L1918">    }</span>

    @Override
    public void renewCA(final AuthenticationToken authenticationToken, final int caid, final String nextSignKeyAlias, Date customNotBefore,
            final boolean createLinkCertificate) throws AuthorizationDeniedException, CryptoTokenOfflineException {
        try {
<span class="nc" id="L1924">            renewCAInternal(authenticationToken, caid, nextSignKeyAlias, customNotBefore, createLinkCertificate, /*newSubjectDN=*/null);</span>
<span class="nc" id="L1925">        } catch (CANameChangeRenewalException e) {</span>
<span class="nc" id="L1926">            throw new IllegalStateException(e);</span>
<span class="nc" id="L1927">        }</span>
<span class="nc" id="L1928">    }</span>

    @Override
    public void renewCANewSubjectDn(AuthenticationToken admin, int caid, boolean regenerateKeys, Date customNotBefore,
            final boolean createLinkCertificate, String newSubjectDn)
            throws CADoesntExistsException, AuthorizationDeniedException, CryptoTokenOfflineException, CANameChangeRenewalException {
<span class="nc" id="L1934">        renewCAInternal(admin, caid, regenerateKeys, customNotBefore, createLinkCertificate, newSubjectDn);</span>
<span class="nc" id="L1935">    }</span>

    @Override
    public void renewCANewSubjectDn(AuthenticationToken admin, int caid, final String nextSignKeyAlias, Date customNotBefore,
            final boolean createLinkCertificate, String newSubjectDn)
            throws CADoesntExistsException, AuthorizationDeniedException, CryptoTokenOfflineException, CANameChangeRenewalException {
<span class="nc" id="L1941">        renewCAInternal(admin, caid, nextSignKeyAlias, customNotBefore, createLinkCertificate, newSubjectDn);</span>
<span class="nc" id="L1942">    }</span>

    private void renewCAInternal(final AuthenticationToken authenticationToken, int caid, final String nextSignKeyAlias, Date customNotBefore,
            final boolean createLinkCertificate, String newSubjectDN)
            throws AuthorizationDeniedException, CryptoTokenOfflineException, CANameChangeRenewalException {
<span class="nc bnc" id="L1947" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L1948">            log.trace(&quot;&gt;CAAdminSession, renewCA(), caid=&quot; + caid);</span>
        }
<span class="nc" id="L1950">        List&lt;Certificate&gt; cachain = null;</span>
<span class="nc" id="L1951">        Certificate cacertificate = null;</span>
        // check authorization
<span class="nc bnc" id="L1953" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CARENEW.resource())) {</span>
<span class="nc" id="L1954">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtorenew&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L1955">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L1956">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L1957">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
        // Get CA info.
        try {
<span class="nc" id="L1961">            CA ca = caSession.getCAForEdit(authenticationToken, caid);</span>

<span class="nc" id="L1963">            String newCAName = null;</span>
<span class="nc bnc" id="L1964" title="All 4 branches missed.">            boolean subjectDNWillBeChanged = newSubjectDN != null &amp;&amp; !newSubjectDN.isEmpty();</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">            if (subjectDNWillBeChanged) {</span>
<span class="nc" id="L1966">                GlobalConfiguration globalConfig = (GlobalConfiguration) globalConfigurationSession</span>
<span class="nc" id="L1967">                        .getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID);</span>
<span class="nc bnc" id="L1968" title="All 2 branches missed.">                if (!globalConfig.getEnableIcaoCANameChange()) {</span>
<span class="nc" id="L1969">                    final String errorMessage = &quot;The \&quot;Enable ICAO CA Name Change\&quot; feature is disabled by administrator. Aborting CA Name Change renewal!&quot;;</span>
<span class="nc" id="L1970">                    log.error(errorMessage);</span>
<span class="nc" id="L1971">                    throw new IllegalStateException(errorMessage);</span>
                }
<span class="nc bnc" id="L1973" title="All 2 branches missed.">                if (ca.getCAType() != CAInfo.CATYPE_X509) {</span>
<span class="nc" id="L1974">                    final String errorMessage = &quot;CVC CA Name Change operation is not supported (Only for X509 CA)&quot;;</span>
<span class="nc" id="L1975">                    log.error(errorMessage);</span>
<span class="nc" id="L1976">                    throw new IllegalStateException(errorMessage);</span>
                }
<span class="nc bnc" id="L1978" title="All 2 branches missed.">                if (CertTools.stringToBCDNString(newSubjectDN).equalsIgnoreCase(ca.getSubjectDN())) {</span>
<span class="nc" id="L1979">                    final String errorMessage = &quot;New Subject DN &quot; + newSubjectDN</span>
                            + &quot; is the same as current. Please choose another name. Aborting CA Name Change renewal.&quot;;
<span class="nc" id="L1981">                    log.error(errorMessage);</span>
<span class="nc" id="L1982">                    throw new CANameChangeRenewalException(errorMessage);</span>
                }
<span class="nc" id="L1984">                newCAName = CertTools.getPartFromDN(newSubjectDN, &quot;CN&quot;);</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">                if (newCAName == null) {</span>
<span class="nc" id="L1986">                    final String errorMessage = &quot;New Subject DN &quot; + newSubjectDN</span>
                            + &quot; does not have Common Name or it is invalid. Aborting CA Name Change renewal!&quot;;
<span class="nc" id="L1988">                    log.error(errorMessage);</span>
<span class="nc" id="L1989">                    throw new CANameChangeRenewalException(errorMessage);</span>
                }
<span class="nc bnc" id="L1991" title="All 2 branches missed.">                if (caSession.existsCa(newCAName)) {</span>
<span class="nc" id="L1992">                    final String errorMessage = &quot;There already exists CA with the name = &quot; + newCAName</span>
                            + &quot;. Please delete it or specify another Subject DN. Aborting CA Name Change renewal.&quot;;
<span class="nc" id="L1994">                    log.error(errorMessage);</span>
<span class="nc" id="L1995">                    throw new CANameChangeRenewalException(errorMessage);</span>
                }
<span class="nc bnc" id="L1997" title="All 2 branches missed.">                if (crlStoreSession.getLastCRL(newSubjectDN, false) != null) {</span>
<span class="nc" id="L1998">                    final String errorMessage = &quot;There are already stored some CRL data with issuer DN equal to specified new SubjectDN = &quot;</span>
                            + newSubjectDN + &quot;. Please delete them. Aborting CA Name Change renewal.&quot;;
<span class="nc" id="L2000">                    log.error(errorMessage);</span>
<span class="nc" id="L2001">                    throw new IllegalStateException(errorMessage);</span>
                }
<span class="nc bnc" id="L2003" title="All 2 branches missed.">                if (ca.getSignedBy() != CAInfo.SELFSIGNED) {</span>
<span class="nc" id="L2004">                    final String errorMessage = &quot;CA name change operation is not supported for self-signed CA&quot;;</span>
<span class="nc" id="L2005">                    log.error(errorMessage);</span>
<span class="nc" id="L2006">                    throw new IllegalStateException(errorMessage);</span>
                }
<span class="nc" id="L2008">                log.info(&quot;CA Name Change (Subject DN change) has been triggered from: &quot; + ca.getSubjectDN() + &quot; to &quot; + newSubjectDN);</span>
            }

<span class="nc bnc" id="L2011" title="All 4 branches missed.">            if (ca.getStatus() == CAConstants.CA_OFFLINE || ca.getCAToken().getTokenStatus(true,</span>
<span class="nc" id="L2012">                    cryptoTokenSession.getCryptoToken(ca.getCAToken().getCryptoTokenId())) == CryptoToken.STATUS_OFFLINE) {</span>
<span class="nc" id="L2013">                String msg = intres.getLocalizedMessage(&quot;error.catokenoffline&quot;, ca.getName());</span>
<span class="nc" id="L2014">                throw new CryptoTokenOfflineException(msg);</span>
            }
<span class="nc bnc" id="L2016" title="All 2 branches missed.">            if (ca.getSignedBy() == CAInfo.SIGNEDBYEXTERNALCA) {</span>
                // We should never get here
<span class="nc" id="L2018">                log.error(&quot;Directly renewing a CA signed by external can not be done&quot;);</span>
<span class="nc" id="L2019">                throw new NotSupportedException(&quot;Directly renewing a CA signed by external can not be done&quot;);</span>
            }

<span class="nc" id="L2022">            final CAToken caToken = ca.getCAToken();</span>
<span class="nc" id="L2023">            final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(caToken.getCryptoTokenId());</span>
<span class="nc" id="L2024">            cryptoToken.testKeyPair(nextSignKeyAlias);</span>
<span class="nc" id="L2025">            caToken.setNextCertSignKey(nextSignKeyAlias);</span>
            // Activate the next signing key(s) and generate audit log
<span class="nc" id="L2027">            caToken.activateNextSignKey();</span>
<span class="nc" id="L2028">            final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L2029">            details.put(&quot;msg&quot;, intres.getLocalizedMessage(&quot;catoken.activatednextkey&quot;, caid));</span>
<span class="nc" id="L2030">            details.put(&quot;certSignKey&quot;, caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN));</span>
<span class="nc" id="L2031">            details.put(&quot;crlSignKey&quot;, caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CRLSIGN));</span>
<span class="nc" id="L2032">            details.put(&quot;sequence&quot;, caToken.getKeySequence());</span>
<span class="nc" id="L2033">            auditSession.log(EventTypes.CA_KEYACTIVATE, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2034">                    String.valueOf(caid), null, null, details);</span>
            // if issuer is in-system CA or selfsigned, then generate new certificate.
<span class="nc" id="L2036">            log.info(&quot;Renewing CA using &quot; + caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN));</span>
<span class="nc" id="L2037">            final PublicKey caPublicKey = cryptoToken.getPublicKey(caToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN));</span>
<span class="nc" id="L2038">            ca.setCAToken(caToken);</span>
<span class="nc" id="L2039">            final CertificateProfile certprofile = certificateProfileSession.getCertificateProfile(ca.getCertificateProfileId());</span>
<span class="nc" id="L2040">            mergeCertificatePoliciesFromCAAndProfile(ca.getCAInfo(), certprofile);</span>

<span class="nc" id="L2042">            final AvailableCustomCertificateExtensionsConfiguration cceConfig = (AvailableCustomCertificateExtensionsConfiguration) globalConfigurationSession</span>
<span class="nc" id="L2043">                    .getCachedConfiguration(AvailableCustomCertificateExtensionsConfiguration.CONFIGURATION_ID);</span>

            //Save old CA certificate before renewal, so we can use its expire date when creating link certificate
<span class="nc" id="L2046">            Certificate oldCaCertificate = ca.getCACertificate();</span>

<span class="nc bnc" id="L2048" title="All 2 branches missed.">            if (ca.getSignedBy() == CAInfo.SELFSIGNED) {</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">                if (subjectDNWillBeChanged) {</span>
<span class="nc" id="L2050">                    ca.setSubjectDN(newSubjectDN);</span>
<span class="nc" id="L2051">                    ca.setName(newCAName); // use CN value for new CA name</span>
<span class="nc" id="L2052">                    ca.setCAId(0); //set it to 0, because we want to new id to be generated based on newSubjectDn</span>
<span class="nc" id="L2053">                    ((X509CA) ca).setNameChanged(true);</span>
                }
                // create selfsigned certificate
<span class="nc" id="L2056">                EndEntityInformation cainfodata = makeEndEntityInformation(ca.getCAInfo());</span>
                // get from CAtoken to make sure it is fresh
<span class="nc" id="L2058">                String sequence = caToken.getKeySequence();</span>

<span class="nc" id="L2060">                cacertificate = ca.generateCertificate(cryptoToken, cainfodata, caPublicKey, -1, customNotBefore, ca.getEncodedValidity(),</span>
                        certprofile, sequence, cceConfig);
                // Build Certificate Chain
<span class="nc" id="L2063">                cachain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L2064">                cachain.add(cacertificate);</span>

                // Save renewed certificate for later use (we'll need their Subject DN within CA renewal with name change)
<span class="nc" id="L2067">                final List&lt;Certificate&gt; certificateChain = ca.getCertificateChain();</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                final List&lt;Certificate&gt; renewedCertificateChain = ca.getRenewedCertificateChain() != null ? ca.getRenewedCertificateChain()</span>
<span class="nc" id="L2069">                        : new ArrayList&lt;Certificate&gt;();</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                renewedCertificateChain.add(certificateChain != null ? certificateChain.get(certificateChain.size() - 1) : null);</span>
<span class="nc" id="L2071">                ca.setRenewedCertificateChain(renewedCertificateChain);</span>
<span class="nc" id="L2072">            } else {</span>
                // Resign with CA above.
<span class="nc bnc" id="L2074" title="All 4 branches missed.">                if (ca.getSignedBy() &gt; CAInfo.SPECIALCAIDBORDER || ca.getSignedBy() &lt; 0) {</span>
                    // Create CA signed by other internal CA.
<span class="nc" id="L2076">                    final CA signca = caSession.getCAForEdit(authenticationToken, Integer.valueOf(ca.getSignedBy()));</span>
                    // Check that the signer is valid
<span class="nc" id="L2078">                    assertSignerValidity(authenticationToken, signca);</span>
                    // Create cacertificate
<span class="nc" id="L2080">                    EndEntityInformation cainfodata = makeEndEntityInformation(ca.getCAInfo());</span>
<span class="nc" id="L2081">                    String sequence = caToken.getKeySequence(); // get from CAtoken to make sure it is fresh</span>
<span class="nc" id="L2082">                    CryptoToken signCryptoToken = cryptoTokenSession.getCryptoToken(signca.getCAToken().getCryptoTokenId());</span>

<span class="nc" id="L2084">                    cacertificate = signca.generateCertificate(signCryptoToken, cainfodata, caPublicKey, -1, customNotBefore, ca.getEncodedValidity(),</span>
                            certprofile, sequence, cceConfig);
                    // Build Certificate Chain
<span class="nc" id="L2087">                    Collection&lt;Certificate&gt; rootcachain = signca.getCertificateChain();</span>
<span class="nc" id="L2088">                    cachain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L2089">                    cachain.add(cacertificate);</span>
<span class="nc" id="L2090">                    cachain.addAll(rootcachain);</span>
                }
            }
            // Set statuses and expire time
<span class="nc" id="L2094">            ca.setExpireTime(CertTools.getNotAfter(cacertificate));</span>
<span class="nc" id="L2095">            ca.setStatus(CAConstants.CA_ACTIVE);</span>
            // Set the new certificate chain that we have created above
<span class="nc" id="L2097">            ca.setCertificateChain(cachain);</span>
            // We need to save all this, audit logging that the CA is changed
<span class="nc" id="L2099">            int caidBeforeNameChange = -1;</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">            if (subjectDNWillBeChanged) {</span>
<span class="nc" id="L2101">                ((X509CA) ca).createOrRemoveLinkCertificateDuringCANameChange(cryptoToken, createLinkCertificate, certprofile, cceConfig, oldCaCertificate);</span>
<span class="nc" id="L2102">                caidBeforeNameChange = caid;</span>
<span class="nc" id="L2103">                caid = CAData.calculateCAId(newSubjectDN).intValue(); // recalculate the caid to corresponds to new CA</span>
<span class="nc" id="L2104">                ca.setCAId(caid); // it was set to 0 above</span>
<span class="nc" id="L2105">                caSession.addCA(authenticationToken, ca); //add new CA into database</span>
            } else {
<span class="nc" id="L2107">                ca.createOrRemoveLinkCertificate(cryptoToken, createLinkCertificate, certprofile, cceConfig, oldCaCertificate);</span>
<span class="nc" id="L2108">                caSession.editCA(authenticationToken, ca, true);</span>
            }

            // Publish the new CA certificate
<span class="nc" id="L2112">            publishCACertificate(authenticationToken, cachain, ca.getCRLPublishers(), ca.getSubjectDN());</span>
<span class="nc" id="L2113">            publishingCrlSession.forceCRL(authenticationToken, caid);</span>
<span class="nc" id="L2114">            publishingCrlSession.forceDeltaCRL(authenticationToken, caid);</span>

<span class="nc bnc" id="L2116" title="All 2 branches missed.">            if (subjectDNWillBeChanged) {</span>
                // If CA has gone through Name Change, add new caid to available CAs for every certificate profile
                //that had the caid before the Name Change)
<span class="nc" id="L2119">                Map&lt;Integer, String&gt; allCertificateProfileIdMap = certificateProfileSession.getCertificateProfileIdToNameMap();</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">                for (Map.Entry&lt;Integer, String&gt; certificateProfileEntry : allCertificateProfileIdMap.entrySet()) {</span>
<span class="nc" id="L2121">                    CertificateProfile certificateProfile = certificateProfileSession.getCertificateProfile(certificateProfileEntry.getKey());</span>
<span class="nc" id="L2122">                    List&lt;Integer&gt; availCAs = certificateProfile.getAvailableCAs();</span>
<span class="nc bnc" id="L2123" title="All 4 branches missed.">                    if (availCAs.contains(caidBeforeNameChange) &amp;&amp; !availCAs.contains(caid)) {</span>
<span class="nc" id="L2124">                        availCAs.add(caid);</span>
<span class="nc" id="L2125">                        certificateProfile.setAvailableCAs(availCAs);</span>
<span class="nc" id="L2126">                        certificateProfileSession.changeCertificateProfile(authenticationToken, certificateProfileEntry.getValue(),</span>
                                certificateProfile);
                    }
<span class="nc" id="L2129">                }</span>

                //Like for certificate profiles we need to the same again for end entity profiles
<span class="nc" id="L2132">                Map&lt;Integer, String&gt; allEndEntityProfileIdMap = endEntityProfileSession.getEndEntityProfileIdToNameMap();</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                for (Integer endEntityProfileId : allEndEntityProfileIdMap.keySet()) {</span>
<span class="nc" id="L2134">                    EndEntityProfile endEntityProfile = endEntityProfileSession.getEndEntityProfile(endEntityProfileId);</span>
<span class="nc" id="L2135">                    Collection&lt;Integer&gt; availCAs = endEntityProfile.getAvailableCAs();</span>
<span class="nc bnc" id="L2136" title="All 4 branches missed.">                    if (availCAs.contains(caidBeforeNameChange) &amp;&amp; !availCAs.contains(caid)) {</span>
<span class="nc" id="L2137">                        availCAs.add(caid);</span>
<span class="nc" id="L2138">                        endEntityProfile.setAvailableCAs(availCAs);</span>
<span class="nc" id="L2139">                        endEntityProfileSession.changeEndEntityProfile(authenticationToken, allEndEntityProfileIdMap.get(endEntityProfileId),</span>
                                endEntityProfile);
                    }
<span class="nc" id="L2142">                }</span>
                // If CA has gone through Name Change, clone all this CA specific access rules with new one with replaced caid for every roles.
<span class="nc" id="L2144">                roleSession.updateCaId(caidBeforeNameChange, caid, true, false);</span>
            }
            // Audit log
<span class="nc" id="L2147">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.renewdca&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2148">            auditSession.log(EjbcaEventTypes.CA_RENEWED, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2149">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2150">        } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L2151">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorrenewca&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2152">            auditSession.log(EjbcaEventTypes.CA_RENEWED, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2153">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2154">            throw e;</span>
<span class="nc" id="L2155">        } catch (CANameChangeRenewalException e) {</span>
<span class="nc" id="L2156">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorrenewca&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2157">            auditSession.log(EjbcaEventTypes.CA_RENEWED, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2158">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2159">            throw e;</span>
<span class="nc" id="L2160">        } catch (Exception e) {</span>
<span class="nc" id="L2161">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorrenewca&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2162">            auditSession.log(EjbcaEventTypes.CA_RENEWED, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2163">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2164">            throw new EJBException(e);</span>
<span class="nc" id="L2165">        }</span>
<span class="nc bnc" id="L2166" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2167">            log.trace(&quot;&lt;CAAdminSession, renewCA(), caid=&quot; + caid);</span>
        }
<span class="nc" id="L2169">    }</span>

    @Override
    public void rolloverCA(final AuthenticationToken authenticationToken, final int caid)
            throws AuthorizationDeniedException, CryptoTokenOfflineException {
<span class="nc bnc" id="L2174" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2175">            log.trace(&quot;&gt;CAAdminSession, rolloverCA(), caid=&quot; + caid);</span>
        }
        // check authorization. we require RENEWCA access for this
<span class="nc bnc" id="L2178" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.CARENEW.resource())) {</span>
<span class="nc" id="L2179">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtorollover&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2180">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2181">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2182">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
        // Get CA info.
        try {
<span class="nc" id="L2186">            CA ca = caSession.getCAForEdit(authenticationToken, caid);</span>
<span class="nc" id="L2187">            final CAToken caToken = ca.getCAToken();</span>
<span class="nc" id="L2188">            final List&lt;Certificate&gt; rolloverChain = ca.getRolloverCertificateChain();</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">            if (rolloverChain == null) {</span>
                // We should never get here
<span class="nc" id="L2191">                log.error(&quot;Can't roll over a CA without a roll over certificate chain&quot;);</span>
<span class="nc" id="L2192">                throw new IllegalStateException(&quot;Can't roll over a CA without a roll over certificate chain&quot;);</span>
            }

            // Replace certificate chain
<span class="nc" id="L2196">            caToken.activateNextSignKey(); // also clears roll over status</span>
<span class="nc" id="L2197">            ca.setCAToken(caToken);</span>
<span class="nc" id="L2198">            ca.setCertificateChain(rolloverChain);</span>
<span class="nc" id="L2199">            ca.clearRolloverCertificateChain();</span>
<span class="nc" id="L2200">            ca.setExpireTime(CertTools.getNotAfter(rolloverChain.get(0)));</span>
            // We need to save all this, audit logging that the CA is changed
<span class="nc" id="L2202">            caSession.editCA(authenticationToken, ca, true);</span>

            // Publish the new CA certificate. Prior to this point it should have been stored but not published.
<span class="nc" id="L2205">            publishCACertificate(authenticationToken, rolloverChain, ca.getCRLPublishers(), ca.getSubjectDN());</span>

            // Change the status of the CA certificate from CERT_ROLLOVERPENDING to CERT_ACTIVE
<span class="nc" id="L2208">            certificateStoreSession.setRolloverDoneStatus(authenticationToken, CertTools.getFingerprintAsString(rolloverChain.get(0)));</span>
<span class="nc" id="L2209">            publishingCrlSession.forceCRL(authenticationToken, caid);</span>
<span class="nc" id="L2210">            publishingCrlSession.forceDeltaCRL(authenticationToken, caid);</span>
            // Audit log
<span class="nc" id="L2212">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.rolledoverca&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2213">            auditSession.log(EjbcaEventTypes.CA_ROLLEDOVER, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2214">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2215">        } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L2216">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorrolloverca&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2217">            auditSession.log(EjbcaEventTypes.CA_ROLLEDOVER, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2218">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2219">            throw e;</span>
<span class="nc" id="L2220">        } catch (Exception e) {</span>
<span class="nc" id="L2221">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorrolloverca&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2222">            auditSession.log(EjbcaEventTypes.CA_ROLLEDOVER, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2223">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2224">            throw new EJBException(e);</span>
<span class="nc" id="L2225">        }</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2227">            log.trace(&quot;&lt;CAAdminSession, rolloverCA(), caid=&quot; + caid);</span>
        }
<span class="nc" id="L2229">    }</span>

    @Override
    public byte[] getLatestLinkCertificate(final int caId) throws CADoesntExistsException {
        try {
<span class="nc" id="L2234">            CA ca = caSession.getCANoLog(new AlwaysAllowLocalAuthenticationToken(new UsernamePrincipal(&quot;Fetching link certificate user.&quot;)), caId);</span>
<span class="nc" id="L2235">            return ca.getLatestLinkCertificate();</span>
<span class="nc" id="L2236">        } catch (AuthorizationDeniedException e) {</span>
<span class="nc" id="L2237">            throw new RuntimeException(e); // Should always be allowed</span>
        }
    }

    @Override
    public void revokeCA(AuthenticationToken admin, int caid, int reason) throws CADoesntExistsException, AuthorizationDeniedException {
        // check authorization
<span class="nc bnc" id="L2244" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(admin, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L2245">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtorevoke&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2246">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2247">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2248">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
        // Get CA info.
<span class="nc" id="L2251">        CA ca = caSession.getCAForEdit(admin, caid);</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">        if(ca == null) {</span>
<span class="nc" id="L2253">            throw new CADoesntExistsException(&quot;No CA with id &quot; + caid + &quot; found&quot;);</span>
        }
        try {
            // Revoke all issued CA certificates for this CA
<span class="nc" id="L2257">            final List&lt;CertificateDataWrapper&gt; cacerts = certificateStoreSession.getCertificateDatasBySubject(ca.getSubjectDN());</span>
<span class="nc" id="L2258">            final Date now = new Date();</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">            for (final CertificateDataWrapper cdw : cacerts) {</span>
<span class="nc" id="L2260">                revocationSession.revokeCertificateInNewTransaction(admin, cdw, ca.getCRLPublishers(), now, reason, ca.getSubjectDN());</span>
<span class="nc" id="L2261">            }</span>
            // Revoke all certificates issued by this CA. If this is a root CA the CA certificates will be included in this batch as well
            // but if this is a subCA these are only the &quot;entity&quot; certificates issued by this CA
<span class="nc bnc" id="L2264" title="All 2 branches missed.">            if (ca.getStatus() != CAConstants.CA_EXTERNAL) {</span>
<span class="nc" id="L2265">                certificateStoreSession.revokeAllCertByCA(admin, ca.getSubjectDN(), reason);</span>
<span class="nc" id="L2266">                publishingCrlSession.forceCRL(admin, ca.getCAId());</span>
            }
<span class="nc" id="L2268">            ca.setRevocationReason(reason);</span>
<span class="nc" id="L2269">            ca.setRevocationDate(new Date());</span>
<span class="nc bnc" id="L2270" title="All 2 branches missed.">            if (ca.getStatus() != CAConstants.CA_EXTERNAL) {</span>
<span class="nc" id="L2271">                ca.setStatus(CAConstants.CA_REVOKED);</span>
            }
            // Store new status, audit logging
<span class="nc" id="L2274">            caSession.editCA(admin, ca, true);</span>
<span class="nc" id="L2275">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.revokedca&quot;, ca.getName(), Integer.valueOf(reason));</span>
<span class="nc" id="L2276">            auditSession.log(EjbcaEventTypes.CA_REVOKED, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2277">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2278">        } catch (CADoesntExistsException | CertificateRevokeException | CryptoTokenOfflineException | CAOfflineException e) {</span>
<span class="nc" id="L2279">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorrevoke&quot;, ca.getName());</span>
<span class="nc" id="L2280">            auditSession.log(EjbcaEventTypes.CA_REVOKED, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2281">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2282">            throw new EJBException(e);</span>
<span class="nc" id="L2283">        }</span>
<span class="nc" id="L2284">    }</span>

    @Override
    public void importCAFromKeyStore(AuthenticationToken admin, String caname, byte[] p12file, String keystorepass, String privkeypass,
            String privateSignatureKeyAlias, String privateEncryptionKeyAlias) {
        try {
            // check authorization
<span class="nc bnc" id="L2291" title="All 2 branches missed.">            if (!authorizationSession.isAuthorizedNoLogging(admin, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L2292">                String msg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtocreateca&quot;, caname);</span>
<span class="nc" id="L2293">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L2294">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L2295">                auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), null, null,</span>
                        null, details);
            }
            // load keystore
<span class="nc" id="L2299">            java.security.KeyStore keystore = KeyStore.getInstance(&quot;PKCS12&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2300">            keystore.load(new java.io.ByteArrayInputStream(p12file), keystorepass.toCharArray());</span>
            // Extract signature keys
<span class="nc bnc" id="L2302" title="All 4 branches missed.">            if (privateSignatureKeyAlias == null || !keystore.isKeyEntry(privateSignatureKeyAlias)) {</span>
<span class="nc" id="L2303">                throw new Exception(&quot;Alias \&quot;&quot; + privateSignatureKeyAlias + &quot;\&quot; not found.&quot;);</span>
            }
<span class="nc" id="L2305">            Certificate[] signatureCertChain = KeyTools.getCertChain(keystore, privateSignatureKeyAlias);</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">            if (signatureCertChain.length &lt; 1) {</span>
<span class="nc" id="L2307">                String msg = &quot;Cannot load certificate chain with alias &quot; + privateSignatureKeyAlias;</span>
<span class="nc" id="L2308">                log.error(msg);</span>
<span class="nc" id="L2309">                throw new Exception(msg);</span>
            }
<span class="nc" id="L2311">            Certificate caSignatureCertificate = signatureCertChain[0];</span>
<span class="nc" id="L2312">            PublicKey p12PublicSignatureKey = caSignatureCertificate.getPublicKey();</span>
<span class="nc" id="L2313">            PrivateKey p12PrivateSignatureKey = null;</span>
<span class="nc" id="L2314">            p12PrivateSignatureKey = (PrivateKey) keystore.getKey(privateSignatureKeyAlias, privkeypass.toCharArray());</span>
<span class="nc" id="L2315">            log.debug(&quot;ImportSignatureKeyAlgorithm=&quot; + p12PrivateSignatureKey.getAlgorithm());</span>

            // Extract encryption keys
<span class="nc" id="L2318">            PrivateKey p12PrivateEncryptionKey = null;</span>
<span class="nc" id="L2319">            PublicKey p12PublicEncryptionKey = null;</span>
<span class="nc" id="L2320">            Certificate caEncryptionCertificate = null;</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">            if (privateEncryptionKeyAlias != null) {</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">                if (!keystore.isKeyEntry(privateEncryptionKeyAlias)) {</span>
<span class="nc" id="L2323">                    throw new Exception(&quot;Alias \&quot;&quot; + privateEncryptionKeyAlias + &quot;\&quot; not found.&quot;);</span>
                }
<span class="nc" id="L2325">                Certificate[] encryptionCertChain = KeyTools.getCertChain(keystore, privateEncryptionKeyAlias);</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">                if (encryptionCertChain.length &lt; 1) {</span>
<span class="nc" id="L2327">                    String msg = &quot;Cannot load certificate chain with alias &quot; + privateEncryptionKeyAlias;</span>
<span class="nc" id="L2328">                    log.error(msg);</span>
<span class="nc" id="L2329">                    throw new Exception(msg);</span>
                }
<span class="nc" id="L2331">                caEncryptionCertificate = encryptionCertChain[0];</span>
<span class="nc" id="L2332">                p12PrivateEncryptionKey = (PrivateKey) keystore.getKey(privateEncryptionKeyAlias, privkeypass.toCharArray());</span>
<span class="nc" id="L2333">                p12PublicEncryptionKey = caEncryptionCertificate.getPublicKey();</span>
            }
<span class="nc" id="L2335">            importCAFromKeys(admin, caname, keystorepass, signatureCertChain, p12PublicSignatureKey, p12PrivateSignatureKey, p12PrivateEncryptionKey,</span>
                    p12PublicEncryptionKey);
<span class="nc" id="L2337">        } catch (Exception e) {</span>
<span class="nc" id="L2338">            String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorimportca&quot;, caname, &quot;PKCS12&quot;, e.getMessage());</span>
<span class="nc" id="L2339">            auditSession.log(EjbcaEventTypes.CA_IMPORT, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), null, null, null,</span>
                    detailsMsg);
<span class="nc" id="L2341">            throw new EJBException(e);</span>
<span class="nc" id="L2342">        }</span>
<span class="nc" id="L2343">    }</span>

    @Override
    public void removeCAKeyStore(AuthenticationToken admin, String caname) throws EJBException {
<span class="nc bnc" id="L2347" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2348">            log.trace(&quot;&gt;removeCAKeyStore&quot;);</span>
        }
        try {
            // check authorization
<span class="nc bnc" id="L2352" title="All 2 branches missed.">            if (!authorizationSession.isAuthorizedNoLogging(admin, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L2353">                String msg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtoremovecatoken&quot;, caname);</span>
<span class="nc" id="L2354">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L2355">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L2356">                auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), null, null,</span>
                        null, details);
            }
<span class="nc" id="L2359">            CA ca = caSession.getCAForEdit(admin, caname);</span>
<span class="nc" id="L2360">            final CAToken currentCaToken = ca.getCAToken();</span>
<span class="nc" id="L2361">            final int cryptoTokenId = currentCaToken.getCryptoTokenId();</span>
<span class="nc" id="L2362">            CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(cryptoTokenId);</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">            if (!(cryptoToken instanceof SoftCryptoToken)) {</span>
<span class="nc" id="L2364">                throw new Exception(&quot;Cannot export anything but a soft token.&quot;);</span>
            }
<span class="nc" id="L2366">            cryptoTokenManagementSession.deactivate(admin, cryptoTokenId);</span>
            // Create a new CAToken with the same properties but without the reference to the removed CryptoToken
<span class="nc" id="L2368">            cryptoTokenSession.removeCryptoToken(cryptoTokenId);</span>
<span class="nc" id="L2369">            final CAToken newCaToken = new CAToken(0, currentCaToken.getProperties());</span>
<span class="nc" id="L2370">            newCaToken.setKeySequence(newCaToken.getKeySequence());</span>
<span class="nc" id="L2371">            newCaToken.setKeySequenceFormat(newCaToken.getKeySequenceFormat());</span>
<span class="nc" id="L2372">            newCaToken.setSignatureAlgorithm(newCaToken.getSignatureAlgorithm());</span>
<span class="nc" id="L2373">            newCaToken.setEncryptionAlgorithm(newCaToken.getEncryptionAlgorithm());</span>
<span class="nc" id="L2374">            ca.setCAToken(newCaToken);</span>
            // Set this CA to offline, since it cannot be used without a CryptoToken this is probably intended.
<span class="nc" id="L2376">            ca.setStatus(CAConstants.CA_OFFLINE);</span>
            // Save to database
<span class="nc" id="L2378">            caSession.editCA(admin, ca, false);</span>
            // Log
<span class="nc" id="L2380">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.removedcakeystore&quot;, Integer.valueOf(ca.getCAId()));</span>
<span class="nc" id="L2381">            auditSession.log(EjbcaEventTypes.CA_REMOVETOKEN, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2382">                    String.valueOf(ca.getCAId()), null, null, detailsMsg);</span>
<span class="nc" id="L2383">        } catch (Exception e) {</span>
<span class="nc" id="L2384">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorremovecakeystore&quot;, caname, &quot;PKCS12&quot;, e.getMessage());</span>
<span class="nc" id="L2385">            auditSession.log(EjbcaEventTypes.CA_REMOVETOKEN, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), null, null,</span>
                    null, detailsMsg);
<span class="nc" id="L2387">            throw new EJBException(detailsMsg, e);</span>
<span class="nc" id="L2388">        }</span>
<span class="nc bnc" id="L2389" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2390">            log.trace(&quot;&lt;removeCAKeyStore&quot;);</span>
        }
<span class="nc" id="L2392">    }</span>

    @Override
    public void restoreCAKeyStore(AuthenticationToken authenticationToken, String caname, byte[] p12file, String keystorepass, String privkeypass,
            String privateSignatureKeyAlias, String privateEncryptionKeyAlias) {
<span class="nc bnc" id="L2397" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2398">            log.trace(&quot;&gt;restoreCAKeyStore&quot;);</span>
        }
        try {
            // check authorization
<span class="nc bnc" id="L2402" title="All 2 branches missed.">            if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L2403">                final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtorestorecatoken&quot;, caname);</span>
<span class="nc" id="L2404">                auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
                        null, null, null, detailsMsg);
            }
<span class="nc" id="L2407">            CA thisCa = caSession.getCAForEdit(authenticationToken, caname);</span>
<span class="nc" id="L2408">            final CAToken thisCAToken = thisCa.getCAToken();</span>
<span class="nc" id="L2409">            CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(thisCAToken.getCryptoTokenId());</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">            if (cryptoToken != null) {</span>
<span class="nc" id="L2411">                throw new Exception(&quot;CA already has an existing CryptoToken reference: &quot; + cryptoToken.getId());</span>
            }
            // load keystore from input
<span class="nc" id="L2414">            KeyStore keystore = KeyStore.getInstance(&quot;PKCS12&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2415">            keystore.load(new ByteArrayInputStream(p12file), keystorepass.toCharArray());</span>
            // Extract signature keys
<span class="nc bnc" id="L2417" title="All 4 branches missed.">            if (privateSignatureKeyAlias == null || !keystore.isKeyEntry(privateSignatureKeyAlias)) {</span>
<span class="nc" id="L2418">                throw new Exception(&quot;Alias \&quot;&quot; + privateSignatureKeyAlias + &quot;\&quot; not found.&quot;);</span>
            }
<span class="nc" id="L2420">            Certificate[] signatureCertChain = KeyTools.getCertChain(keystore, privateSignatureKeyAlias);</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">            if (signatureCertChain.length &lt; 1) {</span>
<span class="nc" id="L2422">                String msg = &quot;Cannot load certificate chain with alias &quot; + privateSignatureKeyAlias;</span>
<span class="nc" id="L2423">                log.error(msg);</span>
<span class="nc" id="L2424">                throw new Exception(msg);</span>
            }
<span class="nc" id="L2426">            Certificate caSignatureCertificate = signatureCertChain[0];</span>
<span class="nc" id="L2427">            PublicKey p12PublicSignatureKey = caSignatureCertificate.getPublicKey();</span>
<span class="nc" id="L2428">            PrivateKey p12PrivateSignatureKey = null;</span>
<span class="nc" id="L2429">            p12PrivateSignatureKey = (PrivateKey) keystore.getKey(privateSignatureKeyAlias, privkeypass.toCharArray());</span>

            // Extract encryption keys
<span class="nc" id="L2432">            PrivateKey p12PrivateEncryptionKey = null;</span>
<span class="nc" id="L2433">            PublicKey p12PublicEncryptionKey = null;</span>
<span class="nc" id="L2434">            Certificate caEncryptionCertificate = null;</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">            if (privateEncryptionKeyAlias != null) {</span>
<span class="nc bnc" id="L2436" title="All 2 branches missed.">                if (!keystore.isKeyEntry(privateEncryptionKeyAlias)) {</span>
<span class="nc" id="L2437">                    throw new Exception(&quot;Alias \&quot;&quot; + privateEncryptionKeyAlias + &quot;\&quot; not found.&quot;);</span>
                }
<span class="nc" id="L2439">                Certificate[] encryptionCertChain = KeyTools.getCertChain(keystore, privateEncryptionKeyAlias);</span>
<span class="nc bnc" id="L2440" title="All 2 branches missed.">                if (encryptionCertChain.length &lt; 1) {</span>
<span class="nc" id="L2441">                    String msg = &quot;Cannot load certificate chain with alias &quot; + privateEncryptionKeyAlias;</span>
<span class="nc" id="L2442">                    log.error(msg);</span>
<span class="nc" id="L2443">                    throw new Exception(msg);</span>
                }
<span class="nc" id="L2445">                caEncryptionCertificate = encryptionCertChain[0];</span>
<span class="nc" id="L2446">                p12PrivateEncryptionKey = (PrivateKey) keystore.getKey(privateEncryptionKeyAlias, privkeypass.toCharArray());</span>
<span class="nc" id="L2447">                p12PublicEncryptionKey = caEncryptionCertificate.getPublicKey();</span>
<span class="nc" id="L2448">            } else {</span>
<span class="nc" id="L2449">                throw new Exception(&quot;Missing encryption key&quot;);</span>
            }

            // Sign something to see that we are restoring the right private signature key
            // BC should support the first algorithm so there is no need to use the SignWithWorkingAlgorithm class.
<span class="nc" id="L2454">            final String testSigAlg = AlgorithmTools.getSignatureAlgorithms(thisCa.getCACertificate().getPublicKey()).get(0);</span>
            // Sign with imported private key
<span class="nc" id="L2456">            byte[] input = &quot;Test data...&quot;.getBytes();</span>
<span class="nc" id="L2457">            Signature signature = Signature.getInstance(testSigAlg, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2458">            signature.initSign(p12PrivateSignatureKey);</span>
<span class="nc" id="L2459">            signature.update(input);</span>
<span class="nc" id="L2460">            byte[] signed = signature.sign();</span>
            // Verify with public key from CA certificate
<span class="nc" id="L2462">            signature = Signature.getInstance(testSigAlg, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2463">            signature.initVerify(thisCa.getCACertificate().getPublicKey());</span>
<span class="nc" id="L2464">            signature.update(input);</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">            if (!signature.verify(signed)) {</span>
<span class="nc" id="L2466">                throw new Exception(&quot;Could not use private key for verification. Wrong p12-file for this CA?&quot;);</span>
            }
            // Import the keys and save to database
<span class="nc" id="L2469">            CAToken catoken = importKeysToCAToken(authenticationToken, keystorepass, thisCAToken.getProperties(), p12PrivateSignatureKey,</span>
<span class="nc" id="L2470">                    p12PublicSignatureKey, p12PrivateEncryptionKey, p12PublicEncryptionKey, signatureCertChain, thisCa.getCAId());</span>
<span class="nc" id="L2471">            thisCa.setCAToken(catoken);</span>
            // Finally save the CA
<span class="nc" id="L2473">            caSession.editCA(authenticationToken, thisCa, true);</span>
            // Log
<span class="nc" id="L2475">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.restoredcakeystore&quot;, Integer.valueOf(thisCa.getCAId()));</span>
<span class="nc" id="L2476">            auditSession.log(EjbcaEventTypes.CA_RESTORETOKEN, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2477">                    String.valueOf(thisCa.getCAId()), null, null, detailsMsg);</span>
<span class="nc" id="L2478">        } catch (Exception e) {</span>
<span class="nc" id="L2479">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errorrestorecakeystore&quot;, caname, &quot;PKCS12&quot;, e.getMessage());</span>
<span class="nc" id="L2480">            auditSession.log(EjbcaEventTypes.CA_RESTORETOKEN, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
                    null, null, null, detailsMsg);
<span class="nc" id="L2482">            throw new EJBException(e);</span>
<span class="nc" id="L2483">        }</span>
<span class="nc bnc" id="L2484" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L2485">            log.trace(&quot;&lt;restoreCAKeyStore&quot;);</span>
        }
<span class="nc" id="L2487">    }</span>

    @Override
    public void importCAFromKeys(AuthenticationToken authenticationToken, String caname, String keystorepass, Certificate[] signatureCertChain,
            PublicKey p12PublicSignatureKey, PrivateKey p12PrivateSignatureKey, PrivateKey p12PrivateEncryptionKey, PublicKey p12PublicEncryptionKey)
            throws CryptoTokenAuthenticationFailedException, CryptoTokenOfflineException, IllegalCryptoTokenException, AuthorizationDeniedException,
            CAExistsException, CAOfflineException {
        // Transform into token
<span class="nc" id="L2495">        int caId = StringTools.strip(CertTools.getSubjectDN(signatureCertChain[0])).hashCode(); // caid</span>
<span class="nc" id="L2496">        CAToken catoken = null;</span>
        try {
<span class="nc" id="L2498">            catoken = importKeysToCAToken(authenticationToken, keystorepass, null, p12PrivateSignatureKey, p12PublicSignatureKey,</span>
                    p12PrivateEncryptionKey, p12PublicEncryptionKey, signatureCertChain, caId);
<span class="nc" id="L2500">        } catch (OperatorCreationException e) {</span>
<span class="nc" id="L2501">            log.error(e.getLocalizedMessage(), e);</span>
<span class="nc" id="L2502">            throw new EJBException(e);</span>
<span class="nc" id="L2503">        }</span>
<span class="nc" id="L2504">        log.debug(&quot;CA-Info: &quot; + catoken.getSignatureAlgorithm() + &quot; &quot; + catoken.getEncryptionAlgorithm());</span>
        // Identify the key algorithms for extended CA services, OCSP, CMS
<span class="nc" id="L2506">        String keyAlgorithm = AlgorithmTools.getKeyAlgorithm(p12PublicSignatureKey);</span>
<span class="nc" id="L2507">        String keySpecification = AlgorithmTools.getKeySpecification(p12PublicSignatureKey);</span>
<span class="nc bnc" id="L2508" title="All 4 branches missed.">        if (keyAlgorithm == null || keyAlgorithm == AlgorithmConstants.KEYALGORITHM_RSA) {</span>
<span class="nc" id="L2509">            keyAlgorithm = AlgorithmConstants.KEYALGORITHM_RSA;</span>
<span class="nc" id="L2510">            keySpecification = &quot;2048&quot;;</span>
        }
        // Do the general import
<span class="nc" id="L2513">        CA ca = importCA(authenticationToken, caname, keystorepass, signatureCertChain, catoken, keyAlgorithm, keySpecification);</span>
        // Finally audit log
<span class="nc" id="L2515">        String msg = intres.getLocalizedMessage(&quot;caadmin.importedca&quot;, caname, &quot;PKCS12&quot;, ca.getStatus());</span>
<span class="nc" id="L2516">        Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L2517">        details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L2518">        auditSession.log(EjbcaEventTypes.CA_IMPORT, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, authenticationToken.toString(),</span>
<span class="nc" id="L2519">                String.valueOf(ca.getCAId()), null, null, details);</span>
<span class="nc" id="L2520">    }</span>

    /**
     * Method that import CA token keys from a P12 file. Was originally used when upgrading from old EJBCA versions. Only supports SHA1 and SHA256
     * with RSA or ECDSA and SHA1 with DSA.
     * @param authenticationToken Auth token
     * @param authenticationCode Auth code
     * @param caTokenProperties Token properties
     * @param privatekey Private key
     * @param publickey Public key
     * @param privateEncryptionKey Encryption  
     * @param publicEncryptionKey Encryption
     * @param caSignatureCertChain Certificates
     * @param caId CA
     * @return CA Token
     * @throws CryptoTokenAuthenticationFailedException Fail
     * @throws IllegalCryptoTokenException Fail
     * @throws OperatorCreationException Fail
     * @throws AuthorizationDeniedException Fail
     */
    private CAToken importKeysToCAToken(AuthenticationToken authenticationToken, String authenticationCode, Properties caTokenProperties,
            PrivateKey privatekey, PublicKey publickey, PrivateKey privateEncryptionKey, PublicKey publicEncryptionKey,
            Certificate[] caSignatureCertChain, int caId)
            throws CryptoTokenAuthenticationFailedException, IllegalCryptoTokenException, OperatorCreationException, AuthorizationDeniedException {
        // If we don't give an authentication code, perhaps we have autoactivation enabled
<span class="nc bnc" id="L2545" title="All 2 branches missed.">        if (StringUtils.isEmpty(authenticationCode)) {</span>
<span class="nc" id="L2546">            String msg = intres.getLocalizedMessage(&quot;token.authcodemissing&quot;, Integer.valueOf(caId));</span>
<span class="nc" id="L2547">            log.info(msg);</span>
<span class="nc" id="L2548">            throw new CryptoTokenAuthenticationFailedException(msg);</span>
        }
<span class="nc bnc" id="L2550" title="All 2 branches missed.">        if (caTokenProperties == null) {</span>
<span class="nc" id="L2551">            caTokenProperties = new Properties();</span>
        }

        try {
            // Currently only RSA keys are supported
<span class="nc" id="L2556">            KeyStore keystore = KeyStore.getInstance(&quot;PKCS12&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2557">            keystore.load(null, null);</span>

            // The CAs certificate is first in chain
<span class="nc" id="L2560">            Certificate cacert = caSignatureCertChain[0];</span>
            // Assume that the same hash algorithm is used for signing that was used to sign this CA cert
<span class="nc" id="L2562">            String signatureAlgorithm = AlgorithmTools.getSignatureAlgorithm(cacert);</span>
<span class="nc" id="L2563">            String keyAlg = AlgorithmTools.getKeyAlgorithm(publickey);</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">            if (keyAlg == null) {</span>
<span class="nc" id="L2565">                throw new IllegalCryptoTokenException(&quot;Unknown public key type: &quot; + publickey.getAlgorithm() + &quot; (&quot; + publickey.getClass() + &quot;)&quot;);</span>
            }

            // import sign keys.
<span class="nc" id="L2569">            final Certificate[] certchain = new Certificate[1];</span>
<span class="nc" id="L2570">            certchain[0] = CertTools.genSelfCert(&quot;CN=SignatureKeyHolder&quot;, 36500, null, privatekey, publickey, signatureAlgorithm, true);</span>

<span class="nc" id="L2572">            keystore.setKeyEntry(CAToken.SOFTPRIVATESIGNKEYALIAS, privatekey, null, certchain);</span>

            // generate enc keys.
            // Encryption keys must be RSA still
<span class="nc" id="L2576">            final String encryptionAlgorithm = AlgorithmTools.getEncSigAlgFromSigAlg(signatureAlgorithm);</span>
<span class="nc" id="L2577">            keyAlg = AlgorithmTools.getKeyAlgorithmFromSigAlg(encryptionAlgorithm);</span>
<span class="nc" id="L2578">            final String enckeyspec = &quot;2048&quot;;</span>
<span class="nc" id="L2579">            KeyPair enckeys = null;</span>
<span class="nc bnc" id="L2580" title="All 4 branches missed.">            if (publicEncryptionKey == null || privateEncryptionKey == null) {</span>
<span class="nc" id="L2581">                enckeys = KeyTools.genKeys(enckeyspec, keyAlg);</span>
            } else {
<span class="nc" id="L2583">                enckeys = new KeyPair(publicEncryptionKey, privateEncryptionKey);</span>
            }
            // generate dummy certificate
<span class="nc" id="L2586">            certchain[0] = CertTools.genSelfCert(&quot;CN=EncryptionKeyHolder&quot;, 36500, null, enckeys.getPrivate(), enckeys.getPublic(),</span>
                    encryptionAlgorithm, true);
<span class="nc" id="L2588">            keystore.setKeyEntry(CAToken.SOFTPRIVATEDECKEYALIAS, enckeys.getPrivate(), null, certchain);</span>

            // Set the token properties
<span class="nc" id="L2591">            caTokenProperties.setProperty(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING, CAToken.SOFTPRIVATESIGNKEYALIAS);</span>
<span class="nc" id="L2592">            caTokenProperties.setProperty(CATokenConstants.CAKEYPURPOSE_CRLSIGN_STRING, CAToken.SOFTPRIVATESIGNKEYALIAS);</span>
<span class="nc" id="L2593">            caTokenProperties.setProperty(CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING, CAToken.SOFTPRIVATEDECKEYALIAS);</span>

            // Write the keystore to byte[] that we can feed to crypto token factory
<span class="nc" id="L2596">            final char[] authCode = authenticationCode.toCharArray();</span>
<span class="nc" id="L2597">            final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L2598">            keystore.store(baos, authCode);</span>

            // Now we have the PKCS12 keystore, from this we can create the CAToken
<span class="nc" id="L2601">            final Properties cryptoTokenProperties = new Properties();</span>
            int cryptoTokenId;
            try {
<span class="nc" id="L2604">                cryptoTokenId = createCryptoTokenWithUniqueName(authenticationToken, &quot;ImportedCryptoToken&quot; + caId, SoftCryptoToken.class.getName(),</span>
<span class="nc" id="L2605">                        cryptoTokenProperties, baos.toByteArray(), authCode);</span>
<span class="nc" id="L2606">            } catch (NoSuchSlotException e1) {</span>
<span class="nc" id="L2607">                throw new RuntimeException(&quot;Attempte to define a slot for a soft crypto token. This should not happen.&quot;);</span>
<span class="nc" id="L2608">            }</span>
<span class="nc" id="L2609">            final CAToken catoken = new CAToken(cryptoTokenId, caTokenProperties);</span>
            // If this is a CVC CA we need to find out the sequence
<span class="nc" id="L2611">            String sequence = CAToken.DEFAULT_KEYSEQUENCE;</span>
<span class="nc bnc" id="L2612" title="All 2 branches missed.">            if (cacert instanceof CardVerifiableCertificate) {</span>
<span class="nc" id="L2613">                CardVerifiableCertificate cvccacert = (CardVerifiableCertificate) cacert;</span>
<span class="nc" id="L2614">                log.debug(&quot;Getting sequence from holderRef in CV certificate.&quot;);</span>
                try {
<span class="nc" id="L2616">                    sequence = cvccacert.getCVCertificate().getCertificateBody().getHolderReference().getSequence();</span>
<span class="nc" id="L2617">                } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L2618">                    log.error(&quot;Can not get sequence from holderRef in CV certificate, using default sequence.&quot;);</span>
<span class="nc" id="L2619">                }</span>
            }
<span class="nc" id="L2621">            log.debug(&quot;Setting sequence &quot; + sequence);</span>
<span class="nc" id="L2622">            catoken.setKeySequence(sequence);</span>
<span class="nc" id="L2623">            log.debug(&quot;Setting default sequence format &quot; + StringTools.KEY_SEQUENCE_FORMAT_NUMERIC);</span>
<span class="nc" id="L2624">            catoken.setKeySequenceFormat(StringTools.KEY_SEQUENCE_FORMAT_NUMERIC);</span>
<span class="nc" id="L2625">            catoken.setSignatureAlgorithm(signatureAlgorithm);</span>
<span class="nc" id="L2626">            catoken.setEncryptionAlgorithm(encryptionAlgorithm);</span>
<span class="nc" id="L2627">            return catoken;</span>
<span class="nc" id="L2628">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L2629">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2630">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L2631">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2632">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2633">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2634">        } catch (CertificateException e) {</span>
<span class="nc" id="L2635">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2636">        } catch (IOException e) {</span>
<span class="nc" id="L2637">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2638">        } catch (IllegalStateException e) {</span>
<span class="nc" id="L2639">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2640">        } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L2641">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2642">        } catch (CryptoTokenOfflineException e) {</span>
<span class="nc" id="L2643">            throw new IllegalCryptoTokenException(e);</span>
        }
    } // importKeys

    @Override
    public void importCAFromHSM(AuthenticationToken authenticationToken, String caname, Certificate[] signatureCertChain, String catokenpassword,
            String catokenclasspath, String catokenproperties) throws CryptoTokenOfflineException, CryptoTokenAuthenticationFailedException,
            IllegalCryptoTokenException, AuthorizationDeniedException, CAExistsException, CAOfflineException, NoSuchSlotException {
<span class="nc" id="L2651">        Certificate cacert = signatureCertChain[0];</span>
<span class="nc" id="L2652">        int caId = StringTools.strip(CertTools.getSubjectDN(cacert)).hashCode();</span>
<span class="nc" id="L2653">        Properties caTokenProperties = CAToken.getPropertiesFromString(catokenproperties);</span>
        // Create the CryptoToken
<span class="nc" id="L2655">        int cryptoTokenId = createCryptoTokenWithUniqueName(authenticationToken, &quot;ImportedCryptoToken&quot; + caId, PKCS11CryptoToken.class.getName(),</span>
<span class="nc" id="L2656">                caTokenProperties, null, catokenpassword.toCharArray());</span>
<span class="nc" id="L2657">        final CAToken catoken = new CAToken(cryptoTokenId, caTokenProperties);</span>
        // Set a lot of properties on the crypto token

        // If this is a CVC CA we need to find out the sequence
<span class="nc" id="L2661">        String signatureAlgorithm = AlgorithmTools.getSignatureAlgorithm(cacert);</span>
<span class="nc" id="L2662">        String sequence = CAToken.DEFAULT_KEYSEQUENCE;</span>
<span class="nc bnc" id="L2663" title="All 2 branches missed.">        if (cacert instanceof CardVerifiableCertificate) {</span>
<span class="nc" id="L2664">            CardVerifiableCertificate cvccacert = (CardVerifiableCertificate) cacert;</span>
<span class="nc" id="L2665">            log.debug(&quot;Getting sequence from holderRef in CV certificate.&quot;);</span>
            try {
<span class="nc" id="L2667">                sequence = cvccacert.getCVCertificate().getCertificateBody().getHolderReference().getSequence();</span>
<span class="nc" id="L2668">            } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L2669">                log.error(&quot;Can not get sequence from holderRef in CV certificate, using default sequence.&quot;);</span>
<span class="nc" id="L2670">            }</span>
        }
<span class="nc" id="L2672">        log.debug(&quot;Setting sequence &quot; + sequence);</span>
<span class="nc" id="L2673">        catoken.setKeySequence(sequence);</span>
<span class="nc" id="L2674">        log.debug(&quot;Setting default sequence format &quot; + StringTools.KEY_SEQUENCE_FORMAT_NUMERIC);</span>
<span class="nc" id="L2675">        catoken.setKeySequenceFormat(StringTools.KEY_SEQUENCE_FORMAT_NUMERIC);</span>
<span class="nc" id="L2676">        catoken.setSignatureAlgorithm(signatureAlgorithm);</span>
        // Encryption keys must be RSA still
<span class="nc" id="L2678">        String encryptionAlgorithm = AlgorithmTools.getEncSigAlgFromSigAlg(signatureAlgorithm);</span>
<span class="nc" id="L2679">        catoken.setEncryptionAlgorithm(encryptionAlgorithm);</span>
        // Identify the key algorithms for extended CA services, OCSP, CMS
<span class="nc" id="L2681">        String keyAlgorithm = AlgorithmTools.getKeyAlgorithm(cacert.getPublicKey());</span>
<span class="nc" id="L2682">        String keySpecification = AlgorithmTools.getKeySpecification(cacert.getPublicKey());</span>
<span class="nc bnc" id="L2683" title="All 4 branches missed.">        if (keyAlgorithm == null || keyAlgorithm == AlgorithmConstants.KEYALGORITHM_RSA) {</span>
<span class="nc" id="L2684">            keyAlgorithm = AlgorithmConstants.KEYALGORITHM_RSA;</span>
<span class="nc" id="L2685">            keySpecification = &quot;2048&quot;;</span>
        }
        // Do the general import
<span class="nc" id="L2688">        importCA(authenticationToken, caname, catokenpassword, signatureCertChain, catoken, keyAlgorithm, keySpecification);</span>
<span class="nc" id="L2689">    }</span>

    /** Wrapper for CryptoToken creation that tries to find a unique CryptoTokenName
     * @param authenticationToken Auth token
     * @param basename Base name
     * @param className Class
     * @param cryptoTokenProperties Properties 
     * @param data Data
     * @param authCode Code
     * @return Int
     * @throws CryptoTokenOfflineException Fail
     * @throws CryptoTokenAuthenticationFailedException Fail
     * @throws AuthorizationDeniedException Fail
     * @throws NoSuchSlotException if no slot with the given label could be found
     */
    private int createCryptoTokenWithUniqueName(AuthenticationToken authenticationToken, String basename, String className,
            Properties cryptoTokenProperties, byte[] data, char[] authCode)
            throws CryptoTokenOfflineException, CryptoTokenAuthenticationFailedException, AuthorizationDeniedException, NoSuchSlotException {
<span class="nc" id="L2707">        int cryptoTokenId = 0;</span>
<span class="nc" id="L2708">        final int maxTriesToFindUnusedCryptoTokenName = 25;</span>
<span class="nc" id="L2709">        String postFix = &quot;&quot;;</span>
<span class="nc bnc" id="L2710" title="All 4 branches missed.">        for (int i = 0; cryptoTokenId == 0 &amp;&amp; i &lt; maxTriesToFindUnusedCryptoTokenName; i++) {</span>
<span class="nc" id="L2711">            String cryptoTokenName = basename + postFix;</span>
            try {
<span class="nc" id="L2713">                cryptoTokenId = cryptoTokenManagementSession.createCryptoToken(authenticationToken, cryptoTokenName, className, cryptoTokenProperties,</span>
                        data, authCode);
<span class="nc" id="L2715">            } catch (CryptoTokenNameInUseException e) {</span>
<span class="nc" id="L2716">                log.info(&quot;CryptoToken with name '&quot; + &quot;' could not be created since the name exists. Trying another name.&quot;);</span>
<span class="nc" id="L2717">                postFix = &quot;_&quot; + i;</span>
<span class="nc" id="L2718">            }</span>
        }
<span class="nc bnc" id="L2720" title="All 2 branches missed.">        if (cryptoTokenId == 0) {</span>
<span class="nc" id="L2721">            final String msg = &quot;Failed to create a CryptoToken with a unique name after &quot; + maxTriesToFindUnusedCryptoTokenName;</span>
<span class="nc" id="L2722">            log.error(msg);</span>
<span class="nc" id="L2723">            throw new RuntimeException(msg);</span>
        }
<span class="nc" id="L2725">        return cryptoTokenId;</span>
    }

    /**
     * @param admin Admin
     * @param caname CA Name
     * @param keystorepass Password
     * @param signatureCertChain Cetificates
     * @param catoken Token
     * @param keyAlgorithm keyalgorithm for extended CA services, OCSP, CMS. Example AlgorithmConstants.KEYALGORITHM_RSA
     * @param keySpecification keyspecification for extended CA services, OCSP, CMS. Example 2048
     * @return CA
     * @throws AuthorizationDeniedException if imported CA was signed by a CA user does not have authorization to.
     * @throws CAExistsException if the CA already exists
     * @throws CAOfflineException if CRLs can not be generated because imported CA did not manage to get online
     * @throws CryptoTokenAuthenticationFailedException if authentication to crypto token failed
     * @throws IllegalCryptoTokenException if CA certificate was not self signed, and chain length &gt; 1
     * @throws CryptoTokenOfflineException if crypto token is unavailable.
     *
     */
    private CA importCA(AuthenticationToken admin, String caname, String keystorepass, Certificate[] signatureCertChain, CAToken catoken,
            String keyAlgorithm, String keySpecification) throws CryptoTokenAuthenticationFailedException, CryptoTokenOfflineException,
            IllegalCryptoTokenException, AuthorizationDeniedException, CAExistsException, CAOfflineException {
        // Create a new CA
<span class="nc" id="L2749">        int signedby = CAInfo.SIGNEDBYEXTERNALCA;</span>
<span class="nc" id="L2750">        int certprof = CertificateProfileConstants.CERTPROFILE_FIXED_SUBCA;</span>
<span class="nc" id="L2751">        String description = &quot;Imported external signed CA&quot;;</span>
<span class="nc" id="L2752">        Certificate caSignatureCertificate = signatureCertChain[0];</span>
<span class="nc" id="L2753">        ArrayList&lt;Certificate&gt; certificatechain = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc bnc" id="L2754" title="All 2 branches missed.">        for (int i = 0; i &lt; signatureCertChain.length; i++) {</span>
<span class="nc" id="L2755">            certificatechain.add(signatureCertChain[i]);</span>
        }
<span class="nc bnc" id="L2757" title="All 2 branches missed.">        if (signatureCertChain.length == 1) {</span>
<span class="nc bnc" id="L2758" title="All 2 branches missed.">            if (verifyIssuer(caSignatureCertificate, caSignatureCertificate)) {</span>
<span class="nc" id="L2759">                signedby = CAInfo.SELFSIGNED;</span>
<span class="nc" id="L2760">                certprof = CertificateProfileConstants.CERTPROFILE_FIXED_ROOTCA;</span>
<span class="nc" id="L2761">                description = &quot;Imported root CA&quot;;</span>
            } else {
                // A less strict strategy can be to assume certificate signed
                // by an external CA. Useful if admin user forgot to create a
                // full certificate chain in PKCS#12 package.
<span class="nc" id="L2766">                log.error(&quot;Cannot import CA &quot; + CertTools.getSubjectDN(caSignatureCertificate) + &quot;: certificate &quot;</span>
<span class="nc" id="L2767">                        + CertTools.getSerialNumberAsString(caSignatureCertificate) + &quot; is not self-signed.&quot;);</span>
<span class="nc" id="L2768">                throw new IllegalCryptoTokenException(&quot;Cannot import CA &quot; + CertTools.getSubjectDN(caSignatureCertificate)</span>
                        + &quot;: certificate is not self-signed. Check &quot; + &quot;certificate chain in PKCS#12&quot;);
            }
<span class="nc bnc" id="L2771" title="All 2 branches missed.">        } else if (signatureCertChain.length &gt; 1) {</span>
            // Assuming certificate chain in forward direction (from target
            // to most-trusted CA). Multiple CA chains can contains the
            // issuer certificate; so only the chain where target certificate
            // is the issuer will be selected.
<span class="nc bnc" id="L2776" title="All 2 branches missed.">            for (int caid : caSession.getAllCaIds()) {</span>
<span class="nc" id="L2777">                CAInfo superCaInfo = caSession.getCAInfo(admin, caid);</span>
<span class="nc" id="L2778">                Iterator&lt;Certificate&gt; i = superCaInfo.getCertificateChain().iterator();</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">                if (i.hasNext()) {</span>
<span class="nc" id="L2780">                    Certificate superCaCert = i.next();</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">                    if (verifyIssuer(caSignatureCertificate, superCaCert)) {</span>
<span class="nc" id="L2782">                        signedby = caid;</span>
<span class="nc" id="L2783">                        description = &quot;Imported sub CA&quot;;</span>
<span class="nc" id="L2784">                        break;</span>
                    }
                }
<span class="nc" id="L2787">            }</span>
        }

<span class="nc" id="L2790">        CAInfo cainfo = null;</span>
<span class="nc" id="L2791">        CA ca = null;</span>
        // We set the validity to be what the CA certificate's validity is. Get the number of days the CA certificate is valid
<span class="nc" id="L2793">        int validity = (int) ((CertTools.getNotAfter(caSignatureCertificate).getTime() - CertTools.getNotBefore(caSignatureCertificate).getTime())</span>
                / (24 * 3600 * 1000));
<span class="nc" id="L2795">        String encodedValidity = validity + &quot;d&quot;;</span>
<span class="nc" id="L2796">        List&lt;ExtendedCAServiceInfo&gt; extendedcaservices = new ArrayList&lt;ExtendedCAServiceInfo&gt;();</span>
<span class="nc" id="L2797">        List&lt;Integer&gt; crlpublishers = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">        if (caSignatureCertificate instanceof X509Certificate) {</span>
            // Create an X509CA
            // Create and active extended CA Services (CMS).
            // Create and active CMS CA Service.
<span class="nc" id="L2802">            extendedcaservices.add(new CmsCAServiceInfo(ExtendedCAServiceInfo.STATUS_INACTIVE,</span>
<span class="nc" id="L2803">                    &quot;CN=CMSCertificate, &quot; + CertTools.getSubjectDN(caSignatureCertificate), &quot;&quot;, keySpecification, keyAlgorithm));</span>
<span class="nc" id="L2804">            extendedcaservices.add(new KeyRecoveryCAServiceInfo(ExtendedCAServiceInfo.STATUS_ACTIVE));</span>

<span class="nc" id="L2806">            cainfo = new X509CAInfo(CertTools.getSubjectDN(caSignatureCertificate), caname, CAConstants.CA_ACTIVE, certprof, encodedValidity,</span>
                    signedby, certificatechain, catoken);
<span class="nc" id="L2808">            cainfo.setExpireTime(CertTools.getNotAfter(caSignatureCertificate));</span>
<span class="nc" id="L2809">            cainfo.setDescription(description);</span>
<span class="nc" id="L2810">            cainfo.setCRLPublishers(crlpublishers);</span>
<span class="nc" id="L2811">            cainfo.setExtendedCAServiceInfos(extendedcaservices);</span>
<span class="nc" id="L2812">            cainfo.setApprovals(new HashMap&lt;ApprovalRequestType, Integer&gt;());</span>
<span class="nc" id="L2813">            ca = new X509CA((X509CAInfo) cainfo);</span>
<span class="nc bnc" id="L2814" title="All 2 branches missed.">        } else if (caSignatureCertificate.getType().equals(&quot;CVC&quot;)) {</span>
            // Create a CVC CA
            // Create the CAInfo to be used for either generating the whole CA
            // or making a request
<span class="nc" id="L2818">            cainfo = new CVCCAInfo(CertTools.getSubjectDN(caSignatureCertificate), caname, CAConstants.CA_ACTIVE, certprof, encodedValidity, signedby,</span>
                    certificatechain, catoken);
<span class="nc" id="L2820">            cainfo.setExpireTime(CertTools.getNotAfter(caSignatureCertificate));</span>
<span class="nc" id="L2821">            cainfo.setDescription(description);</span>
<span class="nc" id="L2822">            cainfo.setCRLPublishers(crlpublishers);</span>
<span class="nc" id="L2823">            cainfo.setExtendedCAServiceInfos(extendedcaservices);</span>
<span class="nc" id="L2824">            cainfo.setApprovals(new HashMap&lt;ApprovalRequestType, Integer&gt;());</span>
<span class="nc" id="L2825">            ca = CvcCA.getInstance((CVCCAInfo) cainfo);</span>
        }
        // We must activate the token, in case it does not have the default password
<span class="nc" id="L2828">        final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(catoken.getCryptoTokenId());</span>
<span class="nc" id="L2829">        cryptoToken.activate(keystorepass.toCharArray());</span>
        try {
<span class="nc" id="L2831">            ca.setCAToken(catoken);</span>
<span class="nc" id="L2832">        } catch (InvalidAlgorithmException e) {</span>
<span class="nc" id="L2833">            throw new IllegalCryptoTokenException(e);</span>
<span class="nc" id="L2834">        }</span>
<span class="nc" id="L2835">        ca.setCertificateChain(certificatechain);</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L2837">            log.debug(&quot;CA-Info: &quot; + catoken.getSignatureAlgorithm() + &quot; &quot; + ca.getCAToken().getEncryptionAlgorithm());</span>
        }
        // Publish CA certificates.
<span class="nc" id="L2840">        publishCACertificate(admin, ca.getCertificateChain(), ca.getCRLPublishers(), ca.getSubjectDN());</span>
        // activate External CA Services
<span class="nc" id="L2842">        activateAndPublishExternalCAServices(admin, cainfo.getExtendedCAServiceInfos(), ca);</span>
        // Store CA in database.
<span class="nc" id="L2844">        caSession.addCA(admin, ca);</span>

        // Create initial CRLs
        try {
<span class="nc" id="L2848">            publishingCrlSession.forceCRL(admin, ca.getCAId());</span>
<span class="nc" id="L2849">            publishingCrlSession.forceDeltaCRL(admin, ca.getCAId());</span>
<span class="nc" id="L2850">        } catch (CADoesntExistsException e) {</span>
<span class="nc" id="L2851">            throw new IllegalStateException(&quot;Newly created CA with ID: &quot; + ca.getCAId() + &quot; was not found in database.&quot;);</span>
<span class="nc" id="L2852">        }</span>

<span class="nc" id="L2854">        return ca;</span>
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public byte[] exportCAKeyStore(AuthenticationToken admin, String caname, String keystorepass, String privkeypass, String privateSignatureKeyAlias,
            String privateEncryptionKeyAlias) {
<span class="nc" id="L2861">        log.trace(&quot;&gt;exportCAKeyStore&quot;);</span>
        try {
<span class="nc" id="L2863">            final CA thisCa = caSession.getCAForEdit(admin, caname);</span>
            // Make sure we are not trying to export a hard or invalid token
<span class="nc" id="L2865">            CAToken thisCAToken = thisCa.getCAToken();</span>
<span class="nc" id="L2866">            final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(thisCAToken.getCryptoTokenId());</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">            if (!(cryptoToken instanceof SoftCryptoToken)) {</span>
<span class="nc" id="L2868">                throw new IllegalCryptoTokenException(&quot;Cannot export anything but a soft token.&quot;);</span>
            }
            // Do not allow export without password protection
<span class="nc bnc" id="L2871" title="All 4 branches missed.">            if (StringUtils.isEmpty(keystorepass) || StringUtils.isEmpty(privkeypass)) {</span>
<span class="nc" id="L2872">                throw new IllegalArgumentException(&quot;Cannot export a token without password protection.&quot;);</span>
            }
            // Check authorization
<span class="nc bnc" id="L2875" title="All 2 branches missed.">            if (!authorizationSession.isAuthorizedNoLogging(admin, StandardRules.ROLE_ROOT.resource())) {</span>
<span class="nc" id="L2876">                String msg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtoexportcatoken&quot;, caname);</span>
<span class="nc" id="L2877">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L2878">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L2879">                auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2880">                        String.valueOf(thisCa.getCAId()), null, null, details);</span>
<span class="nc" id="L2881">                throw new AuthorizationDeniedException(msg);</span>
            }
            // Fetch keys
<span class="nc" id="L2884">            final char[] password = keystorepass.toCharArray();</span>
<span class="nc" id="L2885">            ((SoftCryptoToken) cryptoToken).checkPasswordBeforeExport(password);</span>
<span class="nc" id="L2886">            cryptoToken.activate(password);</span>

<span class="nc" id="L2888">            PrivateKey p12PrivateEncryptionKey = cryptoToken.getPrivateKey(thisCAToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_KEYENCRYPT));</span>
<span class="nc" id="L2889">            PublicKey p12PublicEncryptionKey = cryptoToken.getPublicKey(thisCAToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_KEYENCRYPT));</span>
<span class="nc" id="L2890">            PrivateKey p12PrivateCertSignKey = cryptoToken.getPrivateKey(thisCAToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CERTSIGN));</span>
<span class="nc" id="L2891">            PrivateKey p12PrivateCRLSignKey = cryptoToken.getPrivateKey(thisCAToken.getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_CRLSIGN));</span>
<span class="nc bnc" id="L2892" title="All 2 branches missed.">            if (!p12PrivateCertSignKey.equals(p12PrivateCRLSignKey)) {</span>
<span class="nc" id="L2893">                throw new Exception(&quot;Assertion of equal signature keys failed.&quot;);</span>
            }
            // Proceed with the export
<span class="nc" id="L2896">            byte[] ret = null;</span>
<span class="nc" id="L2897">            String format = null;</span>
<span class="nc bnc" id="L2898" title="All 2 branches missed.">            if (thisCa.getCAType() == CAInfo.CATYPE_CVC) {</span>
<span class="nc" id="L2899">                log.debug(&quot;Exporting private key with algorithm: &quot; + p12PrivateCertSignKey.getAlgorithm() + &quot; of format: &quot;</span>
<span class="nc" id="L2900">                        + p12PrivateCertSignKey.getFormat());</span>
<span class="nc" id="L2901">                format = p12PrivateCertSignKey.getFormat();</span>
<span class="nc" id="L2902">                ret = p12PrivateCertSignKey.getEncoded();</span>
            } else {
<span class="nc" id="L2904">                log.debug(&quot;Exporting PKCS12 keystore&quot;);</span>
<span class="nc" id="L2905">                format = &quot;PKCS12&quot;;</span>
<span class="nc" id="L2906">                KeyStore keystore = KeyStore.getInstance(&quot;PKCS12&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L2907">                keystore.load(null, keystorepass.toCharArray());</span>
                // Load keys into keystore
<span class="nc" id="L2909">                Certificate[] certificateChainSignature = thisCa.getCertificateChain().toArray(new Certificate[0]);</span>
<span class="nc" id="L2910">                Certificate[] certificateChainEncryption = new Certificate[1];</span>
                // certificateChainSignature[0].getSigAlgName(),
                // generate dummy certificate for encryption key.
<span class="nc" id="L2913">                certificateChainEncryption[0] = CertTools.genSelfCertForPurpose(&quot;CN=EncryptionKeyHolder&quot;, 36500, null, p12PrivateEncryptionKey,</span>
<span class="nc" id="L2914">                        p12PublicEncryptionKey, thisCAToken.getEncryptionAlgorithm(), true, X509KeyUsage.keyEncipherment, true);</span>
<span class="nc" id="L2915">                log.debug(&quot;Exporting with sigAlgorithm &quot; + AlgorithmTools.getSignatureAlgorithm(certificateChainSignature[0]) + &quot;encAlgorithm=&quot;</span>
<span class="nc" id="L2916">                        + thisCAToken.getEncryptionAlgorithm());</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">                if (keystore.isKeyEntry(privateSignatureKeyAlias)) {</span>
<span class="nc" id="L2918">                    throw new Exception(&quot;Key \&quot;&quot; + privateSignatureKeyAlias + &quot;\&quot;already exists in keystore.&quot;);</span>
                }
<span class="nc bnc" id="L2920" title="All 2 branches missed.">                if (keystore.isKeyEntry(privateEncryptionKeyAlias)) {</span>
<span class="nc" id="L2921">                    throw new Exception(&quot;Key \&quot;&quot; + privateEncryptionKeyAlias + &quot;\&quot;already exists in keystore.&quot;);</span>
                }

<span class="nc" id="L2924">                keystore.setKeyEntry(privateSignatureKeyAlias, p12PrivateCertSignKey, privkeypass.toCharArray(), certificateChainSignature);</span>
<span class="nc" id="L2925">                keystore.setKeyEntry(privateEncryptionKeyAlias, p12PrivateEncryptionKey, privkeypass.toCharArray(), certificateChainEncryption);</span>
                // Return KeyStore as byte array and clean up
<span class="nc" id="L2927">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L2928">                keystore.store(baos, keystorepass.toCharArray());</span>
<span class="nc bnc" id="L2929" title="All 2 branches missed.">                if (keystore.isKeyEntry(privateSignatureKeyAlias)) {</span>
<span class="nc" id="L2930">                    keystore.deleteEntry(privateSignatureKeyAlias);</span>
                }
<span class="nc bnc" id="L2932" title="All 2 branches missed.">                if (keystore.isKeyEntry(privateEncryptionKeyAlias)) {</span>
<span class="nc" id="L2933">                    keystore.deleteEntry(privateEncryptionKeyAlias);</span>
                }
<span class="nc" id="L2935">                ret = baos.toByteArray();</span>
            }
<span class="nc" id="L2937">            String msg = intres.getLocalizedMessage(&quot;caadmin.exportedca&quot;, caname, format);</span>
<span class="nc" id="L2938">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L2939">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L2940">            auditSession.log(EjbcaEventTypes.CA_EXPORTTOKEN, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2941">                    String.valueOf(thisCa.getCAId()), null, null, details);</span>
<span class="nc" id="L2942">            log.trace(&quot;&lt;exportCAKeyStore&quot;);</span>
<span class="nc" id="L2943">            return ret;</span>
<span class="nc" id="L2944">        } catch (Exception e) {</span>
<span class="nc" id="L2945">            String msg = intres.getLocalizedMessage(&quot;caadmin.errorexportca&quot;, caname, &quot;PKCS12&quot;, e.getMessage());</span>
<span class="nc" id="L2946">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L2947">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L2948">            auditSession.log(EjbcaEventTypes.CA_EXPORTTOKEN, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(), null, null,</span>
                    null, details);
<span class="nc" id="L2950">            throw new EJBException(e);</span>
        }
    }

    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    @Override
    public Collection&lt;Certificate&gt; getAllCACertificates() {
<span class="nc" id="L2957">        final ArrayList&lt;Certificate&gt; returnval = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc bnc" id="L2958" title="All 2 branches missed.">        for (final Integer caid : caSession.getAllCaIds()) {</span>
<span class="nc" id="L2959">            final CAInfo caInfo = caSession.getCAInfoInternal(caid.intValue(), null, true);</span>
<span class="nc bnc" id="L2960" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L2961">                log.debug(&quot;Getting certificate chain for CA: &quot; + caInfo.getName() + &quot;, &quot; + caInfo.getCAId());</span>
            }
<span class="nc" id="L2963">            final Certificate caCertificate = caInfo.getCertificateChain().iterator().next();</span>
<span class="nc" id="L2964">            returnval.add(caCertificate);</span>

<span class="nc" id="L2966">        }</span>
<span class="nc" id="L2967">        return returnval;</span>
    }

    @Override
    public void activateCAService(AuthenticationToken admin, int caid)
            throws AuthorizationDeniedException, ApprovalException, WaitingForApprovalException, CADoesntExistsException {
        // Authorize
<span class="nc bnc" id="L2974" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(admin, AccessRulesConstants.REGULAR_ACTIVATECA)) {</span>
<span class="nc" id="L2975">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtoactivatetoken&quot;, Integer.valueOf(caid));</span>
<span class="nc" id="L2976">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2977">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2978">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
        // Get CA also check authorization for this specific CA
<span class="nc" id="L2981">        final CAInfo cainfo = caSession.getCAInfo(admin, caid);</span>
<span class="nc bnc" id="L2982" title="All 2 branches missed.">        if (cainfo.getStatus() == CAConstants.CA_EXTERNAL) {</span>
<span class="nc" id="L2983">            log.info(intres.getLocalizedMessage(&quot;caadmin.catokenexternal&quot;, Integer.valueOf(caid)));</span>
<span class="nc" id="L2984">            return;</span>
        }
<span class="nc" id="L2986">        final CertificateProfile certProfile = certificateProfileSession.getCertificateProfile(cainfo.getCertificateProfileId());</span>
<span class="nc" id="L2987">        ApprovalProfile approvalProfile = approvalProfileSession.getApprovalProfileForAction(ApprovalRequestType.ACTIVATECA, cainfo, certProfile);</span>
<span class="nc" id="L2988">        final ActivateCATokenApprovalRequest ar = new ActivateCATokenApprovalRequest(cainfo.getName(), &quot;&quot;, admin, caid,</span>
<span class="nc" id="L2989">                ApprovalDataVO.ANY_ENDENTITYPROFILE, approvalProfile, cainfo.getCertificateProfileId());</span>
<span class="nc bnc" id="L2990" title="All 2 branches missed.">        if (ApprovalExecutorUtil.requireApproval(ar, NONAPPROVABLECLASSNAMES_ACTIVATECATOKEN)) {</span>
<span class="nc" id="L2991">            int requestId = approvalSession.addApprovalRequest(admin, ar);</span>
<span class="nc" id="L2992">            throw new WaitingForApprovalException(intres.getLocalizedMessage(&quot;ra.approvalcaactivation&quot;), requestId);</span>
        }
<span class="nc bnc" id="L2994" title="All 2 branches missed.">        if (cainfo.getStatus() == CAConstants.CA_OFFLINE) {</span>
<span class="nc" id="L2995">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.activated&quot;, caid);</span>
<span class="nc" id="L2996">            auditSession.log(EventTypes.CA_SERVICEACTIVATE, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L2997">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L2998">            CA ca = caSession.getCAForEdit(admin, caid);</span>
<span class="nc" id="L2999">            ca.setStatus(CAConstants.CA_ACTIVE);</span>
<span class="nc" id="L3000">            caSession.editCA(admin, ca, false);</span>
<span class="nc" id="L3001">        } else {</span>
<span class="nc" id="L3002">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errornotoffline&quot;, cainfo.getName());</span>
<span class="nc" id="L3003">            auditSession.log(EventTypes.CA_SERVICEACTIVATE, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L3004">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L3005">            throw new RuntimeException(detailsMsg);</span>
        }
<span class="nc" id="L3007">    }</span>

<span class="nc" id="L3009">    private static final ApprovalOveradableClassName[] NONAPPROVABLECLASSNAMES_ACTIVATECATOKEN = {</span>
<span class="nc" id="L3010">            new ApprovalOveradableClassName(org.ejbca.core.model.approval.approvalrequests.ActivateCATokenApprovalRequest.class.getName(), null), };</span>

    @Override
    public void deactivateCAService(AuthenticationToken admin, int caid) throws AuthorizationDeniedException, CADoesntExistsException {
        // Authorize
<span class="nc bnc" id="L3015" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(admin, AccessRulesConstants.REGULAR_ACTIVATECA)) {</span>
<span class="nc" id="L3016">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.notauthorizedtodeactivatetoken&quot;,</span>
<span class="nc" id="L3017">                    caSession.getCAInfoInternal(caid).getName());</span>
<span class="nc" id="L3018">            auditSession.log(EventTypes.ACCESS_CONTROL, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L3019">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L3020">            throw new AuthorizationDeniedException(detailsMsg);</span>
        }
<span class="nc" id="L3022">        final CA ca = caSession.getCAForEdit(admin, caid);</span>
<span class="nc bnc" id="L3023" title="All 2 branches missed.">        if (ca.getStatus() == CAConstants.CA_ACTIVE) {</span>
<span class="nc" id="L3024">            ca.setStatus(CAConstants.CA_OFFLINE);</span>
<span class="nc" id="L3025">            caSession.editCA(admin, ca, false);</span>
<span class="nc" id="L3026">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.deactivated&quot;, caid);</span>
<span class="nc" id="L3027">            auditSession.log(EventTypes.CA_SERVICEDEACTIVATE, EventStatus.SUCCESS, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L3028">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L3029">        } else {</span>
<span class="nc" id="L3030">            final String detailsMsg = intres.getLocalizedMessage(&quot;caadmin.errornotonline&quot;, ca.getName());</span>
<span class="nc" id="L3031">            auditSession.log(EventTypes.CA_SERVICEDEACTIVATE, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L3032">                    String.valueOf(caid), null, null, detailsMsg);</span>
<span class="nc" id="L3033">            throw new RuntimeException(detailsMsg);</span>

        }
<span class="nc" id="L3036">    }</span>

    /** Method used to check if certificate profile id exists in any CA. */
    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public List&lt;String&gt; getCAsUsingCertificateProfile(final int certificateprofileid) {
<span class="nc" id="L3042">        List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L3043" title="All 2 branches missed.">        for (final Integer caid : caSession.getAllCaIds()) {</span>
<span class="nc" id="L3044">            final CAInfo caInfo = caSession.getCAInfoInternal(caid.intValue(), null, true);</span>
<span class="nc bnc" id="L3045" title="All 2 branches missed.">            if (caInfo.getCertificateProfileId() == certificateprofileid) {</span>
<span class="nc" id="L3046">                result.add(caInfo.getName());</span>
            }
<span class="nc" id="L3048">        }</span>
<span class="nc" id="L3049">        return result;</span>
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public boolean exitsPublisherInCAs(int publisherid) {
<span class="nc bnc" id="L3055" title="All 2 branches missed.">        for (final Integer caid : caSession.getAllCaIds()) {</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">            for (final Integer pubInt : caSession.getCAInfoInternal(caid).getCRLPublishers()) {</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">                if (pubInt.intValue() == publisherid) {</span>
                    // We have found a match. No point in looking for more..
<span class="nc" id="L3059">                    return true;</span>
                }
<span class="nc" id="L3061">            }</span>
<span class="nc" id="L3062">        }</span>
<span class="nc" id="L3063">        return false;</span>
    }

    @Override
    public void publishCACertificate(AuthenticationToken admin, Collection&lt;Certificate&gt; certificatechain, Collection&lt;Integer&gt; usedpublishers,
            String caDataDN) throws AuthorizationDeniedException {
<span class="nc" id="L3069">        publishCACertificate(admin, certificatechain, usedpublishers, caDataDN, false);</span>
<span class="nc" id="L3070">    }</span>

    private void publishCACertificate(AuthenticationToken admin, Collection&lt;Certificate&gt; certificatechain, Collection&lt;Integer&gt; usedpublishers,
            String caDataDN, boolean futureRollover) throws AuthorizationDeniedException {

<span class="nc" id="L3075">        Object[] certs = certificatechain.toArray();</span>
<span class="nc bnc" id="L3076" title="All 2 branches missed.">        for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="nc" id="L3077">            Certificate cert = (Certificate) certs[i];</span>
<span class="nc" id="L3078">            String fingerprint = CertTools.getFingerprintAsString(cert);</span>
            // CA fingerprint, figure out the value if this is not a root CA
<span class="nc" id="L3080">            String cafp = fingerprint;</span>
            // Calculate the certificate type
<span class="nc" id="L3082">            boolean isSelfSigned = CertTools.isSelfSigned(cert);</span>
<span class="nc" id="L3083">            int type = CertificateConstants.CERTTYPE_ENDENTITY;</span>
<span class="nc bnc" id="L3084" title="All 2 branches missed.">            if (CertTools.isCA(cert)) {</span>
                // this is a CA
<span class="nc bnc" id="L3086" title="All 2 branches missed.">                if (isSelfSigned) {</span>
<span class="nc" id="L3087">                    type = CertificateConstants.CERTTYPE_ROOTCA;</span>
                } else {
<span class="nc" id="L3089">                    type = CertificateConstants.CERTTYPE_SUBCA;</span>
                    // If not a root CA, the next certificate in the chain
                    // should be the CA of this CA
<span class="nc bnc" id="L3092" title="All 2 branches missed.">                    if ((i + 1) &lt; certs.length) {</span>
<span class="nc" id="L3093">                        Certificate cacert = (Certificate) certs[i + 1];</span>
<span class="nc" id="L3094">                        cafp = CertTools.getFingerprintAsString(cacert);</span>
<span class="nc" id="L3095">                    } else {</span>
                        // We don't have a chain provided, try to find the CA certificate, assuming that we do not have this certificate in the database
<span class="nc" id="L3097">                        List&lt;Certificate&gt; cacerts = certificateStoreSession.findCertificatesBySubject(CertTools.getIssuerDN(cert));</span>
<span class="nc bnc" id="L3098" title="All 4 branches missed.">                        if (cacerts != null &amp;&amp; cacerts.size() &gt; 0) {</span>
<span class="nc bnc" id="L3099" title="All 2 branches missed.">                            for (Certificate cacert : cacerts) {</span>
                                try {
<span class="nc" id="L3101">                                    cert.verify(cacert.getPublicKey());</span>
                                    // If we can verify, it was the correct CA cert
<span class="nc" id="L3103">                                    cafp = CertTools.getFingerprintAsString(cacert); </span>
<span class="nc" id="L3104">                                    break;</span>
<span class="nc" id="L3105">                                } catch (InvalidKeyException | CertificateException | NoSuchAlgorithmException | NoSuchProviderException</span>
                                        | SignatureException e) {
<span class="nc" id="L3107">                                    log.debug(&quot;CA cert could not verify the certificate to import: &quot;+CertTools.getSubjectDN(cacert));</span>
                                }
<span class="nc" id="L3109">                            }</span>
                        }
<span class="nc" id="L3111">                    }</span>
                }
<span class="nc bnc" id="L3113" title="All 2 branches missed.">            } else if (isSelfSigned) {</span>
                // If we don't have basic constraints, but is self signed,
                // we are still a CA, just a stupid CA
<span class="nc" id="L3116">                type = CertificateConstants.CERTTYPE_ROOTCA;</span>
            } else {
                // If and end entity, the next certificate in the chain
                // should be the CA of this end entity
<span class="nc bnc" id="L3120" title="All 2 branches missed.">                if ((i + 1) &lt; certs.length) {</span>
<span class="nc" id="L3121">                    Certificate cacert = (Certificate) certs[i + 1];</span>
<span class="nc" id="L3122">                    cafp = CertTools.getFingerprintAsString(cacert);</span>
                }
            }

<span class="nc" id="L3126">            String name = &quot;SYSTEMCERT&quot;;</span>
<span class="nc bnc" id="L3127" title="All 2 branches missed.">            if (type != CertificateConstants.CERTTYPE_ENDENTITY) {</span>
<span class="nc" id="L3128">                name = &quot;SYSTEMCA&quot;;</span>
            }
            // Store CA certificate in the database if it does not exist
<span class="nc" id="L3131">            CertificateDataWrapper certificateDataWrapper = certificateStoreSession.getCertificateData(fingerprint);</span>
<span class="nc bnc" id="L3132" title="All 2 branches missed.">            if (certificateDataWrapper == null) {</span>
                // If we don't have it in the database, store it
<span class="nc" id="L3134">                long updateTime = System.currentTimeMillis();</span>
<span class="nc" id="L3135">                certificateDataWrapper = certificateStoreSession.storeCertificate(admin, cert, name, cafp,</span>
<span class="nc bnc" id="L3136" title="All 2 branches missed.">                        futureRollover ? CertificateConstants.CERT_ROLLOVERPENDING : CertificateConstants.CERT_ACTIVE, type,</span>
                        CertificateProfileConstants.NO_CERTIFICATE_PROFILE, EndEntityConstants.NO_END_ENTITY_PROFILE, null, updateTime);
<span class="nc" id="L3138">                certificateStoreSession.reloadCaCertificateCache();</span>
            }
<span class="nc bnc" id="L3140" title="All 2 branches missed.">            if (usedpublishers != null) {</span>
<span class="nc" id="L3141">                publisherSession.storeCertificate(admin, usedpublishers, certificateDataWrapper, null, caDataDN, null);</span>
            }
        }

<span class="nc" id="L3145">    }</span>

    @Override
    public void publishCRL(AuthenticationToken admin, Certificate caCert, Collection&lt;Integer&gt; usedpublishers, String caDataDN,
            boolean doPublishDeltaCRL) throws AuthorizationDeniedException {
<span class="nc bnc" id="L3150" title="All 2 branches missed.">        if (usedpublishers == null) {</span>
<span class="nc" id="L3151">            return;</span>
        }
        // Store crl in ca CRL publishers.
<span class="nc bnc" id="L3154" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L3155">            log.debug(&quot;Storing CRL in publishers&quot;);</span>
        }
<span class="nc" id="L3157">        final String issuerDN = CertTools.getSubjectDN(caCert);</span>
<span class="nc" id="L3158">        final String caCertFingerprint = CertTools.getFingerprintAsString(caCert);</span>
<span class="nc" id="L3159">        final byte crl[] = crlStoreSession.getLastCRL(issuerDN, false);</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">        if (crl != null) {</span>
<span class="nc" id="L3161">            final int nr = crlStoreSession.getLastCRLInfo(issuerDN, false).getLastCRLNumber();</span>
<span class="nc" id="L3162">            publisherSession.storeCRL(admin, usedpublishers, crl, caCertFingerprint, nr, caDataDN);</span>
        }
<span class="nc bnc" id="L3164" title="All 2 branches missed.">        if (!doPublishDeltaCRL) {</span>
<span class="nc" id="L3165">            return;</span>
        }
<span class="nc" id="L3167">        final byte deltaCrl[] = crlStoreSession.getLastCRL(issuerDN, true);</span>
<span class="nc bnc" id="L3168" title="All 2 branches missed.">        if (deltaCrl != null) {</span>
<span class="nc" id="L3169">            final int nr = crlStoreSession.getLastCRLInfo(issuerDN, true).getLastCRLNumber();</span>
<span class="nc" id="L3170">            publisherSession.storeCRL(admin, usedpublishers, deltaCrl, caCertFingerprint, nr, caDataDN);</span>
        }
<span class="nc" id="L3172">    }</span>

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public Set&lt;Integer&gt; getAuthorizedPublisherIds(AuthenticationToken admin, List&lt;Integer&gt; excludedTypes) {

        // Set to use to track all authorized publisher IDs
<span class="nc" id="L3179">        final Set&lt;Integer&gt; result = new HashSet&lt;Integer&gt;();</span>
        // Find all publishers, use this set to track unowned publishers
<span class="nc" id="L3181">        final Map&lt;Integer, BasePublisher&gt; allPublishers = publisherSession.getAllPublishers();</span>

        //Firstly, weed out all publishers which we lack authorization to
<span class="nc bnc" id="L3184" title="All 2 branches missed.">        for (Integer key : new HashSet&lt;Integer&gt;(allPublishers.keySet())) {</span>
<span class="nc" id="L3185">            BasePublisher publisher = allPublishers.get(key);</span>
<span class="nc bnc" id="L3186" title="All 2 branches missed.">            if (publisher instanceof CustomPublisherContainer) {</span>
<span class="nc" id="L3187">                final CustomPublisherContainer custompublisherdata = ((CustomPublisherContainer) publisher);</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">                if (custompublisherdata.isCustomAccessRulesSupported()) {</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">                    if (!custompublisherdata.isAuthorizedToPublisher(admin)) {</span>
<span class="nc" id="L3190">                        allPublishers.remove(key);</span>
                    }
                }
            }
<span class="nc" id="L3194">        }</span>

        //remove publishers of excluded types
<span class="nc bnc" id="L3197" title="All 2 branches missed.">        for (Integer key : new HashSet&lt;Integer&gt;(allPublishers.keySet())) {</span>
<span class="nc" id="L3198">            BasePublisher publisher = allPublishers.get(key);</span>
<span class="nc bnc" id="L3199" title="All 2 branches missed.">            if (excludedTypes.contains(publisher.getType())) {</span>
<span class="nc" id="L3200">                allPublishers.remove(key);</span>
            }
<span class="nc" id="L3202">        }</span>

        //Secondly, find all CAs
<span class="nc bnc" id="L3205" title="All 2 branches missed.">        for (final int caId : caSession.getAllCaIds()) {</span>
<span class="nc" id="L3206">            CAInfo cainfo = caSession.getCAInfoInternal(caId);</span>
<span class="nc bnc" id="L3207" title="All 2 branches missed.">            if (cainfo != null) {</span>
<span class="nc" id="L3208">                Collection&lt;Integer&gt; crlPublishers = cainfo.getCRLPublishers();</span>
<span class="nc bnc" id="L3209" title="All 2 branches missed.">                if (crlPublishers != null) {</span>
<span class="nc" id="L3210">                    final boolean authorizedtoca = caSession.authorizedToCANoLogging(admin, caId);</span>
                    // TODO: Logically getCRLPublishers() should return an empty list if empty, but that's a change for another day
<span class="nc bnc" id="L3212" title="All 2 branches missed.">                    for (Integer caPublisherId : crlPublishers) {</span>
                        //This publisher is owned by a CA
<span class="nc" id="L3214">                        allPublishers.remove(caPublisherId);</span>
                        // We don't need to log this access (to CA) since it only decides which publishers to display
<span class="nc bnc" id="L3216" title="All 2 branches missed.">                        if (authorizedtoca) {</span>
                            //Admin has access to the CA, so return it as a result.
<span class="nc" id="L3218">                            result.add(caPublisherId);</span>
                        }
<span class="nc" id="L3220">                    }</span>
                }
            }
<span class="nc" id="L3223">        }</span>
        //Any remaining publishers must be unowned, so add them in as well.
<span class="nc" id="L3225">        result.addAll(allPublishers.keySet());</span>
<span class="nc" id="L3226">        return result;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
	@Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public Set&lt;Integer&gt; getAuthorizedPublisherIds(final AuthenticationToken admin) {
<span class="nc" id="L3233">        return getAuthorizedPublisherIds(admin, Collections.EMPTY_LIST);</span>
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public Set&lt;Integer&gt; getAuthorizedKeyValidatorIds(final AuthenticationToken admin) {
        // Find all key validators, use this set to track not owned key validators.
<span class="nc" id="L3240">        final Map&lt;Integer, Validator&gt; keyValidators = keyValidatorSession.getAllKeyValidators();</span>
        //Firstly, weed out all key validators which we lack authorization to.
        // Set to use to track all authorized key validator IDs
<span class="nc" id="L3243">        final Set&lt;Integer&gt; result = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L3244" title="All 2 branches missed.">        for (final int caId : caSession.getAllCaIds()) {</span>
<span class="nc" id="L3245">            final Collection&lt;Integer&gt; caKeyValidatorIds = caSession.getCAInfoInternal(caId).getValidators();</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">            if (caKeyValidatorIds != null) {</span>
<span class="nc" id="L3247">                final boolean isAuthorizedToCa = caSession.authorizedToCANoLogging(admin, caId);</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">                for (Integer id : caKeyValidatorIds) {</span>
<span class="nc" id="L3249">                    keyValidators.remove(id);</span>
                    // We don't need to log this access (to CA) since it only decides which publishers to display
<span class="nc bnc" id="L3251" title="All 2 branches missed.">                    if (isAuthorizedToCa) {</span>
                        //Admin has access to the CA, so return it as a result.
<span class="nc" id="L3253">                        result.add(id);</span>
                    }
<span class="nc" id="L3255">                }</span>
            }
<span class="nc" id="L3257">        }</span>

        //Any remaining key validators must not be owned, so add them in as well.
<span class="nc" id="L3260">        result.addAll(keyValidators.keySet());</span>
<span class="nc" id="L3261">        return result;</span>
    }

    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    @Override
    public String healthCheck() {
<span class="nc" id="L3267">        final StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L3268">        final boolean caTokenSignTest = EjbcaConfiguration.getHealthCheckCaTokenSignTest();</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L3270">            log.debug(&quot;CaTokenSignTest: &quot; + caTokenSignTest);</span>
        }
<span class="nc" id="L3272">        final HashMap&lt;Integer, CryptoToken&gt; cryptoTokenMap = new HashMap&lt;Integer, CryptoToken&gt;();</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">        for (final Integer caid : caSession.getAllCaIds()) {</span>
<span class="nc" id="L3274">            final CAInfo cainfo = caSession.getCAInfoInternal(caid.intValue());</span>
<span class="nc bnc" id="L3275" title="All 4 branches missed.">            if (cainfo.getStatus() == CAConstants.CA_ACTIVE &amp;&amp; cainfo.getIncludeInHealthCheck()) {</span>
                // Verify that the CA's mapped keys exist and optionally that the test-key is usable
<span class="nc" id="L3277">                final int cryptoTokenId = cainfo.getCAToken().getCryptoTokenId();</span>
<span class="nc" id="L3278">                CryptoToken cryptoToken = cryptoTokenMap.get(Integer.valueOf(cryptoTokenId));</span>
<span class="nc bnc" id="L3279" title="All 2 branches missed.">                if (cryptoToken == null) {</span>
<span class="nc" id="L3280">                    cryptoToken = cryptoTokenSession.getCryptoToken(cryptoTokenId);</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">                    if (cryptoToken != null) {</span>
                        // Cache crypto token lookup locally since multiple CA might use the same and milliseconds count here
<span class="nc" id="L3283">                        cryptoTokenMap.put(Integer.valueOf(cryptoTokenId), cryptoToken);</span>
                    }
                }
<span class="nc" id="L3286">                final int tokenstatus = cainfo.getCAToken().getTokenStatus(caTokenSignTest, cryptoToken);</span>
<span class="nc bnc" id="L3287" title="All 2 branches missed.">                if (tokenstatus == CryptoToken.STATUS_OFFLINE) {</span>
<span class="nc" id="L3288">                    sb.append(&quot;\nCA: Error CA Token is disconnected, CA Name : &quot;).append(cainfo.getName());</span>
<span class="nc" id="L3289">                    log.error(&quot;Error CA Token is disconnected, CA Name : &quot; + cainfo.getName());</span>
                }
            }
<span class="nc" id="L3292">        }</span>
<span class="nc" id="L3293">        return sb.toString();</span>
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public ExtendedCAServiceResponse extendedService(AuthenticationToken admin, int caid, ExtendedCAServiceRequest request)
            throws ExtendedCAServiceRequestException, IllegalExtendedCAServiceRequestException, ExtendedCAServiceNotActiveException,
            CADoesntExistsException, AuthorizationDeniedException, CertificateEncodingException, CertificateException, OperatorCreationException {
        // Get CA that will process request
<span class="nc" id="L3302">        final CA ca = caSession.getCA(admin, caid);</span>
<span class="nc bnc" id="L3303" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L3304">            log.debug(&quot;Extended service with request class '&quot; + request.getClass().getName() + &quot;' called for CA '&quot; + ca.getName() + &quot;'&quot;);</span>
        }
        // We do not yet support using a separate crypto token for key recovery, although we have it stored in the key recovery entry
        // so everything is prepared for this possibility.
<span class="nc" id="L3308">        final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(ca.getCAToken().getCryptoTokenId());</span>
<span class="nc" id="L3309">        final ExtendedCAServiceResponse resp = ca.extendedService(cryptoToken, request);</span>
<span class="nc" id="L3310">        final String msg = intres.getLocalizedMessage(&quot;caadmin.extendedserviceexecuted&quot;, request.getClass().getName(), ca.getName());</span>
<span class="nc" id="L3311">        final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L3312">        details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L3313">        auditSession.log(EjbcaEventTypes.CA_EXTENDEDSERVICE, EventStatus.SUCCESS, ModuleTypes.CA, EjbcaServiceTypes.EJBCA, admin.toString(),</span>
<span class="nc" id="L3314">                String.valueOf(caid), null, null, details);</span>
<span class="nc" id="L3315">        return resp;</span>
    }

    //
    // Private methods
    //

    /**
     * Check if subject certificate is signed by issuer certificate. 
     *		 This method does a lazy check: if signature verification failed
     *      for any reason that prevent verification, e.g. signature algorithm not supported, method returns false. Author: Marco Ferrante
     *
     * @param subject Subject certificate
     * @param issuer Issuer certificate
     * @return true if subject certificate is signed by issuer certificate
     */
    private boolean verifyIssuer(Certificate subject, Certificate issuer) {
        try {
<span class="nc" id="L3333">            PublicKey issuerKey = issuer.getPublicKey();</span>
<span class="nc" id="L3334">            subject.verify(issuerKey);</span>
<span class="nc" id="L3335">            return true;</span>
<span class="nc" id="L3336">        } catch (java.security.GeneralSecurityException e) {</span>
<span class="nc" id="L3337">            return false;</span>
        }
    }

    /**
     * Checks the signer validity given a CA object and throws an EJBException to the caller.
     * This should only be called from create and edit CA methods.
     *
     * @param admin administrator calling the method
     * @param signca a CA object of the signer to be checked
     * @throws EJBException embedding a CertificateExpiredException or a CertificateNotYetValidException if the certificate has expired or is not yet
     *             valid
     */
    private void assertSignerValidity(AuthenticationToken admin, CA signca) {
        // Check validity of signers certificate
<span class="nc" id="L3352">        final Certificate signcert = signca.getCACertificate();</span>
        try {
<span class="nc" id="L3354">            CertTools.checkValidity(signcert, new Date());</span>
<span class="nc" id="L3355">        } catch (CertificateExpiredException ce) {</span>
            // Signers Certificate has expired.
<span class="nc" id="L3357">            String msg = intres.getLocalizedMessage(&quot;signsession.caexpired&quot;, signca.getSubjectDN());</span>
<span class="nc" id="L3358">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L3359">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L3360">            auditSession.log(EjbcaEventTypes.CA_VALIDITY, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L3361">                    String.valueOf(signca.getCAId()), null, null, details);</span>
<span class="nc" id="L3362">            throw new EJBException(ce);</span>
<span class="nc" id="L3363">        } catch (CertificateNotYetValidException cve) {</span>
<span class="nc" id="L3364">            String msg = intres.getLocalizedMessage(&quot;signsession.canotyetvalid&quot;, signca.getSubjectDN());</span>
<span class="nc" id="L3365">            Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L3366">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L3367">            auditSession.log(EjbcaEventTypes.CA_VALIDITY, EventStatus.FAILURE, ModuleTypes.CA, ServiceTypes.CORE, admin.toString(),</span>
<span class="nc" id="L3368">                    String.valueOf(signca.getCAId()), null, null, details);</span>
<span class="nc" id="L3369">            throw new EJBException(cve);</span>
<span class="nc" id="L3370">        }</span>
<span class="nc" id="L3371">    }</span>

    /**
     * Helper method that activates CA services and publisher their certificates, if the services are marked as active
     * @param admin Admin
     * @param extendedCAServiceInfos Service info 
     * @param ca CA
     *
     * @throws AuthorizationDeniedException Fail
     */
    private void activateAndPublishExternalCAServices(AuthenticationToken admin, Collection&lt;ExtendedCAServiceInfo&gt; extendedCAServiceInfos, CA ca)
            throws AuthorizationDeniedException {
<span class="nc" id="L3383">        final AvailableCustomCertificateExtensionsConfiguration cceConfig = (AvailableCustomCertificateExtensionsConfiguration) globalConfigurationSession</span>
<span class="nc" id="L3384">                .getCachedConfiguration(AvailableCustomCertificateExtensionsConfiguration.CONFIGURATION_ID);</span>
        // activate External CA Services
<span class="nc bnc" id="L3386" title="All 2 branches missed.">        for (final ExtendedCAServiceInfo info : extendedCAServiceInfos) {</span>
<span class="nc" id="L3387">            ArrayList&lt;Certificate&gt; certificates = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc bnc" id="L3388" title="All 2 branches missed.">            if (info instanceof CmsCAServiceInfo) {</span>
                try {
<span class="nc" id="L3390">                    final CryptoToken cryptoToken = cryptoTokenSession.getCryptoToken(ca.getCAToken().getCryptoTokenId());</span>
<span class="nc" id="L3391">                    ca.initExtendedService(cryptoToken, ExtendedCAServiceTypes.TYPE_CMSEXTENDEDSERVICE, ca, cceConfig);</span>
<span class="nc" id="L3392">                    final List&lt;Certificate&gt; certPath = ((CmsCAServiceInfo) ca</span>
<span class="nc" id="L3393">                            .getExtendedCAServiceInfo(ExtendedCAServiceTypes.TYPE_CMSEXTENDEDSERVICE)).getCertificatePath();</span>
<span class="nc bnc" id="L3394" title="All 2 branches missed.">                    if (certPath != null) {</span>
<span class="nc" id="L3395">                        certificates.add(certPath.get(0));</span>
                    }
<span class="nc" id="L3397">                } catch (Exception fe) {</span>
<span class="nc" id="L3398">                    String msg = intres.getLocalizedMessage(&quot;caadmin.errorcreatecaservice&quot;, &quot;CMSCAService&quot;);</span>
<span class="nc" id="L3399">                    log.error(msg, fe);</span>
<span class="nc" id="L3400">                    throw new EJBException(fe);</span>
<span class="nc" id="L3401">                }</span>
            }
            // Always store the certificate. Only publish the extended service
            // certificate for active services.
<span class="nc" id="L3405">            Collection&lt;Integer&gt; publishers = null;</span>
<span class="nc bnc" id="L3406" title="All 2 branches missed.">            if (info.getStatus() == ExtendedCAServiceInfo.STATUS_ACTIVE) {</span>
<span class="nc" id="L3407">                publishers = ca.getCRLPublishers();</span>
            }
<span class="nc bnc" id="L3409" title="All 2 branches missed.">            if ((!certificates.isEmpty())) {</span>
<span class="nc" id="L3410">                publishCACertificate(admin, certificates, publishers, ca.getSubjectDN());</span>
            }
<span class="nc" id="L3412">        }</span>
<span class="nc" id="L3413">    }</span>

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public void flushCACache() {
        // Just forward the call, because in CaSession it is only in the local interface and we
        // want to be able to use it from CLI
<span class="nc" id="L3420">        caSession.flushCACache();</span>
<span class="nc" id="L3421">    }</span>

    @Override
    public void customLog(final AuthenticationToken authenticationToken, final String type, final String caName, final String username, final String certificateSn,
            final String msg, final EventType event) throws AuthorizationDeniedException, CADoesntExistsException {
        // Check authorization to perform custom logging.
<span class="nc bnc" id="L3427" title="All 2 branches missed.">        if(!authorizationSession.isAuthorized(authenticationToken, AuditLogRules.LOG_CUSTOM.resource())) {</span>
<span class="nc" id="L3428">            throw new AuthorizationDeniedException(intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;, </span>
<span class="nc" id="L3429">                    AuditLogRules.LOG_CUSTOM.resource(), null));</span>
        }
<span class="nc" id="L3431">        int caId = 0;</span>
<span class="nc bnc" id="L3432" title="All 2 branches missed.">        if(caName != null) {</span>
<span class="nc" id="L3433">            final CAInfo cAInfo = caSession.getCAInfo(authenticationToken, caName);</span>
<span class="nc bnc" id="L3434" title="All 2 branches missed.">            if (cAInfo == null) {</span>
<span class="nc" id="L3435">                throw new CADoesntExistsException(&quot;CA with name &quot; + caName + &quot; doesn't exist.&quot;);</span>
            } 
<span class="nc" id="L3437">            caId = cAInfo.getCAId();</span>
<span class="nc" id="L3438">        } else {</span>
            try {
<span class="nc" id="L3440">                caId = CertTools.getIssuerDN(((X509CertificateAuthenticationToken) authenticationToken).getCertificate()).hashCode();</span>
<span class="nc" id="L3441">            } catch(Exception e) {</span>
<span class="nc" id="L3442">                log.debug(&quot;Could not get CA by users authentication token: &quot; + authenticationToken.getUniqueId(), e);</span>
<span class="nc" id="L3443">            }</span>
        }
<span class="nc" id="L3445">        final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L3446">        details.put(&quot;msg&quot;, type + &quot; : &quot; + msg);</span>
<span class="nc" id="L3447">        auditSession.log(event, EventStatus.SUCCESS, EjbcaModuleTypes.CUSTOM, EjbcaServiceTypes.EJBCA, authenticationToken.toString(), String.valueOf(caId), certificateSn, username, details);</span>
<span class="nc bnc" id="L3448" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L3449">            log.debug(&quot;Custom message '&quot; + msg + &quot;'was written to audit log by &quot; + authenticationToken.getUniqueId());</span>
        }
<span class="nc" id="L3451">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>