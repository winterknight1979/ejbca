<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>KeyStoreCreateSessionBean.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">ejbca-ejb</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.ejb.ra</a> &gt; <span class="el_source">KeyStoreCreateSessionBean.java</span></div><h1>KeyStoreCreateSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.ejbca.core.ejb.ra;

import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.Date;

import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;

import org.apache.log4j.Logger;
import org.cesecore.ErrorCode;
import org.cesecore.authentication.tokens.AlwaysAllowLocalAuthenticationToken;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authentication.tokens.UsernamePrincipal;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.authorization.AuthorizationSessionLocal;
import org.cesecore.authorization.control.StandardRules;
import org.cesecore.certificates.ca.CADoesntExistsException;
import org.cesecore.certificates.ca.CAOfflineException;
import org.cesecore.certificates.ca.CaSessionLocal;
import org.cesecore.certificates.ca.IllegalNameException;
import org.cesecore.certificates.ca.IllegalValidityException;
import org.cesecore.certificates.ca.InvalidAlgorithmException;
import org.cesecore.certificates.certificate.CertificateCreateException;
import org.cesecore.certificates.certificate.CertificateRevokeException;
import org.cesecore.certificates.certificate.IllegalKeyException;
import org.cesecore.certificates.certificate.exception.CertificateSerialNumberException;
import org.cesecore.certificates.certificate.exception.CustomCertificateSerialNumberException;
import org.cesecore.certificates.endentity.EndEntityConstants;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.configuration.GlobalConfigurationSessionLocal;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.keys.token.CryptoTokenOfflineException;
import org.cesecore.keys.util.KeyStoreTools;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.keys.util.PublicKeyWrapper;
import org.cesecore.util.CertTools;
import org.cesecore.util.EJBTools;
import org.ejbca.config.GlobalConfiguration;
import org.ejbca.core.EjbcaException;
import org.ejbca.core.ejb.ca.auth.EndEntityAuthenticationSessionLocal;
import org.ejbca.core.ejb.ca.sign.SignSessionLocal;
import org.ejbca.core.ejb.hardtoken.HardTokenSessionLocal;
import org.ejbca.core.ejb.keyrecovery.KeyRecoverySessionLocal;
import org.ejbca.core.ejb.ra.raadmin.EndEntityProfileSessionLocal;
import org.ejbca.core.model.CertificateSignatureException;
import org.ejbca.core.model.InternalEjbcaResources;
import org.ejbca.core.model.SecConst;
import org.ejbca.core.model.ca.AuthLoginException;
import org.ejbca.core.model.ca.AuthStatusException;
import org.ejbca.core.model.keyrecovery.KeyRecoveryInformation;
import org.ejbca.core.model.ra.NotFoundException;
import org.ejbca.core.model.ra.raadmin.EndEntityProfile;
import org.ejbca.core.model.ra.raadmin.EndEntityProfileValidationException;

/**
 * Implementation of KeyStoreCreateSession
 * Class that has helper methods to generate tokens for users in ejbca.
 *
 * @version $Id: KeyStoreCreateSessionBean.java 29332 2018-06-25 13:39:58Z andresjakobs $
 */

@Stateless(mappedName = JndiConstants.APP_JNDI_PREFIX + &quot;KeyStoreCreateSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
<span class="nc" id="L89">public class KeyStoreCreateSessionBean implements KeyStoreCreateSessionLocal, KeyStoreCreateSessionRemote {</span>
    
<span class="nc" id="L91">    private static final Logger log = Logger.getLogger(KeyStoreCreateSessionBean.class);</span>

<span class="nc" id="L93">    private static final InternalEjbcaResources intres = InternalEjbcaResources.getInstance();</span>

    @EJB
    private GlobalConfigurationSessionLocal globalConfigurationSession;
    @EJB
	private EndEntityAuthenticationSessionLocal authenticationSession;
    @EJB
    private AuthorizationSessionLocal authorizationSession;
    @EJB
    private EndEntityAccessSessionLocal endEntityAccessSession;
    @EJB
    private EndEntityAuthenticationSessionLocal endEntityAuthenticationSession;
    @EJB
    private EndEntityManagementSessionLocal endEntityManagementSession;
    @EJB
    private EndEntityProfileSessionLocal endEntityProfileSession;
    @EJB
    private CaSessionLocal caSession;
    @EJB
    private KeyRecoverySessionLocal keyRecoverySession;
    @EJB
    private SignSessionLocal signSession;
    @EJB
    private HardTokenSessionLocal hardTokenSession;

    @Override
    public byte[] generateOrKeyRecoverTokenAsByteArray(final AuthenticationToken authenticationToken, final String username, final String password, final String hardTokenSN, final String keySpecification, final String keyAlgorithm)
            throws CADoesntExistsException, AuthorizationDeniedException, NotFoundException, EjbcaException {
        // Check if user exists.
<span class="nc" id="L122">        final EndEntityInformation endEntity = endEntityAccessSession.findUser(authenticationToken, username);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if(endEntity == null) {</span>
<span class="nc" id="L124">            log.info(intres.getLocalizedMessage(&quot;ra.errorentitynotexist&quot;, username));</span>
<span class="nc" id="L125">            throw new NotFoundException(intres.getLocalizedMessage(&quot;ra.wrongusernameorpassword&quot;));</span>
        }
        // Check CA ID and authorization.
<span class="nc" id="L128">        final int caId = endEntity.getCAId();</span>
<span class="nc" id="L129">        caSession.verifyExistenceOfCA(caId);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if(!authorizationSession.isAuthorized(authenticationToken, StandardRules.CAACCESS.resource() + caId, StandardRules.CREATECERT.resource())) {</span>
<span class="nc" id="L131">            final String msg = intres.getLocalizedMessage(&quot;authorization.notauthorizedtoresource&quot;, StandardRules.CAACCESS.resource() +caId +</span>
<span class="nc" id="L132">                    &quot;,&quot; + StandardRules.CREATECERT.resource(), null);</span>
<span class="nc" id="L133">            throw new AuthorizationDeniedException(msg);</span>
        }
        // Check token type.
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if(endEntity.getTokenType() != SecConst.TOKEN_SOFT_P12) { // logger</span>
<span class="nc" id="L137">            throw new EjbcaException(ErrorCode.BAD_USER_TOKEN_TYPE, &quot;Error: Wrong Token Type of user, must be 'P12' for PKCS12 requests&quot;);</span>
        }
<span class="nc" id="L139">        final boolean useKeyRecovery = ((GlobalConfiguration) globalConfigurationSession.getCachedConfiguration(GlobalConfiguration.GLOBAL_CONFIGURATION_ID)).getEnableKeyRecovery();</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L141">            log.debug(&quot;usekeyrecovery: &quot; + useKeyRecovery);</span>
        }
<span class="nc bnc" id="L143" title="All 6 branches missed.">        final boolean saveKeys = endEntity.getKeyRecoverable() &amp;&amp; useKeyRecovery &amp;&amp; (endEntity.getStatus() != EndEntityConstants.STATUS_KEYRECOVERY);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L145">            log.debug(&quot;userdata.getKeyRecoverable(): &quot; + endEntity.getKeyRecoverable());</span>
<span class="nc" id="L146">            log.debug(&quot;userdata.getStatus(): &quot; + endEntity.getStatus());</span>
<span class="nc" id="L147">            log.debug(&quot;savekeys: &quot; + saveKeys);</span>
        }
<span class="nc bnc" id="L149" title="All 4 branches missed.">        final boolean loadKeys = (endEntity.getStatus() == EndEntityConstants.STATUS_KEYRECOVERY) &amp;&amp; useKeyRecovery;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L151">            log.debug(&quot;loadkeys: &quot; + loadKeys);</span>
        }
<span class="nc" id="L153">        final int endEntityProfileId = endEntity.getEndEntityProfileId();</span>
<span class="nc" id="L154">        final EndEntityProfile endEntityProfile = endEntityProfileSession.getEndEntityProfile(endEntityProfileId);</span>
<span class="nc" id="L155">        final boolean reuseCertificate = endEntityProfile.getReUseKeyRecoveredCertificate();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L157">            log.debug(&quot;reusecertificate: &quot; + reuseCertificate);</span>
        }
        try {
<span class="nc" id="L160">            final KeyStore keyStore = generateOrKeyRecoverToken(authenticationToken, username, password, caId,</span>
                    keySpecification, keyAlgorithm, null, null, false, loadKeys, saveKeys, reuseCertificate, endEntityProfileId);
<span class="nc" id="L162">            final String alias = keyStore.aliases().nextElement();</span>
<span class="nc" id="L163">            final X509Certificate certificate = (X509Certificate) keyStore.getCertificate(alias);</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">            if ((hardTokenSN != null) &amp;&amp; (certificate != null)) {</span>
<span class="nc" id="L165">                hardTokenSession.addHardTokenCertificateMapping(authenticationToken,hardTokenSN,certificate);</span>
            }
<span class="nc" id="L167">            return KeyStoreTools.getAsByteArray(keyStore, password);</span>
<span class="nc" id="L168">        } catch (AuthLoginException e) { // Is handled as EjbcaException at caller (EjbcaWS).</span>
<span class="nc" id="L169">            throw e;</span>
<span class="nc" id="L170">        } catch (AuthStatusException e) { // Is handled as EjbcaException at caller (EjbcaWS).</span>
<span class="nc" id="L171">            throw e;</span>
<span class="nc" id="L172">        } catch (Exception e) {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L174">                log.debug(&quot;Re-throw exception in RA master API: &quot; + e.getMessage(), e);</span>
            }
<span class="nc" id="L176">            throw new EjbcaException(ErrorCode.INTERNAL_ERROR, e.getMessage());</span>
        }
    }

    @Override
    public byte[] generateOrKeyRecoverTokenAsByteArray(AuthenticationToken administrator, String username, String password, int caid, String keyspec,
            String keyalg, boolean createJKS, boolean loadkeys, boolean savekeys, boolean reusecertificate, int endEntityProfileId)
            throws AuthorizationDeniedException, KeyStoreException, InvalidAlgorithmParameterException, CADoesntExistsException, IllegalKeyException,
            CertificateCreateException, IllegalNameException, CertificateRevokeException, CertificateSerialNumberException,
            CryptoTokenOfflineException, IllegalValidityException, CAOfflineException, InvalidAlgorithmException,
            CustomCertificateSerialNumberException, AuthStatusException, AuthLoginException, EndEntityProfileValidationException, NoSuchEndEntityException,
            CertificateSignatureException, CertificateEncodingException, CertificateException, NoSuchAlgorithmException, InvalidKeySpecException {
<span class="nc" id="L188">        KeyStore keyStore = generateOrKeyRecoverToken(administrator, username, password, caid, keyspec, keyalg, null, null, createJKS, loadkeys,</span>
                savekeys,
                reusecertificate, endEntityProfileId);
<span class="nc" id="L191">        return KeyStoreTools.getAsByteArray(keyStore, password);</span>
    }

    @Override
    public KeyStore generateOrKeyRecoverToken(AuthenticationToken administrator, String username, String password, int caid,
            String keyspec, String keyalg, Date notBefore, Date notAfter, boolean createJKS, boolean loadkeys, boolean savekeys,
            boolean reusecertificate,
            int endEntityProfileId)
            throws AuthorizationDeniedException, KeyStoreException, InvalidAlgorithmParameterException, CADoesntExistsException, IllegalKeyException,
            CertificateCreateException, IllegalNameException, CertificateRevokeException, CertificateSerialNumberException,
            CryptoTokenOfflineException, IllegalValidityException, CAOfflineException, InvalidAlgorithmException,
            CustomCertificateSerialNumberException, AuthStatusException, AuthLoginException, EndEntityProfileValidationException, NoSuchEndEntityException,
            CertificateSignatureException, CertificateEncodingException, CertificateException, NoSuchAlgorithmException, InvalidKeySpecException {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L205">            log.trace(&quot;&gt;generateOrKeyRecoverToken&quot;);</span>
        }
<span class="nc" id="L207">        boolean isNewToken = false;</span>
<span class="nc" id="L208">    	KeyRecoveryInformation keyData = null;</span>
<span class="nc" id="L209">    	KeyPair rsaKeys = null;</span>
<span class="nc" id="L210">    	EndEntityInformation userdata = endEntityAccessSession.findUser(administrator, username);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">    	if (userdata.getStatus() == EndEntityConstants.STATUS_NEW) {</span>
<span class="nc" id="L212">    	    isNewToken = true;</span>
    	}
<span class="nc bnc" id="L214" title="All 2 branches missed.">    	if (loadkeys) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    	    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L216">    	        log.debug(&quot;Recovering keys for user: &quot;+ username);</span>
    	    }
            // used saved keys.
<span class="nc" id="L219">			keyData = keyRecoverySession.recoverKeys(administrator, username, endEntityProfileId);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">    		if (keyData == null) {</span>
<span class="nc" id="L221">    			throw new KeyStoreException(&quot;No key recovery data exists for user&quot;);</span>
    		}
<span class="nc" id="L223">    		rsaKeys = keyData.getKeyPair();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">    		if (reusecertificate) {</span>
    			// This is only done if reusecertificate == true because if you don't re-use certificate
    		    // signSession.createCertificate is called, which set status to generated, unless finishUser == false in CA config
<span class="nc bnc" id="L227" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L228">                    log.debug(&quot;Re-using old certificate for user: &quot;+ username);</span>
                }
<span class="nc" id="L230">    			keyRecoverySession.unmarkUser(administrator,username);</span>
    		}
<span class="nc" id="L232">    		caid = keyData.getIssuerDN().hashCode(); // always use the CA of the certificate</span>
    	} else {
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L235">                log.debug(&quot;Generating new keys for user: &quot;+ username);</span>
            }

            //KeyStore algorithm specification inside endEntityInformation has priority since its algorithm is approved
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (userdata.getExtendedInformation() != null) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                if (userdata.getExtendedInformation().getKeyStoreAlgorithmType() != null</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                        &amp;&amp; userdata.getExtendedInformation().getKeyStoreAlgorithmSubType() != null) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L243">                        log.debug(&quot;Using the key-store algorithm specification found inside the endEntityInformation (&quot;</span>
<span class="nc" id="L244">                                + userdata.getExtendedInformation().getKeyStoreAlgorithmType() + &quot;_&quot;</span>
<span class="nc" id="L245">                                + userdata.getExtendedInformation().getKeyStoreAlgorithmSubType() + &quot;) instead of one provided separately (&quot; + keyalg</span>
                                + &quot;_&quot; + keyspec + &quot;)&quot;);
                    }
<span class="nc" id="L248">                    keyalg = userdata.getExtendedInformation().getKeyStoreAlgorithmType();</span>
<span class="nc" id="L249">                    keyspec = userdata.getExtendedInformation().getKeyStoreAlgorithmSubType();</span>
                }
            }
            // generate new keys.
<span class="nc" id="L253">            rsaKeys = KeyTools.genKeys(keyspec, keyalg);</span>
    	}
<span class="nc" id="L255">    	X509Certificate cert = null;</span>
<span class="nc bnc" id="L256" title="All 4 branches missed.">    	if ((reusecertificate) &amp;&amp; (keyData != null)) {</span>
<span class="nc" id="L257">            cert = (X509Certificate) keyData.getCertificate(); // TODO Validity ignored here?</span>
<span class="nc" id="L258">    		boolean finishUser = true;</span>
<span class="nc" id="L259">			finishUser = caSession.getCAInfo(administrator,caid).getFinishUser();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">    		if (finishUser) {</span>
<span class="nc" id="L261">				authenticationSession.finishUser(userdata);</span>
    		}
<span class="nc" id="L263">    	} else {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L265">                log.debug(&quot;Generating new certificate for user: &quot;+ username);</span>
            }
<span class="nc" id="L267">            cert = (X509Certificate) signSession.createCertificate(administrator, username, password, new PublicKeyWrapper(rsaKeys.getPublic()), -1,</span>
                    notBefore, notAfter);
    	}
    	// Clear password from database
<span class="nc" id="L271">    	userdata = endEntityAccessSession.findUser(administrator, username); //Get GENERATED end entity information</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (userdata.getStatus() == EndEntityConstants.STATUS_GENERATED) {</span>
            // If we have a successful key recovery via EJBCA WS we implicitly want to allow resetting of the password without edit_end_entity rights (ECA-4947)
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (loadkeys) {</span>
<span class="nc" id="L275">                endEntityManagementSession.setClearTextPassword(new AlwaysAllowLocalAuthenticationToken(</span>
                        new UsernamePrincipal(&quot;Implicit authorization from key recovery operation to reset password.&quot;)), username, null);
<span class="nc bnc" id="L277" title="All 2 branches missed.">            } else if (isNewToken) {</span>
                // If we generate a new token through an enrollment, we don't want to demand access to edit_end_entity
<span class="nc" id="L279">                endEntityManagementSession.setClearTextPassword(new AlwaysAllowLocalAuthenticationToken(</span>
                        new UsernamePrincipal(&quot;Implicit authorization from new enrollments&quot;)), username, null);
            } else {
<span class="nc" id="L282">                endEntityManagementSession.setClearTextPassword(administrator, username, null);</span>
            }
    	}
        // Make a certificate chain from the certificate and the CA-certificate
<span class="nc" id="L286">        Certificate[] cachain = signSession.getCertificateChain(caid).toArray(new Certificate[0]);</span>
        // Verify CA-certificate
<span class="nc" id="L288">    	Certificate rootcert = cachain[cachain.length - 1];</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">    	if (CertTools.isSelfSigned(rootcert)) {</span>
    		try {
<span class="nc" id="L291">    			rootcert.verify(rootcert.getPublicKey());</span>
<span class="nc" id="L292">    		} catch (GeneralSecurityException se) {</span>
<span class="nc" id="L293">                throw new CertificateSignatureException(&quot;RootCA certificate does not verify, issuerDN: &quot; + CertTools.getIssuerDN(rootcert)</span>
<span class="nc" id="L294">                        + &quot;, subjectDN: &quot; + CertTools.getSubjectDN(rootcert), se);</span>
<span class="nc" id="L295">    		}</span>
    	} else {
<span class="nc" id="L297">    		throw new CertificateSignatureException(&quot;RootCA certificate not self-signed, issuerDN: &quot;+CertTools.getIssuerDN(rootcert)+&quot;, subjectDN: &quot;+CertTools.getSubjectDN(rootcert));</span>
    	}
        // Verify that the user-certificate is signed by our CA
<span class="nc" id="L300">    	Certificate cacert = cachain[0];</span>
    	try {
<span class="nc" id="L302">    		cert.verify(cacert.getPublicKey());</span>
<span class="nc" id="L303">    	} catch (GeneralSecurityException se) {</span>
<span class="nc" id="L304">    		throw new CertificateSignatureException(&quot;Generated certificate does not verify using CA-certificate, issuerDN: &quot;+CertTools.getIssuerDN(cert)+&quot;, subjectDN: &quot;+CertTools.getSubjectDN(cert)+</span>
<span class="nc" id="L305">    				&quot;, caIssuerDN: &quot;+CertTools.getIssuerDN(cacert)+&quot;, caSubjectDN: &quot;+CertTools.getSubjectDN(cacert), se);</span>
<span class="nc" id="L306">    	}</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">    	if (savekeys) {</span>
            // Save generated keys to database.
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L310">                log.debug(&quot;Saving generated keys for recovery for user: &quot;+ username);</span>
            }
<span class="nc" id="L312">			keyRecoverySession.addKeyRecoveryData(administrator, EJBTools.wrap(cert), username, EJBTools.wrap(rsaKeys));</span>
    	}
        //  Use CN if as alias in the keystore, if CN is not present use username
<span class="nc" id="L315">    	String alias = CertTools.getPartFromDN(CertTools.getSubjectDN(cert), &quot;CN&quot;);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">    	if (alias == null) {</span>
<span class="nc" id="L317">    		alias = username;</span>
    	}
        // Store keys and certificates in keystore.
<span class="nc" id="L320">    	KeyStore ks = null;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">    	if (createJKS) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L323">                log.debug(&quot;Generating JKS for user: &quot;+ username);</span>
            }
<span class="nc" id="L325">    		ks = KeyTools.createJKS(alias, rsaKeys.getPrivate(), password, cert, cachain);</span>
    	} else {
<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L328">                log.debug(&quot;Generating PKCS12 for user: &quot;+ username);</span>
            }
<span class="nc" id="L330">    		ks = KeyTools.createP12(alias, rsaKeys.getPrivate(), cert, cachain);</span>
    	}
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L333">            log.trace(&quot;&lt;generateOrKeyRecoverToken&quot;);</span>
        }
<span class="nc" id="L335">    	return ks;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>