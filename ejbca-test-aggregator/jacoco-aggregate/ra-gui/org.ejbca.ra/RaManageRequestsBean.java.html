<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RaManageRequestsBean.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">ra-gui</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.ra</a> &gt; <span class="el_source">RaManageRequestsBean.java</span></div><h1>RaManageRequestsBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.ejbca.ra;

import java.io.Serializable;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.ejb.EJB;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ManagedProperty;
import javax.faces.bean.ViewScoped;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.ejbca.core.model.era.RaApprovalRequestInfo;
import org.ejbca.core.model.era.RaMasterApiProxyBeanLocal;
import org.ejbca.core.model.era.RaRequestsSearchRequest;
import org.ejbca.core.model.era.RaRequestsSearchResponse;

/**
 * Backing bean for Manage Requests page (for a list of requests)
 *
 * @see RaManageRequestBean
 * @version $Id: RaManageRequestsBean.java 28085 2018-01-24 09:20:32Z henriks $
 * TODO: Use CDI beans 
 */
@SuppressWarnings(&quot;deprecation&quot;)
@ManagedBean
@ViewScoped
<span class="nc" id="L49">public class RaManageRequestsBean implements Serializable {</span>

    private static final long serialVersionUID = 1L;
<span class="nc" id="L52">    private static final Logger log = Logger.getLogger(RaManageRequestsBean.class);</span>

    @EJB
    private RaMasterApiProxyBeanLocal raMasterApiProxyBean;

    @ManagedProperty(value=&quot;#{raAccessBean}&quot;)
    private RaAccessBean raAccessBean;
<span class="nc" id="L59">    public void setRaAccessBean(final RaAccessBean raAccessBean) { this.raAccessBean = raAccessBean; }</span>

    @ManagedProperty(value=&quot;#{raAuthenticationBean}&quot;)
    private RaAuthenticationBean raAuthenticationBean;
<span class="nc" id="L63">    public void setRaAuthenticationBean(final RaAuthenticationBean raAuthenticationBean) { this.raAuthenticationBean = raAuthenticationBean; }</span>

    @ManagedProperty(value=&quot;#{raLocaleBean}&quot;)
    private RaLocaleBean raLocaleBean;
<span class="nc" id="L67">    public void setRaLocaleBean(final RaLocaleBean raLocaleBean) { this.raLocaleBean = raLocaleBean; }</span>

<span class="nc" id="L69">    private RaRequestsSearchResponse lastExecutedResponse = null;</span>

<span class="nc" id="L71">    private List&lt;ApprovalRequestGUIInfo&gt; resultsFiltered = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L73">    private enum ViewTab { TO_APPROVE, PENDING, PROCESSED, CUSTOM_SEARCH };</span>
<span class="nc" id="L74">    private ViewTab viewTab = ViewTab.TO_APPROVE;</span>
<span class="nc" id="L75">    private boolean customSearchingWaiting = true;</span>
<span class="nc" id="L76">    private boolean customSearchingProcessed = true;</span>
<span class="nc" id="L77">    private boolean customSearchingExpired = true;</span>
    private String customSearchStartDate;
    private String customSearchEndDate;
    private String customSearchExpiresDays;

<span class="nc" id="L82">    private enum SortBy { ID, REQUEST_DATE, CA, TYPE, DISPLAY_NAME, REQUESTER_NAME, STATUS };</span>
<span class="nc" id="L83">    private SortBy sortBy = SortBy.REQUEST_DATE;</span>
<span class="nc" id="L84">    private boolean sortAscending = true;</span>

    public String getTab() {
<span class="nc bnc" id="L87" title="All 2 branches missed.">        return viewTab != null ? viewTab.name().toLowerCase(Locale.ROOT) : null;</span>
    }

    public void setTab(final String value) {
        try {
<span class="nc bnc" id="L92" title="All 2 branches missed.">            viewTab = !StringUtils.isBlank(value) ? ViewTab.valueOf(value.toUpperCase(Locale.ROOT)) : ViewTab.TO_APPROVE;</span>
<span class="nc" id="L93">        } catch (IllegalArgumentException e) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L95">                log.debug(&quot;Invalid value for the 'tab' parameter: '&quot; + value + &quot;'&quot;);</span>
            }
<span class="nc" id="L97">            viewTab = ViewTab.TO_APPROVE;</span>
<span class="nc" id="L98">        }</span>
<span class="nc" id="L99">    }</span>

    public boolean isViewingNeedsApproval() {
<span class="nc bnc" id="L102" title="All 2 branches missed.">        return viewTab == ViewTab.TO_APPROVE;</span>
    }

    public boolean isViewingPendingApproval() {
<span class="nc bnc" id="L106" title="All 2 branches missed.">        return viewTab == ViewTab.PENDING;</span>
    }

    public boolean isViewingProcessed() {
<span class="nc bnc" id="L110" title="All 2 branches missed.">        return viewTab == ViewTab.PROCESSED;</span>
    }

    public boolean isViewingCustom() {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        return viewTab == ViewTab.CUSTOM_SEARCH;</span>
    }


    public void searchAndFilter() {
<span class="nc" id="L119">        final RaRequestsSearchRequest searchRequest = new RaRequestsSearchRequest();</span>
<span class="nc bnc" id="L120" title="All 5 branches missed.">        switch (viewTab) {</span>
        case CUSTOM_SEARCH:
            try {
                // TODO timezone?
<span class="nc bnc" id="L124" title="All 2 branches missed.">                if (!StringUtils.isBlank(customSearchStartDate)) {</span>
<span class="nc" id="L125">                    searchRequest.setStartDate(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(customSearchStartDate.trim()));</span>
                }
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if (!StringUtils.isBlank(customSearchEndDate)) {</span>
<span class="nc" id="L128">                    final Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L129">                    cal.setTime(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(customSearchEndDate.trim()));</span>
<span class="nc" id="L130">                    cal.add(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L131">                    searchRequest.setEndDate(cal.getTime());</span>
                }
<span class="nc bnc" id="L133" title="All 2 branches missed.">                if (!StringUtils.isBlank(customSearchExpiresDays)) {</span>
<span class="nc" id="L134">                    final Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L135">                    cal.setTime(new Date());</span>
<span class="nc" id="L136">                    cal.add(Calendar.DAY_OF_MONTH, Integer.parseInt(customSearchExpiresDays.trim()));</span>
<span class="nc" id="L137">                    searchRequest.setExpiresBefore(cal.getTime());</span>
                    // Only requests in waiting state can expire
<span class="nc" id="L139">                    customSearchingWaiting = true;</span>
<span class="nc" id="L140">                    customSearchingProcessed = false;</span>
<span class="nc" id="L141">                    customSearchingExpired = false;</span>
                }
<span class="nc" id="L143">                searchRequest.setSearchingWaitingForMe(customSearchingWaiting);</span>
<span class="nc" id="L144">                searchRequest.setSearchingPending(customSearchingWaiting); // those are also waiting</span>
<span class="nc" id="L145">                searchRequest.setSearchingHistorical(customSearchingProcessed);</span>
<span class="nc" id="L146">                searchRequest.setSearchingExpired(customSearchingExpired);</span>
<span class="nc" id="L147">                searchRequest.setIncludeOtherAdmins(true);</span>
<span class="nc" id="L148">            } catch (ParseException e) {</span>
                // Text field is validated by f:validateRegex, so shouldn't happen
<span class="nc" id="L150">                throw new IllegalStateException(&quot;Invalid date value&quot;, e);</span>
<span class="nc" id="L151">            }</span>
            break;
        case TO_APPROVE:
<span class="nc" id="L154">            searchRequest.setSearchingWaitingForMe(true);</span>
<span class="nc" id="L155">            break;</span>
        case PENDING:
<span class="nc" id="L157">            searchRequest.setSearchingPending(true);</span>
<span class="nc" id="L158">            break;</span>
        case PROCESSED:
<span class="nc" id="L160">            searchRequest.setSearchingHistorical(true);</span>
            break;
        }
        
<span class="nc" id="L164">        Map&lt;Integer, String&gt; raInfoMap = raMasterApiProxyBean</span>
<span class="nc" id="L165">                .getAuthorizedEndEntityProfileIdsToNameMap(raAuthenticationBean.getAuthenticationToken());</span>
        
<span class="nc" id="L167">        lastExecutedResponse = raMasterApiProxyBean.searchForApprovalRequests(raAuthenticationBean.getAuthenticationToken(), searchRequest);</span>

<span class="nc" id="L169">        final List&lt;RaApprovalRequestInfo&gt; reqInfos = lastExecutedResponse.getApprovalRequests();</span>
<span class="nc" id="L170">        final List&lt;ApprovalRequestGUIInfo&gt; guiInfos = new ArrayList&lt;&gt;();</span>
        
        /** Based on the tabs in the GUI we have different criteria to show requests: 
         *  TO_APPROVE tab: Check if user is authorized to approve and also if she has proper EEP.
         *  PENDING FOR APROVAL: Only those request issued by me should be shown!
         *  PROCESSED &amp; CUSTOM_SEARCH: Basically all the request minus those which the user doesn't have power to approve.
        **/
<span class="nc bnc" id="L177" title="All 2 branches missed.">        for (final RaApprovalRequestInfo reqInfo : reqInfos) {</span>
<span class="nc" id="L178">            final ApprovalRequestGUIInfo approvalRequestGuiInfo = new ApprovalRequestGUIInfo(reqInfo, raLocaleBean, raAccessBean);</span>
<span class="nc bnc" id="L179" title="All 6 branches missed.">            if (searchRequest.isSearchingWaitingForMe() &amp;&amp; approvalRequestGuiInfo.isCanApprove() &amp;&amp; !raInfoMap.isEmpty()) {</span>
<span class="nc" id="L180">                guiInfos.add(approvalRequestGuiInfo);</span>
<span class="nc bnc" id="L181" title="All 6 branches missed.">            } else if (searchRequest.isSearchingPending() &amp;&amp; (approvalRequestGuiInfo.isRequestedByMe() || approvalRequestGuiInfo.isCanView())) {</span>
<span class="nc" id="L182">                guiInfos.add(approvalRequestGuiInfo);</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">            } else if (searchRequest.isSearchingHistorical() &amp;&amp; !approvalRequestGuiInfo.isCanApprove()) {</span>
<span class="nc" id="L184">                guiInfos.add(approvalRequestGuiInfo);                </span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            } else if (searchRequest.isSearchingExpired()) {</span>
<span class="nc" id="L186">                guiInfos.add(approvalRequestGuiInfo);</span>
            }
<span class="nc" id="L188">        }</span>

<span class="nc" id="L190">        resultsFiltered = guiInfos;</span>
<span class="nc" id="L191">        sort();</span>
<span class="nc" id="L192">    }</span>

<span class="nc" id="L194">    public boolean isCustomSearchingWaiting() { return customSearchingWaiting; }</span>
<span class="nc" id="L195">    public void setCustomSearchingWaiting(final boolean customSearchingWaiting) { this.customSearchingWaiting = customSearchingWaiting; }</span>
<span class="nc" id="L196">    public boolean isCustomSearchingProcessed() { return customSearchingProcessed; }</span>
<span class="nc" id="L197">    public void setCustomSearchingProcessed(final boolean customSearchingProcessed) { this.customSearchingProcessed = customSearchingProcessed; }</span>
<span class="nc" id="L198">    public boolean isCustomSearchingExpired() { return customSearchingExpired; }</span>
<span class="nc" id="L199">    public void setCustomSearchingExpired(final boolean customSearchingExpired) { this.customSearchingExpired = customSearchingExpired; }</span>
<span class="nc" id="L200">    public String getCustomSearchStartDate() { return customSearchStartDate; }</span>
<span class="nc" id="L201">    public void setCustomSearchStartDate(final String startDate) { this.customSearchStartDate = StringUtils.trim(startDate); }</span>
<span class="nc" id="L202">    public String getCustomSearchEndDate() { return customSearchEndDate; }</span>
<span class="nc" id="L203">    public void setCustomSearchEndDate(final String endDate) { this.customSearchEndDate = StringUtils.trim(endDate); }</span>
<span class="nc" id="L204">    public String getCustomSearchExpiresDays() { return customSearchExpiresDays; }</span>
<span class="nc" id="L205">    public void setCustomSearchExpiresDays(final String customSearchExpiresDays) { this.customSearchExpiresDays = StringUtils.trim(customSearchExpiresDays); }</span>

    public List&lt;ApprovalRequestGUIInfo&gt; getFilteredResults() {
<span class="nc" id="L208">        return resultsFiltered;</span>
    }

    public boolean isMoreResultsAvailable() {
<span class="nc bnc" id="L212" title="All 4 branches missed.">        return lastExecutedResponse != null &amp;&amp; lastExecutedResponse.isMightHaveMoreResults();</span>
    }

    // Sorting
    private void sort() {
<span class="nc" id="L217">        Collections.sort(resultsFiltered, new Comparator&lt;ApprovalRequestGUIInfo&gt;() {</span>
            @Override
            public int compare(ApprovalRequestGUIInfo o1, ApprovalRequestGUIInfo o2) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">                int sortDir = (isSortAscending() ? 1 : -1);</span>
<span class="nc bnc" id="L221" title="All 7 branches missed.">                switch (sortBy) {</span>
                // TODO locale-aware sorting
<span class="nc" id="L223">                case ID: return o1.getId().compareTo(o2.getId()) * sortDir;</span>
<span class="nc" id="L224">                case CA: return o1.getCa().compareTo(o2.getCa()) * sortDir;</span>
<span class="nc" id="L225">                case TYPE: return o1.getType().compareTo(o2.getType()) * sortDir;</span>
<span class="nc" id="L226">                case DISPLAY_NAME: return o1.getDisplayName().compareTo(o2.getDisplayName()) * sortDir;</span>
<span class="nc" id="L227">                case REQUESTER_NAME: return o1.getRequesterName().compareTo(o2.getRequesterName()) * sortDir;</span>
<span class="nc" id="L228">                case STATUS: return o1.getStatus().compareTo(o2.getStatus()) * sortDir;</span>
                case REQUEST_DATE:
                default:
                    // We compare the date objects (o1.request.getRequestDate()) and not the strings (o1.getRequestDate())
<span class="nc" id="L232">                    return o1.request.getApprovalData().getRequestDate().compareTo(o2.request.getApprovalData().getRequestDate()) * sortDir;</span>
                }
            }
        });
<span class="nc" id="L236">    }</span>

<span class="nc" id="L238">    public String getSortedByRequestDate() { return getSortedBy(SortBy.REQUEST_DATE); }</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">    public void sortByRequestDate() { sortBy(SortBy.REQUEST_DATE, viewTab == ViewTab.PROCESSED || viewTab == ViewTab.CUSTOM_SEARCH); }</span>
<span class="nc" id="L240">    public String getSortedByID() { return getSortedBy(SortBy.ID); }</span>
<span class="nc" id="L241">    public void sortByID() { sortBy(SortBy.ID, false); }</span>
<span class="nc" id="L242">    public String getSortedByCA() { return getSortedBy(SortBy.CA); }</span>
<span class="nc" id="L243">    public void sortByCA() { sortBy(SortBy.CA, true); }</span>
<span class="nc" id="L244">    public String getSortedByType() { return getSortedBy(SortBy.TYPE); }</span>
<span class="nc" id="L245">    public void sortByType() { sortBy(SortBy.TYPE, true); }</span>
<span class="nc" id="L246">    public String getSortedByDisplayName() { return getSortedBy(SortBy.DISPLAY_NAME); }</span>
<span class="nc" id="L247">    public void sortByDisplayName() { sortBy(SortBy.DISPLAY_NAME, true); }</span>
<span class="nc" id="L248">    public String getSortedByRequesterName() { return getSortedBy(SortBy.REQUESTER_NAME); }</span>
<span class="nc" id="L249">    public void sortByRequesterName() { sortBy(SortBy.REQUESTER_NAME, true); }</span>
<span class="nc" id="L250">    public String getSortedByStatus() { return getSortedBy(SortBy.STATUS); }</span>
<span class="nc" id="L251">    public void sortByStatus() { sortBy(SortBy.STATUS, true); }</span>

    public String getSortColumn() {
<span class="nc" id="L254">        return sortBy.name();</span>
    }

    public void setSortColumn(final String value) {
        try {
<span class="nc bnc" id="L259" title="All 2 branches missed.">            sortBy = !StringUtils.isBlank(value) ? SortBy.valueOf(value.toUpperCase(Locale.ROOT)) : SortBy.REQUEST_DATE;</span>
<span class="nc" id="L260">        } catch (IllegalArgumentException e) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L262">                log.debug(&quot;Invalid value for the 'sortColumn' parameter: '&quot; + value + &quot;'&quot;);</span>
            }
<span class="nc" id="L264">            sortBy = SortBy.REQUEST_DATE;</span>
<span class="nc" id="L265">        }</span>
<span class="nc" id="L266">    }</span>

    private String getSortedBy(final SortBy sortBy) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (this.sortBy.equals(sortBy)) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            return isSortAscending() ? &quot;\u25bc&quot; : &quot;\u25b2&quot;;</span>
        }
<span class="nc" id="L272">        return &quot;&quot;;</span>
    }

    /** Set current sort column. Flip the order if the column was already selected. 
     * @param sortBy Column
     * @param defaultAscending Order */
    private void sortBy(final SortBy sortBy, final boolean defaultAscending) { 
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (this.sortBy.equals(sortBy)) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            sortAscending = !isSortAscending();</span>
        } else {
<span class="nc" id="L282">            sortAscending = defaultAscending;</span>
        }
<span class="nc" id="L284">        this.sortBy = sortBy;</span>
<span class="nc" id="L285">        sort();</span>
<span class="nc" id="L286">    }</span>

    public boolean isSortAscending() {
<span class="nc" id="L289">        return sortAscending;</span>
    }

    public void setSortAscending(final boolean value) {
<span class="nc" id="L293">        sortAscending = value;</span>
<span class="nc" id="L294">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>