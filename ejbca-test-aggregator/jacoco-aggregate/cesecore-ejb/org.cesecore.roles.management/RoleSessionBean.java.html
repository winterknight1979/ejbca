<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RoleSessionBean.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">ejbca-test-aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-ejb</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.roles.management</a> &gt; <span class="el_source">RoleSessionBean.java</span></div><h1>RoleSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.roles.management;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.audit.enums.EventStatus;
import org.cesecore.audit.enums.EventTypes;
import org.cesecore.audit.enums.ModuleTypes;
import org.cesecore.audit.enums.ServiceTypes;
import org.cesecore.audit.log.SecurityEventsLoggerSessionLocal;
import org.cesecore.authentication.tokens.AlwaysAllowLocalAuthenticationToken;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authentication.tokens.AuthenticationTokenMetaData;
import org.cesecore.authentication.tokens.LocalJvmOnlyAuthenticationToken;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.authorization.AuthorizationSessionLocal;
import org.cesecore.authorization.control.StandardRules;
import org.cesecore.authorization.user.matchvalues.AccessMatchValue;
import org.cesecore.authorization.user.matchvalues.AccessMatchValueReverseLookupRegistry;
import org.cesecore.internal.InternalResources;
import org.cesecore.internal.UpgradeableDataHashMap;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.roles.AccessRulesHelper;
import org.cesecore.roles.Role;
import org.cesecore.roles.RoleExistsException;
import org.cesecore.roles.member.RoleMember;
import org.cesecore.roles.member.RoleMemberData;
import org.cesecore.roles.member.RoleMemberDataSessionLocal;

/**
 * Implementation of the RoleSession interfaces.
 * 
 * @version $Id: RoleSessionBean.java 28474 2018-03-13 10:23:28Z samuellb $
 */
@Stateless(mappedName = JndiConstants.APP_JNDI_PREFIX + &quot;RoleSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
<span class="nc" id="L62">public class RoleSessionBean implements RoleSessionLocal, RoleSessionRemote {</span>

<span class="nc" id="L64">    private static final Logger log = Logger.getLogger(RoleSessionBean.class);</span>

    @EJB
    private AuthorizationSessionLocal authorizationSession;
    @EJB
    private RoleDataSessionLocal roleDataSession;
    @EJB
    private RoleMemberDataSessionLocal roleMemberDataSession;
    @EJB
    private SecurityEventsLoggerSessionLocal securityEventsLoggerSession;

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public Role getRole(final AuthenticationToken authenticationToken, final String nameSpace, final String roleName) throws AuthorizationDeniedException {
<span class="nc" id="L78">        final Role role = roleDataSession.getRole(nameSpace, roleName);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (role!=null) {</span>
<span class="nc" id="L80">            final Set&lt;Integer&gt; roleIdsCallerBelongsTo = roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken);</span>
<span class="nc" id="L81">            assertAuthorizedToAllAccessRules(authenticationToken, role, roleIdsCallerBelongsTo);</span>
<span class="nc" id="L82">            assertAuthorizedToNameSpace(authenticationToken, role, roleIdsCallerBelongsTo);</span>
        }
        // Always return a copy to prevent shared access
<span class="nc bnc" id="L85" title="All 2 branches missed.">        return role==null ? null : new Role(role);</span>
    }

    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public Role getRole(final AuthenticationToken authenticationToken, final int roleId) throws AuthorizationDeniedException {
<span class="nc" id="L91">        final Role role = roleDataSession.getRole(roleId);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (role!=null) {</span>
<span class="nc" id="L93">            final Set&lt;Integer&gt; roleIdsCallerBelongsTo = roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken);</span>
<span class="nc" id="L94">            assertAuthorizedToAllAccessRules(authenticationToken, role, roleIdsCallerBelongsTo);</span>
<span class="nc" id="L95">            assertAuthorizedToNameSpace(authenticationToken, role, roleIdsCallerBelongsTo);</span>
        }
        // Always return a copy to prevent shared access
<span class="nc bnc" id="L98" title="All 2 branches missed.">        return role==null ? null : new Role(role);</span>
    }
    
    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public List&lt;Role&gt; getRolesAuthenticationTokenIsMemberOf(final AuthenticationToken authenticationToken) {
<span class="nc" id="L104">        final List&lt;Role&gt; roles = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        for (final int roleId : roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken)) {</span>
<span class="nc" id="L106">            roles.add(roleDataSession.getRole(roleId));</span>
<span class="nc" id="L107">        }</span>
<span class="nc" id="L108">        return roles;</span>
    }

    /*
     * NOTE: This separate method for remote EJB calls exists for a good reason: If this is invoked as a part of a
     * local transaction, the LocalJvmOnlyAuthenticationToken will be valid for subsequent authentication calls.
     */
    @Override
    public List&lt;Role&gt; getRolesAuthenticationTokenIsMemberOfRemote(AuthenticationToken authenticationTokenForAuhtorization, AuthenticationToken authenticationTokenToCheck) {
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (authenticationTokenToCheck instanceof LocalJvmOnlyAuthenticationToken) {</span>
            // Ensure that the matching procedure below also works for remote EJB calls
<span class="nc" id="L119">            ((LocalJvmOnlyAuthenticationToken) authenticationTokenToCheck).initRandomToken();</span>
        }
<span class="nc" id="L121">        final List&lt;Role&gt; roles = getRolesAuthenticationTokenIsMemberOf(authenticationTokenToCheck);</span>
<span class="nc" id="L122">        roles.retainAll(getAuthorizedRoles(authenticationTokenForAuhtorization));</span>
<span class="nc" id="L123">        return roles;</span>
    }
    
    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public List&lt;Role&gt; getAuthorizedRolesWithAccessToResource(final AuthenticationToken authenticationToken, final String resource) {
<span class="nc" id="L129">        final List&lt;Role&gt; roles = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        for (final Role role : getAuthorizedRoles(authenticationToken)) {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if (AccessRulesHelper.hasAccessToResource(role.getAccessRules(), resource)) {</span>
<span class="nc" id="L132">                roles.add(role);</span>
            }
<span class="nc" id="L134">        }</span>
<span class="nc" id="L135">        return roles;</span>
    }
    
    @Override
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    public List&lt;Role&gt; getAuthorizedRoles(final AuthenticationToken authenticationToken) {
<span class="nc" id="L141">        final List&lt;Role&gt; roles = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L142">        final Set&lt;Integer&gt; roleIdsCallerBelongsTo = roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        for (final Role role : roleDataSession.getAllRoles()) {</span>
            // Verify that the caller is authorized to role's namespace
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (!isAuthorizedToNameSpace(authenticationToken, role, roleIdsCallerBelongsTo)) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L147">                    log.debug(&quot;'&quot; + authenticationToken.toString() + &quot;' is not authorized to the namespace '&quot;+role.getNameSpace()+&quot;'.&quot;);</span>
                }
                continue;
            }
            // Verify that the caller is authorized to all access rules in this role
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (!isAuthorizedToAllAccessRules(authenticationToken, role, roleIdsCallerBelongsTo)) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L154">                    log.debug(&quot;'&quot; + authenticationToken.toString() + &quot;' is not authorized to all access rules in role '&quot;+role.getRoleNameFull()+&quot;'.&quot;);</span>
                }
                continue;
            }
            // Verify that the caller is authorized to all CAs that are issuers of members in this role
<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (!isAuthorizedToAllRoleMembersIssuers(authenticationToken, role.getRoleId())) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L161">                    log.debug(&quot;'&quot; + authenticationToken.toString() + &quot;' is not authorized to all members in role '&quot;+role.getRoleNameFull()+&quot;'.&quot;);</span>
                }
                continue;
            }
<span class="nc" id="L165">            roles.add(role);</span>
<span class="nc" id="L166">        }</span>
<span class="nc" id="L167">        return roles;</span>
    }

    @Override
    public boolean deleteRoleIdempotent(final AuthenticationToken authenticationToken, final int roleId) throws AuthorizationDeniedException {
<span class="nc" id="L172">        assertAuthorizedToEditRoles(authenticationToken);</span>
<span class="nc" id="L173">        final Role role = roleDataSession.getRole(roleId);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (role==null) {</span>
<span class="nc" id="L175">            return false;</span>
        }
        // Check that authenticationToken is allowed to remove the role with all its rights
<span class="nc" id="L178">        final Set&lt;Integer&gt; roleIdsCallerBelongsTo = roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken);</span>
<span class="nc" id="L179">        assertAuthorizedToAllAccessRules(authenticationToken, role, roleIdsCallerBelongsTo);</span>
<span class="nc" id="L180">        assertAuthorizedToNameSpace(authenticationToken, role, roleIdsCallerBelongsTo);</span>
<span class="nc" id="L181">        assertNonImportantRoleMembership(authenticationToken, role, roleIdsCallerBelongsTo);</span>
<span class="nc" id="L182">        boolean ret = roleDataSession.deleteRoleNoAuthorizationCheck(role.getRoleId());</span>
<span class="nc" id="L183">        RoleCache.INSTANCE.updateWith(role.getRoleId(), 0, null, null);</span>
<span class="nc" id="L184">        final String msg = InternalResources.getInstance().getLocalizedMessage(&quot;authorization.roleremoved&quot;, role.getRoleNameFull());</span>
<span class="nc" id="L185">        final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L186">        details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L187">        details.put(&quot;roleId&quot;, role.getRoleId());</span>
<span class="nc" id="L188">        details.put(&quot;roleName&quot;, role.getRoleName());</span>
<span class="nc" id="L189">        details.put(&quot;nameSpace&quot;, role.getNameSpace());</span>
<span class="nc" id="L190">        securityEventsLoggerSession.log(EventTypes.ROLE_DELETION, EventStatus.SUCCESS, ModuleTypes.ROLES, ServiceTypes.CORE,</span>
<span class="nc" id="L191">                authenticationToken.toString(), null, null, null, details);</span>
<span class="nc" id="L192">        final List&lt;RoleMember&gt; roleMembers = roleMemberDataSession.findRoleMemberByRoleId(role.getRoleId());</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        for (final RoleMember roleMember : roleMembers) {</span>
<span class="nc" id="L194">            ret |= roleMemberDataSession.remove(roleMember.getId());</span>
<span class="nc" id="L195">        }</span>
<span class="nc" id="L196">        return ret;</span>
    }
    
    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    @Override
    public void assertAuthorizedToRoleMembers(final AuthenticationToken authenticationToken, final int roleId, final boolean requireEditAccess) throws AuthorizationDeniedException {
        // Check if the caller is authorized to edit roles in general
<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (requireEditAccess) {</span>
<span class="nc" id="L204">            assertAuthorizedToEditRoles(authenticationToken);</span>
        } else {
<span class="nc" id="L206">            assertAuthorizedToViewRoles(authenticationToken);</span>
        }
        // Is the authToken authorized to the role found by id in the database?
<span class="nc bnc" id="L209" title="All 2 branches missed.">        final Role roleById = roleId==Role.ROLE_ID_UNASSIGNED ? null : roleDataSession.getRole(roleId);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (roleById!=null) {</span>
<span class="nc" id="L211">            final Set&lt;Integer&gt; roleIdsCallerBelongsTo = roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken);</span>
<span class="nc" id="L212">            assertAuthorizedToAllAccessRules(authenticationToken, roleById, roleIdsCallerBelongsTo);</span>
<span class="nc" id="L213">            assertAuthorizedToNameSpace(authenticationToken, roleById, roleIdsCallerBelongsTo);</span>
        }
<span class="nc" id="L215">    }</span>
    
    private Role getOriginalRoleAndAssertAuthorizedToEdit(final AuthenticationToken authenticationToken, final Role role, final boolean requireNonImportantRoleMembership)
            throws AuthorizationDeniedException {
        // Check if the caller is authorized to edit roles in general
<span class="nc" id="L220">        assertAuthorizedToEditRoles(authenticationToken);</span>
        // Is the authToken authorized to the role as provided as an argument?
<span class="nc" id="L222">        final Set&lt;Integer&gt; roleIdsCallerBelongsTo = roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken);</span>
<span class="nc" id="L223">        assertAuthorizedToAllAccessRules(authenticationToken, role, roleIdsCallerBelongsTo);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (requireNonImportantRoleMembership) {</span>
<span class="nc" id="L225">            assertNonImportantRoleMembership(authenticationToken, role, roleIdsCallerBelongsTo);</span>
        }
<span class="nc" id="L227">        assertAuthorizedToNameSpace(authenticationToken, role, roleIdsCallerBelongsTo);</span>
        // Is the authToken authorized to the role found by id in the database?
<span class="nc bnc" id="L229" title="All 2 branches missed.">        final Role roleById = role.getRoleId()==Role.ROLE_ID_UNASSIGNED ? null : roleDataSession.getRole(role.getRoleId());</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (roleById!=null) {</span>
<span class="nc" id="L231">            assertAuthorizedToAllAccessRules(authenticationToken, roleById, roleIdsCallerBelongsTo);</span>
<span class="nc" id="L232">            assertAuthorizedToNameSpace(authenticationToken, roleById, roleIdsCallerBelongsTo);</span>
        }
<span class="nc" id="L234">        return roleById;</span>
    }
    

    @Override
    public Role persistRole(final AuthenticationToken authenticationToken, final Role role) throws RoleExistsException, AuthorizationDeniedException {
<span class="nc" id="L240">        return persistRole(authenticationToken, role, true);</span>
    }
    
    @Override
    public Role persistRole(final AuthenticationToken authenticationToken, final Role role, final boolean requireNonImportantRoleMembership)
            throws RoleExistsException, AuthorizationDeniedException {
        // Normalize and minimize access rules before checking authorization
<span class="nc" id="L247">        role.normalizeAccessRules();</span>
<span class="nc" id="L248">        role.minimizeAccessRules();</span>
<span class="nc" id="L249">        final Role roleById = getOriginalRoleAndAssertAuthorizedToEdit(authenticationToken, role, requireNonImportantRoleMembership);</span>
        // Sort access rules to make raw xml editing (e.g. statedump) easier
<span class="nc" id="L251">        role.sortAccessRules();</span>
<span class="nc" id="L252">        final Role roleByName = roleDataSession.getRole(role.getNameSpace(), role.getRoleName());</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (roleById == null) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (roleByName!=null) {</span>
<span class="nc" id="L255">                throw new RoleExistsException(InternalResources.getInstance().getLocalizedMessage(&quot;authorization.erroraddroleexists&quot;, role.getRoleNameFull()));</span>
            }
            // Enforce a non-empty role name
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (StringUtils.isEmpty(role.getRoleName())) {</span>
<span class="nc" id="L259">                throw new IllegalArgumentException(&quot;Role name cannot be empty.&quot;);</span>
            }
            // Persist new role
<span class="nc" id="L262">            role.setRoleId(roleDataSession.persistRole(role).getRoleId());</span>
<span class="nc" id="L263">            final String msg = InternalResources.getInstance().getLocalizedMessage(&quot;authorization.roleadded&quot;, role.getRoleName());</span>
<span class="nc" id="L264">            final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L265">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L266">            details.put(&quot;roleId&quot;, role.getRoleId());</span>
<span class="nc" id="L267">            details.put(&quot;roleName&quot;, role.getRoleName());</span>
<span class="nc" id="L268">            details.put(&quot;nameSpace&quot;, role.getNameSpace());</span>
<span class="nc" id="L269">            securityEventsLoggerSession.log(EventTypes.ROLE_CREATION, EventStatus.SUCCESS, ModuleTypes.ROLES, ServiceTypes.CORE,</span>
<span class="nc" id="L270">                    authenticationToken.toString(), null, null, null, details);</span>
<span class="nc" id="L271">        } else {</span>
            // Save to existing role
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (roleByName==null) {</span>
                // Audit log that the role will be renamed when persisted
<span class="nc" id="L275">                final String msg = InternalResources.getInstance().getLocalizedMessage(&quot;authorization.rolerenamed&quot;, roleById.getRoleNameFull(),</span>
<span class="nc" id="L276">                        role.getRoleNameFull());</span>
<span class="nc" id="L277">                Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L278">                details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L279">                details.put(&quot;roleId&quot;, role.getRoleId());</span>
<span class="nc" id="L280">                details.put(&quot;roleNameOld&quot;, roleById.getRoleName());</span>
<span class="nc" id="L281">                details.put(&quot;roleNameNew&quot;, role.getRoleName());</span>
<span class="nc" id="L282">                details.put(&quot;nameSpaceOld&quot;, roleById.getNameSpace());</span>
<span class="nc" id="L283">                details.put(&quot;nameSpaceNew&quot;, role.getNameSpace());</span>
<span class="nc" id="L284">                securityEventsLoggerSession.log(EventTypes.ROLE_RENAMING, EventStatus.SUCCESS, ModuleTypes.ROLES, ServiceTypes.CORE,</span>
<span class="nc" id="L285">                        authenticationToken.toString(), null, null, null, details);</span>
<span class="nc" id="L286">            } else {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (roleByName.getRoleId() != role.getRoleId()) {</span>
<span class="nc" id="L288">                    throw new RoleExistsException(&quot;A role with the same name exists.&quot;);</span>
                }
            }
            // Persist data changes
<span class="nc" id="L292">            roleDataSession.persistRole(role);</span>
        }
        // Audit log access rule changes (also for new roles)
<span class="nc" id="L295">        final HashMap&lt;String, Boolean&gt; newAccessRules = role.getAccessRules();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        final HashMap&lt;String, Boolean&gt; oldAccessRules = roleById==null ? new HashMap&lt;String, Boolean&gt;() : roleById.getAccessRules();</span>
<span class="nc" id="L297">        final Map&lt;Object,Object&gt; oldAuditMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        for (final Entry&lt;String,Boolean&gt; entry : oldAccessRules.entrySet()) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            oldAuditMap.put(entry.getKey(), entry.getValue().booleanValue() ? &quot;allow&quot; : &quot;deny&quot;);</span>
<span class="nc" id="L300">        }</span>
<span class="nc" id="L301">        final Map&lt;Object,Object&gt; newAuditMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        for (final Entry&lt;String,Boolean&gt; entry : newAccessRules.entrySet()) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            newAuditMap.put(entry.getKey(), entry.getValue().booleanValue() ? &quot;allow&quot; : &quot;deny&quot;);</span>
<span class="nc" id="L304">        }</span>
<span class="nc" id="L305">        final Map&lt;Object, Object&gt; auditLogDiffMap = UpgradeableDataHashMap.diffMaps(oldAuditMap, newAuditMap);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (!auditLogDiffMap.isEmpty()) {</span>
<span class="nc" id="L307">            final StringBuilder rulesMsg = new StringBuilder();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            for (Map.Entry&lt;Object, Object&gt; entry : auditLogDiffMap.entrySet()) {</span>
<span class="nc" id="L309">                rulesMsg.append(&quot;[&quot; + entry.getKey().toString() + &quot;:&quot;+entry.getValue().toString()+&quot;]&quot;);</span>
<span class="nc" id="L310">            }</span>
<span class="nc" id="L311">            final String msg = InternalResources.getInstance().getLocalizedMessage(&quot;authorization.accessruleschanged&quot;, role.getRoleNameFull(), rulesMsg.toString());</span>
<span class="nc" id="L312">            final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L313">            details.put(&quot;msg&quot;, msg);</span>
<span class="nc" id="L314">            details.put(&quot;roleId&quot;, role.getRoleId());</span>
<span class="nc" id="L315">            details.put(&quot;roleName&quot;, role.getRoleName());</span>
<span class="nc" id="L316">            details.put(&quot;nameSpace&quot;, role.getNameSpace());</span>
<span class="nc" id="L317">            securityEventsLoggerSession.log(EventTypes.ROLE_ACCESS_RULE_CHANGE, EventStatus.SUCCESS, ModuleTypes.ROLES, ServiceTypes.CORE,</span>
<span class="nc" id="L318">                    authenticationToken.toString(), null, null, null, details);</span>
        }
<span class="nc" id="L320">        return role;</span>
    }

    /**
     * Asserts that authentication token is authorized to edit roles in general. 
     * 
     * @param authenticationToken a token for the authenticating entity
     * @throws AuthorizationDeniedException if not authorized
     */
    private void assertAuthorizedToEditRoles(AuthenticationToken authenticationToken) throws AuthorizationDeniedException {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.EDITROLES.resource())) {</span>
<span class="nc" id="L331">            String msg = InternalResources.getInstance().getLocalizedMessage(&quot;authorization.notauthorizedtoeditroles&quot;, authenticationToken.toString());</span>
<span class="nc" id="L332">            throw new AuthorizationDeniedException(msg);</span>
        }
<span class="nc" id="L334">    }</span>
    
    /** Like {@link #assertAuthorizedToEditRoles(AuthenticationToken)}, but check for view access 
     * @param authenticationToken Token
     * @throws AuthorizationDeniedException if denied */
    private void assertAuthorizedToViewRoles(AuthenticationToken authenticationToken) throws AuthorizationDeniedException {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, StandardRules.VIEWROLES.resource())) {</span>
<span class="nc" id="L341">            String msg = InternalResources.getInstance().getLocalizedMessage(&quot;authorization.notauthorizedtoviewroles&quot;, authenticationToken.toString());</span>
<span class="nc" id="L342">            throw new AuthorizationDeniedException(msg);</span>
        }
<span class="nc" id="L344">    }</span>

    /** @param authenticationToken Token
     * @param role Role
     * @param roleIdsCallerBelongsTo Caller role 
     * @throws AuthorizationDeniedException if the caller is not authorized to one of the rules granted access to (even implied) by this role */
    private void assertAuthorizedToAllAccessRules(final AuthenticationToken authenticationToken, final Role role, final Set&lt;Integer&gt; roleIdsCallerBelongsTo) throws AuthorizationDeniedException {
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (!isAuthorizedToAllAccessRules(authenticationToken, role, roleIdsCallerBelongsTo)) {</span>
<span class="nc" id="L352">            throw new AuthorizationDeniedException(&quot;Not authorized to all access rules in role.&quot;);</span>
        }
<span class="nc" id="L354">    }</span>

    /** @param authenticationToken Token
     * @param role Role
     * @param roleIdsCallerBelongsTo Caller roles 
     * @return booleam
      */
    private boolean isAuthorizedToAllAccessRules(final AuthenticationToken authenticationToken, final Role role, final Set&lt;Integer&gt; roleIdsCallerBelongsTo) {
        // Verify that authenticationToken has access to every single added allow access rule
<span class="nc bnc" id="L363" title="All 2 branches missed.">        for (final Entry&lt;String, Boolean&gt; entry : role.getAccessRules().entrySet()) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (entry.getValue().booleanValue()) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (!authorizationSession.isAuthorizedNoLogging(authenticationToken, entry.getKey())) {</span>
                    // Role would allow what is is not granted to current authenticationToken
<span class="nc" id="L367">                    return false;</span>
                }
            }
<span class="nc" id="L370">        }</span>
        // Verify that role does not have access to any rule that is denied to this authenticationToken
<span class="nc" id="L372">        HashMap&lt;String, Boolean&gt; totalAccessRules = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        for (final int roleId : roleIdsCallerBelongsTo) {</span>
<span class="nc" id="L374">            totalAccessRules = AccessRulesHelper.getAccessRulesUnion(totalAccessRules, roleDataSession.getRole(roleId).getAccessRules());</span>
<span class="nc" id="L375">        }</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        for (final Entry&lt;String, Boolean&gt; entry : totalAccessRules.entrySet()) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (!entry.getValue().booleanValue()) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                if (role.hasAccessToResource(entry.getKey())) {</span>
                    // Role would allow what is denied to current authenticationToken
<span class="nc" id="L380">                    return false;</span>
                }
            }
<span class="nc" id="L383">        }</span>
<span class="nc" id="L384">        return true;</span>
    }

    /** @param authenticationToken Token
     * @param role Role
     * @param roleIdsCallerBelongsTo Caller role
     * @throws AuthorizationDeniedException if the nameSpace is not &quot;owned&quot; by the caller. */
    private void assertAuthorizedToNameSpace(final AuthenticationToken authenticationToken, final Role role, final Set&lt;Integer&gt; roleIdsCallerBelongsTo) throws AuthorizationDeniedException {
        // Assert that AuthenticationToken is allowed to mess with the role's nameSpace
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (!isAuthorizedToNameSpace(authenticationToken, role, roleIdsCallerBelongsTo)) {</span>
<span class="nc" id="L394">            throw new AuthorizationDeniedException(&quot;Current AuthenticationToken is not authorized to the namespace '&quot;+role.getNameSpace()+&quot;'.&quot;);</span>
        }
<span class="nc" id="L396">    }</span>
    
    /** @param authenticationToken Token
     * @param roleId Role
     * @return true if the authenticationToken is authorized to all CAs that are issuers of RoleMembers in this Role */
    private boolean isAuthorizedToAllRoleMembersIssuers(final AuthenticationToken authenticationToken, final int roleId) {
        // Verify that the caller is authorized to all CAs that are issuers of members in this role
<span class="nc" id="L403">        final Set&lt;String&gt; tokenIssuerAccessRules = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        for (final RoleMemberData roleMemberData : roleMemberDataSession.findByRoleId(roleId)) {</span>
<span class="nc" id="L405">            final AuthenticationTokenMetaData metaData = AccessMatchValueReverseLookupRegistry.INSTANCE.getMetaData(roleMemberData.getTokenType());</span>
<span class="nc" id="L406">            final AccessMatchValue accessMatchValue = metaData.getAccessMatchValueIdMap().get(roleMemberData.getTokenMatchKey());</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if (accessMatchValue.isIssuedByCa()) {</span>
<span class="nc" id="L408">                tokenIssuerAccessRules.add(StandardRules.CAACCESS.resource() + roleMemberData.getTokenIssuerId());</span>
            }
<span class="nc" id="L410">        }</span>
<span class="nc" id="L411">        return authorizationSession.isAuthorizedNoLogging(authenticationToken, tokenIssuerAccessRules.toArray(new String[tokenIssuerAccessRules.size()]));</span>
    }

    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    @Override
    public void assertNonImportantRoleMembership(final AuthenticationToken authenticationToken, final int roleId) throws AuthorizationDeniedException {
<span class="nc" id="L417">        final Role role = roleDataSession.getRole(roleId);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (role!=null) {</span>
            // Check that authenticationToken is allowed to remove the role with all its rights
<span class="nc" id="L420">            final Set&lt;Integer&gt; roleIdsCallerBelongsTo = roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken);</span>
<span class="nc" id="L421">            assertNonImportantRoleMembership(authenticationToken, role, roleIdsCallerBelongsTo);</span>
        }
<span class="nc" id="L423">    }</span>

    private void assertNonImportantRoleMembership(final AuthenticationToken authenticationToken, final Role role, final Set&lt;Integer&gt; roleIdsCallerBelongsTo) throws AuthorizationDeniedException {
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (role.getRoleId()!=Role.ROLE_ID_UNASSIGNED) {</span>
            // Check that authenticationToken is not about to lock itself out by modifying its own role
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (roleIdsCallerBelongsTo.contains(role.getRoleId())) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L430">                    log.debug(&quot;'&quot;+authenticationToken+&quot;' relies on match from Role with id &quot; + role.getRoleId() + &quot; for access.&quot;);</span>
                }
                // As long as the admin does not lower its own privileges we are ok with
<span class="nc" id="L433">                HashMap&lt;String, Boolean&gt; accessRulesBefore = new HashMap&lt;&gt;();</span>
<span class="nc" id="L434">                HashMap&lt;String, Boolean&gt; accessRulesAfter = new HashMap&lt;&gt;();</span>
<span class="nc" id="L435">                final Set&lt;String&gt; accessToNamespacesBefore = new HashSet&lt;&gt;();</span>
<span class="nc" id="L436">                final Set&lt;String&gt; accessToNamespacesAfter = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                for (final int roleId : roleIdsCallerBelongsTo) {</span>
<span class="nc" id="L438">                    final Role existingRole = roleDataSession.getRole(roleId);</span>
<span class="nc" id="L439">                    final HashMap&lt;String, Boolean&gt; accessRulesFromRole = existingRole.getAccessRules();</span>
<span class="nc" id="L440">                    accessRulesBefore = AccessRulesHelper.getAccessRulesUnion(accessRulesBefore, accessRulesFromRole);</span>
<span class="nc" id="L441">                    accessToNamespacesBefore.add(existingRole.getNameSpace());</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                    if (roleId!=role.getRoleId()) {</span>
<span class="nc" id="L443">                        accessRulesAfter = AccessRulesHelper.getAccessRulesUnion(accessRulesAfter, accessRulesFromRole);</span>
<span class="nc" id="L444">                        accessToNamespacesAfter.add(existingRole.getNameSpace());</span>
                    } else {
<span class="nc" id="L446">                        accessToNamespacesAfter.add(role.getNameSpace());</span>
                    }
<span class="nc" id="L448">                }</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">                if (!accessRulesBefore.equals(accessRulesAfter)) {</span>
<span class="nc" id="L450">                    throw new AuthorizationDeniedException(&quot;Granted access of the current administrator might be affected by this change.&quot;);</span>
                }
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if (!accessToNamespacesBefore.equals(accessToNamespacesAfter) &amp;&amp;</span>
<span class="nc bnc" id="L453" title="All 4 branches missed.">                        !(accessToNamespacesBefore.contains(&quot;&quot;) &amp;&amp; accessToNamespacesAfter.contains(&quot;&quot;))) {</span>
<span class="nc" id="L454">                    throw new AuthorizationDeniedException(&quot;Granted namespace access of the current administrator would be affected by this change.&quot;);</span>
                }
<span class="nc bnc" id="L456" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L457">                    log.debug(&quot;Access granted to '&quot;+authenticationToken+&quot;' would not be affected by not being a member of Role with id &quot; + role.getRoleId() + &quot;.&quot;);</span>
                }
<span class="nc" id="L459">            } else {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L461">                    log.debug(&quot;'&quot;+authenticationToken+&quot;' does not rely on match from Role with id &quot; + role.getRoleId() + &quot;.&quot;);</span>
                }
            }
        }
<span class="nc" id="L465">    }</span>
    
    /** @param authenticationToken Token
     * @param role Role
     * @param roleIdsCallerBelongsTo Caller roles
     * @return boolean */
    private boolean isAuthorizedToNameSpace(final AuthenticationToken authenticationToken, final Role role, final Set&lt;Integer&gt; roleIdsCallerBelongsTo) {
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (authenticationToken instanceof AlwaysAllowLocalAuthenticationToken) {</span>
<span class="nc" id="L473">            return true; // AlwaysAllowLocalAuthenticationToken cannot belong to any roles, so the code below will not work</span>
        }
        // Assert that AuthenticationToken is allowed to mess with the role's nameSpace
<span class="nc" id="L476">        final Set&lt;String&gt; ownedNameSpaces = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">        for (final int current : roleIdsCallerBelongsTo) {</span>
<span class="nc" id="L478">            ownedNameSpaces.add(roleDataSession.getRole(current).getNameSpace());</span>
<span class="nc" id="L479">        }</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">        return ownedNameSpaces.contains(&quot;&quot;) || ownedNameSpaces.contains(role.getNameSpace());</span>
    }

    @TransactionAttribute(TransactionAttributeType.SUPPORTS)
    @Override
    public List&lt;String&gt; getAuthorizedNamespaces(final AuthenticationToken authenticationToken) {
<span class="nc" id="L486">        final Set&lt;String&gt; namespaces = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        for (final int current : roleMemberDataSession.getRoleIdsMatchingAuthenticationToken(authenticationToken)) {</span>
<span class="nc" id="L488">            namespaces.add(roleDataSession.getRole(current).getNameSpace());</span>
<span class="nc" id="L489">        }</span>
<span class="nc bnc" id="L490" title="All 4 branches missed.">        if (namespaces.contains(&quot;&quot;) || authenticationToken instanceof AlwaysAllowLocalAuthenticationToken) {</span>
            // Add all namespaces from authorized roles
<span class="nc bnc" id="L492" title="All 2 branches missed.">            for (final Role role : getAuthorizedRoles(authenticationToken)) {</span>
<span class="nc" id="L493">                namespaces.add(role.getNameSpace());</span>
<span class="nc" id="L494">            }</span>
        }
<span class="nc" id="L496">        return new ArrayList&lt;&gt;(namespaces);</span>
    }
    
    @Override
    public boolean updateCaId(final int caIdOld, final int caIdNew, final boolean keepOldAccessRule, final boolean updateRoleMembers) {
<span class="nc" id="L501">        final String resourceOld = AccessRulesHelper.normalizeResource(StandardRules.CAACCESS.resource() + caIdOld);</span>
<span class="nc" id="L502">        final String resourceNew = AccessRulesHelper.normalizeResource(StandardRules.CAACCESS.resource() + caIdNew);</span>
<span class="nc" id="L503">        boolean hasChangedAnything = false;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        for (final Role role : roleDataSession.getAllRoles()) {</span>
<span class="nc" id="L505">            final Boolean state = role.getAccessRules().get(resourceOld);</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if (state!=null) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                if (!keepOldAccessRule) {</span>
<span class="nc" id="L508">                    role.getAccessRules().remove(resourceOld);</span>
                }
<span class="nc" id="L510">                role.getAccessRules().put(resourceNew, state);</span>
<span class="nc" id="L511">                roleDataSession.persistRole(role);</span>
<span class="nc" id="L512">                hasChangedAnything = true;</span>
            }
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (updateRoleMembers) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                for (final RoleMember roleMember : roleMemberDataSession.findRoleMemberByRoleId(role.getRoleId())) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                    if (roleMember.getTokenIssuerId()==caIdOld) {</span>
                        // Do more expensive checks if it is a potential match
<span class="nc" id="L518">                        final AccessMatchValue accessMatchValue = AccessMatchValueReverseLookupRegistry.INSTANCE.getMetaData(</span>
<span class="nc" id="L519">                                roleMember.getTokenType()).getAccessMatchValueIdMap().get(roleMember.getTokenMatchKey());</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                        if (accessMatchValue.isIssuedByCa()) {</span>
<span class="nc" id="L521">                            roleMember.setTokenIssuerId(caIdNew);</span>
<span class="nc" id="L522">                            roleMemberDataSession.persistRoleMember(roleMember);</span>
<span class="nc" id="L523">                            hasChangedAnything = true;</span>
                        }
                    }
<span class="nc" id="L526">                }</span>
            }
<span class="nc" id="L528">        }</span>
<span class="nc" id="L529">        return hasChangedAnything;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>