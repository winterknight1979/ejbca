<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IntegrityProtectedAuditorSessionBean.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-ejb</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.audit.impl.integrityprotected</a> &gt; <span class="el_source">IntegrityProtectedAuditorSessionBean.java</span></div><h1>IntegrityProtectedAuditorSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.audit.impl.integrityprotected;

import java.io.File;
import java.io.IOException;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TimeZone;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import org.apache.commons.lang.time.FastDateFormat;
import org.apache.log4j.Logger;
import org.cesecore.audit.AuditDevicesConfig;
import org.cesecore.audit.AuditLogEntry;
import org.cesecore.audit.audit.AuditExporter;
import org.cesecore.audit.audit.AuditLogExportReport;
import org.cesecore.audit.audit.AuditLogExporterException;
import org.cesecore.audit.audit.AuditLogReportElem;
import org.cesecore.audit.audit.AuditLogValidationReport;
import org.cesecore.audit.audit.AuditLogValidatorException;
import org.cesecore.audit.audit.SigningFileOutputStream;
import org.cesecore.audit.enums.EventStatus;
import org.cesecore.audit.enums.EventTypes;
import org.cesecore.audit.enums.ModuleTypes;
import org.cesecore.audit.enums.ServiceTypes;
import org.cesecore.audit.log.SecurityEventsLoggerSessionLocal;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.dbprotection.DatabaseProtectionException;
import org.cesecore.keys.token.CryptoToken;
import org.cesecore.util.ValidityDate;
import org.cesecore.util.query.Criteria;
import org.cesecore.util.query.QueryCriteria;
import org.cesecore.util.query.QueryGenerator;

/**
 * This class handles secure logs auditing.
 *
 * &lt;p&gt;This was created to evaluate the performance of using database integrity
 * protection instead of custom code for log singing.
 *
 * &lt;p&gt;The index &quot;CREATE UNIQUE INDEX auditrecorddata_idx1 ON AuditRecordData
 * (nodeId,timeStamp,sequenceNumber);&quot; should be present for proper validation
 * and export performance.
 *
 * @version $Id: IntegrityProtectedAuditorSessionBean.java 31134 2019-01-11
 *     11:08:16Z jeklund $
 */
@Stateless
@TransactionAttribute(TransactionAttributeType.REQUIRED)
<span class="nc" id="L73">public class IntegrityProtectedAuditorSessionBean</span>
    implements IntegrityProtectedAuditorSessionLocal {

    /** Logger. */
<span class="nc" id="L77">  private static final Logger LOG =</span>
<span class="nc" id="L78">      Logger.getLogger(IntegrityProtectedAuditorSessionBean.class);</span>

  /** EM. */
  @PersistenceContext(unitName = CesecoreConfiguration.PERSISTENCE_UNIT)
  private EntityManager entityManager;

  /** Context. */
  @Resource private SessionContext sessionContext;
  /** Logger session. */
  @EJB private SecurityEventsLoggerSessionLocal securityEventsLogger;
  /** Myself needs to be injected in postConstruct. */
  private IntegrityProtectedAuditorSessionLocal
      integrityProtectedAuditorSession;

  /** Set up. */
  @PostConstruct
  public void postConstruct() {
<span class="nc" id="L95">    integrityProtectedAuditorSession =</span>
<span class="nc" id="L96">        sessionContext.getBusinessObject(</span>
            IntegrityProtectedAuditorSessionLocal.class);
<span class="nc" id="L98">  }</span>

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public AuditLogExportReport exportAuditLogs(
      final AuthenticationToken token,
      final CryptoToken cryptoToken,
      final Date timestamp,
      final boolean deleteAfterExport,
      final Map&lt;String, Object&gt; signatureDetails,
      final Properties properties,
      final Class&lt;? extends AuditExporter&gt; c)
      throws AuditLogExporterException {
<span class="nc" id="L111">    final AuditLogExportReport report = new AuditLogExportReport();</span>
    try {
<span class="nc" id="L113">      final File exportFile =</span>
<span class="nc" id="L114">          AuditDevicesConfig.getExportFile(properties, timestamp);</span>
<span class="nc" id="L115">      try (SigningFileOutputStream signingFileOutputStream =</span>
          new SigningFileOutputStream(
              exportFile, cryptoToken, signatureDetails)) {
<span class="nc" id="L118">        final AuditExporter auditExporter = c.getConstructor().newInstance();</span>
<span class="nc" id="L119">        auditExporter.setOutputStream(signingFileOutputStream);</span>
<span class="nc" id="L120">        verifyAndOptionalExport(</span>
            auditExporter,
            report,
            timestamp,
<span class="nc" id="L124">            AuditDevicesConfig.getAuditLogExportFetchSize(properties));</span>
<span class="nc" id="L125">        report.setExportedFile(exportFile.getCanonicalPath());</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L127">          LOG.debug(&quot;Exported &quot; + report.getExportCount() + &quot; rows.&quot;);</span>
        }
<span class="nc" id="L129">        logVerificationResult(report.errors().size(), timestamp, token);</span>
        // Sign the exported file ... it will write the signature on the side
<span class="nc" id="L131">        final String signatureFilename =</span>
<span class="nc" id="L132">            signingFileOutputStream.writeSignature();</span>
<span class="nc" id="L133">        report.setSignatureFile(signatureFilename);</span>
        // Log export success
<span class="nc" id="L135">        final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L136">        details.put(&quot;deleteAfterExport&quot;, deleteAfterExport);</span>
<span class="nc" id="L137">        details.put(</span>
            &quot;timestamp&quot;,
<span class="nc" id="L139">            ValidityDate.formatAsISO8601(</span>
                new Date(), ValidityDate.TIMEZONE_UTC));
<span class="nc" id="L141">        securityEventsLogger.log(</span>
            EventTypes.LOG_EXPORT,
            EventStatus.SUCCESS,
            ModuleTypes.SECURITY_AUDIT,
            ServiceTypes.CORE,
<span class="nc" id="L146">            token.toString(),</span>
            null,
            null,
            null,
            details);
        // Delete the exported log entries if requested
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (deleteAfterExport) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L154">            LOG.debug(&quot;deleting exported logs&quot;);</span>
          }
<span class="nc" id="L156">          final int deletedRowCount =</span>
<span class="nc" id="L157">              integrityProtectedAuditorSession.deleteRows(</span>
                  token, timestamp, properties);
<span class="nc bnc" id="L159" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L160">            LOG.debug(</span>
                &quot;Deleted &quot;
                    + deletedRowCount
                    + &quot; rows from audit log after export.&quot;);
          }
        }
<span class="nc" id="L166">        auditExporter.close();</span>
      }
<span class="nc" id="L168">    } catch (final Exception e) {</span>
<span class="nc" id="L169">      throw new AuditLogExporterException(e.getMessage(), e);</span>
<span class="nc" id="L170">    }</span>
<span class="nc" id="L171">    return report;</span>
  }

  /* Since we modify the database we need to run this in a transaction. */
  @Override
  @TransactionAttribute(TransactionAttributeType.REQUIRED)
  public int deleteRows(
      final AuthenticationToken token,
      final Date timestamp,
      final Properties properties) {
<span class="nc" id="L181">    final Map&lt;String, Object&gt; detailsDelete =</span>
        new LinkedHashMap&lt;String, Object&gt;();
<span class="nc" id="L183">    detailsDelete.put(</span>
        &quot;timestamp&quot;,
<span class="nc" id="L185">        FastDateFormat.getInstance(</span>
<span class="nc" id="L186">                ValidityDate.ISO8601_DATE_FORMAT, TimeZone.getTimeZone(&quot;GMT&quot;))</span>
<span class="nc" id="L187">            .format(timestamp));</span>
<span class="nc" id="L188">    securityEventsLogger.log(</span>
        EventTypes.LOG_DELETE,
        EventStatus.VOID,
        ModuleTypes.SECURITY_AUDIT,
        ServiceTypes.CORE,
<span class="nc" id="L193">        token.toString(),</span>
        null,
        null,
        null,
        detailsDelete);
    // Delete all the exported logs (from all nodes)
    final QueryCriteria queryCriteria =
<span class="nc" id="L200">        QueryCriteria.create()</span>
<span class="nc" id="L201">            .add(</span>
<span class="nc" id="L202">                Criteria.leq(</span>
<span class="nc" id="L203">                    AuditLogEntry.FIELD_TIMESTAMP, timestamp.getTime()));</span>
<span class="nc" id="L204">    return buildConditionalQuery(</span>
            entityManager, &quot;DELETE FROM AuditRecordData a&quot;, queryCriteria, 0, 0)
<span class="nc" id="L206">        .executeUpdate();</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.SUPPORTS)
  public List&lt;? extends AuditLogEntry&gt; selectAuditLogs(
      final AuthenticationToken token,
      final int startIndex,
      final int max,
      final QueryCriteria criteria,
      final Properties properties) {
<span class="nc" id="L217">    return internalSelectAuditLogs(startIndex, max, criteria);</span>
  }

  @Override
  @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
  public AuditLogValidationReport verifyLogsIntegrity(
      final AuthenticationToken token,
      final Date timestamp,
      final Properties properties)
      throws AuditLogValidatorException {
<span class="nc" id="L227">    final AuditLogValidationReport report = new AuditLogValidationReport();</span>
    try {
<span class="nc" id="L229">      verifyAndOptionalExport(</span>
          null,
          report,
          timestamp,
<span class="nc" id="L233">          AuditDevicesConfig.getAuditLogExportFetchSize(properties));</span>
      // Log the success or failure depending on if verification returns error
      // or not
<span class="nc" id="L236">      logVerificationResult(report.errors().size(), timestamp, token);</span>
<span class="nc" id="L237">    } catch (final Exception e) {</span>
<span class="nc" id="L238">      throw new AuditLogValidatorException(e.getMessage(), e);</span>
<span class="nc" id="L239">    }</span>
<span class="nc" id="L240">    return report;</span>
  }

  /**
   * Read batches of logs from the database. If the database integrity check
   * fails, the batch will be processed row by row. Results are added to the
   * report.
   *
   * @param auditExporter can be null if no export should take place
   * @param report is a AuditLogValidationReport or AuditLogExportReport
   * @param timestamp process all entries up until this time (should be epoch
   *     GMT)
   * @param fetchSize size
   * @throws IOException if io fails
   */
  private void verifyAndOptionalExport(
      final AuditExporter auditExporter,
      final AuditLogValidationReport report,
      final Date timestamp,
      final int fetchSize)
      throws IOException {
    // Get a list of the nodes that have data in the database
<span class="nc bnc" id="L262" title="All 2 branches missed.">    for (final String nodeId : getNodeIds()) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L264">        LOG.debug(&quot;exportAuditLogs for nodeId &quot; + nodeId);</span>
      }
      // Assuming timeStamp is in UTC
      final QueryCriteria queryCriteria =
<span class="nc" id="L268">          QueryCriteria.create()</span>
<span class="nc" id="L269">              .add(</span>
<span class="nc" id="L270">                  (Criteria.and(</span>
<span class="nc" id="L271">                      Criteria.eq(AuditLogEntry.FIELD_NODEID, nodeId),</span>
<span class="nc" id="L272">                      Criteria.leq(</span>
<span class="nc" id="L273">                          AuditLogEntry.FIELD_TIMESTAMP, timestamp.getTime()))))</span>
<span class="nc" id="L274">              .add(Criteria.orderAsc(AuditLogEntry.FIELD_SEQUENCENUMBER));</span>
<span class="nc" id="L275">      int startIndex = 1;</span>
<span class="nc" id="L276">      final Holder&lt;Long&gt; lastSeqNumber = new Holder&lt;Long&gt;(Long.valueOf(-1L));</span>
      while (true) {
        try {
<span class="nc" id="L279">          final List&lt;AuditRecordData&gt; queryResult =</span>
<span class="nc" id="L280">              verifyLogsIntegritySubset(</span>
                  startIndex,
                  fetchSize,
                  queryCriteria,
                  report,
                  lastSeqNumber,
                  nodeId);
<span class="nc" id="L287">          final int results = queryResult.size();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">          if (results == 0) {</span>
<span class="nc" id="L289">            break; // No more data for this node</span>
          }
<span class="nc" id="L291">          startIndex += results;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">          if (auditExporter != null) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            for (final AuditRecordData auditRecordData : queryResult) {</span>
<span class="nc" id="L294">              writeToExport(auditExporter, auditRecordData);</span>
<span class="nc" id="L295">              ((AuditLogExportReport) report).incExportCount();</span>
<span class="nc" id="L296">            }</span>
          }
<span class="nc" id="L298">        } catch (DatabaseProtectionException e) {</span>
          // One of the FETCH_SIZE entries failed.. we have to go through line
          // by line to find out witch one..
<span class="nc bnc" id="L301" title="All 2 branches missed.">          for (int i = 0; i &lt; fetchSize; i++) {</span>
            try {
<span class="nc" id="L303">              final List&lt;AuditRecordData&gt; queryResult =</span>
<span class="nc" id="L304">                  verifyLogsIntegritySubset(</span>
                      startIndex,
                      1,
                      queryCriteria,
                      report,
                      lastSeqNumber,
                      nodeId);
<span class="nc" id="L311">              final int results = queryResult.size();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">              if (results != 1) {</span>
<span class="nc" id="L313">                break; // No more data for this node</span>
              }
<span class="nc bnc" id="L315" title="All 2 branches missed.">              if (auditExporter != null) {</span>
<span class="nc" id="L316">                writeToExport(auditExporter, queryResult.get(0));</span>
<span class="nc" id="L317">                ((AuditLogExportReport) report).incExportCount();</span>
              }
<span class="nc" id="L319">            } catch (DatabaseProtectionException e2) {</span>
<span class="nc" id="L320">              final AuditRecordData auditRecordData =</span>
<span class="nc" id="L321">                  (AuditRecordData) e2.getEntity();</span>
              // Add to report
<span class="nc" id="L323">              report.warn(</span>
                  new AuditLogReportElem(
<span class="nc" id="L325">                      lastSeqNumber.get().longValue(),</span>
<span class="nc" id="L326">                      auditRecordData.getSequenceNumber(),</span>
                      &quot;log with sequence number after &quot;
                          + lastSeqNumber
                          + &quot; on nodeId &quot;
                          + nodeId
                          + &quot; could not be verified&quot;));
<span class="nc" id="L332">              lastSeqNumber.set(auditRecordData.getSequenceNumber());</span>
              // We still export it
              // TODO: It might make sense to make it configurable to export
              // when verification fails..
<span class="nc bnc" id="L336" title="All 2 branches missed.">              if (auditExporter != null) {</span>
<span class="nc" id="L337">                writeToExport(auditExporter, auditRecordData);</span>
<span class="nc" id="L338">                ((AuditLogExportReport) report).incExportCount();</span>
              }
<span class="nc" id="L340">            }</span>
<span class="nc" id="L341">            startIndex += 1;</span>
          }
<span class="nc" id="L343">        }</span>
      }
<span class="nc" id="L345">    }</span>
<span class="nc" id="L346">  }</span>

  /**
   * We want to export exactly like it was stored in the database, to comply
   * with requirements on logging systems where no altering of the original log
   * data is allowed.
   *
   * @param auditExporter Exporter
   * @param auditRecordData Data to export
   * @throws IOException if write fails
   */
  private void writeToExport(
      final AuditExporter auditExporter, final AuditRecordData auditRecordData)
      throws IOException {
<span class="nc" id="L360">    auditExporter.writeStartObject();</span>
<span class="nc" id="L361">    auditExporter.writeField(&quot;pk&quot;, auditRecordData.getPk());</span>
<span class="nc" id="L362">    auditExporter.writeField(&quot;nodeId&quot;, auditRecordData.getNodeId());</span>
<span class="nc" id="L363">    auditExporter.writeField(</span>
<span class="nc" id="L364">        &quot;sequenceNumber&quot;, auditRecordData.getSequenceNumber());</span>
<span class="nc" id="L365">    auditExporter.writeField(&quot;timestamp&quot;, auditRecordData.getTimeStamp());</span>
<span class="nc" id="L366">    auditExporter.writeField(</span>
<span class="nc" id="L367">        &quot;eventType&quot;, auditRecordData.getEventTypeValue().toString());</span>
<span class="nc" id="L368">    auditExporter.writeField(</span>
<span class="nc" id="L369">        &quot;eventStatus&quot;, auditRecordData.getEventStatusValue().toString());</span>
<span class="nc" id="L370">    auditExporter.writeField(&quot;authToken&quot;, auditRecordData.getAuthToken());</span>
<span class="nc" id="L371">    auditExporter.writeField(</span>
<span class="nc" id="L372">        &quot;service&quot;, auditRecordData.getServiceTypeValue().toString());</span>
<span class="nc" id="L373">    auditExporter.writeField(</span>
<span class="nc" id="L374">        &quot;module&quot;, auditRecordData.getModuleTypeValue().toString());</span>
<span class="nc" id="L375">    auditExporter.writeField(&quot;customId&quot;, auditRecordData.getCustomId());</span>
<span class="nc" id="L376">    auditExporter.writeField(</span>
<span class="nc" id="L377">        &quot;searchDetail1&quot;, auditRecordData.getSearchDetail1());</span>
<span class="nc" id="L378">    auditExporter.writeField(</span>
<span class="nc" id="L379">        &quot;searchDetail2&quot;, auditRecordData.getSearchDetail2());</span>
<span class="nc" id="L380">    auditExporter.writeField(</span>
<span class="nc" id="L381">        &quot;additionalDetails&quot;, auditRecordData.getAdditionalDetails());</span>
<span class="nc" id="L382">    auditExporter.writeField(</span>
<span class="nc" id="L383">        &quot;rowProtection&quot;, auditRecordData.getRowProtection());</span>
<span class="nc" id="L384">    auditExporter.writeEndObject();</span>
<span class="nc" id="L385">  }</span>

  /**
   * Fetch a batch of log rows from the database (implying database integrity
   * check) and verifies that all sequence numbers are present.
   *
   * @param startIndex start batch from this position
   * @param max entries per batch
   * @param queryCriteria where clause
   * @param report will be updated when a problem is found
   * @param lastSeqNumber will be updated to the last sequence number processed
   *     in this subset
   * @param nodeId identifier of which node that claims to have written this
   *     data
   * @return the log entries we fetched from the database so the caller may
   *     export these
   * @throws DatabaseProtectionException if the intregrity verification fails
   *     for one of the entries in the batch during fetch
   */
  private List&lt;AuditRecordData&gt; verifyLogsIntegritySubset(
      final int startIndex,
      final int max,
      final QueryCriteria queryCriteria,
      final AuditLogValidationReport report,
      final Holder&lt;Long&gt; lastSeqNumber,
      final String nodeId)
      throws DatabaseProtectionException {
<span class="nc" id="L412">    final List&lt;AuditRecordData&gt; queryResult =</span>
<span class="nc" id="L413">        internalSelectAuditLogs(</span>
            startIndex,
            max,
            queryCriteria); // Might throw DatabaseProtectionException
    // Loop through results and verify that the sequence order is correct
<span class="nc bnc" id="L418" title="All 2 branches missed.">    for (int i = 0; i &lt; queryResult.size(); i++) {</span>
<span class="nc" id="L419">      final long currentSeqNumber =</span>
<span class="nc" id="L420">          queryResult.get(i).getSequenceNumber().longValue();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">      if (currentSeqNumber != lastSeqNumber.get().longValue() + 1) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L423">          LOG.debug(</span>
              &quot;Log verification failure for log on node &quot;
                  + nodeId
                  + &quot;. Missing entry. Last sequenceNumber was &quot;
                  + lastSeqNumber
                  + &quot; and current is &quot;
                  + currentSeqNumber);
        }
        // Add to report
<span class="nc" id="L432">        report.warn(</span>
            new AuditLogReportElem(
<span class="nc" id="L434">                lastSeqNumber.get(),</span>
<span class="nc" id="L435">                Long.valueOf(currentSeqNumber),</span>
                &quot;missing log with sequence number &quot;
<span class="nc" id="L437">                    + (lastSeqNumber.get().longValue() + 1)</span>
                    + &quot; on nodeId &quot;
                    + nodeId));
      }
<span class="nc" id="L441">      lastSeqNumber.set(Long.valueOf(currentSeqNumber));</span>
    }
<span class="nc" id="L443">    return queryResult;</span>
  }

  /**
   * Log the outcome of the verification to the secure audit log based on the
   * supplied number of errors.
   *
   * @param errors Errors
   * @param timestamp time
   * @param token Authorization
   */
  private void logVerificationResult(
      final int errors, final Date timestamp, final AuthenticationToken token) {
<span class="nc" id="L456">    final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L457">    details.put(</span>
        &quot;timestamp&quot;,
<span class="nc" id="L459">        FastDateFormat.getInstance(</span>
<span class="nc" id="L460">                ValidityDate.ISO8601_DATE_FORMAT, TimeZone.getTimeZone(&quot;GMT&quot;))</span>
<span class="nc" id="L461">            .format(timestamp));</span>
<span class="nc" id="L462">    EventStatus status = EventStatus.SUCCESS;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">    if (errors &gt; 0) {</span>
<span class="nc" id="L464">      status = EventStatus.FAILURE;</span>
<span class="nc" id="L465">      details.put(&quot;errors&quot;, errors);</span>
    }
<span class="nc" id="L467">    securityEventsLogger.log(</span>
        EventTypes.LOG_VERIFY,
        status,
        ModuleTypes.SECURITY_AUDIT,
        ServiceTypes.CORE,
<span class="nc" id="L472">        token.toString(),</span>
        null,
        null,
        null,
        details);
<span class="nc" id="L477">  }</span>

  /**
   * Select log entries using the supplied criteria. Optionally using startIndex
   * and resultLimit (used if &gt;0).
   *
   * @param startIndex Index
   * @param max no. of records
   * @param criteria search criteria
   * @return log entries
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;AuditRecordData&gt; internalSelectAuditLogs(
      final int startIndex, final int max, final QueryCriteria criteria) {
<span class="nc" id="L491">    return buildConditionalQuery(</span>
            entityManager,
            &quot;SELECT a FROM AuditRecordData a&quot;,
            criteria,
            startIndex,
            max)
<span class="nc" id="L497">        .getResultList();</span>
  }

  /**
   * @return a unique list of node identifiers that have been writing audit log
   *     to the database.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private List&lt;String&gt; getNodeIds() {
<span class="nc" id="L506">    return entityManager</span>
<span class="nc" id="L507">        .createQuery(&quot;SELECT DISTINCT a.nodeId FROM AuditRecordData a&quot;)</span>
<span class="nc" id="L508">        .getResultList();</span>
  }

  /**
   * Build a JPA Query from the supplied queryStr and criteria. Optionally using
   * startIndex and resultLimit (used if &gt;0).
   *
   * @param theEntityManager EM
   * @param queryStr Query
   * @param criteria Criteria
   * @param startIndex Index
   * @param resultLimit Max results
   * @return JPA query
   */
  private Query buildConditionalQuery(
      final EntityManager theEntityManager,
      final String queryStr,
      final QueryCriteria criteria,
      final int startIndex,
      final int resultLimit) {
<span class="nc" id="L528">    Query query = null;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">    if (criteria == null) {</span>
<span class="nc" id="L530">      query = theEntityManager.createQuery(queryStr);</span>
    } else {
<span class="nc" id="L532">      QueryGenerator generator =</span>
<span class="nc" id="L533">          QueryGenerator.generator(AuditRecordData.class, criteria, &quot;a&quot;);</span>
<span class="nc" id="L534">      final String conditions = generator.generate();</span>
<span class="nc" id="L535">      query = theEntityManager.createQuery(queryStr + conditions);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">      for (final String key : generator.getParameterKeys()) {</span>
<span class="nc" id="L537">        final Object param = generator.getParameterValue(key);</span>
<span class="nc" id="L538">        query.setParameter(key, param);</span>
<span class="nc" id="L539">      }</span>
    }
<span class="nc bnc" id="L541" title="All 2 branches missed.">    if (resultLimit &gt; 0) {</span>
<span class="nc" id="L542">      query.setMaxResults(resultLimit);</span>
    }
<span class="nc bnc" id="L544" title="All 2 branches missed.">    if (startIndex &gt; 0) {</span>
<span class="nc" id="L545">      query.setFirstResult(startIndex - 1);</span>
    }
<span class="nc" id="L547">    return query;</span>
  }

  /**
   * Class used internally for holding an object that can updated by a method.
   *
   * @param &lt;T&gt; Type
   */
  private class Holder&lt;T&gt; {
      /** Object. */
    private T object;

<span class="nc" id="L559">    Holder(final T anObject) {</span>
<span class="nc" id="L560">      set(anObject);</span>
<span class="nc" id="L561">    }</span>

    /**
     * @param anObject object
     */
    public void set(final T anObject) {
<span class="nc" id="L567">      this.object = anObject;</span>
<span class="nc" id="L568">    }</span>

    public T get() {
<span class="nc" id="L571">      return object;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>