<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>KeyValidatorSessionBean.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Unit Test Aggregator</a> &gt; <a href="../index.html" class="el_bundle">cesecore-ejb</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.validation</a> &gt; <span class="el_source">KeyValidatorSessionBean.java</span></div><h1>KeyValidatorSessionBean.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General                  *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.keys.validation;

import java.io.Serializable;
import java.security.PublicKey;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import org.apache.commons.collections.CollectionUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.util.encoders.Base64;
import org.cesecore.audit.enums.EventStatus;
import org.cesecore.audit.enums.EventTypes;
import org.cesecore.audit.enums.ModuleTypes;
import org.cesecore.audit.enums.ServiceTypes;
import org.cesecore.audit.log.SecurityEventsLoggerSessionLocal;
import org.cesecore.authentication.tokens.AuthenticationToken;
import org.cesecore.authorization.AuthorizationDeniedException;
import org.cesecore.authorization.AuthorizationSessionLocal;
import org.cesecore.authorization.control.StandardRules;
import org.cesecore.certificates.ca.CA;
import org.cesecore.certificates.ca.CaSessionLocal;
import org.cesecore.certificates.ca.IllegalValidityException;
import org.cesecore.certificates.ca.internal.CertificateValidity;
import org.cesecore.certificates.certificate.request.RequestMessage;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificateprofile.CertificateProfileSessionLocal;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.config.ExternalScriptsConfiguration;
import org.cesecore.configuration.GlobalConfigurationSessionLocal;
import org.cesecore.internal.InternalResources;
import org.cesecore.jndi.JndiConstants;
import org.cesecore.profiles.ProfileData;
import org.cesecore.profiles.ProfileSessionLocal;
import org.cesecore.util.CertTools;

/**
 * Handles management of key validators.
 *
 * @version $Id: KeyValidatorSessionBean.java 29947 2018-10-02 06:56:41Z aminkh
 *     $
 */
@Stateless(
    mappedName = JndiConstants.APP_JNDI_PREFIX + &quot;KeyValidatorSessionRemote&quot;)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
<span class="nc" id="L74">public class KeyValidatorSessionBean</span>
    implements KeyValidatorSessionLocal, KeyValidatorSessionRemote {

  /** NOTE: Should be replaced by a ManagedExecutorService when we drop support
   * for JEE 6. */
<span class="nc" id="L79">  private static final ExecutorService EXECUTOR_SERVICE =</span>
<span class="nc" id="L80">      Executors.newFixedThreadPool(64);</span>

  /** Class logger. */
<span class="nc" id="L83">  private static final Logger LOG =</span>
<span class="nc" id="L84">      Logger.getLogger(KeyValidatorSessionBean.class);</span>

  /** Internal localization of logs and errors. */
<span class="nc" id="L87">  private static final InternalResources INTRES =</span>
<span class="nc" id="L88">      InternalResources.getInstance();</span>

  /** Session. */
  @EJB private AuthorizationSessionLocal authorizationSession;
  /** Session. */
  @EJB private GlobalConfigurationSessionLocal globalConfigurationSession;
  /** Session. */
  @EJB private CaSessionLocal caSession;
  /** Session. */
  @EJB private CertificateProfileSessionLocal certificateProfileSession;
  /** Session. */
  @EJB private ProfileSessionLocal profileSession;
  /** Session. */
  @EJB private SecurityEventsLoggerSessionLocal auditSession;

  @Override
  public Validator getValidator(final int id) {
<span class="nc" id="L105">    return getValidatorInternal(id, true);</span>
  }

  @Override
  public String getKeyValidatorName(final int id) {
<span class="nc bnc" id="L110" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L111">      LOG.trace(&quot;&gt;getKeyValidatorName(id: &quot; + id + &quot;)&quot;);</span>
    }
<span class="nc" id="L113">    final Validator entity = getValidatorInternal(id, true);</span>
<span class="nc" id="L114">    String result = null;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">    if (null != entity) {</span>
<span class="nc" id="L116">      result = entity.getProfileName();</span>
    }
<span class="nc bnc" id="L118" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L119">      LOG.trace(&quot;&lt;getKeyValidatorName(): &quot; + result);</span>
    }
<span class="nc" id="L121">    return result;</span>
  }

  @Override
  public void importValidator(
      final AuthenticationToken admin, final Validator validator)
      throws AuthorizationDeniedException, KeyValidatorExistsException {
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L129">      LOG.trace(</span>
          &quot;&gt;addKeyValidator(name: &quot;
<span class="nc" id="L131">              + validator.getProfileName()</span>
              + &quot;, id: &quot;
<span class="nc" id="L133">              + validator.getProfileId()</span>
              + &quot;)&quot;);
    }
<span class="nc" id="L136">    addValidatorInternal(admin, validator);</span>
<span class="nc" id="L137">    final String message =</span>
<span class="nc" id="L138">        INTRES.getLocalizedMessage(</span>
<span class="nc" id="L139">            &quot;validator.added_validator&quot;, validator.getProfileName());</span>
<span class="nc" id="L140">    final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L141">    details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L142">    auditSession.log(</span>
        EventTypes.VALIDATOR_CREATION,
        EventStatus.SUCCESS,
        ModuleTypes.VALIDATOR,
        ServiceTypes.CORE,
<span class="nc" id="L147">        admin.toString(),</span>
        null,
        null,
        null,
        details);
<span class="nc bnc" id="L152" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L153">      LOG.trace(&quot;&lt;addKeyValidator()&quot;);</span>
    }
<span class="nc" id="L155">  }</span>

  @Override
  public void changeKeyValidator(
      final AuthenticationToken admin, final Validator validator)
      throws AuthorizationDeniedException, KeyValidatorDoesntExistsException {
<span class="nc" id="L161">    assertIsAuthorizedToEditValidators(admin);</span>
<span class="nc" id="L162">    ProfileData data = profileSession.findById(validator.getProfileId());</span>
    final String message;
<span class="nc" id="L164">    final String name = validator.getProfileName();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">    if (data != null) {</span>
<span class="nc" id="L166">      profileSession.changeProfile(validator);</span>
      // Since loading a KeyValidator is quite complex, we simple purge the
      // cache here.
<span class="nc" id="L169">      ValidatorCache.INSTANCE.removeEntry(data.getId());</span>
<span class="nc" id="L170">      message = INTRES.getLocalizedMessage(&quot;validator.changed_validator&quot;, name);</span>
<span class="nc" id="L171">      final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L172">      details.put(&quot;msg&quot;, message);</span>
      // TODO: Include a diff in the changelog
      // (profileData.getProfile().diff(profile);), but make sure to resolve all
      // steps so that we don't
      //      output a ton of serialized garbage (see ECA-5276)
<span class="nc" id="L177">      auditSession.log(</span>
          EventTypes.VALIDATOR_CHANGE,
          EventStatus.SUCCESS,
          ModuleTypes.VALIDATOR,
          ServiceTypes.CORE,
<span class="nc" id="L182">          admin.toString(),</span>
          null,
          null,
          null,
          details);
<span class="nc" id="L187">    } else {</span>
<span class="nc" id="L188">      message =</span>
<span class="nc" id="L189">          INTRES.getLocalizedMessage(&quot;validator.error.change_validator&quot;, name);</span>
<span class="nc" id="L190">      LOG.info(message);</span>
<span class="nc" id="L191">      throw new KeyValidatorDoesntExistsException(</span>
          &quot;Validator by ID &quot;
<span class="nc" id="L193">              + validator.getProfileId()</span>
              + &quot; does not exist in database.&quot;);
    }
<span class="nc" id="L196">  }</span>

  @Override
  public void removeKeyValidator(
      final AuthenticationToken admin, final int validatorId)
      throws AuthorizationDeniedException, CouldNotRemoveKeyValidatorException {
<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L203">      LOG.trace(&quot;&gt;removeKeyValidator(id: &quot; + validatorId + &quot;)&quot;);</span>
    }
<span class="nc" id="L205">    assertIsAuthorizedToEditValidators(admin);</span>
    String message;

<span class="nc" id="L208">    ProfileData data = profileSession.findById(validatorId);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (data == null) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L211">        LOG.debug(</span>
            &quot;Trying to remove a key validator that does not exist with ID: &quot;
                + validatorId);
      }
<span class="nc" id="L215">      return;</span>
    }

<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (caSession.existsKeyValidatorInCAs(data.getId())) {</span>
<span class="nc" id="L219">      throw new CouldNotRemoveKeyValidatorException();</span>
    }

<span class="nc" id="L222">    profileSession.removeProfile(data);</span>
    // Purge the cache here.
<span class="nc" id="L224">    ValidatorCache.INSTANCE.removeEntry(data.getId());</span>
<span class="nc" id="L225">    message =</span>
<span class="nc" id="L226">        INTRES.getLocalizedMessage(</span>
<span class="nc" id="L227">            &quot;validator.removed_validator&quot;, data.getProfileName());</span>
<span class="nc" id="L228">    final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L229">    details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L230">    auditSession.log(</span>
        EventTypes.VALIDATOR_REMOVAL,
        EventStatus.SUCCESS,
        ModuleTypes.VALIDATOR,
        ServiceTypes.CORE,
<span class="nc" id="L235">        admin.toString(),</span>
        null,
        null,
        null,
        details);
<span class="nc bnc" id="L240" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L241">      LOG.trace(&quot;&lt;removeKeyValidator()&quot;);</span>
    }
<span class="nc" id="L243">  }</span>

  @Override
  public void removeKeyValidator(
      final AuthenticationToken admin, final String validatorName)
      throws AuthorizationDeniedException, CouldNotRemoveKeyValidatorException {
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L250">      LOG.trace(&quot;&gt;removeKeyValidator(id: &quot; + validatorName + &quot;)&quot;);</span>
    }
<span class="nc" id="L252">    assertIsAuthorizedToEditValidators(admin);</span>
    String message;

<span class="nc" id="L255">    List&lt;ProfileData&gt; datas =</span>
<span class="nc" id="L256">        profileSession.findByNameAndType(validatorName, Validator.TYPE_NAME);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">    if (datas == null) {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L259">        LOG.debug(</span>
            &quot;Trying to remove a key validator that does not exist with name: &quot;
                + validatorName);
      }
<span class="nc" id="L263">      return;</span>
    } else {
<span class="nc bnc" id="L265" title="All 2 branches missed.">      for (ProfileData data : datas) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (caSession.existsKeyValidatorInCAs(data.getId())) {</span>
<span class="nc" id="L267">          throw new CouldNotRemoveKeyValidatorException();</span>
        }
<span class="nc" id="L269">        profileSession.removeProfile(data);</span>
        // Purge the cache here.
<span class="nc" id="L271">        ValidatorCache.INSTANCE.removeEntry(data.getId());</span>
<span class="nc" id="L272">        message =</span>
<span class="nc" id="L273">            INTRES.getLocalizedMessage(</span>
<span class="nc" id="L274">                &quot;validator.removed_validator&quot;, data.getProfileName());</span>
<span class="nc" id="L275">        final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L276">        details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L277">        auditSession.log(</span>
            EventTypes.VALIDATOR_REMOVAL,
            EventStatus.SUCCESS,
            ModuleTypes.VALIDATOR,
            ServiceTypes.CORE,
<span class="nc" id="L282">            admin.toString(),</span>
            null,
            null,
            null,
            details);
<span class="nc" id="L287">      }</span>
    }

<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L291">      LOG.trace(&quot;&lt;removeKeyValidator()&quot;);</span>
    }
<span class="nc" id="L293">  }</span>

  @Override
  public void flushKeyValidatorCache() {
<span class="nc" id="L297">    ValidatorCache.INSTANCE.flush();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L299">      LOG.debug(&quot;Flushed KeyValidator cache.&quot;);</span>
    }
<span class="nc" id="L301">  }</span>

  @Override
  public int addKeyValidator(
      final AuthenticationToken admin, final Validator validator)
      throws AuthorizationDeniedException, KeyValidatorExistsException {
<span class="nc" id="L307">    final int id = addValidatorInternal(admin, validator);</span>
<span class="nc" id="L308">    final String message =</span>
<span class="nc" id="L309">        INTRES.getLocalizedMessage(</span>
<span class="nc" id="L310">            &quot;validator.added_validator&quot;, validator.getProfileName());</span>
<span class="nc" id="L311">    final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L312">    details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L313">    auditSession.log(</span>
        EventTypes.VALIDATOR_CREATION,
        EventStatus.SUCCESS,
        ModuleTypes.VALIDATOR,
        ServiceTypes.CORE,
<span class="nc" id="L318">        admin.toString(),</span>
        null,
        null,
        null,
        details);
<span class="nc" id="L323">    return id;</span>
  }

  @Override
  public void cloneKeyValidator(
      final AuthenticationToken admin,
      final int validatorId,
      final String newName)
      throws AuthorizationDeniedException, KeyValidatorDoesntExistsException,
          KeyValidatorExistsException {
<span class="nc" id="L333">    cloneKeyValidator(admin, getValidatorInternal(validatorId, true), newName);</span>
<span class="nc" id="L334">  }</span>

  @Override
  public void cloneKeyValidator(
      final AuthenticationToken admin,
      final Validator validator,
      final String newName)
      throws AuthorizationDeniedException, KeyValidatorDoesntExistsException,
          KeyValidatorExistsException {
<span class="nc" id="L343">    Validator validatorClone = null;</span>
<span class="nc" id="L344">    final Integer origProfileId = validator.getProfileId();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">    if (origProfileId == null) {</span>
<span class="nc" id="L346">      throw new KeyValidatorDoesntExistsException(</span>
<span class="nc" id="L347">          &quot;Could not find key validator &quot; + validator.getProfileName());</span>
    }
<span class="nc" id="L349">    validatorClone = getValidator(origProfileId).clone();</span>
<span class="nc" id="L350">    validatorClone.setProfileName(newName);</span>
    try {
<span class="nc" id="L352">      addValidatorInternal(admin, validatorClone);</span>
<span class="nc" id="L353">      final String message =</span>
<span class="nc" id="L354">          INTRES.getLocalizedMessage(</span>
              &quot;validator.cloned_validator&quot;,
              newName,
<span class="nc" id="L357">              validator.getProfileName());</span>
<span class="nc" id="L358">      final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L359">      details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L360">      auditSession.log(</span>
          EventTypes.VALIDATOR_CREATION,
          EventStatus.SUCCESS,
          ModuleTypes.VALIDATOR,
          ServiceTypes.CORE,
<span class="nc" id="L365">          admin.toString(),</span>
          null,
          null,
          null,
          details);
<span class="nc" id="L370">    } catch (KeyValidatorExistsException e) {</span>
<span class="nc" id="L371">      final String message =</span>
<span class="nc" id="L372">          INTRES.getLocalizedMessage(</span>
              &quot;validator.error.clone_validator&quot;,
              newName,
<span class="nc" id="L375">              validator.getProfileName());</span>
<span class="nc" id="L376">      LOG.info(message);</span>
<span class="nc" id="L377">      throw e;</span>
<span class="nc" id="L378">    }</span>
<span class="nc" id="L379">  }</span>

  @Override
  public void renameKeyValidator(
      final AuthenticationToken admin,
      final int validatorId,
      final String newName)
      throws AuthorizationDeniedException, KeyValidatorDoesntExistsException,
          KeyValidatorExistsException {
<span class="nc" id="L388">    renameKeyValidator(admin, getValidatorInternal(validatorId, true), newName);</span>
<span class="nc" id="L389">  }</span>

  @Override
  public void renameKeyValidator(
      final AuthenticationToken admin,
      final Validator validator,
      final String newName)
      throws AuthorizationDeniedException, KeyValidatorDoesntExistsException,
          KeyValidatorExistsException {
<span class="nc bnc" id="L398" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L399">      LOG.trace(</span>
          &quot;&gt;renameKeyValidator(from &quot;
<span class="nc" id="L401">              + validator.getProfileName()</span>
              + &quot; to &quot;
              + newName
              + &quot;)&quot;);
    }
<span class="nc" id="L406">    assertIsAuthorizedToEditValidators(admin);</span>
<span class="nc" id="L407">    boolean success = false;</span>
<span class="nc" id="L408">    if (profileSession</span>
<span class="nc" id="L409">        .findByNameAndType(newName, Validator.TYPE_NAME)</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        .isEmpty()) {</span>
<span class="nc" id="L411">      ProfileData data = profileSession.findById(validator.getProfileId());</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">      if (data != null) {</span>
<span class="nc" id="L413">        data.setProfileName(newName);</span>
<span class="nc" id="L414">        success = true;</span>
        // Since loading a key validator is quite complex, we simple purge the
        // cache here.
<span class="nc" id="L417">        ValidatorCache.INSTANCE.removeEntry(data.getId());</span>
      }
    }
<span class="nc bnc" id="L420" title="All 2 branches missed.">    if (success) {</span>
<span class="nc" id="L421">      final String message =</span>
<span class="nc" id="L422">          INTRES.getLocalizedMessage(</span>
              &quot;validator.renamed_validator&quot;,
<span class="nc" id="L424">              validator.getProfileName(),</span>
              newName);
<span class="nc" id="L426">      final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L427">      details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L428">      auditSession.log(</span>
          EventTypes.VALIDATOR_RENAME,
          EventStatus.SUCCESS,
          ModuleTypes.VALIDATOR,
          ServiceTypes.CORE,
<span class="nc" id="L433">          admin.toString(),</span>
          null,
          null,
          null,
          details);
<span class="nc" id="L438">    } else {</span>
<span class="nc" id="L439">      final String message =</span>
<span class="nc" id="L440">          INTRES.getLocalizedMessage(</span>
              &quot;validator.errorrenamekeyvalidator&quot;,
<span class="nc" id="L442">              validator.getProfileName(),</span>
              newName);
<span class="nc" id="L444">      LOG.info(message);</span>
<span class="nc" id="L445">      throw new KeyValidatorExistsException();</span>
    }
<span class="nc bnc" id="L447" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L448">      LOG.trace(&quot;&lt;renameKeyValidator()&quot;);</span>
    }
<span class="nc" id="L450">  }</span>

  @Override
  public Map&lt;Integer, Validator&gt; getAllKeyValidators() {
<span class="nc" id="L454">    final List&lt;ProfileData&gt; keyValidators =</span>
<span class="nc" id="L455">        findAllProfiles(Validator.TYPE_NAME);</span>
<span class="nc" id="L456">    final Map&lt;Integer, Validator&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc" id="L457">    final boolean enabled =</span>
        ((ExternalScriptsConfiguration)
<span class="nc" id="L459">                globalConfigurationSession.getCachedConfiguration(&quot;0&quot;))</span>
<span class="nc" id="L460">            .getEnableExternalScripts();</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">    for (ProfileData data : keyValidators) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">      if (!enabled</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">          &amp;&amp; data.getProfile() instanceof ExternalCommandCertificateValidator) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L465">          LOG.trace(</span>
              &quot;Skip &quot;
<span class="nc" id="L467">                  + data.getProfileType()</span>
                  + &quot; with name &quot;
<span class="nc" id="L469">                  + data.getProfileName()</span>
                  + &quot; because calls for external command certificate&quot;
                  + &quot; validators are disabled.&quot;);
        }
        continue;
      }
      // Cast is safe since we know we retrieved the correct implementation
      try {
<span class="nc" id="L477">        result.put(data.getId(), (Validator) data.getProfile());</span>
<span class="nc" id="L478">      } catch (IllegalStateException e) {</span>
        // NOPMD: Implementation not available in this version if EJBCA
<span class="nc" id="L480">      }</span>
<span class="nc" id="L481">    }</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">      for (Integer id : result.keySet()) {</span>
<span class="nc" id="L484">        LOG.debug(</span>
            &quot;Key validators found in datastore: &quot;
                + id
                + &quot;:&quot;
<span class="nc" id="L488">                + result.get(id).getProfileName());</span>
<span class="nc" id="L489">      }</span>
    }
<span class="nc" id="L491">    return result;</span>
  }

  // Not used.
  @Override
  public Map&lt;Integer, Validator&gt; getKeyValidatorsById(
      final Collection&lt;Integer&gt; ids) {
<span class="nc" id="L498">    final List&lt;ProfileData&gt; keyValidators =</span>
<span class="nc" id="L499">        findAllProfiles(Validator.TYPE_NAME);</span>
<span class="nc" id="L500">    final Map&lt;Integer, Validator&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">    for (ProfileData data : keyValidators) {</span>
<span class="nc" id="L502">      result.put(data.getId(), (Validator) data.getProfile());</span>
<span class="nc" id="L503">    }</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">      for (Integer id : result.keySet()) {</span>
<span class="nc" id="L506">        LOG.debug(</span>
            &quot;Key validators found in datastore: &quot;
                + id
                + &quot;:&quot;
<span class="nc" id="L510">                + result.get(id).getProfileName());</span>
<span class="nc" id="L511">      }</span>
    }
<span class="nc" id="L513">    return result;</span>
  }

  @Override
  public Map&lt;Integer, String&gt; getKeyValidatorIdToNameMap() {
<span class="nc" id="L518">    final HashMap&lt;Integer, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">    for (ProfileData data : findAllProfiles(Validator.TYPE_NAME)) {</span>
<span class="nc" id="L520">      result.put(data.getId(), data.getProfileName());</span>
<span class="nc" id="L521">    }</span>
<span class="nc" id="L522">    return result;</span>
  }

  @Override
  public Map&lt;Integer, String&gt; getKeyValidatorIdToNameMap(
      final int applicableCa) {
<span class="nc" id="L528">    final HashMap&lt;Integer, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">    for (Entry&lt;Integer, Validator&gt; data : getAllKeyValidators().entrySet()) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">      if (data.getValue().getApplicableCaTypes().contains(applicableCa)) {</span>
<span class="nc" id="L531">        result.put(data.getKey(), data.getValue().getProfileName());</span>
      }
<span class="nc" id="L533">    }</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L535">      LOG.debug(</span>
          &quot;Found validators for applicable CAs &quot;
              + applicableCa
              + &quot;: &quot;
              + result);
    }
<span class="nc" id="L541">    return result;</span>
  }

  @Override
  public void validateDnsNames(
      final AuthenticationToken authenticationToken,
      final CA ca,
      final EndEntityInformation endEntityInformation,
      final RequestMessage requestMessage)
      throws ValidationException {
<span class="nc bnc" id="L551" title="All 2 branches missed.">    if (!CollectionUtils.isEmpty(ca.getValidators())) {</span>
      Validator baseValidator;
      DnsNameValidator validator;
<span class="nc bnc" id="L554" title="All 2 branches missed.">      for (Integer id : ca.getValidators()) {</span>
<span class="nc" id="L555">        baseValidator = getValidatorInternal(id, true);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (baseValidator != null</span>
            &amp;&amp; baseValidator
<span class="nc" id="L558">                .getValidatorSubType()</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                .equals(DnsNameValidator.class)) {</span>
<span class="nc" id="L560">          validator = (DnsNameValidator) baseValidator;</span>
          // Filter for validator criteria.
<span class="nc bnc" id="L562" title="All 2 branches missed.">          if (baseValidator instanceof CertificateProfileAwareValidator</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">              &amp;&amp; !filterCertificateProfileAwareValidator(</span>
<span class="nc" id="L564">                  validator, endEntityInformation.getCertificateProfileId())) {</span>
<span class="nc" id="L565">            continue;</span>
          }
<span class="nc" id="L567">          CertificateProfile certificateProfile =</span>
<span class="nc" id="L568">              certificateProfileSession.getCertificateProfile(</span>
<span class="nc" id="L569">                  endEntityInformation.getCertificateProfileId());</span>
<span class="nc" id="L570">          final String subjectAltName =</span>
<span class="nc" id="L571">              endEntityInformation.getSubjectAltName();</span>
<span class="nc" id="L572">          final List&lt;String&gt; dnsNames = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">          for (String split : subjectAltName.split(&quot;,&quot;)) {</span>
<span class="nc" id="L574">            if (split</span>
<span class="nc" id="L575">                .trim()</span>
<span class="nc" id="L576">                .toLowerCase()</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                .startsWith(CertTools.DNS.toLowerCase())) {</span>
<span class="nc" id="L578">              dnsNames.add(split.trim().substring(CertTools.DNS.length() + 1));</span>
            }
          }
          // If the certificate profile allows extension override, there may be
          // SANs mixed in among the extensions in the request message
<span class="nc bnc" id="L583" title="All 4 branches missed.">          if (certificateProfile.getAllowExtensionOverride()</span>
              &amp;&amp; requestMessage != null) {
<span class="nc" id="L585">            Extensions extensions = requestMessage.getRequestExtensions();</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (extensions != null) {</span>
<span class="nc" id="L587">              Extension extension =</span>
<span class="nc" id="L588">                  extensions.getExtension(Extension.subjectAlternativeName);</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">              if (extension != null) {</span>
<span class="nc" id="L590">                String extendedSubjectAltName =</span>
<span class="nc" id="L591">                    CertTools.getAltNameStringFromExtension(extension);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                for (String split : extendedSubjectAltName.split(&quot;,&quot;)) {</span>
<span class="nc" id="L593">                  if (split</span>
<span class="nc" id="L594">                      .trim()</span>
<span class="nc" id="L595">                      .toLowerCase()</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                      .startsWith(CertTools.DNS.toLowerCase())) {</span>
<span class="nc" id="L597">                    dnsNames.add(</span>
<span class="nc" id="L598">                        split.trim().substring(CertTools.DNS.length() + 1));</span>
                  }
                }
              }
            }
          }

<span class="nc" id="L605">          Entry&lt;Boolean, List&lt;String&gt;&gt; result =</span>
<span class="nc" id="L606">              validator.validate(</span>
                  EXECUTOR_SERVICE,
<span class="nc" id="L608">                  dnsNames.toArray(new String[dnsNames.size()]));</span>

<span class="nc" id="L610">          final String validatorName = validator.getProfileName();</span>
<span class="nc" id="L611">          final List&lt;String&gt; messages = result.getValue();</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">          if (!result.getKey()) {</span>
            // Validation has failed. Not security event as such, since it will
            // break issuance and not cause anything important to happen.
            // We want thorough logging in order to trouble shoot though
<span class="nc" id="L616">            final String message =</span>
<span class="nc" id="L617">                INTRES.getLocalizedMessage(</span>
                    &quot;validator.caa.validation_failed&quot;,
                    validatorName,
<span class="nc" id="L620">                    validator.getIssuer(),</span>
                    messages);
<span class="nc" id="L622">            LOG.info(</span>
                EventTypes.VALIDATOR_VALIDATION_FAILED
                    + &quot;;&quot;
                    + EventStatus.FAILURE
                    + &quot;;&quot;
                    + ModuleTypes.VALIDATOR
                    + &quot;;&quot;
                    + ServiceTypes.CORE
                    + &quot;;msg=&quot;
                    + message);
<span class="nc" id="L632">            final int index = validator.getFailedAction();</span>
<span class="nc" id="L633">            performValidationFailedActions(index, message);</span>
<span class="nc" id="L634">          } else {</span>
            // Validation succeeded, this can be considered a security audit
            // event because CAs may be asked to present this as evidence to an
            // auditor
<span class="nc" id="L638">            final String message =</span>
<span class="nc" id="L639">                INTRES.getLocalizedMessage(</span>
                    &quot;validator.caa.validation_successful&quot;,
                    validatorName,
<span class="nc" id="L642">                    validator.getIssuer(),</span>
                    messages);
<span class="nc" id="L644">            final Map&lt;String, Object&gt; details =</span>
                new LinkedHashMap&lt;String, Object&gt;();
<span class="nc" id="L646">            details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L647">            auditSession.log(</span>
                EventTypes.VALIDATOR_VALIDATION_SUCCESS,
                EventStatus.SUCCESS,
                ModuleTypes.VALIDATOR,
                ServiceTypes.CORE,
<span class="nc" id="L652">                authenticationToken.toString(),</span>
<span class="nc" id="L653">                String.valueOf(ca.getCAId()),</span>
                null,
<span class="nc" id="L655">                endEntityInformation.getUsername(),</span>
                details);
          }
        }
<span class="nc" id="L659">      }</span>
    } else {
<span class="nc bnc" id="L661" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L662">        LOG.debug(</span>
            &quot;No validators configured for CA &quot;
<span class="nc" id="L664">                + ca.getName()</span>
                + &quot; (ID=&quot;
<span class="nc" id="L666">                + ca.getCAId()</span>
                + &quot;).&quot;);
      }
    }
<span class="nc" id="L670">  }</span>

  @Override
  public boolean validatePublicKey(
      final AuthenticationToken admin,
      final CA ca,
      final EndEntityInformation endEntityInformation,
      final CertificateProfile certificateProfile,
      final Date notBefore,
      final Date notAfter,
      final PublicKey publicKey)
      throws ValidationException, IllegalValidityException {
<span class="nc" id="L682">    boolean result = true;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">    if (ca != null</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        &amp;&amp; !CollectionUtils.isEmpty(</span>
            ca
<span class="nc" id="L686">                .getValidators())) { // || certificateProfile.isTypeRootCA() ||</span>
                                     // certificateProfile.isTypeSubCA()
<span class="nc" id="L688">      final CertificateValidity certificateValidity =</span>
          new CertificateValidity(
              endEntityInformation,
              certificateProfile,
              notBefore,
              notAfter,
<span class="nc" id="L694">              ca.getCACertificate(),</span>
              false,
              false);
<span class="nc bnc" id="L697" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L698">        LOG.debug(</span>
            &quot;Validate &quot;
<span class="nc" id="L700">                + publicKey.getAlgorithm()</span>
                + &quot; public key with &quot;
<span class="nc" id="L702">                + publicKey.getFormat()</span>
                + &quot; format.&quot;);
<span class="nc" id="L704">        LOG.debug(</span>
<span class="nc" id="L705">            &quot;Certificate 'notBefore' &quot; + certificateValidity.getNotBefore());</span>
<span class="nc" id="L706">        LOG.debug(</span>
<span class="nc" id="L707">            &quot;Certificate 'notAfter' &quot; + certificateValidity.getNotAfter());</span>
      }
      Validator baseValidator;
      KeyValidator validator;
      String name;
<span class="nc bnc" id="L712" title="All 2 branches missed.">      for (Integer id : ca.getValidators()) {</span>
<span class="nc" id="L713">        baseValidator = getValidatorInternal(id, true);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (baseValidator != null</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            &amp;&amp; baseValidator.getValidatorSubType().equals(KeyValidator.class)) {</span>
<span class="nc" id="L716">          validator = (KeyValidator) baseValidator;</span>
<span class="nc" id="L717">          name = validator.getProfileName();</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">          if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L719">            LOG.trace(</span>
<span class="nc" id="L720">                &quot;Try to apply key validator: &quot; + validator.toDisplayString());</span>
          }
          try {
            // Filter for validator criteria.
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (validator instanceof CertificateProfileAwareValidator</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                &amp;&amp; !filterCertificateProfileAwareValidator(</span>
                    validator,
<span class="nc" id="L727">                    endEntityInformation.getCertificateProfileId())) {</span>
<span class="nc" id="L728">              continue;</span>
            }
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (validator instanceof ValidityAwareValidator</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">                &amp;&amp; !filterValidityAwareValidator(</span>
                    validator,
<span class="nc" id="L733">                    certificateValidity.getNotBefore(),</span>
<span class="nc" id="L734">                    certificateValidity.getNotAfter())) {</span>
<span class="nc" id="L735">              continue;</span>
            }
<span class="nc" id="L737">            final String fingerprint =</span>
<span class="nc" id="L738">                CertTools.createPublicKeyFingerprint(publicKey, &quot;SHA-256&quot;);</span>
<span class="nc" id="L739">            LOG.info(</span>
<span class="nc" id="L740">                INTRES.getLocalizedMessage(</span>
                    &quot;validator.key.isbeingprocessed&quot;,
                    name,
<span class="nc" id="L743">                    endEntityInformation.getUsername(),</span>
                    fingerprint));
<span class="nc" id="L745">            List&lt;String&gt; messages =</span>
<span class="nc" id="L746">                validator.validate(publicKey, certificateProfile);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            if (messages.size() &gt; 0) { // Validation has failed.</span>
<span class="nc" id="L748">              result = false;</span>
<span class="nc" id="L749">              final int index = validator.getFailedAction();</span>
<span class="nc" id="L750">              final String message =</span>
<span class="nc" id="L751">                  INTRES.getLocalizedMessage(</span>
                      &quot;validator.key.validation_failed&quot;, name, messages);
<span class="nc" id="L753">              final Map&lt;String, Object&gt; details =</span>
                  new LinkedHashMap&lt;String, Object&gt;();
<span class="nc" id="L755">              details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L756">              auditSession.log(</span>
                  EventTypes.VALIDATOR_VALIDATION_FAILED,
                  EventStatus.FAILURE,
                  ModuleTypes.VALIDATOR,
                  ServiceTypes.CORE,
<span class="nc" id="L761">                  admin.toString(),</span>
<span class="nc" id="L762">                  String.valueOf(ca.getCAId()),</span>
                  fingerprint,
<span class="nc" id="L764">                  endEntityInformation.getUsername(),</span>
                  details);
<span class="nc" id="L766">              performValidationFailedActions(index, message);</span>
<span class="nc" id="L767">            } else {</span>
<span class="nc" id="L768">              final byte[] keyBytes = publicKey.getEncoded();</span>
              final String publicKeyEncoded =
<span class="nc bnc" id="L770" title="All 2 branches missed.">                  (keyBytes != null</span>
<span class="nc" id="L771">                      ? new String(Base64.encode(keyBytes))</span>
<span class="nc" id="L772">                      : &quot;null&quot;);</span>
<span class="nc" id="L773">              final String message =</span>
<span class="nc" id="L774">                  INTRES.getLocalizedMessage(</span>
                      &quot;validator.key.validation_successful&quot;,
                      name,
                      publicKeyEncoded);
<span class="nc" id="L778">              LOG.info(message);</span>
<span class="nc" id="L779">              final Map&lt;String, Object&gt; details =</span>
                  new LinkedHashMap&lt;String, Object&gt;();
<span class="nc" id="L781">              details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L782">              auditSession.log(</span>
                  EventTypes.VALIDATOR_VALIDATION_SUCCESS,
                  EventStatus.SUCCESS,
                  ModuleTypes.VALIDATOR,
                  ServiceTypes.CORE,
<span class="nc" id="L787">                  admin.toString(),</span>
<span class="nc" id="L788">                  String.valueOf(ca.getCAId()),</span>
                  null,
<span class="nc" id="L790">                  endEntityInformation.getUsername(),</span>
                  details);
            }
<span class="nc" id="L793">          } catch (ValidatorNotApplicableException e) {</span>
            // This methods either throws a KeyValidationException, or just logs
            // a message and validation should be considered successful
            // use method performValidationFailedActions because it's the same
            // actions
<span class="nc" id="L798">            performValidationFailedActions(</span>
<span class="nc" id="L799">                validator.getNotApplicableAction(), e.getMessage());</span>
<span class="nc" id="L800">          } catch (ValidationException e) {</span>
<span class="nc" id="L801">            throw e;</span>
<span class="nc" id="L802">          }</span>
        }
<span class="nc" id="L804">      }</span>
<span class="nc" id="L805">    } else {</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L807">        LOG.debug(</span>
            &quot;No key validator configured for CA &quot;
<span class="nc" id="L809">                + ca.getName()</span>
                + &quot; (ID=&quot;
<span class="nc" id="L811">                + ca.getCAId()</span>
                + &quot;).&quot;);
      }
    }
<span class="nc" id="L815">    return result;</span>
  }

  @Override
  public void validateCertificate(
      final AuthenticationToken authenticationToken,
      final IssuancePhase phase,
      final CA ca,
      final EndEntityInformation endEntityInformation,
      final X509Certificate certificate)
      throws ValidationException {
<span class="nc bnc" id="L826" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L827">      LOG.debug(&quot;Validate certificate for phase &quot; + phase);</span>
    }
<span class="nc bnc" id="L829" title="All 4 branches missed.">    if (ca != null &amp;&amp; !CollectionUtils.isEmpty(ca.getValidators())) {</span>
      Validator baseValidator;
      CertificateValidator validator;
      String name;
<span class="nc bnc" id="L833" title="All 2 branches missed.">      for (Integer id : ca.getValidators()) {</span>
<span class="nc" id="L834">        baseValidator = getValidatorInternal(id, true);</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (baseValidator != null</span>
            &amp;&amp; baseValidator
<span class="nc" id="L837">                .getValidatorSubType()</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">                .equals(CertificateValidator.class)) {</span>
<span class="nc" id="L839">          validator = (CertificateValidator) baseValidator;</span>
<span class="nc" id="L840">          name = validator.getProfileName();</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">          if (phase.getIndex() != validator.getPhase()) {</span>
<span class="nc" id="L842">            continue;</span>
          }
<span class="nc bnc" id="L844" title="All 2 branches missed.">          if (validator instanceof CertificateProfileAwareValidator</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">              &amp;&amp; !filterCertificateProfileAwareValidator(</span>
<span class="nc" id="L846">                  validator, endEntityInformation.getCertificateProfileId())) {</span>
<span class="nc" id="L847">            continue;</span>
          }
<span class="nc bnc" id="L849" title="All 2 branches missed.">          if (validator instanceof ValidityAwareValidator</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">              &amp;&amp; !filterValidityAwareValidator(</span>
                  validator,
<span class="nc" id="L852">                  certificate.getNotBefore(),</span>
<span class="nc" id="L853">                  certificate.getNotAfter())) {</span>
<span class="nc" id="L854">            continue;</span>
          }
          try {
<span class="nc" id="L857">            final String fingerprint =</span>
<span class="nc" id="L858">                CertTools.createPublicKeyFingerprint(</span>
<span class="nc" id="L859">                    certificate.getPublicKey(), &quot;SHA-256&quot;);</span>
<span class="nc" id="L860">            LOG.info(</span>
<span class="nc" id="L861">                INTRES.getLocalizedMessage(</span>
                    &quot;validator.certificate.isbeingprocessed&quot;,
                    name,
                    phase,
<span class="nc" id="L865">                    endEntityInformation.getUsername(),</span>
                    fingerprint));
<span class="nc" id="L867">            final ExternalScriptsConfiguration externalScriptsConfiguration =</span>
                (ExternalScriptsConfiguration)
<span class="nc" id="L869">                    globalConfigurationSession.getCachedConfiguration(&quot;0&quot;);</span>
<span class="nc" id="L870">            final ExternalScriptsWhitelist externalScriptsWhitelist =</span>
<span class="nc" id="L871">                ExternalScriptsWhitelist.fromText(</span>
<span class="nc" id="L872">                    externalScriptsConfiguration.getExternalScriptsWhitelist(),</span>
                    externalScriptsConfiguration
<span class="nc" id="L874">                        .getIsExternalScriptsWhitelistEnabled());</span>
<span class="nc" id="L875">            final List&lt;String&gt; messages =</span>
<span class="nc" id="L876">                validator.validate(ca, certificate, externalScriptsWhitelist);</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (messages.size() &gt; 0) { // Evaluation has failed.</span>
<span class="nc" id="L878">              final String message =</span>
<span class="nc" id="L879">                  INTRES.getLocalizedMessage(</span>
                      &quot;validator.certificate.validation_failed&quot;,
                      name,
                      messages);
<span class="nc" id="L883">              final Map&lt;String, Object&gt; details =</span>
                  new LinkedHashMap&lt;String, Object&gt;();
<span class="nc" id="L885">              details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L886">              auditSession.log(</span>
                  EventTypes.VALIDATOR_VALIDATION_FAILED,
                  EventStatus.FAILURE,
                  ModuleTypes.VALIDATOR,
                  ServiceTypes.CORE,
<span class="nc" id="L891">                  authenticationToken.toString(),</span>
<span class="nc" id="L892">                  String.valueOf(ca.getCAId()),</span>
                  fingerprint,
<span class="nc" id="L894">                  endEntityInformation.getUsername(),</span>
                  details);
<span class="nc" id="L896">              performValidationFailedActions(</span>
<span class="nc" id="L897">                  validator.getFailedAction(), message);</span>
<span class="nc" id="L898">            } else {</span>
<span class="nc" id="L899">              final String message =</span>
<span class="nc" id="L900">                  INTRES.getLocalizedMessage(</span>
                      &quot;validator.certificate.validation_successful&quot;,
                      name,
                      fingerprint);
<span class="nc" id="L904">              LOG.info(message);</span>
<span class="nc" id="L905">              final Map&lt;String, Object&gt; details =</span>
                  new LinkedHashMap&lt;String, Object&gt;();
<span class="nc" id="L907">              details.put(&quot;msg&quot;, message);</span>
<span class="nc" id="L908">              auditSession.log(</span>
                  EventTypes.VALIDATOR_VALIDATION_SUCCESS,
                  EventStatus.SUCCESS,
                  ModuleTypes.VALIDATOR,
                  ServiceTypes.CORE,
<span class="nc" id="L913">                  authenticationToken.toString(),</span>
<span class="nc" id="L914">                  String.valueOf(ca.getCAId()),</span>
                  null,
<span class="nc" id="L916">                  endEntityInformation.getUsername(),</span>
                  details);
            }
<span class="nc" id="L919">          } catch (ValidatorNotApplicableException e) {</span>
            // This methods either throws a KeyValidationException, or just logs
            // a message and validation should be considered successful
            // use method performValidationFailedActions because it's the same
            // actions
<span class="nc" id="L924">            performValidationFailedActions(</span>
<span class="nc" id="L925">                validator.getNotApplicableAction(), e.getMessage());</span>
<span class="nc" id="L926">          } catch (CertificateException e) {</span>
<span class="nc" id="L927">            throw new ValidationException(</span>
                &quot;Certificate to validate could not be parsed or decoded: &quot;
<span class="nc" id="L929">                    + e.getMessage(),</span>
                e);
<span class="nc" id="L931">          }</span>
        }
<span class="nc" id="L933">      }</span>
    }
<span class="nc" id="L935">  }</span>

  /** Method is never called.
   *
   * @param admin Asmin
   * @param profile Prof
   * @param logging Log
   * @param resources Resource
   * @return bool
   */
  public boolean authorizedToKeyValidatorWithResource(
      final AuthenticationToken admin,
      final CertificateProfile profile,
      final boolean logging,
      final String... resources) {
    // We need to check that admin also have rights to the passed in resources
<span class="nc" id="L951">    final List&lt;String&gt; rules = new ArrayList&lt;&gt;(Arrays.asList(resources));</span>
    // Check that admin is authorized to all CAids
<span class="nc bnc" id="L953" title="All 2 branches missed.">    for (final Integer caid : profile.getAvailableCAs()) {</span>
<span class="nc" id="L954">      rules.add(StandardRules.CAACCESS.resource() + caid);</span>
<span class="nc" id="L955">    }</span>
    // Perform authorization check
<span class="nc" id="L957">    boolean ret = false;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">    if (logging) {</span>
<span class="nc" id="L959">      ret =</span>
<span class="nc" id="L960">          authorizationSession.isAuthorized(</span>
<span class="nc" id="L961">              admin, rules.toArray(new String[rules.size()]));</span>
    } else {
<span class="nc" id="L963">      ret =</span>
<span class="nc" id="L964">          authorizationSession.isAuthorizedNoLogging(</span>
<span class="nc" id="L965">              admin, rules.toArray(new String[rules.size()]));</span>
    }
<span class="nc" id="L967">    return ret;</span>
  }

  @Override
  public Collection&lt;Integer&gt; getAuthorizedKeyValidatorIds(
      final AuthenticationToken admin, final String keyValidatorAccessRule) {
<span class="nc" id="L973">    final ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L974">    final Map&lt;Integer, String&gt; map = getKeyValidatorIdToNameMap();</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">    if (authorizationSession.isAuthorizedNoLogging(</span>
        admin, keyValidatorAccessRule)) {
<span class="nc" id="L977">      final boolean rootAccess =</span>
<span class="nc" id="L978">          authorizationSession.isAuthorizedNoLogging(</span>
<span class="nc" id="L979">              admin, StandardRules.ROLE_ROOT.resource());</span>
<span class="nc" id="L980">      final List&lt;Integer&gt; authorizedCPIDs =</span>
<span class="nc" id="L981">          certificateProfileSession.getAuthorizedCertificateProfileIds(</span>
              admin, 0);
<span class="nc bnc" id="L983" title="All 2 branches missed.">      for (final Entry&lt;Integer, String&gt; entry : map.entrySet()) {</span>
        // Check that administrator have access to all certificate profiles
        // referenced by the validator
<span class="nc" id="L986">        Validator val = getValidator(entry.getKey());</span>
<span class="nc" id="L987">        boolean allexists = true;</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">        for (final Integer nextcpid : val.getCertificateProfileIds()) {</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">          if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L990">            LOG.trace(</span>
                &quot;Validator '&quot;
<span class="nc" id="L992">                    + val.getProfileName()</span>
                    + &quot;' has &quot;
<span class="nc" id="L994">                    + val.getCertificateProfileIds().size()</span>
                    + &quot; no of CPs selected&quot;);
          }
          // If any CP is selected, it's access to all (only authorized will be
          // displayed)
<span class="nc bnc" id="L999" title="All 2 branches missed.">          if (nextcpid.intValue() == -1) {</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1001">              LOG.debug(</span>
                  &quot;Validator is applicable to all certificate profiles, not&quot;
                      + &quot; limiting access based on CPs&quot;);
            }
<span class="nc" id="L1005">            allexists = true;</span>
<span class="nc" id="L1006">            break;</span>
          }
          // superadmin should be able to access profiles with missing CA Ids
<span class="nc bnc" id="L1009" title="All 4 branches missed.">          if (!authorizedCPIDs.contains(nextcpid) &amp;&amp; (!rootAccess)) {</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1011">              LOG.debug(</span>
                  &quot;Validator have certificate profile &quot;
                      + nextcpid
                      + &quot; selected which admin is not authorized to:&quot;
<span class="nc" id="L1015">                      + admin.toString());</span>
            }
<span class="nc" id="L1017">            allexists = false;</span>
<span class="nc" id="L1018">            break;</span>
          }
<span class="nc" id="L1020">        }</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (allexists) {</span>
<span class="nc" id="L1022">          result.add(entry.getKey());</span>
        }
<span class="nc" id="L1024">      }</span>
    }
<span class="nc" id="L1026">    return result;</span>
  }

  @Override
  public List&lt;Integer&gt; getConflictingKeyValidatorIds(
      final Validator validator) {
<span class="nc" id="L1032">    final List&lt;ProfileData&gt; conflicts =</span>
<span class="nc" id="L1033">        profileSession.findByNameAndType(</span>
<span class="nc" id="L1034">            validator.getProfileName(), Validator.TYPE_NAME);</span>
<span class="nc" id="L1035">    final List&lt;Integer&gt; conflictingValidatorIds = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">    for (final ProfileData conflict : conflicts) {</span>
<span class="nc" id="L1037">      conflictingValidatorIds.add(conflict.getId());</span>
<span class="nc" id="L1038">    }</span>
<span class="nc" id="L1039">    return conflictingValidatorIds;</span>
  }

  @Override
  public void replaceKeyValidator(
      final AuthenticationToken authenticationToken,
      final LinkedHashMap&lt;Object, Object&gt; data,
      final int id)
      throws AuthorizationDeniedException {
<span class="nc" id="L1048">    assertIsAuthorizedToEditValidators(authenticationToken);</span>

<span class="nc" id="L1050">    final Validator validatorToUpdate = getValidator(id);</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">    if (validatorToUpdate == null) {</span>
<span class="nc" id="L1052">      return;</span>
    }
<span class="nc" id="L1054">    validatorToUpdate.setDataMap(data);</span>
<span class="nc" id="L1055">    ValidatorCache.INSTANCE.flush();</span>

<span class="nc" id="L1057">    final String auditMessage =</span>
<span class="nc" id="L1058">        INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1059">            &quot;validator.changed_validator&quot;, validatorToUpdate.getProfileName());</span>
<span class="nc" id="L1060">    final Map&lt;String, Object&gt; details = new LinkedHashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L1061">    details.put(&quot;msg&quot;, auditMessage);</span>
<span class="nc" id="L1062">    auditSession.log(</span>
        EventTypes.VALIDATOR_CHANGE,
        EventStatus.SUCCESS,
        ModuleTypes.VALIDATOR,
        ServiceTypes.CORE,
<span class="nc" id="L1067">        authenticationToken.toString(),</span>
        null,
        null,
        null,
        details);
<span class="nc" id="L1072">  }</span>

  /**
   * Gets a validator by cache or database, can return null. Puts it into the
   * cache, if not already present.
   *
   * @param id the validators id.
   * @param fromCache true if the validator can be taken from cache.
   * @return a cloned validator that can be used at will without affecting the
   *     cache contents, edits have to be saved with replaceKeyValidator
   */
  private Validator getValidatorInternal(
      final int id, final boolean fromCache) {
<span class="nc" id="L1085">    Validator result = null;</span>
    // If we should read from cache, and we have an id to use in the cache, and
    // the cache does not need to be updated
<span class="nc bnc" id="L1088" title="All 4 branches missed.">    if (fromCache &amp;&amp; !ValidatorCache.INSTANCE.shouldCheckForUpdates(id)) {</span>
      // Get from cache (or null)
<span class="nc" id="L1090">      result = ValidatorCache.INSTANCE.getEntry(id);</span>
    }

    // if we selected to not read from cache, or if the cache did not contain
    // this entry
<span class="nc bnc" id="L1095" title="All 2 branches missed.">    if (result == null) {</span>

      // We need to read from database because we specified to not get from
      // cache or we don't have anything in the cache
<span class="nc" id="L1099">      final ProfileData data = profileSession.findById(id);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">      if (data != null) {</span>
<span class="nc" id="L1101">        result = (Validator) data.getProfile();</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1103">          LOG.debug(&quot;Load validator: &quot; + result.getDataMap());</span>
        }
<span class="nc" id="L1105">        final int digest = data.getProtectString(0).hashCode();</span>
        // The cache compares the database data with what is in the cache
        // If database is different from cache, replace it in the cache
<span class="nc" id="L1108">        ValidatorCache.INSTANCE.updateWith(</span>
<span class="nc" id="L1109">            data.getId(), digest, data.getProfileName(), result);</span>
<span class="nc" id="L1110">      } else {</span>
        // Ensure that it is removed from cache if it exists
<span class="nc" id="L1112">        ValidatorCache.INSTANCE.removeEntry(id);</span>
      }
    }
<span class="nc bnc" id="L1115" title="All 2 branches missed.">    if (result == null) {</span>
<span class="nc" id="L1116">      LOG.warn(&quot;Validator with id &quot; + id + &quot; didn't return any validator&quot;);</span>
    }
    // We need to clone the validator, otherwise the cache contents will be
    // modifiable from the outside
<span class="nc bnc" id="L1120" title="All 2 branches missed.">    if (result != null) {</span>
<span class="nc" id="L1121">      return result.clone();</span>
    }
<span class="nc" id="L1123">    return null;</span>
  }

  /**
   * Adds a key validator or throws an exception.
   *
   * @param admin AuthenticationToken of administrator.
   * @param keyValidator the validator to add.
   * @return the profile ID
   * @throws AuthorizationDeniedException If access denied
   * @throws KeyValidatorExistsException If validator does not exist
   */
  private int addValidatorInternal(
      final AuthenticationToken admin, final Validator keyValidator)
      throws AuthorizationDeniedException, KeyValidatorExistsException {
<span class="nc" id="L1138">    assertIsAuthorizedToEditValidators(admin);</span>
<span class="nc" id="L1139">    if (profileSession</span>
<span class="nc" id="L1140">        .findByNameAndType(keyValidator.getProfileName(), Validator.TYPE_NAME)</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        .isEmpty()) {</span>
<span class="nc" id="L1142">      return profileSession.addProfile(keyValidator);</span>
    } else {
<span class="nc" id="L1144">      final String message =</span>
<span class="nc" id="L1145">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1146">              &quot;validator.error.add_validator&quot;, keyValidator.getProfileName());</span>
<span class="nc" id="L1147">      LOG.info(message);</span>
<span class="nc" id="L1148">      throw new KeyValidatorExistsException();</span>
    }
  }

  /**
   * Assert the administrator is authorized to edit key validators.
   *
   * @param admin AuthenticationToken of administrator.
   * @throws AuthorizationDeniedException if the administrator is not authorized
   *     to.
   */
  private void assertIsAuthorizedToEditValidators(
      final AuthenticationToken admin) throws AuthorizationDeniedException {
<span class="nc bnc" id="L1161" title="All 2 branches missed.">    if (!authorizationSession.isAuthorized(</span>
<span class="nc" id="L1162">        admin, StandardRules.VALIDATOREDIT.resource())) {</span>
<span class="nc" id="L1163">      final String message =</span>
<span class="nc" id="L1164">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L1165">              &quot;store.editkeyvalidatornotauthorized&quot;, admin.toString());</span>
<span class="nc" id="L1166">      throw new AuthorizationDeniedException(message);</span>
    }
<span class="nc" id="L1168">  }</span>

  /**
   * Applies validity conditions (see {@link KeyValidatorDateConditions}) to the
   * validator.
   *
   * @param validator the validator.
   * @param certificateNotBefore the certificates not before validity.
   * @param certificateNotAfter the certificates not after validity.
   * @return false, if the conditions does not match.
   */
  private boolean filterValidityAwareValidator(
      final ValidityAwareValidator validator,
      final Date certificateNotBefore,
      final Date certificateNotAfter) {
<span class="nc bnc" id="L1183" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1184">      LOG.trace(&quot;Try to apply validity aware validator: &quot; + validator);</span>
    }
<span class="nc" id="L1186">    final String name = validator.getProfileName();</span>
<span class="nc" id="L1187">    boolean result = true;</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">    if (!KeyValidatorDateConditions.evaluate(</span>
<span class="nc" id="L1189">        validator.getNotBefore(),</span>
        certificateNotBefore,
<span class="nc" id="L1191">        validator.getNotBeforeCondition())) {</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1193">        LOG.debug(</span>
<span class="nc" id="L1194">            INTRES.getLocalizedMessage(</span>
                &quot;validator.filterconditiondoesnotmatch&quot;, name, &quot;notBefore&quot;));
      }
<span class="nc" id="L1197">      result = false;</span>
    }
<span class="nc bnc" id="L1199" title="All 2 branches missed.">    if (!KeyValidatorDateConditions.evaluate(</span>
<span class="nc" id="L1200">        validator.getNotAfter(),</span>
        certificateNotAfter,
<span class="nc" id="L1202">        validator.getNotAfterCondition())) {</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1204">        LOG.debug(</span>
<span class="nc" id="L1205">            INTRES.getLocalizedMessage(</span>
                &quot;validator.filterconditiondoesnotmatch&quot;, name, &quot;notAfter&quot;));
      }
<span class="nc" id="L1208">      result = false;</span>
    }
<span class="nc" id="L1210">    return result;</span>
  }

  /**
   * Applies certificate profile conditions to the validator.
   *
   * @param validator the validator.
   * @param certificateProfileId the certificate profile id.
   * @return false, if the conditions does not match.
   */
  private boolean filterCertificateProfileAwareValidator(
      final CertificateProfileAwareValidator validator,
      final int certificateProfileId) {
<span class="nc bnc" id="L1223" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1224">      LOG.trace(</span>
          &quot;Try to apply certificate profile aware validator: &quot; + validator);
    }
<span class="nc" id="L1227">    boolean result = true;</span>
<span class="nc" id="L1228">    final List&lt;Integer&gt; ids = validator.getCertificateProfileIds();</span>
<span class="nc" id="L1229">    final boolean isAll = validator.isAllCertificateProfileIds();</span>
<span class="nc bnc" id="L1230" title="All 6 branches missed.">    if (!isAll &amp;&amp; null != ids &amp;&amp; !ids.contains(certificateProfileId)) {</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1232">        LOG.debug(</span>
<span class="nc" id="L1233">            INTRES.getLocalizedMessage(</span>
                &quot;validator.filterconditiondoesnotmatch&quot;,
<span class="nc" id="L1235">                validator.getProfileName(),</span>
                &quot;applicableCertificateProfiles&quot;));
      }
<span class="nc" id="L1238">      result = false;</span>
    }
<span class="nc" id="L1240">    return result;</span>
  }

  /**
   * Calling overloaded method performValidationFailedActions when parameter
   * shortMessage should be the same as the message.
   *
   * @param failedAction Action
   * @param message Message
   * @throws ValidationException On fail
   */
  private void performValidationFailedActions(
      final int failedAction, final String message) throws ValidationException {
<span class="nc" id="L1253">    performValidationFailedActions(failedAction, message, message);</span>
<span class="nc" id="L1254">  }</span>

  /**
   * Post processes every validation depending on its failed action.
   *
   * @param failedAction the failed action index (see {@link
   *     KeyValidationFailedActions}).
   * @param message the message to log.
   * @param shortMessage the error message to EJBCA Certificate Enrollment Error
   *     page
   * @throws ValidationException if a failed validation has to be abort the
   *     certificate issuance.
   */
  private void performValidationFailedActions(
      final int failedAction, final String message, final String shortMessage)
      throws ValidationException {
<span class="nc bnc" id="L1270" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1271">      LOG.debug(&quot;Perform post action &quot; + failedAction + &quot; - &quot; + message);</span>
    }
<span class="nc bnc" id="L1273" title="All 2 branches missed.">    if (KeyValidationFailedActions.LOG_INFO.getIndex() == failedAction) {</span>
<span class="nc" id="L1274">      LOG.info(message);</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">    } else if (KeyValidationFailedActions.LOG_WARN.getIndex() == failedAction) {</span>
<span class="nc" id="L1276">      LOG.warn(message);</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">    } else if (KeyValidationFailedActions.LOG_ERROR.getIndex()</span>
        == failedAction) {
<span class="nc" id="L1279">      LOG.error(message);</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">    } else if (KeyValidationFailedActions.ABORT_CERTIFICATE_ISSUANCE.getIndex()</span>
        == failedAction) {
<span class="nc" id="L1282">      throw new ValidationException(shortMessage);</span>
    } else {
      // NOOP
<span class="nc" id="L1285">      LOG.debug(message);</span>
    }
<span class="nc" id="L1287">  }</span>

  /**
   * Gets all profiles by type.
   *
   * @param profileType the profile type.
   * @return all profiles that match that type. {@link
   *     ExternalCommandCertificateValidator} is only included if calls to
   *     external scripts are enabled.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  // profileType does not change here!
  private List&lt;ProfileData&gt; findAllProfiles(final String profileType) {
<span class="nc" id="L1300">    final List&lt;ProfileData&gt; profiles =</span>
<span class="nc" id="L1301">        profileSession.findAllProfiles(profileType);</span>
<span class="nc" id="L1302">    final boolean enabled =</span>
        ((ExternalScriptsConfiguration)
<span class="nc" id="L1304">                globalConfigurationSession.getCachedConfiguration(&quot;0&quot;))</span>
<span class="nc" id="L1305">            .getEnableExternalScripts();</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">    if (enabled) {</span>
<span class="nc" id="L1307">      return profiles;</span>
    } else {
<span class="nc" id="L1309">      final List&lt;ProfileData&gt; result = new ArrayList&lt;ProfileData&gt;();</span>
      Class&lt;? extends Serializable&gt; profileClass;
<span class="nc bnc" id="L1311" title="All 2 branches missed.">      for (ProfileData profile : profiles) {</span>
<span class="nc" id="L1312">          profileClass =</span>
                  (Class&lt;? extends Serializable&gt;)
<span class="nc" id="L1314">                      profile.getProfile().getDataMap().get(&quot;profile.type&quot;);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        if (profileClass == null</span>
            || !ExternalCommandCertificateValidator.class
<span class="nc" id="L1317">                .getName()</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                .equals(profileClass.getName())) {</span>
<span class="nc" id="L1319">          result.add(profile);</span>
        }
<span class="nc" id="L1321">      }</span>
<span class="nc" id="L1322">      return result;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>