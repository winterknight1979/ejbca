<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyRecoveryData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ejbca-entity</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.ejb.keyrecovery</a> &gt; <span class="el_source">KeyRecoveryData.java</span></div><h1>KeyRecoveryData.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.ejbca.core.ejb.keyrecovery;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.PostLoad;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Query;
import javax.persistence.Table;
import javax.persistence.Transient;

import org.apache.log4j.Logger;
import org.cesecore.dbprotection.ProtectedData;
import org.cesecore.dbprotection.ProtectionStringBuilder;
import org.cesecore.util.Base64;
import org.cesecore.util.StringTools;

/**
 * Representation of a certificates key recovery data.
 * 
 * @version $Id: KeyRecoveryData.java 25742 2017-04-25 10:38:47Z anatom $
 */
@Entity
@Table(name=&quot;KeyRecoveryData&quot;)
public class KeyRecoveryData extends ProtectedData implements Serializable {

	private static final long serialVersionUID = 1L;
<span class="fc" id="L45">	private static final Logger log = Logger.getLogger(KeyRecoveryData.class);</span>

	private KeyRecoveryDataPK keyRecoveryDataPK;
	private String username;
	private Boolean markedAsRecoverableBool;
	private Integer markedAsRecoverableInt;
	private String keyData;
<span class="pc" id="L52">    private int cryptoTokenId = 0;</span>
    private String keyAlias;
    private String publicKeyId;
<span class="pc" id="L55">	private int rowVersion = 0;</span>
	private String rowProtection;
	
	/**
	 * Entity holding key recovery data of users certificate.
	 *
	 * @param certificatesn of certificate the keys are belonging to.
	 * @param issuerdn issuerdn of certificate the keys are belonging to.
	 * @param username of the owner of the keys.
	 * @param cryptoTokenId the id of the cryptoToken that holds the key protecting this key recovery entry
     * @param keyAlias the alias of the key protecting this key recovery entry
     * @param publicKeyId the keyId (same as subjectKeyId of a certificateData) of key protecting this key recovery entry
	 * @param keydata the actual keydata.
	 */
<span class="nc" id="L69">	public KeyRecoveryData(final BigInteger certificatesn, final String issuerdn, final String username, final byte[] keydata, final int cryptoTokenId, final String keyAlias, final String publicKeyId) {</span>
<span class="nc" id="L70">		setKeyRecoveryDataPK(new KeyRecoveryDataPK(certificatesn.toString(16), issuerdn));</span>
<span class="nc" id="L71">		setUsername(username);</span>
<span class="nc" id="L72">		setMarkedAsRecoverable(false);</span>
<span class="nc" id="L73">		setKeyDataFromByteArray(keydata);</span>
<span class="nc" id="L74">		setCryptoTokenId(cryptoTokenId);</span>
<span class="nc" id="L75">		setKeyAlias(keyAlias);</span>
<span class="nc" id="L76">		setPublicKeyId(publicKeyId);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">		if (log.isDebugEnabled()) {</span>
<span class="nc" id="L78">		    log.debug(&quot;Created Key Recoverydata for user &quot; + username);</span>
		}
<span class="nc" id="L80">	}</span>

<span class="fc" id="L82">	public KeyRecoveryData() { }</span>

<span class="fc" id="L84">	public KeyRecoveryDataPK getKeyRecoveryDataPK() { return keyRecoveryDataPK; }</span>
<span class="fc" id="L85">	public void setKeyRecoveryDataPK(KeyRecoveryDataPK keyRecoveryDataPK) { this.keyRecoveryDataPK = keyRecoveryDataPK; }</span>
	
	@Transient
<span class="nc" id="L88">	public String getIssuerDN() { return keyRecoveryDataPK.issuerDN; }</span>

	//@Column
<span class="fc" id="L91">	public String getUsername() { return username; }</span>
<span class="fc" id="L92">	public void setUsername(String username) { this.username = StringTools.stripUsername(username); }</span>

	@Transient
	public boolean getMarkedAsRecoverable() {
<span class="nc" id="L96">		Boolean markB = getMarkedAsRecoverableBool();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (markB != null) {</span>
<span class="nc" id="L98">			return markB.booleanValue();</span>
		}
<span class="nc" id="L100">		Integer markI = getMarkedAsRecoverableInt();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">		if (markI != null) {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">			return markI.intValue() == 1;</span>
		}
<span class="nc" id="L104">		throw new RuntimeException(&quot;Could not retreive KeyRecoveryData.markedAsRecoverable from database.&quot;);</span>
	}
	public void setMarkedAsRecoverable(boolean markedAsRecoverable) {
<span class="fc" id="L107">		setMarkedAsRecoverableBool(Boolean.valueOf(markedAsRecoverable));</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">		setMarkedAsRecoverableInt(markedAsRecoverable ? 1 : 0);</span>
<span class="fc" id="L109">	}</span>

	/**
	 * Use getMarkedAsRecoverable() instead of this method!
	 * Ingres:     Transient
	 * Non-ingres: Mapped to &quot;markedAsRecoverable&quot; 
	 * @return bool
	 */
<span class="fc" id="L117">	public Boolean getMarkedAsRecoverableBool() { return markedAsRecoverableBool; }</span>
<span class="fc" id="L118">	public void setMarkedAsRecoverableBool(Boolean markedAsRecoverableBool) { this.markedAsRecoverableBool = markedAsRecoverableBool; }</span>

	/**
	 * Use getMarkedAsRecoverable() instead of this method!
	 * Ingres:     Mapped to &quot;markedAsRecoverable&quot;
	 * Non-ingres: Transient 
	 * @return int
	 */
<span class="nc" id="L126">	public Integer getMarkedAsRecoverableInt() { return markedAsRecoverableInt; }</span>
<span class="fc" id="L127">	public void setMarkedAsRecoverableInt(Integer markedAsRecoverableInt) { this.markedAsRecoverableInt = markedAsRecoverableInt; }</span>
	
	
	//@Column @Lob
<span class="fc" id="L131">	public String getKeyData() { return keyData; } </span>
<span class="fc" id="L132">	public void setKeyData(String keyData) { this.keyData = keyData; }</span>

	//@Version @Column
<span class="fc" id="L135">    public int getCryptoTokenId() { return cryptoTokenId; }</span>
<span class="nc" id="L136">    public void setCryptoTokenId(int cryptoTokenId) { this.cryptoTokenId = cryptoTokenId; }</span>

    //@Version @Column
<span class="fc" id="L139">    public String getKeyAlias() {return keyAlias; }</span>
<span class="nc" id="L140">    public void setKeyAlias(String keyAlias) { this.keyAlias = keyAlias; }</span>

    //@Version @Column
<span class="fc" id="L143">    public String getPublicKeyId() {return publicKeyId; }</span>
<span class="nc" id="L144">    public void setPublicKeyId(String publicKeyId) { this.publicKeyId = publicKeyId; }</span>

	//@Version @Column
<span class="fc" id="L147">	public int getRowVersion() { return rowVersion; }</span>
<span class="fc" id="L148">	public void setRowVersion(int rowVersion) { this.rowVersion = rowVersion; }</span>

	//@Column @Lob
	@Override
<span class="fc" id="L152">	public String getRowProtection() { return rowProtection; }</span>
	@Override
<span class="fc" id="L154">	public void setRowProtection(String rowProtection) { this.rowProtection = rowProtection; }</span>

	@Transient
	public BigInteger getCertificateSN() {
<span class="nc" id="L158">		return new BigInteger(keyRecoveryDataPK.getCertSN(), 16);</span>
	}
	/*public void setCertificateSN(BigInteger certificatesn) {
		keyRecoveryDataPK.setCertSN(certificatesn.toString(16));
	}*/
	
	@Transient
	public byte[] getKeyDataAsByteArray() {
<span class="nc" id="L166">		return Base64.decode(this.getKeyData().getBytes());</span>
	}

    public void setKeyDataFromByteArray(byte[] keydata) {
<span class="nc" id="L170">		setKeyData(new String(Base64.encode(keydata)));</span>
<span class="nc" id="L171">	}</span>

    //
    // Start Database integrity protection methods
    //

    @Transient
    @Override
    protected String getProtectString(final int version) {
<span class="nc" id="L180">        final ProtectionStringBuilder build = new ProtectionStringBuilder();</span>
        // rowVersion is automatically updated by JPA, so it's not important, it is only used for optimistic locking
<span class="nc" id="L182">        build.append(getKeyRecoveryDataPK().getIssuerDN()).append(getKeyRecoveryDataPK().getCertSN()).append(getUsername()).append(getMarkedAsRecoverable()).append(getKeyData());</span>
<span class="nc" id="L183">        return build.toString();</span>
    }

    @Transient
    @Override
    protected int getProtectVersion() {
<span class="nc" id="L189">        return 1;</span>
    }

    @PrePersist
    @PreUpdate
    @Override
    protected void protectData() {
<span class="fc" id="L196">        super.protectData();</span>
<span class="fc" id="L197">    }</span>

    @PostLoad
    @Override
    protected void verifyData() {
<span class="nc" id="L202">        super.verifyData();</span>
<span class="nc" id="L203">    }</span>

    @Override
    @Transient
    protected String getRowId() {
<span class="nc" id="L208">        return new ProtectionStringBuilder().append(getKeyRecoveryDataPK().getIssuerDN()).append(getKeyRecoveryDataPK().getCertSN()).toString();</span>
    }

    //
    // End Database integrity protection methods
    //

	//
    // Search functions. 
    //

	/** @param entityManager EM
	 * @param pk PK
	 * @return the found entity instance or null if the entity does not exist */
    public static KeyRecoveryData findByPK(EntityManager entityManager, KeyRecoveryDataPK pk) {
<span class="nc" id="L223">    	return entityManager.find(KeyRecoveryData.class, pk);</span>
    }

	/** @param entityManager EM
	 * @param username User
	 * @return return the query results as a List. */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static List&lt;KeyRecoveryData&gt; findByUsername(EntityManager entityManager, String username) {
<span class="nc" id="L231">    	Query query = entityManager.createQuery(&quot;SELECT a FROM KeyRecoveryData a WHERE a.username=:username&quot;);</span>
<span class="nc" id="L232">    	query.setParameter(&quot;username&quot;, username);</span>
<span class="nc" id="L233">    	return query.getResultList();</span>
    }    
	 
	/** @param entityManager EM
	 * @param usermark User
	 * @return return the query results as a List. */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static List&lt;KeyRecoveryData&gt; findByUserMark(EntityManager entityManager, String usermark) {
<span class="nc" id="L241">    	List&lt;KeyRecoveryData&gt; ret = null;</span>
    	try {
<span class="nc" id="L243">        	Query query = entityManager.createQuery(&quot;SELECT a FROM KeyRecoveryData a WHERE a.username=:usermark AND a.markedAsRecoverableBool=TRUE&quot;);</span>
<span class="nc" id="L244">        	query.setParameter(&quot;usermark&quot;, usermark);</span>
<span class="nc" id="L245">    		ret = query.getResultList();</span>
<span class="nc" id="L246">    	} catch (Exception e) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">    		if (log.isDebugEnabled()) {</span>
<span class="nc" id="L248">        		log.debug(&quot;If database does not support boolean (like Ingres) we would expect an Exception here. Trying to treat markedAsRecoverable as an Integer.&quot;, e);</span>
    		}
<span class="nc" id="L250">        	Query query = entityManager.createQuery(&quot;SELECT a FROM KeyRecoveryData a WHERE a.username=:usermark AND a.markedAsRecoverableInt=1&quot;);</span>
<span class="nc" id="L251">        	query.setParameter(&quot;usermark&quot;, usermark);</span>
<span class="nc" id="L252">    		ret = query.getResultList();</span>
<span class="nc" id="L253">    	}</span>
<span class="nc" id="L254">    	return ret;</span>
    }    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>