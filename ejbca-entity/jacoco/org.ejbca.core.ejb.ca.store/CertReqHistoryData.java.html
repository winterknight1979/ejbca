<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CertReqHistoryData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">EJBCA JPA Entities</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.core.ejb.ca.store</a> &gt; <span class="el_source">CertReqHistoryData.java</span></div><h1>CertReqHistoryData.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.ejbca.core.ejb.ca.store;

import java.beans.XMLEncoder;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.cert.Certificate;
import java.util.Date;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.PostLoad;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.TypedQuery;

import org.apache.log4j.Logger;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.dbprotection.ProtectedData;
import org.cesecore.dbprotection.ProtectionStringBuilder;
import org.cesecore.util.CertTools;
import org.cesecore.util.SecureXMLDecoder;
import org.cesecore.util.StringTools;
import org.ejbca.core.model.ca.store.CertReqHistory;
import org.ejbca.core.model.ra.UserDataVO;
import org.ejbca.util.FixEndOfBrokenXML;

/**
 * Representation of historical information about the data user to create a certificate.
 * 
 * the information is currently used to:
 * - list request history for a user
 * - find issuing User DN (EndEntityInformation) when republishing a certificate (in case the userDN for the user changed)
 * 
 * @version $Id: CertReqHistoryData.java 34163 2020-01-02 15:00:17Z samuellb $
 */ 
@SuppressWarnings(&quot;deprecation&quot;)
@Entity
@Table(name=&quot;CertReqHistoryData&quot;)
public class CertReqHistoryData extends ProtectedData implements Serializable {

	private static final long serialVersionUID = 1L;
<span class="fc" id="L64">	private static final Logger log = Logger.getLogger(CertReqHistoryData.class);</span>

	private String issuerDN;
	private String fingerprint;
	private String serialNumber;
	private long timestamp;
	private String userDataVO;
	private String username;
<span class="pc" id="L72">	private int rowVersion = 0;</span>
	private String rowProtection;

	/**
	 * Entity Bean holding info about a request data at the time the certificate was issued.
	 * 
	 * @param incert the certificate issued
	 * @param issuerDN should be the same as CertTools.getIssuerDN(incert)
	 * @param endEntityInformation the data used to issue the certificate. 
	 */
<span class="nc" id="L82">	public CertReqHistoryData(Certificate incert, String issuerDN, EndEntityInformation endEntityInformation) {</span>
		// Exctract fields to store with the certificate.
<span class="nc" id="L84">		setFingerprint(CertTools.getFingerprintAsString(incert));</span>
<span class="nc" id="L85">        setIssuerDN(issuerDN);</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L87">        	log.debug(&quot;Creating certreqhistory data, serial=&quot; + CertTools.getSerialNumberAsString(incert) + &quot;, issuer=&quot; + getIssuerDN());</span>
        }
<span class="nc" id="L89">        setSerialNumber(CertTools.getSerialNumber(incert).toString());</span>
<span class="nc" id="L90">        setTimestamp(new Date().getTime());</span>
<span class="nc" id="L91">		setUsername(endEntityInformation.getUsername());</span>
<span class="nc" id="L92">		storeEndEntityInformation(endEntityInformation);</span>
<span class="nc" id="L93">	}</span>
	private void storeEndEntityInformation(EndEntityInformation endEntityInformation) {
		try {
			// Save the user admin data in xml encoding.
<span class="nc" id="L97">			final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L98">			try (final XMLEncoder encoder = new XMLEncoder(baos)) {</span>
<span class="nc" id="L99">			    encoder.writeObject(endEntityInformation);</span>
			}
<span class="nc" id="L101">			final String s = baos.toString(&quot;UTF-8&quot;);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">			if (log.isDebugEnabled()) {</span>
<span class="nc" id="L103">				log.debug(printEndEntityInformationXML(&quot;endEntityInformation:&quot;,s));</span>
			}
<span class="nc" id="L105">			setUserDataVO(s);</span>
<span class="nc" id="L106">		} catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L107">			log.error(&quot;&quot;, e);</span>
<span class="nc" id="L108">			throw new RuntimeException(e);    	                                              </span>
<span class="nc" id="L109">		} </span>
<span class="nc" id="L110">	}</span>

<span class="fc" id="L112">	public CertReqHistoryData() { }</span>
	
	/**
	 * DN of issuer of certificate
	 * Should not be used outside of entity bean, use getCertReqHistory instead
	 * @return issuer dn
	 */
	//@Column
<span class="fc" id="L120">	public String getIssuerDN() { return issuerDN; }</span>
	/**
	 * Use setIssuer instead
	 * @param issuerDN issuer dn
	 */
<span class="fc" id="L125">	public void setIssuerDN(String issuerDN) { this.issuerDN =issuerDN; }</span>

	/**
	 * Fingerprint of certificate
	 * Should not be used outside of entity bean, use getCertReqHistory instead
	 * @return fingerprint
	 */
	//@Id @Column
<span class="fc" id="L133">	public String getFingerprint() { return fingerprint; }</span>
	/**
	 * Fingerprint of certificate
	 * Shouldn't be set after creation.
	 * @param fingerprint fingerprint
	 */
<span class="fc" id="L139">	public void setFingerprint(String fingerprint) { this.fingerprint = fingerprint; }</span>

	/**
	 * Serialnumber formated as BigInteger.toString()
	 * Should not be used outside of entity bean, use getCertReqHistory instead
	 * @return serial number
	 */
	//@Column
<span class="fc" id="L147">	public String getSerialNumber() { return serialNumber; }</span>

	/**
	 * Serialnumber formated as BigInteger.toString()
	 * Shouldn't be set after creation.
	 * @param serialNumber serial number
	 */
<span class="fc" id="L154">	public void setSerialNumber(String serialNumber) { this.serialNumber = serialNumber; }</span>

	/**
	 * Date formated as seconds since 1970 (== Date.getTime())
	 * Should not be used outside of entity bean, use getCertReqHistory instead
	 * @return timestamp 
	 */
	//@Column
<span class="fc" id="L162">	public long getTimestamp() { return timestamp; }</span>

	/**
	 * Date formated as seconds since 1970 (== Date.getTime())
	 * Shouldn't be set after creation.
	 * @param timestamp when certificate request info was stored
	 */
<span class="fc" id="L169">	public void setTimestamp(long timestamp) { this.timestamp = timestamp; }</span>

	/**
     * UserDataVO in xmlencoded String format
     * Should not be used outside of entity bean, use getCertReqHistory instead
     * @return  xmlencoded encoded UserDataVO
     */
    //@Column @Lob
<span class="fc" id="L177">    public String getUserDataVO() { return userDataVO; }</span>

    /**
     * UserDataVO in  xmlencoded String format
     * Shouldn't be set after creation.
     * @param userDataVO xmlencoded encoded UserDataVO
     */
<span class="fc" id="L184">    public void setUserDataVO(String userDataVO) { this.userDataVO = userDataVO; }</span>

	/**
	 * username in database
	 * Should not be used outside of entity bean, use getCertReqHistory instead
	 * @return username
	 */
	//@Column
<span class="fc" id="L192">	public String getUsername() { return username; }</span>

	/**
	 * username
	 * Shouldn't be set after creation.
	 * @param username username
	 */
<span class="fc" id="L199">	public void setUsername(String username) { this.username = StringTools.stripUsername(username); }</span>

	//@Version @Column
<span class="fc" id="L202">	public int getRowVersion() { return rowVersion; }</span>
<span class="fc" id="L203">	public void setRowVersion(int rowVersion) { this.rowVersion = rowVersion; }</span>

	//@Column @Lob
	@Override
<span class="fc" id="L207">	public String getRowProtection() { return rowProtection; }</span>
	@Override
<span class="fc" id="L209">	public void setRowProtection(String rowProtection) { this.rowProtection = rowProtection; }</span>

	//
	// Public business methods used to help us manage certificates
	//

	/**
	 * Returns the value object containing the information of the entity bean.
	 * This is the method that should be used to retreive cert req history 
	 * correctly.
	 * 
	 * NOTE: This method will try to repair broken XML and will in that case
	 * update the database. This means that this method must always run in a
	 * transaction! 
	 * 
	 * @return certificate request history object
	 */
	@Transient
    public CertReqHistory getCertReqHistory() {

<span class="nc" id="L229">		return new CertReqHistory(this.getFingerprint(),this.getSerialNumber(),</span>
<span class="nc" id="L230">		                          this.getIssuerDN(),this.getUsername(),new Date(this.getTimestamp()),</span>
<span class="nc" id="L231">		                          decodeXML(getUserDataVO(), false));</span>
	}
	
	/** just used internally in the this class to indicate that the XML can not be fixed.
	 */
	private class NotPossibleToFixXML extends Exception {
		private static final long serialVersionUID = 3690860390706539637L;

        // just used internally in the this class to indicate that the XML can not be fixed.
<span class="nc" id="L240">		public NotPossibleToFixXML() {</span>
			// do nothing
<span class="nc" id="L242">		}</span>
	}
	
	/** decode objects that have been serialized to xml.
	 * This method tries to fix xml that has been broken by some characters missing in the end.
	 * This has been found in some older DB during upgrade from EJBCA 3.4, and seemed to be due to 
	 * internationalized characters. This seemed to truncate the XML somehow, and here we try to handle that
	 * in a nice way.  
	 * @param sXML XML
	 * @param lastTry  Bool
	 * @return Info
	 */
    private EndEntityInformation decodeXML(final String sXML, final boolean lastTry) {
<span class="nc" id="L255">		final byte baXML[] = sXML.getBytes(StandardCharsets.UTF_8);</span>
<span class="nc" id="L256">		EndEntityInformation endEntityInformation = null;</span>
		// The EndEntityInformation object is not fully serializable by XMLEncoder/Decoder
		// (the &quot;type&quot; field is not serialized correctly), so we set ignoreErrors to true
<span class="nc" id="L259">		try (final SecureXMLDecoder decoder = new SecureXMLDecoder(new ByteArrayInputStream(baXML), true)) {</span>
<span class="nc" id="L260">			Object o = decoder.readObject();</span>
			try  {
<span class="nc" id="L262">				endEntityInformation  = (EndEntityInformation)o;</span>
<span class="nc" id="L263">			} catch( ClassCastException e ) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">				if (log.isTraceEnabled()) {</span>
<span class="nc" id="L265">					log.trace(&quot;Trying to decode old type of CertReqHistoryData: &quot;+e.getMessage());</span>
				}
				// It is probably an older object of type UserDataVO
<span class="nc" id="L268">				UserDataVO olddata = (UserDataVO)o;</span>
<span class="nc" id="L269">				endEntityInformation = olddata.toEndEntityInformation();</span>
<span class="nc" id="L270">			}</span>
<span class="nc" id="L271">		} catch( Throwable t ) { // NOPMD: catch all to try to repair</span>
			// try to repair the end of the XML string.
			// this will only succeed if a limited number of chars is lost in the end of the string
			// note that this code will not make anything worse and that it will not be run if the XML can be encoded.
			// 
			try {
<span class="nc bnc" id="L277" title="All 2 branches missed.">				if ( lastTry ) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">				    if (t instanceof IOException) {</span>
<span class="nc" id="L279">				        final String msg = &quot;Failed to parse data map for certificate request history for '&quot; + getFingerprint() + &quot;': &quot; + t.getMessage();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">			            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L281">			                log.debug(msg + &quot;. Data:\n&quot; + sXML);</span>
			            }
<span class="nc" id="L283">			            throw new IllegalStateException(msg, t);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">				    } else if (t instanceof RuntimeException) {</span>
<span class="nc" id="L285">				        throw (RuntimeException) t;</span>
				    }
<span class="nc" id="L287">					return null;</span>
				}
<span class="nc" id="L289">				final String sFixedXML = FixEndOfBrokenXML.fixXML(sXML, &quot;string&quot;, &quot;&lt;/void&gt;&lt;/object&gt;&lt;/java&gt;&quot;);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">				if ( sFixedXML==null ) {</span>
<span class="nc" id="L291">					throw new NotPossibleToFixXML();					</span>
				}
<span class="nc" id="L293">				endEntityInformation = decodeXML(sFixedXML, true);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">				if ( endEntityInformation==null ) {</span>
<span class="nc" id="L295">					throw new NotPossibleToFixXML();</span>
				}
<span class="nc" id="L297">				storeEndEntityInformation(endEntityInformation); // store it right so it does not have to be repaired again.</span>
<span class="nc" id="L298">				log.warn(printEndEntityInformationXML(&quot;XML has been repaired. Trailing tags fixed. DB updated with correct XML.&quot;, sXML));</span>
<span class="nc" id="L299">				return endEntityInformation;</span>
<span class="nc" id="L300">			} catch ( NotPossibleToFixXML e ) {</span>
<span class="nc" id="L301">				log.error(printEndEntityInformationXML(&quot;Not possible to decode EndEntityInformation. No way to fix the XML.&quot;, sXML), t);</span>
<span class="nc" id="L302">				return null;</span>
			}
<span class="nc" id="L304">		}</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">		if (log.isTraceEnabled() ) {</span>
<span class="nc" id="L306">			log.trace(printEndEntityInformationXML(&quot;Successfully decoded EndEntityInformation XML.&quot;,sXML));</span>
		}
		/* Code that fixes broken XML that has actually been parsed. It seems that the decoder is not checking for the java end tag.
		 * Currently this is left out in order to not mess with working but broken XML.
		if ( sXML.indexOf(&quot;&lt;java&quot;)&gt;0 &amp;&amp; sXML.indexOf(&quot;&lt;/java&gt;&quot;)&lt;0 ) {
			storeEndEntityInformation(endEntityInformation); // store it right				
		}
		 */
<span class="nc" id="L314">		return endEntityInformation;</span>
	}
	private String printEndEntityInformationXML(String sComment, String sXML) {
<span class="nc" id="L317">		final StringWriter sw = new StringWriter();</span>
<span class="nc" id="L318">		final PrintWriter pw = new PrintWriter(sw);</span>
<span class="nc" id="L319">		pw.println(sComment);</span>
<span class="nc" id="L320">		pw.println(&quot;XMLDATA start on next line:&quot;);</span>
<span class="nc" id="L321">		pw.print(sXML);</span>
<span class="nc" id="L322">		pw.println(&quot;| end of XMLDATA. The char before '|' was the last XML.&quot;);</span>
<span class="nc" id="L323">		pw.println();</span>
<span class="nc" id="L324">		pw.println(&quot;Issuer DN: &quot;+getIssuerDN());</span>
<span class="nc" id="L325">		pw.println(&quot;Serial #&quot;+getSerialNumber());</span>
<span class="nc" id="L326">		pw.println(&quot;User name: &quot;+getUsername());</span>
<span class="nc" id="L327">		pw.println(&quot;Certificate fingerprint: &quot;+getFingerprint());</span>
<span class="nc" id="L328">		pw.println();</span>
<span class="nc" id="L329">		return sw.toString();</span>
	}

    //
    // Start Database integrity protection methods
    //

    @Transient
    @Override
    protected String getProtectString(final int version) {
<span class="nc" id="L339">        final ProtectionStringBuilder build = new ProtectionStringBuilder();</span>
        // rowVersion is automatically updated by JPA, so it's not important, it is only used for optimistic locking
<span class="nc" id="L341">        build.append(getFingerprint()).append(getIssuerDN()).append(getSerialNumber()).append(getTimestamp()).append(getUserDataVO()).append(getUsername());</span>
<span class="nc" id="L342">        return build.toString();</span>
    }

    @Transient
    @Override
    protected int getProtectVersion() {
<span class="nc" id="L348">        return 1;</span>
    }

    @PrePersist
    @PreUpdate
    @Override
    protected void protectData() {
<span class="fc" id="L355">        super.protectData();</span>
<span class="fc" id="L356">    }</span>

    @PostLoad
    @Override
    protected void verifyData() {
<span class="nc" id="L361">        super.verifyData();</span>
<span class="nc" id="L362">    }</span>

    @Override
    @Transient
    protected String getRowId() {
<span class="nc" id="L367">        return getFingerprint();</span>
    }

    //
    // End Database integrity protection methods
    //

	//
	// Search functions. 
	//

	/** @param entityManager EM
	 * @param fingerprint FP
	 * @return the found entity instance or null if the entity does not exist */
	public static CertReqHistoryData findById(EntityManager entityManager, String fingerprint) {
<span class="nc" id="L382">		return entityManager.find(CertReqHistoryData.class, fingerprint);</span>
	}
	
	/** @param entityManager EM
	 * @param issuerDN DN
	 * @param serialNumber SN 
	 * @return return the query results as a List. */
    public static List&lt;CertReqHistoryData&gt; findByIssuerDNSerialNumber(EntityManager entityManager, String issuerDN, String serialNumber) {
<span class="nc" id="L390">		final TypedQuery&lt;CertReqHistoryData&gt; query = entityManager.createQuery(&quot;SELECT a FROM CertReqHistoryData a WHERE a.issuerDN=:issuerDN AND a.serialNumber=:serialNumber&quot;, CertReqHistoryData.class);</span>
<span class="nc" id="L391">		query.setParameter(&quot;issuerDN&quot;, issuerDN);</span>
<span class="nc" id="L392">		query.setParameter(&quot;serialNumber&quot;, serialNumber);</span>
<span class="nc" id="L393">		return query.getResultList();</span>
	}

	/** @param entityManager EM
	 * @param username User
	 * @return return the query results as a List. */
    public static List&lt;CertReqHistoryData&gt; findByUsername(EntityManager entityManager, String username) {
<span class="nc" id="L400">	    final TypedQuery&lt;CertReqHistoryData&gt; query = entityManager.createQuery(&quot;SELECT a FROM CertReqHistoryData a WHERE a.username=:username&quot;, CertReqHistoryData.class);</span>
<span class="nc" id="L401">		query.setParameter(&quot;username&quot;, username);</span>
<span class="nc" id="L402">		return query.getResultList();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>