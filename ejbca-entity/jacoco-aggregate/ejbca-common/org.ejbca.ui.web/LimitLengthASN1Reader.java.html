<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LimitLengthASN1Reader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">ejbca-entity</a> &gt; <a href="../index.html" class="el_bundle">ejbca-common</a> &gt; <a href="index.source.html" class="el_package">org.ejbca.ui.web</a> &gt; <span class="el_source">LimitLengthASN1Reader.java</span></div><h1>LimitLengthASN1Reader.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.ejbca.ui.web;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1InputStream;
import org.cesecore.certificates.ocsp.exception.MalformedRequestException;
import org.ejbca.core.model.InternalEjbcaResources;

/** Helper class used all bytes for the first ASN.1 object in the stream. 
 * Limits the size that is ever read to MAX_REQUEST_SIZE. This class is used for example to read requests from POSTs to servlets, 
 * when you want to make sure that you never read too many bytes that might have been sent by an attacker.
 * Can only be used to read ASN.1 sequences, will throw MalformedException if first tag is not a sequence.
 * Example usage:
 * &lt;pre&gt;
 * final ServletInputStream in = request.getInputStream(); // ServletInputStream does not have to be closed, container handles this
 * ret = new LimitLengthASN1Reader(in, n).readFirstASN1Object();
 * &lt;/pre&gt;
 * 
 * @version $Id: LimitLengthASN1Reader.java 22152 2015-11-04 15:42:43Z mikekushner $
 */
public class LimitLengthASN1Reader extends ASN1InputStream {

<span class="fc" id="L38">	private static final Logger m_log = Logger.getLogger(LimitLengthASN1Reader.class);</span>
	/** Internal localization of logs and errors */
<span class="fc" id="L40">	private static final InternalEjbcaResources intres = InternalEjbcaResources.getInstance();</span>

	/** Max size of a request is 100000 bytes */
	public static final int MAX_REQUEST_SIZE = 100000;
	
	private ByteArrayOutputStream baos;

	final private int contentLength; 
	/**
	 * 
	 * @param input IS
	 * @param contentLength the provided contentLength, we do not trust it but will use it if given
	 */
	public LimitLengthASN1Reader(final InputStream input, final int contentLength) {
<span class="fc" id="L54">		super(input, MAX_REQUEST_SIZE);</span>
<span class="fc" id="L55">		this.baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L56">		this.contentLength = contentLength;</span>
<span class="fc" id="L57">	}</span>
	/* (non-Javadoc)
	 * @see java.io.FilterInputStream#read()
	 * This method is used in #readLeangth()
	 */
	@Override
	public int read() throws IOException {
<span class="fc" id="L64">		final int result = super.read();</span>
<span class="fc" id="L65">		this.baos.write(result);</span>
<span class="fc" id="L66">		return result;</span>
	}
	/**
	 * Read the 'value' of the top ASN1 object and append it to the already read 'tag' and 'value'
	 * @param length nr of value bytes that we should read
	 * @return the top ASN1 object
	 * @throws IOException IO fail
	 * @throws MalformedRequestException if the number of bytes read is less than length, i.e. asn.1 length tag was invalid
	 */
	private byte[] readTopASN1(final int length) throws IOException, MalformedRequestException {
        // This small code snippet is inspired/copied from apache IO utils by Tomas Gustavsson...
<span class="fc" id="L77">        final byte[] buf = new byte[length]; // buf of length length, normal optimal case is only one read operation below</span>
<span class="fc" id="L78">        int n = 0;</span>
<span class="fc" id="L79">        int bytesRead = 0;</span>
        // We must always read until it returns -1, make sure we read maximum length bytes
<span class="fc bfc" id="L81" title="All 2 branches covered.">        while (-1 != (n = read(buf, 0, length-bytesRead))) {</span>
<span class="fc" id="L82">            bytesRead += n;</span>
<span class="fc" id="L83">            this.baos.write(buf, 0, n);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            if (bytesRead &gt;= length) {</span>
                // We read as much as we should, stop reading
<span class="fc" id="L86">                break;</span>
            }
        }
<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (bytesRead != length) {</span>
            // If we have read less bytes than we should have, the asn.1 was incorrect and this might be some type of attempt to perform buffer overflow
<span class="fc" id="L91">            final String msg = intres.getLocalizedMessage(&quot;request.notcorrectasn1length&quot;, Integer.valueOf(length), Integer.valueOf(bytesRead));</span>
<span class="fc" id="L92">            m_log.info(msg);</span>
<span class="fc" id="L93">            throw new MalformedRequestException(msg);</span>
        }
<span class="fc" id="L95">        this.baos.flush();</span>
<span class="fc" id="L96">        return this.baos.toByteArray();</span>
	}

	/** Reads all bytes for the first ASN.1 object in the stream. Limits the size that is ever read to MAX_REQUEST_SIZE.
	 * @return all bytes for the first ASN.1 object in the stream. 
	 * @throws IOException IO fail
	 * @throws MalformedRequestException if the request is too large or not correctly GET encoded.
	 */
	public byte[] readFirstASN1Object() throws IOException, MalformedRequestException {
<span class="fc" id="L105">		final int tag = read() &amp; 0x1f;</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">		if (tag != SEQUENCE) {</span>
<span class="fc" id="L107">			final String msg = intres.getLocalizedMessage(&quot;request.notasequence&quot;, Integer.valueOf(tag));</span>
<span class="fc" id="L108">			m_log.info(msg);</span>
<span class="fc" id="L109">			throw new MalformedRequestException(msg);</span>
		}
<span class="fc" id="L111">		final int length = readLength();</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">		if (length &gt; MAX_REQUEST_SIZE) {</span>
<span class="nc" id="L113">			final String msg = intres.getLocalizedMessage(&quot;request.toolarge&quot;, Integer.valueOf(MAX_REQUEST_SIZE), Integer.valueOf(length));</span>
<span class="nc" id="L114">			m_log.info(msg);</span>
<span class="nc" id="L115">			throw new MalformedRequestException(msg);</span>
		}
		// If there was an asn.1 stream of undefined length we will try to read it the classic way, limiting the size of bytes read.
<span class="fc bfc" id="L118" title="All 2 branches covered.">		if (length &lt; 0) {// undefined length</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">			if (this.contentLength &gt; MAX_REQUEST_SIZE) {</span>
<span class="nc" id="L120">				final String msg = intres.getLocalizedMessage(&quot;request.toolarge&quot;, Integer.valueOf(MAX_REQUEST_SIZE), Integer.valueOf(this.baos.size()));</span>
<span class="nc" id="L121">				m_log.info(msg);</span>
<span class="nc" id="L122">				throw new MalformedRequestException(msg);</span>
			}
<span class="fc" id="L124">			final int tlByteLength = this.baos.toByteArray().length;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">			if (this.contentLength &lt; tlByteLength) { // Content-length invalid. Try to read although.</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">				if (m_log.isTraceEnabled()) {</span>
<span class="nc" id="L127">					m_log.trace(&quot;No content-length, reading as much as we have (&lt;MAX_REQUEST_SIZE)&quot;);</span>
				}
<span class="fc" id="L129">				final byte[] t = new byte[10240];</span>
<span class="fc" id="L130">				int r = 0;</span>
<span class="fc" id="L131">				int len = 0;</span>
<span class="pc bpc" id="L132" title="1 of 4 branches missed.">				while ( ((len = read(t)) != -1) &amp;&amp; (r &lt; LimitLengthASN1Reader.MAX_REQUEST_SIZE) ) { // never read more than MAX_OCSP_REQUEST_SIZE bytes</span>
<span class="fc" id="L133">					this.baos.write(t, 0, len);</span>
<span class="fc" id="L134">					r = r + len;</span>
				}
<span class="fc" id="L136">				return this.baos.toByteArray();</span>
			}
			// Read content-length bytes from stream
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">			if (m_log.isTraceEnabled()) {</span>
<span class="nc" id="L140">				m_log.trace(&quot;Got content-length: &quot;+this.contentLength);</span>
			}
<span class="fc" id="L142">			return readTopASN1(this.contentLength-tlByteLength); // 'tlByteLength' bytes already read. 'this.contentLength &lt;= MAX_REQUEST_SIZE' tested above.</span>
		}
		// defined length, just read as many bytes as the length tag says
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">		if (m_log.isTraceEnabled()) {</span>
<span class="nc" id="L146">			m_log.trace(&quot;Got ASN1 length: &quot;+length);</span>
		}
<span class="fc" id="L148">		return readTopASN1(length);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>