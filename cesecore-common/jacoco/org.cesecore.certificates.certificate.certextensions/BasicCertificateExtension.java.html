<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BasicCertificateExtension.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.certificate.certextensions</a> &gt; <span class="el_source">BasicCertificateExtension.java</span></div><h1>BasicCertificateExtension.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.certificate.certextensions;

import java.io.IOException;
import java.math.BigInteger;
import java.security.PublicKey;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Boolean;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.DERNull;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERPrintableString;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.DERUTF8String;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.certificates.ca.CA;
import org.cesecore.certificates.ca.internal.CertificateValidity;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.cesecore.internal.InternalResources;

/**
 * The default basic certificate extension that has two property.
 * 
 * 'value' : The value returned 'encoding' : How the value is encoded.
 * 
 * Optionally, a new property can be defined:
 * 
 * 'nvalues' : number of values of type 'encoding'
 * 
 * Thus, the extension will be of type 'SEQUENCE OF ENCODING' with a size of nvalues. The members will be: 'value1', 'value2' and so on.
 * 
 * Optionally, an other property can be defined:
 * 
 *  'dynamic' : true/false if the extension value(s) should be allowed to be 
 *              overridden by value(s) put as extensiondata in 
 *              ExtendedInformation. Default is 'false'.
 *
 *
 * See documentation for more information.
 * 
 * @version $Id: BasicCertificateExtension.java 30583 2018-11-22 17:32:11Z samuellb $
 */
<span class="fc" id="L67">public class BasicCertificateExtension extends CertificateExtension implements CustomCertificateExtension {</span>

    private static final long serialVersionUID = 6896964791897238060L;

    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L72">	private static final Logger log = Logger.getLogger(BasicCertificateExtension.class);</span>

<span class="fc" id="L74">    private static final InternalResources intres = InternalResources.getInstance();</span>
    
    private static final String DISPLAY_NAME = &quot;Basic Certificate Extension&quot;;

<span class="fc" id="L78">    private enum Encoding {</span>
<span class="fc" id="L79">        ENCODING_DERBITSTRING(&quot;DERBITSTRING&quot;),</span>
<span class="fc" id="L80">        ENCODING_DERINTEGER(&quot;DERINTEGER&quot;),</span>
<span class="fc" id="L81">        ENCODING_DEROCTETSTRING(&quot;DEROCTETSTRING&quot;),</span>
<span class="fc" id="L82">        ENCODING_DERBOOLEAN(&quot;DERBOOLEAN&quot;),</span>
<span class="fc" id="L83">        ENCODING_DERPRINTABLESTRING(&quot;DERPRINTABLESTRING&quot;),</span>
<span class="fc" id="L84">        ENCODING_DERUTF8STRING(&quot;DERUTF8STRING&quot;),</span>
<span class="fc" id="L85">        ENCODING_DERIA5STRING(&quot;DERIA5STRING&quot;),</span>
<span class="fc" id="L86">        ENCODING_DERNULL(&quot;DERNULL&quot;),</span>
<span class="fc" id="L87">        ENCODING_DEROBJECT(&quot;DEROBJECT&quot;),</span>
<span class="fc" id="L88">        ENCODING_DEROID(&quot;DERBOJECTIDENTIFIER&quot;);</span>
        
<span class="fc" id="L90">        private static final Map&lt;String, Encoding&gt; lookupMap = new HashMap&lt;String, Encoding&gt;();</span>
        
        static {
<span class="fc bfc" id="L93" title="All 2 branches covered.">            for(Encoding encoding : Encoding.values()) {</span>
<span class="fc" id="L94">                lookupMap.put(encoding.value(), encoding);</span>
            }
<span class="fc" id="L96">        }</span>
        
        private final String value;

        
<span class="fc" id="L101">        private Encoding(String value) {</span>
<span class="fc" id="L102">            this.value = value;</span>
<span class="fc" id="L103">        }</span>
        
        public String value() {
<span class="fc" id="L106">            return value;</span>
        }
        
        public boolean equals(Encoding otherValue) {
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            if(otherValue == null) {</span>
<span class="nc" id="L111">                return false;</span>
            }
<span class="fc" id="L113">            return value.equalsIgnoreCase(otherValue.value());</span>
        }
        
        public static final Encoding fromString(String value) {
<span class="fc" id="L117">            return lookupMap.get(StringUtils.upperCase(value, Locale.ROOT));</span>
        }
        
      
    }


    /** 
     * The value is expected to by hex encoded and is added as an byte array 
     * as the extension value. 
     **/
<span class="fc" id="L128">    private static String ENCODING_RAW = &quot;RAW&quot;;</span>
<span class="fc" id="L129">    private static String ENCODING_DERNULL = &quot;DERNULL&quot;;</span>

    // Defined Properties
<span class="fc" id="L132">    private static String PROPERTY_VALUE = &quot;value&quot;;</span>
<span class="fc" id="L133">    private static String PROPERTY_ENCODING = &quot;encoding&quot;;</span>
<span class="fc" id="L134">    private static String PROPERTY_NVALUES = &quot;nvalues&quot;;</span>
<span class="fc" id="L135">    private static String PROPERTY_DYNAMIC  = &quot;dynamic&quot;;</span>
    
<span class="fc" id="L137">    private static final Map&lt;String, String[]&gt; propertiesMap = new HashMap&lt;String, String[]&gt;();</span>
    
    static {
<span class="fc" id="L140">        Encoding[] encodings = Encoding.values();</span>
        // +1 because we need to add RAW as well in the end
<span class="fc" id="L142">        String[] encodingValues = new String[encodings.length+1];</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        for(int i = 0; i &lt; encodings.length; i++) {</span>
<span class="fc" id="L144">            encodingValues[i] = encodings[i].value;</span>
        }
        // Add RAW last
<span class="fc" id="L147">        encodingValues[encodingValues.length-1] = ENCODING_RAW;</span>
        
<span class="fc" id="L149">        propertiesMap.put(PROPERTY_ENCODING, encodingValues);</span>
<span class="fc" id="L150">        propertiesMap.put(PROPERTY_VALUE, new String[]{});</span>
<span class="fc" id="L151">        propertiesMap.put(PROPERTY_DYNAMIC, CustomCertificateExtension.BOOLEAN);</span>
<span class="fc" id="L152">    }</span>
    
    {
<span class="fc" id="L155">        setDisplayName(DISPLAY_NAME);</span>
<span class="fc" id="L156">    }</span>

    /**
     * @deprecated use getValueEncoded instead.
     */
    public ASN1Encodable getValue(EndEntityInformation userData, CA ca, CertificateProfile certProfile, PublicKey userPublicKey, PublicKey caPublicKey, CertificateValidity val)
    throws CertificateExtensionException {
<span class="nc" id="L163">        throw new UnsupportedOperationException(&quot;Use getValueEncoded instead&quot;);</span>
    }

    /**
     * Returns the defined property 'value' in the encoding specified in 'encoding'.
     * 
     * This certificate extension implementations overrides this method as it 
     * want to be able to return a byte[] with the extension value. Otherwise 
     * the implementation could have been put in the getValue method as the 
     * super class CertificateExtension has a default implementation for 
     * getValueEncoded which calls getValue.
     * 
     * @param userData
     *            Used to lookup extension data
     * @param ca
     *            not used
     * @param certProfile
     *            not used
     * @see org.cesecore.certificates.certificate.certextensions.CertificateExtension#getValueEncoded(EndEntityInformation, CA, CertificateProfile, PublicKey,
     *      PublicKey, CertificateValidity)
     */
    @Override
    public byte[] getValueEncoded(EndEntityInformation userData, CA ca, CertificateProfile certProfile, PublicKey userPublicKey,
            PublicKey caPublicKey, CertificateValidity val) throws CertificateExtensionException {
<span class="fc" id="L187">        String[] values = getValues(userData, null);</span>
<span class="fc" id="L188">        return handleValues(values);</span>
    }
    
    @Override
    public byte[] getValueEncoded(EndEntityInformation userData, CA ca, CertificateProfile certProfile, PublicKey userPublicKey,
            PublicKey caPublicKey, CertificateValidity val, String oid) throws CertificateExtensionException {
<span class="nc" id="L194">        String[] values = getValues(userData, oid);</span>
<span class="nc" id="L195">        return handleValues(values);</span>
    }

    private byte[] handleValues(String[] values) throws CertificateExtensionException {
        final byte[] result;
<span class="fc" id="L200">        String encoding = StringUtils.trim(getProperties().getProperty(PROPERTY_ENCODING));</span>
<span class="pc bpc" id="L201" title="2 of 8 branches missed.">        if (values == null || values.length == 0 || (values[0] == null &amp;&amp; !encoding.equalsIgnoreCase(ENCODING_DERNULL))) {</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">            if (!isRequiredFlag()) {</span>
<span class="nc" id="L203">                return null;</span>
            }
<span class="fc" id="L205">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.incorrectvalue&quot;, Integer.valueOf(getId()), getOID()));</span>
        }

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (encoding.equalsIgnoreCase(ENCODING_RAW)) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            if (values.length &gt; 1) {</span>
                // nvalues can not be used together with encoding=RAW
<span class="fc" id="L211">                throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.certextmissconfigured&quot;, Integer.valueOf(getId())));</span>
            } else {
<span class="fc" id="L213">                result = parseRaw(values[0]);</span>
            }
        } else {
            try {
<span class="fc bfc" id="L217" title="All 2 branches covered.">                if (values.length &gt; 1) {</span>
<span class="fc" id="L218">                    ASN1EncodableVector ev = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                    for (String value : values) {</span>
<span class="fc" id="L220">                        ASN1Encodable derval = parseValue(encoding, value);</span>
<span class="fc" id="L221">                        ev.add(derval);</span>
                    }
<span class="fc" id="L223">                    result = new DERSequence(ev).getEncoded();</span>
<span class="fc" id="L224">                } else {</span>
<span class="fc" id="L225">                    result = parseValue(encoding, values[0]).toASN1Primitive().getEncoded();</span>
                }
<span class="nc" id="L227">            } catch (IOException ioe) {</span>
<span class="nc" id="L228">                throw new CertificateExtensionException(ioe.getMessage(), ioe);</span>
<span class="fc" id="L229">            }</span>
        }
<span class="fc" id="L231">        return result;</span>
    }

    /**
     * Get the extension value by first looking in the ExtendedInformation (if 
     * dynamic is enabled) and then in the static configuration.
     * 
     * @param userData The userdata to get the ExtendedInformation from
     * @param oid OID
     * @return The value(s) for the extension (usually 1) or null if no value found
     */
    private String[] getValues(EndEntityInformation userData, final String oid) {
<span class="fc" id="L243">        String[] result = null;</span>

<span class="fc" id="L245">        boolean dynamic = Boolean.parseBoolean(StringUtils.trim(getProperties().getProperty(PROPERTY_DYNAMIC, Boolean.FALSE.toString())));</span>

<span class="fc" id="L247">        String strnvalues = getProperties().getProperty(PROPERTY_NVALUES);</span>
        int nvalues;

<span class="pc bpc" id="L250" title="1 of 4 branches missed.">        if ( strnvalues == null || strnvalues.trim().equals(&quot;&quot;) ) {</span>
<span class="fc" id="L251">            nvalues = 0;</span>
        } else {
<span class="fc" id="L253">            nvalues = Integer.parseInt(strnvalues);</span>
        }

<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (dynamic) {</span>
<span class="fc" id="L257">            final ExtendedInformation ei = userData.getExtendedInformation();</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">            if (ei == null) {</span>
<span class="nc" id="L259">                result = null;</span>
            } else {
<span class="fc bfc" id="L261" title="All 2 branches covered.">                if (nvalues &lt; 1 ) {</span>
<span class="fc" id="L262">                    String value = null;</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                    if (oid != null) {</span>
<span class="nc" id="L264">                        value = userData.getExtendedInformation().getExtensionData(oid);</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">                        if (value == null || value.trim().isEmpty()) {</span>
<span class="nc" id="L266">                            value = userData.getExtendedInformation().getExtensionData(oid + &quot;.&quot; + PROPERTY_VALUE);</span>
                        }
                    } else {
<span class="fc" id="L269">                        value = userData.getExtendedInformation().getExtensionData(getOID());</span>
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">                        if (value == null || value.trim().isEmpty()) {</span>
<span class="fc" id="L271">                            value = userData.getExtendedInformation().getExtensionData(getOID() + &quot;.&quot; + PROPERTY_VALUE);</span>
                        }
                    }
<span class="fc bfc" id="L274" title="All 2 branches covered.">                    if (value == null) {</span>
<span class="fc" id="L275">                        result = null;</span>
                    } else {
<span class="fc" id="L277">                        result = new String[] { value };</span>
                    }
<span class="fc" id="L279">                } else {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                    for (int i = 1; i &lt;= nvalues; i++) {</span>
<span class="fc" id="L281">                        String value = null;</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">                        if (oid != null) {</span>
<span class="nc" id="L283">                            value = userData.getExtendedInformation().getExtensionData(oid + &quot;.&quot; + PROPERTY_VALUE + Integer.toString(i));</span>
                        } else {
<span class="fc" id="L285">                            value = userData.getExtendedInformation().getExtensionData(getOID() + &quot;.&quot; + PROPERTY_VALUE + Integer.toString(i));</span>
                        }
<span class="fc bfc" id="L287" title="All 2 branches covered.">                        if (value != null) {</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">                            if (result == null) {</span>
<span class="fc" id="L289">                                result = new String[nvalues];</span>
                            }
<span class="fc" id="L291">                            result[i - 1] = value;</span>
                        }
                    }
                }
            }
        }
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">            if (nvalues &lt; 1 ) {</span>
<span class="fc" id="L299">                String value = getProperties().getProperty(PROPERTY_VALUE);</span>
<span class="fc bfc" id="L300" title="All 4 branches covered.">                if ( value == null || value.trim().equals(&quot;&quot;) ) {</span>
<span class="fc" id="L301">                    value = getProperties().getProperty(PROPERTY_VALUE+&quot;1&quot;);</span>
                }
<span class="fc" id="L303">                result = new String[] { value };</span>
<span class="fc" id="L304">            } else {</span>
<span class="fc" id="L305">                result = new String[nvalues];</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">                for (int i=1; i&lt;=nvalues; i++) {</span>
<span class="fc" id="L307">                    result[i - 1] = getProperties().getProperty(PROPERTY_VALUE+Integer.toString(i));</span>
                }
            }
        }
<span class="fc" id="L311">        return result;</span>
    } 

    private ASN1Encodable parseValue(String encoding, String value) throws CertificateExtensionException {

<span class="fc" id="L316">        ASN1Encodable toret = null;</span>
        
<span class="fc" id="L318">        Encoding encodingType = Encoding.fromString(encoding);</span>
        
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if(encodingType == null) {</span>
<span class="fc" id="L321">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.incorrectenc&quot;, encoding,</span>
<span class="fc" id="L322">                    Integer.valueOf(getId())));</span>
        }

<span class="pc bpc" id="L325" title="4 of 8 branches missed.">        if (!Encoding.ENCODING_DERNULL.equals(encodingType) &amp;&amp; ((value == null || value.trim().equals(&quot;&quot;)) &amp;&amp; isRequiredFlag())) {</span>
<span class="nc" id="L326">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.incorrectvalue&quot;, Integer.valueOf(getId()), getOID()));</span>
        }

<span class="pc bpc" id="L329" title="1 of 11 branches missed.">        switch(encodingType) { </span>
        case ENCODING_DERBITSTRING:
<span class="fc" id="L331">            toret = parseDERBitString(value);</span>
<span class="fc" id="L332">            break;</span>
        case ENCODING_DERINTEGER:
<span class="fc" id="L334">            toret = parseDERInteger(value);</span>
<span class="fc" id="L335">            break;</span>
        case ENCODING_DEROCTETSTRING:
<span class="fc" id="L337">            toret = parseDEROctetString(value);</span>
<span class="fc" id="L338">            break;</span>
        case ENCODING_DERBOOLEAN:
<span class="fc" id="L340">            toret = parseDERBoolean(value);</span>
<span class="fc" id="L341">            break;</span>
        case ENCODING_DEROID:
<span class="fc" id="L343">            toret = parseDEROID(value);</span>
<span class="fc" id="L344">            break;</span>
        case ENCODING_DERPRINTABLESTRING:
<span class="fc" id="L346">            toret = parseDERPrintableString(value);</span>
<span class="fc" id="L347">            break;</span>
        case ENCODING_DERUTF8STRING:
<span class="fc" id="L349">            toret = parseDERUTF8String(value);</span>
<span class="fc" id="L350">            break;</span>
        case ENCODING_DERIA5STRING:
<span class="fc" id="L352">            toret = parseDERIA5String(value);</span>
<span class="fc" id="L353">            break;</span>
        case ENCODING_DERNULL:
<span class="fc" id="L355">            toret = DERNull.INSTANCE;</span>
<span class="fc" id="L356">            break;</span>
        case ENCODING_DEROBJECT:
<span class="fc" id="L358">            toret = parseHexEncodedDERObject(value);</span>
<span class="fc" id="L359">            break;</span>
        default:
<span class="nc" id="L361">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.incorrectenc&quot;, encoding,</span>
<span class="nc" id="L362">                    Integer.valueOf(getId())));</span>
        }
<span class="fc" id="L364">        return toret;</span>
    }

    private ASN1Encodable parseDERBitString(String value) throws CertificateExtensionException {
<span class="fc" id="L368">        ASN1Encodable retval = null;</span>
        try {
<span class="fc" id="L370">            BigInteger bigInteger = new BigInteger(value, 2);</span>
<span class="fc" id="L371">            int padBits = value.length() - 1 - value.lastIndexOf(&quot;1&quot;);</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            if (padBits == 8) {</span>
<span class="nc" id="L373">                padBits = 0;</span>
            }
<span class="fc" id="L375">            byte[] byteArray = bigInteger.toByteArray();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            if (byteArray[0] == 0) {</span>
                // Remove empty extra byte
                // System.arraycopy handles creating of temporary array when destinatio is the same
<span class="fc" id="L379">                System.arraycopy(byteArray, 1, byteArray, 0, byteArray.length-1);</span>
            }
<span class="fc" id="L381">            retval = new DERBitString(byteArray, padBits);</span>
<span class="fc" id="L382">        } catch (NumberFormatException e) {</span>
<span class="fc" id="L383">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L384">                    Integer.valueOf(getId()), getOID()));</span>
<span class="fc" id="L385">        }</span>

<span class="fc" id="L387">        return retval;</span>
    }

    private ASN1Encodable parseDEROID(String value) throws CertificateExtensionException {
<span class="fc" id="L391">        ASN1Encodable retval = null;</span>
        try {
<span class="fc" id="L393">            retval = new ASN1ObjectIdentifier(value);</span>
<span class="fc" id="L394">        } catch (Exception e) {</span>
<span class="fc" id="L395">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L396">                    Integer.valueOf(getId()), getOID()));</span>
<span class="fc" id="L397">        }</span>

<span class="fc" id="L399">        return retval;</span>
    }

    private ASN1Encodable parseDERInteger(String value) throws CertificateExtensionException {
<span class="fc" id="L403">        ASN1Encodable retval = null;</span>
        try {
<span class="fc" id="L405">            BigInteger intValue = new BigInteger(value, 10);</span>
<span class="fc" id="L406">            retval = new ASN1Integer(intValue);</span>
<span class="fc" id="L407">        } catch (NumberFormatException e) {</span>
<span class="fc" id="L408">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L409">                    Integer.valueOf(getId()), getOID()));</span>
<span class="fc" id="L410">        }</span>

<span class="fc" id="L412">        return retval;</span>
    }

    private ASN1Encodable parseDEROctetString(String value) throws CertificateExtensionException {
<span class="fc" id="L416">        ASN1Encodable retval = null;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (value.matches(&quot;^\\p{XDigit}*&quot;)) {</span>
<span class="fc" id="L418">            byte[] bytes = Hex.decode(value);</span>
<span class="fc" id="L419">            retval = new DEROctetString(bytes);</span>
<span class="fc" id="L420">        } else {</span>
<span class="fc" id="L421">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L422">                    Integer.valueOf(getId()), getOID()));</span>
        }
<span class="fc" id="L424">        return retval;</span>
    }

    /**
     * Tries to read the hex-string as an DERObject. If it contains more than one ASN1Encodable object, return a DERSequence of the objects.
     * @param value value
     * @return DER sequence
     * @throws CertificateExtensionException on fail
     */
    private ASN1Encodable parseHexEncodedDERObject(String value) throws CertificateExtensionException {
<span class="fc" id="L434">        ASN1Encodable retval = null;</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (value.matches(&quot;^\\p{XDigit}*&quot;)) {</span>
<span class="fc" id="L436">            byte[] bytes = Hex.decode(value);</span>
            try {
<span class="fc" id="L438">                ASN1InputStream ais = new ASN1InputStream(bytes);</span>
<span class="fc" id="L439">                ASN1Encodable firstObject = ais.readObject();</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">                if (ais.available() &gt; 0) {</span>
<span class="nc" id="L441">                    ASN1EncodableVector ev = new ASN1EncodableVector();</span>
<span class="nc" id="L442">                    ev.add(firstObject);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    while (ais.available() &gt; 0) {</span>
<span class="nc" id="L444">                        ev.add(ais.readObject());</span>
                    }
<span class="nc" id="L446">                    retval = new DERSequence(ev);</span>
<span class="nc" id="L447">                } else {</span>
<span class="fc" id="L448">                    retval = firstObject;</span>
                }
<span class="fc" id="L450">                ais.close();</span>
<span class="nc" id="L451">            } catch (Exception e) {</span>
<span class="nc" id="L452">                throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="nc" id="L453">                        Integer.valueOf(getId()), getOID()));</span>
<span class="fc" id="L454">            }</span>
<span class="fc" id="L455">        } else {</span>
<span class="fc" id="L456">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L457">                    Integer.valueOf(getId()), getOID()));</span>
        }
<span class="fc" id="L459">        return retval;</span>
    }

    private ASN1Encodable parseDERBoolean(String value) throws CertificateExtensionException {
<span class="fc" id="L463">        ASN1Encodable retval = null;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (value.equalsIgnoreCase(&quot;TRUE&quot;)) {</span>
<span class="fc" id="L465">            retval = ASN1Boolean.TRUE;</span>
        }

<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (value.equalsIgnoreCase(&quot;FALSE&quot;)) {</span>
<span class="fc" id="L469">            retval = ASN1Boolean.FALSE;</span>
        }

<span class="fc bfc" id="L472" title="All 2 branches covered.">        if (retval == null) {</span>
<span class="fc" id="L473">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L474">                    Integer.valueOf(getId()), getOID()));</span>
        }

<span class="fc" id="L477">        return retval;</span>
    }

    private ASN1Encodable parseDERPrintableString(String value) throws CertificateExtensionException {
        try {
<span class="fc" id="L482">            return new DERPrintableString(value, true);</span>
<span class="fc" id="L483">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L484">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L485">                    Integer.valueOf(getId()), getOID()));</span>
        }
    }

    private ASN1Encodable parseDERUTF8String(String value) {
<span class="fc" id="L490">        return new DERUTF8String(value);</span>
    }

    private ASN1Encodable parseDERIA5String(String value) throws CertificateExtensionException {
        try {
<span class="fc" id="L495">            return new DERIA5String(value, true);</span>
<span class="fc" id="L496">        } catch (java.lang.IllegalArgumentException e) {</span>
<span class="fc" id="L497">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.illegalvalue&quot;, value,</span>
<span class="fc" id="L498">                    Integer.valueOf(getId()), getOID()));</span>
        }
    }

    private byte[] parseRaw(String value) throws CertificateExtensionException {
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">        if(value == null) {</span>
<span class="nc" id="L504">            throw new CertificateExtensionException(intres.getLocalizedMessage(&quot;certext.basic.incorrectvalue&quot;, Integer.valueOf(getId()), getOID()));</span>
        }
<span class="fc" id="L506">        return Hex.decode(value);</span>
    }

    @Override
    public Map&lt;String, String[]&gt; getAvailableProperties() {
<span class="nc" id="L511">        return propertiesMap;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>