<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InternalKeyBindingBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keybind</a> &gt; <span class="el_source">InternalKeyBindingBase.java</span></div><h1>InternalKeyBindingBase.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keybind;

import java.io.Serializable;
import java.security.cert.Certificate;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.log4j.Logger;
import org.cesecore.config.AvailableExtendedKeyUsagesConfiguration;
import org.cesecore.internal.UpgradeableDataHashMap;
import org.cesecore.util.ui.DynamicUiProperty;

/**
 * Holder of general InternalKeyBinding relevant properties.
 *
 * @version $Id: InternalKeyBindingBase.java 30208 2018-10-26 09:04:57Z samuellb
 *     $
 */
<span class="fc" id="L36">public abstract class InternalKeyBindingBase extends UpgradeableDataHashMap</span>
    implements InternalKeyBinding {

  private static final long serialVersionUID = 1L;
  /** Logger. */
<span class="fc" id="L41">  private static final Logger LOG =</span>
<span class="fc" id="L42">      Logger.getLogger(InternalKeyBindingBase.class);</span>
  /** Property. */
  private static final String PROP_NEXT_KEY_PAIR_ALIAS = &quot;nextKeyPairAlias&quot;;
  /** Property. */
  private static final String PROP_TRUSTED_CERTIFICATE_REFERENCES =
      &quot;trustedCertificateReferences&quot;;
  /** Property. */
  private static final String PROP_SIGNATURE_ALGORITHM = &quot;signatureAlgorithm&quot;;
  /** Extensions. */
  private static final String PROP_OCSP_EXTENSION = &quot;ocspExtensions&quot;;
  /** Prefix. */
  private static final String BASECLASS_PREFIX = &quot;BASECLASS_&quot;;
  /** Prefix. */
  public static final String SUBCLASS_PREFIX = &quot;SUBCLASS_&quot;;
  /** ID. */
  private int internalKeyBindingId;
  /** Name. */
  private String name;
  /** Status. */
  private InternalKeyBindingStatus status;
  /** Status. */
  private InternalKeyBindingOperationalStatus operationalStatus;
  /** ID. */
  private String certificateId;
  /** ID. */
  private int cryptoTokenId;
  /** Alias. */
  private String keyPairAlias;
  /** Refs.  */
  private List&lt;InternalKeyBindingTrustEntry&gt; trustedCertificateReferences;
  /** extensions. */
  private List&lt;String&gt; ocspExtensions;
  /** Algo. */
  private String signatureAlgorithm;

  /**
   * Map.
   */
<span class="fc" id="L80">  private final LinkedHashMap&lt;String, DynamicUiProperty&lt;? extends Serializable&gt;&gt;</span>
      propertyTemplates = new LinkedHashMap&lt;&gt;();

  /**
   * @param property property
   */
  protected void addProperty(
      final DynamicUiProperty&lt;? extends Serializable&gt; property) {
<span class="fc" id="L88">    propertyTemplates.put(property.getName(), property);</span>
<span class="fc" id="L89">  }</span>

  @Override
  public Map&lt;String, DynamicUiProperty&lt;? extends Serializable&gt;&gt;
      getCopyOfProperties() {
<span class="nc" id="L94">    final LinkedHashMap&lt;String, DynamicUiProperty&lt;? extends Serializable&gt;&gt; ret =</span>
        new LinkedHashMap&lt;&gt;();
<span class="nc bnc" id="L96" title="All 2 branches missed.">    for (String key : propertyTemplates.keySet()) {</span>
<span class="nc" id="L97">      DynamicUiProperty&lt;? extends Serializable&gt; current =</span>
<span class="nc" id="L98">          propertyTemplates.get(key);</span>
<span class="nc" id="L99">      final DynamicUiProperty&lt;? extends Serializable&gt; clone = current.clone();</span>
<span class="nc" id="L100">      clone.setValueGeneric(getProperty(clone.getName()).getValue());</span>
<span class="nc" id="L101">      ret.put(key, clone);</span>
<span class="nc" id="L102">    }</span>
<span class="nc" id="L103">    return ret;</span>
  }

  @Override
  public DynamicUiProperty&lt;? extends Serializable&gt; getProperty(
      final String aName) {
<span class="fc" id="L109">    DynamicUiProperty&lt;? extends Serializable&gt; property =</span>
<span class="fc" id="L110">        propertyTemplates.get(aName);</span>
<span class="fc" id="L111">    property = new DynamicUiProperty&lt;&gt;(property);</span>
<span class="fc" id="L112">    property.setValueGeneric(getData(aName, property.getDefaultValue()));</span>
<span class="fc" id="L113">    return property;</span>
  }

  @Override
  public void setProperty(final String aName, final Serializable value) {
<span class="fc" id="L118">    putData(aName, value);</span>
<span class="fc" id="L119">  }</span>

  @Override
  public void init(
      final int aInternalKeyBindingId,
      final String aName,
      final InternalKeyBindingStatus aStatus,
      final String aCertificateId,
      final int aCryptoTokenId,
      final String aKeyPairAlias,
      final LinkedHashMap&lt;Object, Object&gt; aDataMap) {
<span class="nc" id="L130">    this.internalKeyBindingId = aInternalKeyBindingId;</span>
<span class="nc" id="L131">    setName(aName);</span>
<span class="nc" id="L132">    setStatus(aStatus);</span>
<span class="nc" id="L133">    setCertificateId(aCertificateId);</span>
<span class="nc" id="L134">    setCryptoTokenId(aCryptoTokenId);</span>
<span class="nc" id="L135">    setKeyPairAlias(aKeyPairAlias);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (aDataMap.get(VERSION) == null) {</span>
      // If we are creating a new object we need a version
<span class="nc" id="L138">      aDataMap.put(VERSION, Float.valueOf(getLatestVersion()));</span>
    }
<span class="nc" id="L140">    loadData(aDataMap);</span>
<span class="nc" id="L141">  }</span>

  @Override
  public int getId() {
<span class="nc" id="L145">    return internalKeyBindingId;</span>
  }

  @Override
  public String getName() {
<span class="nc" id="L150">    return name;</span>
  }

  @Override
  public void setName(final String aName) {
<span class="nc" id="L155">    this.name = aName;</span>
<span class="nc" id="L156">  }</span>

  @Override
  public InternalKeyBindingStatus getStatus() {
<span class="nc bnc" id="L160" title="All 2 branches missed.">    if (status == null) {</span>
<span class="nc" id="L161">      status = InternalKeyBindingStatus.DISABLED;</span>
    }
<span class="nc" id="L163">    return status;</span>
  }

  @Override
  public void setStatus(final InternalKeyBindingStatus aStatus) {
<span class="nc bnc" id="L168" title="All 2 branches missed.">    if (aStatus == null) {</span>
<span class="nc" id="L169">      this.status = InternalKeyBindingStatus.DISABLED;</span>
    } else {
<span class="nc" id="L171">      this.status = aStatus;</span>
    }
<span class="nc" id="L173">  }</span>

  @Override
  public InternalKeyBindingOperationalStatus getOperationalStatus() {
<span class="nc bnc" id="L177" title="All 2 branches missed.">    if (operationalStatus == null) {</span>
<span class="nc" id="L178">      operationalStatus = InternalKeyBindingOperationalStatus.OFFLINE;</span>
    }
<span class="nc" id="L180">    return operationalStatus;</span>
  }

  @Override
  public void setOperationalStatus(
      final InternalKeyBindingOperationalStatus aOperationalStatus) {
<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (aOperationalStatus == null) {</span>
<span class="nc" id="L187">      this.operationalStatus = InternalKeyBindingOperationalStatus.OFFLINE;</span>
    } else {
<span class="nc" id="L189">      this.operationalStatus = aOperationalStatus;</span>
    }
<span class="nc" id="L191">  }</span>

  @Override
  public String getCertificateId() {
<span class="nc" id="L195">    return certificateId;</span>
  }

  @Override
  public void setCertificateId(final String aCertificateId) {
<span class="nc" id="L200">    this.certificateId = aCertificateId;</span>
<span class="nc" id="L201">  }</span>

  @Override
  public int getCryptoTokenId() {
<span class="nc" id="L205">    return cryptoTokenId;</span>
  }

  @Override
  public void setCryptoTokenId(final int aCryptoTokenId) {
<span class="nc" id="L210">    this.cryptoTokenId = aCryptoTokenId;</span>
<span class="nc" id="L211">  }</span>

  @Override
  public String getKeyPairAlias() {
<span class="nc" id="L215">    return keyPairAlias;</span>
  }

  @Override
  public void setKeyPairAlias(final String aKeyPairAlias) {
<span class="nc" id="L220">    this.keyPairAlias = aKeyPairAlias;</span>
<span class="nc" id="L221">  }</span>

  @Override
  public String getNextKeyPairAlias() {
<span class="nc" id="L225">    return getData(PROP_NEXT_KEY_PAIR_ALIAS, (String) null);</span>
  }

  @Override
  public void setNextKeyPairAlias(final String aNextKeyPairAlias) {
<span class="nc" id="L230">    putData(PROP_NEXT_KEY_PAIR_ALIAS, aNextKeyPairAlias);</span>
<span class="nc" id="L231">  }</span>

  @Override
  public void updateCertificateIdAndCurrentKeyAlias(
          final String aCertificateId) {
<span class="nc" id="L236">    setCertificateId(aCertificateId);</span>
<span class="nc" id="L237">    setKeyPairAlias(getNextKeyPairAlias());</span>
<span class="nc" id="L238">    setNextKeyPairAlias(null);</span>
<span class="nc" id="L239">  }</span>

  /** Format. */
<span class="fc" id="L242">  private static final SimpleDateFormat DATE_FORMAT_MS =</span>
      new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;);
  /** Format. */
<span class="fc" id="L245">  private static final Pattern DATE_FORMAT_PATTERN =</span>
<span class="fc" id="L246">      Pattern.compile(&quot;_\\d{8}\\d{6}$&quot;);</span>
  /** Format. */
<span class="fc" id="L248">  private static final Pattern DATE_FORMAT_PATTERN_MS =</span>
<span class="fc" id="L249">      Pattern.compile(&quot;_\\d{8}\\d{9}$&quot;);</span>

  /**
   * Replace existing postfix or generate add a new one (using current time with
   * millisecond granularity).
   *
   * @param oldAlias alias
   * @return new alias
   */
  private String getNewAlias(final String oldAlias) {
<span class="nc" id="L259">    final Matcher matcherMs = DATE_FORMAT_PATTERN_MS.matcher(oldAlias);</span>
<span class="nc" id="L260">    final String newPostFix = &quot;_&quot; + DATE_FORMAT_MS.format(new Date());</span>
    // Check if the key alias postfix is in EJBCA 6.2.4+ format
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (matcherMs.find()) {</span>
      // Replace postfix in millisecond format
<span class="nc" id="L264">      return matcherMs.replaceAll(newPostFix);</span>
    } else {
<span class="nc" id="L266">      final Matcher matcher = DATE_FORMAT_PATTERN.matcher(oldAlias);</span>
      // Check if the key alias postfix is in EJBCA 6.2.3- format
<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (matcher.find()) {</span>
        // Replace postfix with millisecond format
<span class="nc" id="L270">        return matcher.replaceAll(newPostFix);</span>
      } else {
        // No postfix, add one
<span class="nc" id="L273">        return oldAlias + newPostFix;</span>
      }
    }
  }

  @Override
  public void generateNextKeyPairAlias() {
<span class="nc" id="L280">    final String currentKeyPairAlias = getKeyPairAlias();</span>
<span class="nc" id="L281">    final String nextKeyPairAlias = getNewAlias(currentKeyPairAlias);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L283">      LOG.debug(</span>
          &quot;nextKeyPairAlias for internalKeyBinding &quot;
              + internalKeyBindingId
              + &quot; will be &quot;
              + nextKeyPairAlias);
    }
<span class="nc" id="L289">    setNextKeyPairAlias(nextKeyPairAlias);</span>
<span class="nc" id="L290">  }</span>

  @Override
  public List&lt;InternalKeyBindingTrustEntry&gt; getTrustedCertificateReferences() {
<span class="nc bnc" id="L294" title="All 2 branches missed.">    if (trustedCertificateReferences == null) {</span>
<span class="nc" id="L295">      trustedCertificateReferences =</span>
<span class="nc" id="L296">          getDataInternal(</span>
              PROP_TRUSTED_CERTIFICATE_REFERENCES,
              new ArrayList&lt;InternalKeyBindingTrustEntry&gt;());
    }
    // Return a shallow copy of the list
    final ArrayList&lt;InternalKeyBindingTrustEntry&gt;
<span class="nc" id="L302">        aTrustedCertificateReferences =</span>
            new ArrayList&lt;InternalKeyBindingTrustEntry&gt;();
<span class="nc" id="L304">    aTrustedCertificateReferences.addAll(this.trustedCertificateReferences);</span>
<span class="nc" id="L305">    return aTrustedCertificateReferences;</span>
  }

  @Override
  public void setTrustedCertificateReferences(
      final List&lt;InternalKeyBindingTrustEntry&gt; aTrustedCertificateReferences) {
<span class="nc" id="L311">    this.trustedCertificateReferences = aTrustedCertificateReferences;</span>
    // Always save it as an ArrayList that we know is Serializable
<span class="nc" id="L313">    final ArrayList&lt;InternalKeyBindingTrustEntry&gt; arrayList =</span>
        new ArrayList&lt;InternalKeyBindingTrustEntry&gt;(
<span class="nc" id="L315">            aTrustedCertificateReferences.size());</span>
<span class="nc" id="L316">    arrayList.addAll(aTrustedCertificateReferences);</span>
<span class="nc" id="L317">    putDataInternal(PROP_TRUSTED_CERTIFICATE_REFERENCES, arrayList);</span>
<span class="nc" id="L318">  }</span>

  @Override
  public List&lt;String&gt; getOcspExtensions() {
<span class="nc bnc" id="L322" title="All 2 branches missed.">    if (ocspExtensions == null) {</span>
<span class="nc" id="L323">      ocspExtensions =</span>
<span class="nc" id="L324">          getDataInternal(PROP_OCSP_EXTENSION, new ArrayList&lt;String&gt;());</span>
    }
<span class="nc" id="L326">    final ArrayList&lt;String&gt; ocspExensions = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L327">    ocspExensions.addAll(this.ocspExtensions);</span>
<span class="nc" id="L328">    return ocspExtensions;</span>
  }

  @Override
  public void setOcspExtensions(final List&lt;String&gt; aOcspExtensions) {
<span class="nc" id="L333">    this.ocspExtensions = aOcspExtensions;</span>
<span class="nc" id="L334">    final ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L335">    arrayList.addAll(aOcspExtensions);</span>
<span class="nc" id="L336">    putDataInternal(PROP_OCSP_EXTENSION, arrayList);</span>
<span class="nc" id="L337">  }</span>

  @Override
  public String getSignatureAlgorithm() {
<span class="nc bnc" id="L341" title="All 2 branches missed.">    if (signatureAlgorithm == null) {</span>
<span class="nc" id="L342">      signatureAlgorithm = getDataInternal(PROP_SIGNATURE_ALGORITHM, null);</span>
    }
<span class="nc" id="L344">    return signatureAlgorithm;</span>
  }

  @Override
  public void setSignatureAlgorithm(final String aSignatureAlgorithm) {
<span class="nc" id="L349">    this.signatureAlgorithm = aSignatureAlgorithm;</span>
<span class="nc" id="L350">    putDataInternal(PROP_SIGNATURE_ALGORITHM, aSignatureAlgorithm);</span>
<span class="nc" id="L351">  }</span>

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public LinkedHashMap&lt;Object, Object&gt; getDataMapToPersist() {
<span class="nc" id="L356">    return (LinkedHashMap&lt;Object, Object&gt;) saveData();</span>
  }

  @Override
  public abstract float getLatestVersion();

  @Override
  public abstract void assertCertificateCompatability(
      Certificate certificate,
      AvailableExtendedKeyUsagesConfiguration ekuConfig)
      throws CertificateImportException;

  @Override
  public void upgrade() {
    // TODO: Here we can to upgrades of base properties when needed.. we do not
    // to store a version for this as well tough..
<span class="nc" id="L372">    upgrade(getLatestVersion(), getVersion());</span>
<span class="nc" id="L373">  }</span>

  /**
   * Invoked after the all data has been loaded in init(...).
   *
   * @param latestVersion new version
   * @param currentVersion old version
   */
  protected abstract void upgrade(
      float latestVersion, float currentVersion);

  /**
   * Store data in the underlying map. Encourages use of String valued keys.
   *
   * @param key key
   * @param value value
   */
  private void putData(final String key, final Object value) {
<span class="fc" id="L391">    data.put(SUBCLASS_PREFIX + key, value);</span>
<span class="fc" id="L392">  }</span>

  /**
   * @param key key
   * @param defaultValue value
   * @param &lt;T&gt; type
   * @return data from the underlying map. Encourages use of String valued keys.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private &lt;T&gt; T getData(final String key, final T defaultValue) {
<span class="fc" id="L402">    final T ret = (T) data.get(SUBCLASS_PREFIX + key);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">    return ret == null ? defaultValue : ret;</span>
  }

  /**
   * Store data in the underlying map. Encourages use of String valued keys.
   *
   * @param key key
   * @param value value
   */
  private void putDataInternal(final String key, final Object value) {
<span class="nc" id="L413">    data.put(BASECLASS_PREFIX + key, value);</span>
<span class="nc" id="L414">  }</span>

  /**
   * @param key key
   * @param defaultValue value
   * @param &lt;T&gt; type
   * @return data from the underlying map. Encourages use of String valued keys.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private &lt;T&gt; T getDataInternal(final String key, final T defaultValue) {
<span class="nc" id="L424">    final T ret = (T) data.get(BASECLASS_PREFIX + key);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">    return ret == null ? defaultValue : ret;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>