<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util.query</a> &gt; <span class="el_source">QueryGenerator.java</span></div><h1>QueryGenerator.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.util.query;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.PredicateUtils;
import org.apache.commons.lang.StringUtils;
import org.cesecore.util.QueryParameterException;
import org.cesecore.util.query.clauses.Order;
import org.cesecore.util.query.elems.LogicOperator;
import org.cesecore.util.query.elems.Operation;
import org.cesecore.util.query.elems.RelationalOperator;
import org.cesecore.util.query.elems.Term;

/**
 * Class responsible for Query Generation.
 *
 * &lt;p&gt;Queries will be generated according to provided Criteria. Each criteria
 * (composing Terms) will be subdued to validation.
 *
 * &lt;p&gt;&lt;em&gt;For usage examples @see QueryCriteriaTest&lt;/em&gt;
 *
 * @version $Id: QueryGenerator.java 27999 2018-01-18 09:17:13Z mikekushner $
 */
public final class QueryGenerator implements Serializable {

  private static final long serialVersionUID = 1567027442267416376L;
  /** Params. */
<span class="nc" id="L47">  private final Map&lt;String, Object&gt; parameters =</span>
      new LinkedHashMap&lt;String, Object&gt;();
  /** Qurey. */
  private final Query query;
  /** Fields. */
<span class="nc" id="L52">  private final List&lt;String&gt; availableFields = new ArrayList&lt;String&gt;();</span>
  /** Criteria. */
  private final QueryCriteria criteria;

  /** Class holding query construction logic. */
  private final class Query {
      /** query. */
<span class="nc" id="L59">    private final StringBuilder query = new StringBuilder();</span>
    /** alias. */
    private final String attrAlias;
    /** Where. */
    private static final String WHERE = &quot;WHERE&quot;;
    /** Sep. */
    private static final String SEPARATOR = &quot; &quot;;

<span class="nc" id="L67">    Query(final String anAttrAlias) {</span>
<span class="nc" id="L68">      this.attrAlias = anAttrAlias;</span>
<span class="nc" id="L69">    }</span>

    public Query where() {
<span class="nc" id="L72">      query.append(SEPARATOR).append(WHERE);</span>
<span class="nc" id="L73">      return this;</span>
    }

    public Query attribute(final String name) {
<span class="nc" id="L77">      query.append(SEPARATOR).append(attrAlias).append(&quot;.&quot;).append(name);</span>
<span class="nc" id="L78">      return this;</span>
    }

    public Query parameter(final String name) {
<span class="nc" id="L82">      query.append(SEPARATOR).append(&quot;:&quot; + name);</span>
<span class="nc" id="L83">      return this;</span>
    }

    private Query operator(final RelationalOperator op) {
      final String operator =
<span class="nc bnc" id="L88" title="All 2 branches missed.">          op == RelationalOperator.EQ</span>
<span class="nc" id="L89">              ? &quot;=&quot;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">              : op == RelationalOperator.GE</span>
<span class="nc" id="L91">                  ? &quot;&gt;=&quot;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                  : op == RelationalOperator.GT</span>
<span class="nc" id="L93">                      ? &quot;&gt;&quot;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">                      : op == RelationalOperator.LE</span>
<span class="nc" id="L95">                          ? &quot;&lt;=&quot;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                          : op == RelationalOperator.LT</span>
<span class="nc" id="L97">                              ? &quot;&lt;&quot;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                              : op == RelationalOperator.NEQ</span>
<span class="nc" id="L99">                                  ? &quot;!=&quot;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                                  : op == RelationalOperator.BETWEEN</span>
<span class="nc" id="L101">                                      ? &quot;BETWEEN&quot;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                                      : op == RelationalOperator.LIKE</span>
<span class="nc" id="L103">                                          ? &quot;LIKE&quot;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                                          : op == RelationalOperator.NULL</span>
<span class="nc" id="L105">                                              ? &quot;IS NULL&quot;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">                                              : op == RelationalOperator.NOTNULL</span>
<span class="nc" id="L107">                                                  ? &quot;IS NOT NULL&quot;</span>
<span class="nc" id="L108">                                                  : &quot;&quot;;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (operator.isEmpty()) {</span>
<span class="nc" id="L110">        throw new QueryParameterException(&quot;operator not recognized&quot;);</span>
      }
<span class="nc" id="L112">      query.append(SEPARATOR).append(operator);</span>
<span class="nc" id="L113">      return this;</span>
    }

    private Query operator(final LogicOperator op) {
<span class="nc" id="L117">      query.append(SEPARATOR).append(op.toString());</span>
<span class="nc" id="L118">      return this;</span>
    }

    public Query order(final String name, final Order.Value order) {
<span class="nc" id="L122">      query</span>
<span class="nc" id="L123">          .append(SEPARATOR)</span>
<span class="nc" id="L124">          .append(&quot;ORDER BY&quot;)</span>
<span class="nc" id="L125">          .append(SEPARATOR)</span>
<span class="nc" id="L126">          .append(attrAlias)</span>
<span class="nc" id="L127">          .append(&quot;.&quot;)</span>
<span class="nc" id="L128">          .append(name)</span>
<span class="nc" id="L129">          .append(SEPARATOR)</span>
<span class="nc" id="L130">          .append(order.toString());</span>
<span class="nc" id="L131">      return this;</span>
    }

    public boolean isEmpty() {
<span class="nc bnc" id="L135" title="All 2 branches missed.">      return query.length() == 0;</span>
    }

    public String toString() {
<span class="nc" id="L139">      return query.toString();</span>
    }
  }

  private QueryGenerator(
      final Class&lt;?&gt; clazz,
      final QueryCriteria aCriteria,
<span class="nc" id="L146">      final String alias) {</span>
<span class="nc" id="L147">    query = new Query(alias);</span>
<span class="nc" id="L148">    this.criteria = aCriteria;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">    for (final Field f : clazz.getDeclaredFields()) {</span>
<span class="nc" id="L150">      availableFields.add(f.getName());</span>
    }
<span class="nc" id="L152">  }</span>

  /**
   * Returns a new QueryGenerator or null if criteria is null.
   *
   * @param clazz class
   * @param criteria QueryCriteria
   * @param attrAlias alias
   * @return QueryGenerator or null if criteria is null
   */
  public static QueryGenerator generator(
      final Class&lt;?&gt; clazz,
      final QueryCriteria criteria,
      final String attrAlias) {
<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (criteria == null) {</span>
<span class="nc" id="L167">      return null;</span>
    }
<span class="nc" id="L169">    return new QueryGenerator(clazz, criteria, attrAlias);</span>
  }

  /**
   * Generates the SQL query according to the criteria passed in generator.
   *
   * @return generated Query.
   */
  public String generate() {
<span class="nc bnc" id="L178" title="All 2 branches missed.">    if (query.isEmpty()) {</span>
<span class="nc" id="L179">      final List&lt;Elem&gt; elements = criteria.getElements();</span>
<span class="nc" id="L180">      final List&lt;Elem&gt; terms = new ArrayList&lt;Elem&gt;();</span>
<span class="nc" id="L181">      final List&lt;Elem&gt; clauses = new ArrayList&lt;Elem&gt;();</span>

<span class="nc" id="L183">      CollectionUtils.selectRejected(</span>
<span class="nc" id="L184">          elements, PredicateUtils.instanceofPredicate(Order.class), terms);</span>
<span class="nc" id="L185">      CollectionUtils.select(</span>
<span class="nc" id="L186">          elements, PredicateUtils.instanceofPredicate(Order.class), clauses);</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">      if (terms.size() &gt; 0) {</span>
<span class="nc" id="L189">        query.where();</span>
      }
<span class="nc" id="L191">      termTraversal(terms);</span>
<span class="nc" id="L192">      clauseTraversal(clauses);</span>
    }
<span class="nc" id="L194">    return query.toString();</span>
  }

  /**
   * Traverses the terms list that is constructed according to the elements list
   * in the QueryCriteria.
   *
   * @param elements elements
   */
  private void termTraversal(final List&lt;Elem&gt; elements) {
<span class="nc" id="L204">    boolean first = true;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">    for (final Elem element : elements) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">      if (!first) {</span>
<span class="nc" id="L207">        query.operator(LogicOperator.AND);</span>
      } else {
<span class="nc" id="L209">        first = false;</span>
      }
<span class="nc" id="L211">      generate(element);</span>
<span class="nc" id="L212">    }</span>
<span class="nc" id="L213">  }</span>

  /**
   * Traverses the clauses list that is constructed according to the elements
   * list in the QueryCriteria.
   *
   * @param clauses clauses
   */
  private void clauseTraversal(final List&lt;Elem&gt; clauses) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">    for (final Elem clause : clauses) {</span>
<span class="nc" id="L223">      generate(clause);</span>
<span class="nc" id="L224">    }</span>
<span class="nc" id="L225">  }</span>

  /**
   * Partial query generation according to the provided element.
   *
   * @param elem Term or Operation or Order object
   */
  private void generate(final Elem elem) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">    if (elem instanceof Operation) {</span>
<span class="nc" id="L234">      generateRestriction((Operation) elem);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">    } else if (elem instanceof Term) {</span>
<span class="nc" id="L236">      generateRestriction((Term) elem);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">    } else if (elem instanceof Order) {</span>
<span class="nc" id="L238">      generateRestriction((Order) elem);</span>
    } else {
<span class="nc" id="L240">      throw new QueryParameterException(&quot;No matched restriction&quot;);</span>
    }
<span class="nc" id="L242">  }</span>

  private void generateRestriction(final Operation op) {
<span class="nc" id="L245">    generateRestriction(op.getTerm());</span>
<span class="nc" id="L246">    query.operator(op.getOperator());</span>
<span class="nc" id="L247">    final Elem elem = op.getElement();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">    if (elem != null) {</span>
<span class="nc" id="L249">      generate(elem);</span>
    }
<span class="nc" id="L251">  }</span>

  private void generateRestriction(final Term term) {
<span class="nc" id="L254">    validate(term.getName());</span>
<span class="nc" id="L255">    query.attribute(term.getName()).operator(term.getOperator());</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (term.getOperator() == RelationalOperator.BETWEEN) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L258">      final AbstractMap.SimpleEntry&lt;Object, Object&gt; values =</span>
<span class="nc" id="L259">          (AbstractMap.SimpleEntry&lt;Object, Object&gt;) term.getValue();</span>
<span class="nc" id="L260">      query</span>
<span class="nc" id="L261">          .parameter(genAndStoreParameter(term.getName(), values.getKey()))</span>
<span class="nc" id="L262">          .operator(LogicOperator.AND)</span>
<span class="nc" id="L263">          .parameter(genAndStoreParameter(term.getName(), values.getValue()));</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">    } else if (term.getOperator() != RelationalOperator.NULL</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        &amp;&amp; term.getOperator() != RelationalOperator.NOTNULL) {</span>
<span class="nc" id="L266">      query.parameter(genAndStoreParameter(term.getName(), term.getValue()));</span>
    }
<span class="nc" id="L268">  }</span>

  private void generateRestriction(final Order order) {
<span class="nc" id="L271">    validate(order.getName());</span>
<span class="nc" id="L272">    query.order(order.getName(), order.getOrder());</span>
<span class="nc" id="L273">  }</span>

  /** @return all stored parameter names. */
  public Set&lt;String&gt; getParameterKeys() {
<span class="nc" id="L277">    return parameters.keySet();</span>
  }

  /**
   * @param key key
   * @return the value of a stored parameter
   */
  public Object getParameterValue(final String key) {
<span class="nc" id="L285">    return parameters.get(key);</span>
  }

  /**
   * Validates the provided name against our naming strategy ... columns with
   * alphanumeric chars only.
   *
   * @param name to be validated
   */
  private void validate(final String name) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">    if (!StringUtils.isAlphanumeric(name)) {</span>
<span class="nc" id="L296">      throw new QueryParameterException(</span>
          &quot;parameter is not alphanumeric &quot; + name);
    }
<span class="nc bnc" id="L299" title="All 2 branches missed.">    if (!availableFields.contains(name)) {</span>
<span class="nc" id="L300">      throw new QueryParameterException(&quot;parameter is not valid field &quot; + name);</span>
    }
<span class="nc" id="L302">  }</span>

  /**
   * Generated a valid parameter name. Uses an internal store to associate the
   * generated name (parameter) to a value.
   *
   * @param name that will be used as a seed to the parameter name
   * @param value to be associated with the parameter name
   * @return parameter name
   */
  private String genAndStoreParameter(final String name, final Object value) {
<span class="nc" id="L313">    int i = 0;</span>
    while (true) {
<span class="nc" id="L315">      final String parameter = name + i++;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">      if (!parameters.containsKey(parameter)) {</span>
<span class="nc" id="L317">        parameters.put(parameter, value);</span>
<span class="nc" id="L318">        return parameter;</span>
      }
<span class="nc" id="L320">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>