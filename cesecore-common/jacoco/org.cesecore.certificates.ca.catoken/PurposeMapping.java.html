<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PurposeMapping.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security - Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca.catoken</a> &gt; <span class="el_source">PurposeMapping.java</span></div><h1>PurposeMapping.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca.catoken;

import java.util.HashSet;
import java.util.Hashtable;
import java.util.Map;
import java.util.Properties;
import java.util.Set;



/** Class wraps keystring properties. The properties passed in to it can contain fields as the constants:
 * 
 * The values of the properties consists of purposeproperty and keyalias
 * &lt;pre&gt;
 *    certSignKey fooalias02
 *    crlSignKey fooalias02
 *    keyEncryptKey fooencalias
 *    hardTokenEncrypt fooencalias
 *    previousCertSignKey fooalias01
 *    nextCertSignKey fooalias03
 *    testKey testalias
 *    defaultKey defaultalias
 * &lt;/pre&gt;
 *  When the strings are added they are mapped to different key purposes, CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN etc. 
 *  When the method getString is called with CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN it will return fooalias, if getString is called
 *  with a key purpose that was not specified, for example CryptoTokenConstants.CAKEYPURPOSE_KEYENCRYPT it will return defaultalias.
 *  
 *   The returned values are supposed to be used to get keys for different aliases from a keystore.
 * 
 * @version $Id: PurposeMapping.java 22852 2016-02-23 17:37:16Z jeklund $
 */
public final class PurposeMapping {
    
    final private Map&lt;Integer, String&gt; map;
    final private Map&lt;Integer, String&gt; keymap;
    final private String defaultKeyAlias;
    
    /** 
     * Key string properties with entries consisting of one of the fixed key strings mapping to a key alias. The key alias is user defined.
	 * &lt;pre&gt;
	 *    certSignKey fooalias02
	 *    crlSignKey fooalias02
	 *    keyEncryptKey fooencalias
	 *    hardTokenEncrypt fooencalias
	 *    previousCertSignKey fooalias01
	 *    nextCertSignKey fooalias03
	 *    testKey testalias
	 *    defaultKey defaultalias
	 * &lt;/pre&gt;
     * 
     * @param properties key string properties
     */
<span class="fc" id="L65">    public PurposeMapping(final Properties properties) {</span>
    	/** Map of keypurpose integer (CATokenConstants.CAKEYPURPOSE_CERTSIGN) and alias string as defined in Properties */
<span class="fc" id="L67">    	map = new Hashtable&lt;Integer, String&gt;();</span>
    	/** Map of keypurpose integer (CATokenConstants.CAKEYPURPOSE_CERTSIGN) and key purpose string (CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING)
    	 * for the properties defined in Properties */
<span class="fc" id="L70">    	keymap = new Hashtable&lt;Integer, String&gt;();</span>
<span class="fc" id="L71">    	String defaultKeyAliasTmp = null;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">    	if (properties != null) {</span>
<span class="fc" id="L73">    		defaultKeyAliasTmp = properties.getProperty(CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING);</span>
<span class="fc" id="L74">    		addKey(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING,</span>
    				CATokenConstants.CAKEYPURPOSE_CERTSIGN,
    				properties);
<span class="fc" id="L77">    		addKey(CATokenConstants.CAKEYPURPOSE_CRLSIGN_STRING,</span>
    				CATokenConstants.CAKEYPURPOSE_CRLSIGN,
    				properties);
<span class="fc" id="L80">    		addKey(CATokenConstants.CAKEYPURPOSE_KEYENCRYPT_STRING,</span>
    				CATokenConstants.CAKEYPURPOSE_KEYENCRYPT,
    				properties);
<span class="fc" id="L83">    		addKey(CATokenConstants.CAKEYPURPOSE_TESTKEY_STRING,</span>
    				CATokenConstants.CAKEYPURPOSE_KEYTEST,
    				properties);
<span class="fc" id="L86">    		addKey(CATokenConstants.CAKEYPURPOSE_HARDTOKENENCRYPT_STRING,</span>
    				CATokenConstants.CAKEYPURPOSE_HARDTOKENENCRYPT,
    				properties);    		
<span class="fc" id="L89">    		addKey(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING_PREVIOUS,</span>
    				CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS,
    				properties);    		
<span class="fc" id="L92">    		addKey(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING_NEXT,</span>
    				CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT,
    				properties);    		
    	}
<span class="fc bfc" id="L96" title="All 2 branches covered.">    	defaultKeyAlias = defaultKeyAliasTmp!=null ? defaultKeyAliasTmp.trim() : null;</span>
<span class="fc" id="L97">    } </span>
    private void addKey(final String keyPurposeString, final int purpose, final Properties properties) {
<span class="fc" id="L99">        String alias = properties.getProperty(keyPurposeString);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (alias!=null) {</span>
<span class="fc" id="L101">            alias = alias.trim();</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            if (!alias.isEmpty()) {</span>
<span class="fc" id="L103">                map.put(Integer.valueOf(purpose), alias);</span>
<span class="fc" id="L104">                keymap.put(Integer.valueOf(purpose), keyPurposeString);</span>
            }
        }
<span class="fc" id="L107">    }</span>
    /** Returns which key alias string is used for a certain key purpose. 
     * For example for CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN would either a key alias as defined by the property &quot;CAKEYPURPOSE_CERTSIGN_STRING myCertSignKey&quot; (myCertSignKey) 
     * or null be returned. null is returned if no CAKEYPURPOSE_CERTSIGN_STRING (certSignKey) property was specified by the user.
     * @param purpose purpose
     * @return alias
     */ 
    public String getAlias(final int purpose) {
        String alias;
        try {
<span class="fc" id="L117">            alias = map.get(Integer.valueOf(purpose));</span>
<span class="nc" id="L118">        } catch (Exception e) {</span>
<span class="nc" id="L119">            alias = null;</span>
<span class="fc" id="L120">        }</span>
<span class="pc bpc" id="L121" title="1 of 4 branches missed.">        if (alias!=null &amp;&amp; !alias.isEmpty()) {</span>
<span class="fc" id="L122">            return alias;</span>
        }
        // Special handling of these two key purposes, because if they do not exist, very strange things can happen 
        // if we claim that our &quot;defaultKey&quot; is the previous or next signing key, when it in fact is not.
<span class="fc bfc" id="L126" title="All 4 branches covered.">        if (purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS &amp;&amp; purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT) {</span>
<span class="fc" id="L127">        	return defaultKeyAlias;</span>
        }
<span class="fc" id="L129">        return null;</span>
    }
    /** Returns which property key is used for a certain key purpose. 
     * For example for CryptoTokenConstants.CAKEYPURPOSE_CERTSIGN would either CAKEYPURPOSE_CERTSIGN_STRING (certSignKey) 
     * or CAKEYPURPOSE_DEFAULT_STRING (defaultKey) be returned.
     * Special handling is for CERTSIGN_PREVIOUS and CERTSIGN_NEXT. If they can not be found, the defaultKey is _not_ returned.
     * @param purpose purpose
     * @return property
     */ 
    public String getPurposeProperty(final int purpose) {
        String s;
        try {
<span class="fc" id="L141">            s = keymap.get(Integer.valueOf(purpose));</span>
<span class="nc" id="L142">        } catch(Exception e) {</span>
<span class="nc" id="L143">            s = null;</span>
<span class="fc" id="L144">        }</span>
<span class="pc bpc" id="L145" title="1 of 4 branches missed.">        if ( s!=null &amp;&amp; s.length()&gt;0 ) {</span>
<span class="fc" id="L146">            return s;</span>
        }
        // Special handling of these two key purposes, because if they do not exist, very strange things can happen 
        // if we claim that our &quot;defaultKey&quot; is the previous or next signing key, when it in fact is not.
<span class="fc bfc" id="L150" title="All 4 branches covered.">        if ((purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS) &amp;&amp; (purpose != CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT)) {</span>
<span class="fc" id="L151">        	return CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING;</span>
        }
<span class="fc" id="L153">        return null;</span>
    }
    
    /** Returns an array with all key aliases that have been registered in this mapping.
     * 
     * @return String[] with key aliases
     */
    public String[] getAliases() {
<span class="fc" id="L161">        final Set&lt;String&gt; set = new HashSet&lt;&gt;(map.values());</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (defaultKeyAlias != null) {</span>
<span class="fc" id="L163">            set.add(defaultKeyAlias);</span>
        }
<span class="fc" id="L165">        return set.toArray(new String[set.size()]);</span>
    }
    
    public String toString() {
<span class="nc" id="L169">    	return map.toString();</span>
    }
    
    /** @param alias alias
     * @return true if the provided alias is mapped exactly once */
    public boolean isAliasMappedForSinglePurpose(final String alias) {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (alias==null) {</span>
<span class="nc" id="L176">            return false;</span>
        }
<span class="fc" id="L178">        boolean mappedOnce = false;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        for (final int keyPupose : CATokenConstants.ALL_KEY_PURPOSES) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (alias.equals(getAlias(keyPupose))) {</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                if (mappedOnce) {</span>
<span class="fc" id="L182">                    return false;</span>
                }
<span class="fc" id="L184">                mappedOnce = true;</span>
            }
        }
<span class="fc" id="L187">        return mappedOnce;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>