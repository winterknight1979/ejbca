<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringTools.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util</a> &gt; <span class="el_source">StringTools.java</span></div><h1>StringTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.util;

import com.google.common.net.InternetDomainName;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import org.apache.commons.lang.CharUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.DecoderException;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.config.ConfigurationHolder;

/**
 * This class implements some utility functions that are useful when handling
 * Strings.
 *
 * @version $Id: StringTools.java 30973 2019-01-03 14:33:40Z samuellb $
 */
public final class StringTools {
    /** Logger. */
<span class="fc" id="L61">  private static final Logger LOG = Logger.getLogger(StringTools.class);</span>

  /** IPv4. */
<span class="fc" id="L64">  private static Pattern validIpv4Pattern = null;</span>
  /** IPv6. */
<span class="fc" id="L66">  private static Pattern validIpv6Pattern = null;</span>
  /** newline. */
<span class="fc" id="L68">  private static Pattern windowsOrMacNewlines =</span>
<span class="fc" id="L69">      Pattern.compile(&quot;\r\n?&quot;); // Matches Windows \r\n and Mac \r</span>
  /** IPv4. */
  private static final String IPV4_PATTERN =
      &quot;(([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.)&quot;
      + &quot;{3}([01]?\\d\\d?|2[0-4]\\d|25[0-5])&quot;;
 /** IPv6. */
  private static final String IPV6_PATTERN =
      &quot;([0-9a-f]{1,4}:){7}([0-9a-f]){1,4}&quot;;

  static {
    try {
<span class="fc" id="L80">      validIpv4Pattern =</span>
<span class="fc" id="L81">          Pattern.compile(IPV4_PATTERN, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L82">      validIpv6Pattern =</span>
<span class="fc" id="L83">          Pattern.compile(IPV6_PATTERN, Pattern.CASE_INSENSITIVE);</span>
<span class="nc" id="L84">    } catch (PatternSyntaxException e) {</span>
<span class="nc" id="L85">      LOG.error(&quot;Unable to compile IP address validation pattern&quot;, e);</span>
<span class="fc" id="L86">    }</span>
  }

  private StringTools() { } // Not for instantiation

  /**
   * Class that will be used to see if a character belong to a specific
   * category. This is a singleton, with static initialization, meaning that it
   * is thread safe. It also means that the
   * CesecoreConfiguration.getForbiddenCharacters() can not be changed
   * dynamically, but a re-start of EJBCA is needed if this calue is changed in
   * the properties file
   */
  public static final class CharSet {
      /** Singleton. */
<span class="fc" id="L101">    private static CharSet instance =</span>
<span class="fc" id="L102">        new CharSet(CesecoreConfiguration.getForbiddenCharacters());</span>

    /**
     * @return the instance
     */
    public static CharSet getInstance() {
<span class="nc" id="L108">        return instance;</span>
    }

    /** Charset. */
<span class="fc" id="L112">    private Set&lt;Character&gt; charSet = null;</span>
    /**
     * Create a set of characters from a char array.
     *
     * @param array chars
     */
<span class="fc" id="L118">    private CharSet(final char[] array) {</span>
<span class="fc" id="L119">      final Set&lt;Character&gt; set = new HashSet&lt;Character&gt;();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">      for (final char c : array) {</span>
<span class="fc" id="L121">        set.add(Character.valueOf(c));</span>
      }
<span class="fc" id="L123">      this.charSet = set;</span>
<span class="fc" id="L124">    }</span>
    /**
     * Check if a character is belonging to the set.
     *
     * @param c the character to test
     * @return true if belonging
     */
    boolean contains(final char c) {
<span class="fc" id="L132">      return this.charSet.contains(Character.valueOf(c));</span>
    }

    /** Used to reset the value so we can JUnit test the class. */
    public static void reset() {
<span class="fc" id="L137">      instance = new CharSet(CesecoreConfiguration.getForbiddenCharacters());</span>
<span class="fc" id="L138">    }</span>
  }

  /** Characters that are not allowed in XSS compatible strings. */
<span class="fc" id="L142">  private static final CharSet STRIP_XSS = new CharSet(new char[] {'&lt;', '&gt;'});</span>
  /** Characters that are not allowed
   * in strings that may be used in db queries. */
<span class="fc" id="L145">  private static final CharSet STRIP_SQL_CHARS =</span>
      new CharSet(
          new char[] {
            '\'', '\&quot;', '\n', '\r', '\\', ';', '&amp;', '|', '!', '\0', '%', '`',
            '&lt;', '&gt;', '?', '$', '~'
          });
  /** Characters that are not allowed in strings that may be used in db queries,
   assuming single quote is escaped. */
<span class="fc" id="L153">  private static final CharSet STRIP_SQL_SINGLE_Q_ESCAPED =</span>
      new CharSet(
          new char[] {
            '\&quot;', '\n', '\r', '\\', ';', '&amp;', '|', '!', '\0', '%', '`', '&lt;',
            '&gt;', '?', '$', '~'
          });
  /** Characters that are not allowed in filenames. */
<span class="fc" id="L160">  private static final CharSet STRIP_FILENAME_CHARS =</span>
      new CharSet(
          new char[] {
            '\0', '\n', '\r', '/', '\\', '?', '%', '$', '*', ':', ';', '|',
            '\&quot;', '\'', '`', '&lt;', '&gt;'
          });
  /** Characters that are allowed to escape in strings.
   RFC 2253, section 2.4 lists ',' '&quot;' '\' '+' '&lt;' '&gt;' ';' as valid escaped
   chars.
   Also allow '=' to be escaped. */
<span class="fc" id="L170">  private static final CharSet ALLOWED_ESCAPE_CHARS =</span>
      new CharSet(
          new char[] {',', '\&quot;', '\\', '+', '&lt;', '&gt;', ';', '=', '#', ' '});

  /** PAttern. */
<span class="fc" id="L175">  private static final Pattern WS = Pattern.compile(&quot;\\s+&quot;);</span>

  /** msk. */
  public static final int KEY_SEQUENCE_FORMAT_NUMERIC = 1;
  /** msk. */
  public static final int KEY_SEQUENCE_FORMAT_ALPHANUMERIC = 2;
  /** msk. */
  public static final int KEY_SEQUENCE_FORMAT_COUNTRY_CODE_PLUS_NUMERIC = 4;
  /** msk. */
  public static final int KEY_SEQUENCE_FORMAT_COUNTRY_CODE_PLUS_ALPHANUMERIC =
      8;

  /**
   * Converts every string in a list to lower case.
   *
   * @param strings the strings to convert
   * @return all strings converted to lower case
   */
  public static List&lt;String&gt; toLowerCase(final List&lt;String&gt; strings) {
<span class="nc" id="L194">    final List&lt;String&gt; lowerCaseStrings = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">    for (final String string : strings) {</span>
<span class="nc" id="L196">      lowerCaseStrings.add(string.toLowerCase());</span>
<span class="nc" id="L197">    }</span>
<span class="nc" id="L198">    return lowerCaseStrings;</span>
  }

  /**
   * Strips all special characters from a string by replacing them with a
   * forward slash, '/'. This method is used for various Strings, like
   * SubjectDNs.
   *
   * @param str the string whose contents will be stripped.
   * @return the stripped version of the input string.
   */
  public static String strip(final String str) {
<span class="fc" id="L210">    return strip(str, CharSet.instance);</span>
  }

  /**
   * Strips '&amp;lt;' and '&amp;gt;' as well as all special characters from a string by
   * replacing them with a forward slash, '/'.
   *
   * @param str the string whose contents will be stripped.
   * @return the stripped version of the input string.
   */
  public static String stripUsername(final String str) {
<span class="fc" id="L221">    String xssStripped = strip(str, STRIP_XSS);</span>
<span class="fc" id="L222">    return strip(xssStripped);</span>
  }

  /**
   * Strips characters that are not allowed in filenames.
   *
   * @param str the string whose contents will be stripped.
   * @return the stripped version of the input string.
   */
  public static String stripFilename(final String str) {
    // The strip() method does not work here, because it replaces forbidden
    // characters with /
    // Also, there's no need to unescape anything here.
<span class="nc" id="L235">    return stripWithEscapesDisallowed(str, STRIP_FILENAME_CHARS);</span>
  }

  /**
   * Strips characters that are not allowed in filenames, and replaces spaces
   * with underscores.
   *
   * @param str the string whose contents will be stripped.
   * @return the stripped version of the input string.
   */
  public static String stripFilenameReplaceSpaces(final String str) {
<span class="nc" id="L246">    return stripFilename(str.replace(' ', '_'));</span>
  }

  /**
   * Removes all characters in stripThis from the given string.
   *
   * @param str original string, to be stripped.
   * @param stripThis set of characters that should be stripped.
   * @return the stripped string
   */
  private static String stripWithEscapesDisallowed(
      final String str, final CharSet stripThis) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L259">      return null;</span>
    }
<span class="nc" id="L261">    final StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">      if (!stripThis.contains(str.charAt(i))) {</span>
<span class="nc" id="L264">        sb.append(str.charAt(i));</span>
      }
    }
<span class="nc" id="L267">    return sb.toString();</span>
  }

  /**
   * Characters from 'str' will be stripped like this: any character that is in
   * the 'stripThis' set will be replaced with '/'. any character that is
   * escaped (preceded with '\') and not in the
   *  {@value #ALLOWED_ESCAPE_CHARS} set
   * will be replaced with '/'. when a character is replaced with '/' and also
   * escaped then the preceding escape character '\' will be removed.
   *
   * @param str the original string
   * @param stripThis set of characters that should be stripped.
   * @return the stripped string
   */
  private static String strip(final String str, final CharSet stripThis) {
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L284">      return null;</span>
    }
<span class="fc" id="L286">    final StringBuilder buf = new StringBuilder(str);</span>
<span class="fc" id="L287">    int index = 0;</span>
<span class="fc" id="L288">    int end = buf.length();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">    while (index &lt; end) {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">      if (buf.charAt(index) == '\\') {</span>
        // Found an escape character.
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (index + 1 == end) {</span>
          // If this is the last character we should remove it.
<span class="nc" id="L294">          buf.setCharAt(index, '/');</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        } else if (!isAllowedEscape(buf.charAt(index + 1))) {</span>
          // We did not allow this character to be escaped. Replace both the \
          // and the character with a single '/'.
<span class="fc" id="L298">          buf.setCharAt(index, '/');</span>
<span class="fc" id="L299">          buf.deleteCharAt(index + 1);</span>
<span class="fc" id="L300">          end--;</span>
        } else {
<span class="fc" id="L302">          index++;</span>
        }
<span class="fc bfc" id="L304" title="All 2 branches covered.">      } else if (stripThis.contains(buf.charAt(index))) {</span>
        // Illegal character. Replace it with a '/'.
<span class="fc" id="L306">        buf.setCharAt(index, '/');</span>
      }
<span class="fc" id="L308">      index++;</span>
    }
<span class="fc" id="L310">    final String result = buf.toString();</span>
<span class="pc bpc" id="L311" title="3 of 4 branches missed.">    if (LOG.isDebugEnabled() &amp;&amp; !result.equals(str)) {</span>
<span class="nc" id="L312">      LOG.debug(</span>
          &quot;Some chars stripped. Was '&quot; + str + &quot;' is now '&quot; + result + &quot;'.&quot;);
    }
<span class="fc" id="L315">    return result;</span>
  }

  /**
   * Checks if a string contains characters that would be potentially dangerous
   * to use in an SQL query.
   *
   * @param str the string whose contents would be stripped.
   * @return the offending characters with descriptions, or an empty set
   *     otherwise.
   * @see #strip
   */
  public static Set&lt;String&gt; hasSqlStripChars(final String str) {
<span class="fc" id="L328">    return hasStripChars(str, STRIP_SQL_CHARS);</span>
  }

  /**
   * Checks if a string contains characters that would be potentially dangerous
   * to use in a non-parameterized SQL query, assuming the the '-char is
   * properly handled (escaped).
   *
   * @param str the string whose contents would be stripped.
   * @return the offending characters with descriptions, or an empty set
   *     otherwise.
   * @see #strip
   */
  public static Set&lt;String&gt; hasSqlStripCharsAssumingSingleQuoteEscape(
      final String str) {
<span class="nc" id="L343">    return hasStripChars(str, STRIP_SQL_SINGLE_Q_ESCAPED);</span>
  }

  /**
   * Checks if a string contains characters that would be potentially dangerous
   * to use as DN, username etc.
   *
   * @param str the string whose contents would be stripped.
   * @return the offending characters with descriptions, or an empty set
   *     otherwise.
   * @see #strip
   */
  public static Set&lt;String&gt; hasStripChars(final String str) {
<span class="fc" id="L356">    return hasStripChars(str, CharSet.instance);</span>
  }

  /**
   * Check if 'str' has any chars that should be stripped by a call to {@link
   * #strip(String, CharSet)}.
   *
   * @param str the string to be tested.
   * @param checkThese characters that must be stripped.
   * @return the offending characters with descriptions, or an empty set
   *     otherwise.
   */
  private static Set&lt;String&gt; hasStripChars(
      final String str, final CharSet checkThese) {
<span class="fc" id="L370">    Set&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L372">      return result;</span>
    }
<span class="fc" id="L374">    int index = 0;</span>
<span class="fc" id="L375">    final int end = str.length();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">    while (index &lt; end) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">      if (str.charAt(index) == '\\') {</span>
        // Found an escape character.
<span class="fc bfc" id="L379" title="All 2 branches covered.">        if (index + 1 == end) {</span>
          // If this is the last character.
<span class="fc" id="L381">          result.add(&quot;A trailing escape charater ('\').&quot;);</span>
<span class="fc" id="L382">          break;</span>
        }
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (!isAllowedEscape(str.charAt(index + 1))) {</span>
<span class="fc" id="L385">          result.add(</span>
<span class="fc" id="L386">              &quot;Character that may not be escaped: &quot; + str.charAt(index + 1));</span>
<span class="fc" id="L387">          break;</span>
        }
<span class="fc" id="L389">        index++; // Skip one extra..</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">      } else if (checkThese.contains(str.charAt(index))) {</span>
        // Found an illegal character.
<span class="fc" id="L392">        result.add(&quot;'&quot; + str.charAt(index) + &quot;'&quot;);</span>
      }
<span class="fc" id="L394">      index++;</span>
    }
<span class="fc" id="L396">    return result;</span>
  }

  /**
   * Checks if a character is an allowed escape character according to
   * allowedEscapeChars.
   *
   * @param ch the char to check
   * @return true if char is an allowed escape character, false if now
   */
  private static boolean isAllowedEscape(final char ch) {
<span class="fc bfc" id="L407" title="All 4 branches covered.">    return ALLOWED_ESCAPE_CHARS.contains(ch) &amp;&amp; !CharSet.instance.contains(ch);</span>
  }

  /**
   * Strips all whitespace including space, tabs, newlines etc from the given
   * string.
   *
   * @param str the string
   * @return the string with all whitespace removed
   * @since 2.1b1
   */
  public static String stripWhitespace(final String str) {
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L420">      return null;</span>
    }
<span class="fc" id="L422">    return WS.matcher(str).replaceAll(&quot;&quot;);</span>
  }

  /**
   * Converts ip-adress octets, according to ipStringToOctets to human readable
   * string in form 10.1.1.1 for ipv4 adresses.
   *
   * @param octets bytes
   * @return ip address string, null if input is invalid
   * @see #ipStringToOctets(String)
   */
  public static String ipOctetsToString(final byte[] octets) {
<span class="fc" id="L434">    String ret = null;</span>
<span class="fc" id="L435">    final int length = 4;</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">    if (octets.length == length) {</span>
<span class="fc" id="L437">      String ip = &quot;&quot;;</span>
      // IPv4 address
<span class="fc bfc" id="L439" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
        // What is going on there is that we are promoting a (signed) byte to
        // int,
        // and then doing a bitwise AND operation on it to wipe out everything
        // but
        // the first 8 bits. Because Java treats the byte as signed, if its
        // unsigned
        // value is above &gt; 127, the sign bit will be set, and it will appear to
        // java
        // to be negative. When it gets promoted to int, bits 0 through 7 will
        // be the
        // same as the byte, and bits 8 through 31 will be set to 1. So the
        // bitwise
        // AND with 0x000000FF clears out all of those bits.
<span class="fc" id="L453">          final int mask = 0x000000FF;</span>
<span class="fc" id="L454">        final int intByte = mask &amp; octets[i];</span>
<span class="fc" id="L455">        final short t = (short) intByte; // NOPMD, we need short</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">        if (StringUtils.isNotEmpty(ip)) {</span>
<span class="fc" id="L457">          ip += &quot;.&quot;;</span>
        }
<span class="fc" id="L459">        ip += t;</span>
      }
<span class="fc" id="L461">      ret = ip;</span>
    }
    // TODO: IPv6
<span class="fc" id="L464">    return ret;</span>
  }

  /**
   * Converts an IP-address string to octets of binary ints. ipv4 is of form
   * a.b.c.d, i.e. at least four octets for example 192.168.5.54 ipv6 is of form
   * a:b:c:d:e:f:g:h, for example 2001:0db8:85a3:0000:0000:8a2e:0370:7334
   *
   * &lt;p&gt;Result is tested with openssl, that it's subjectAltName displays as
   * intended.
   *
   * @param str string form of ip-address
   * @return octets, empty array if input format is invalid, never null
   */
  public static byte[] ipStringToOctets(final String str) {
<span class="fc" id="L479">    byte[] ret = null;</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">    if (StringTools.isIpAddress(str)) {</span>
      try {
<span class="fc" id="L482">        final InetAddress adr = InetAddress.getByName(str);</span>
<span class="fc" id="L483">        ret = adr.getAddress();</span>
<span class="nc" id="L484">      } catch (UnknownHostException e) {</span>
<span class="nc" id="L485">        LOG.info(&quot;Error parsing ip address (ipv4 or ipv6): &quot;, e);</span>
<span class="fc" id="L486">      }</span>
    }
<span class="fc bfc" id="L488" title="All 2 branches covered.">    if (ret == null) {</span>
<span class="fc" id="L489">      LOG.info(&quot;Not a IPv4 or IPv6 address, returning empty array.&quot;);</span>
<span class="fc" id="L490">      ret = new byte[0];</span>
    }
<span class="fc" id="L492">    return ret;</span>
  }

  /**
   * Determine if the given string is a valid IPv4 or IPv6 address. This method
   * uses pattern matching to see if the given string could be a valid IP
   * address. Snitched from
   * http://www.java2s.com/Code/Java/Network-Protocol/DetermineifthegivenstringisavalidIPv4orIPv6address.htm
   * Under LGPLv2 license.
   *
   * @param ipAddress A string that is to be examined to verify whether or not
   *     it could be a valid IP address.
   * @return &lt;code&gt;true&lt;/code&gt; if the string is a value that is a valid IP
   *     address, &lt;code&gt;false&lt;/code&gt; otherwise.
   */
  public static boolean isIpAddress(final String ipAddress) {
<span class="fc" id="L508">    Matcher m1 = StringTools.validIpv4Pattern.matcher(ipAddress);</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">    if (m1.matches()) {</span>
<span class="fc" id="L510">      return true;</span>
    }
<span class="fc" id="L512">    Matcher m2 = StringTools.validIpv6Pattern.matcher(ipAddress);</span>
<span class="fc" id="L513">    return m2.matches();</span>
  }

  /**
   * Check if a string constitutes a valid hostname for the dNSName attribute of
   * the Subject Alternative Name X.509 certificate extension. This method does
   * NOT check if the hostname can be resolved to an IP address, is registered
   * with ICANN ect. Instead, the following checks are performed:
   *
   * &lt;ul&gt;
   *   &lt;li&gt;Any leading wildcard is stripped.
   *   &lt;li&gt;The DNS name is not allowed to end with a dot.
   *   &lt;li&gt;The input most be a syntactically valid hostname as per RFC 2181 and
   *       RFC 3490.
   *   &lt;li&gt;T̶h̶e̶ ̶d̶o̶m̶a̶i̶n̶ ̶n̶a̶m̶e̶ ̶m̶u̶s̶t̶ ̶n̶o̶t̶ ̶b̶e̶ ̶a̶
   *       ̶r̶e̶g̶i̶s̶t̶r̶y̶ ̶s̶u̶f̶f̶i̶x̶.
   *   &lt;li&gt;T̶h̶e̶ ̶d̶o̶m̶a̶i̶n̶ ̶n̶a̶m̶e̶ ̶m̶u̶s̶t̶ ̶n̶o̶t̶ ̶b̶e̶ ̶a̶
   *       ̶t̶o̶p̶-̶l̶e̶v̶e̶l̶ ̶d̶o̶m̶a̶i̶n̶.
   * &lt;/ul&gt;
   *
   * This implementation is null-safe and relies on Guava's &lt;code&gt;
   * InternetDomainName&lt;/code&gt; implementation for hostname validation a̶n̶d̶
   * ̶i̶d̶e̶n̶t̶i̶f̶i̶c̶a̶t̶i̶o̶n̶ ̶o̶f̶ ̶r̶e̶g̶i̶s̶t̶r̶y̶ ̶s̶u̶f̶f̶i̶c̶e̶s̶
   * ̶a̶n̶d̶ ̶T̶L̶D̶s̶.
   *
   * &lt;p&gt;Identification of TLDs and registry suffices are currently not supported
   * because this functionality requires a newer version of the Guava library.
   *
   * @param odnsName the DNS name to check
   * @return true if the input is valid SAN dNSName attribute value
   */
  public static boolean isValidSanDnsName(final String odnsName) {
<span class="fc" id="L545">    String dnsName = odnsName;</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">    if (dnsName == null) {</span>
<span class="nc" id="L547">      return false;</span>
    }
    // FQDN ending with a dot is accepted by Guava, so we need to check for that
    // separately
<span class="fc bfc" id="L551" title="All 2 branches covered.">    if (dnsName.endsWith(&quot;.&quot;)) {</span>
<span class="fc" id="L552">      return false;</span>
    }
    // Strip any leading wildcard
<span class="fc bfc" id="L555" title="All 2 branches covered.">    dnsName = dnsName.startsWith(&quot;*.&quot;) ? dnsName.substring(2) : dnsName;</span>
<span class="fc" id="L556">    return InternetDomainName.isValid(dnsName);</span>
    // TODO Once we get Guava &gt;=23.4 (requires Java 8)
    // final InternetDomainName internetDomainName =
    // InternetDomainName.from(dnsName);
    // return !internetDomainName.isRegistrySuffix() &amp;&amp;
    // !internetDomainName.isTopLevelDomain();
  }

  /**
   * Takes input and converts to Base64 on the format &quot;B64:&amp;lt;base64 endoced
   * string&amp;gt;&quot;, if the string is not null or empty.
   *
   * @param s String to base64 encode
   * @return Base64 encoded string, or original string if it was null or empty
   */
  public static String putBase64String(final String s) {
<span class="fc" id="L572">    return putBase64String(s, false);</span>
  }

  /**
   * Takes input and converts to Base64 on the format &quot;B64:&amp;lt;base64 endoced
   * string&amp;gt;&quot;, if the string is not null or empty.
   *
   * @param s String to base64 encode
   * @param dontEncodeAsciiPrintable if the String is made up of pure ASCII
   *     printable characters, we will not B64 encode it
   * @return Base64 encoded string, or original string if it was null or empty
   */
  public static String putBase64String(
      final String s, final boolean dontEncodeAsciiPrintable) {
<span class="fc bfc" id="L586" title="All 2 branches covered.">    if (StringUtils.isEmpty(s)) {</span>
<span class="fc" id="L587">      return s;</span>
    }
<span class="fc bfc" id="L589" title="All 2 branches covered.">    if (s.startsWith(&quot;B64:&quot;)) {</span>
      // Only encode once
<span class="fc" id="L591">      return s;</span>
    }
<span class="fc bfc" id="L593" title="All 4 branches covered.">    if (dontEncodeAsciiPrintable &amp;&amp; StringUtils.isAsciiPrintable(s)) {</span>
<span class="fc" id="L594">      return s;</span>
    }
    // Since we used getBytes(s, &quot;UTF-8&quot;) in this method, we must use UTF-8 when
    // doing the reverse in another method
<span class="fc" id="L598">    return &quot;B64:&quot;</span>
<span class="fc" id="L599">        + new String(Base64.encode(s.getBytes(StandardCharsets.UTF_8), false));</span>
  }

  /**
   * Takes a string given as input and converts it from Base64 if the string
   * begins with the case-insensitive prefix b64, i.e. is on format
   * &quot;b64:&amp;lt;base64 encoded string&amp;gt;&quot;.
   *
   * @param input String to Base64 decode
   * @return Base64 decoded string, or original string if it was not base64
   *     encoded
   */
  public static String getBase64String(final String input) {
<span class="fc bfc" id="L612" title="All 2 branches covered.">    if (StringUtils.isEmpty(input)) {</span>
<span class="fc" id="L613">      return input;</span>
    }
<span class="fc bfc" id="L615" title="All 2 branches covered.">    if (!input.toLowerCase().startsWith(&quot;b64:&quot;)) {</span>
<span class="fc" id="L616">      return input;</span>
    }
<span class="fc" id="L618">    final String base64Data = input.substring(4);</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">    if (base64Data.length() == 0) {</span>
<span class="fc" id="L620">      return input;</span>
    }
    try {
      // Since we used getBytes(s, &quot;UTF-8&quot;) in the method putBase64String, we
      // must use UTF-8 when doing the reverse
<span class="fc" id="L625">      return new String(Base64.decode(base64Data.getBytes(&quot;UTF-8&quot;)), &quot;UTF-8&quot;);</span>
<span class="nc" id="L626">    } catch (UnsupportedEncodingException | DecoderException e) {</span>
<span class="nc" id="L627">      return input;</span>
    }
  }

  /**
   * Converts hexadecimal string to BigInteger. Hex prefix (0x) is ignored
   *
   * @param ohexString HEX value with or without '0x' prefix
   * @return BigInteger value
   */
  public static BigInteger getBigIntegerFromHexString(final String ohexString) {
<span class="nc" id="L638">      String hexString = ohexString;</span>
<span class="nc bnc" id="L639" title="All 4 branches missed.">      if (hexString.startsWith(&quot;0x&quot;) || hexString.startsWith(&quot;0X&quot;)) {</span>
<span class="nc" id="L640">      hexString = hexString.substring(2, hexString.length());</span>
    }
<span class="nc" id="L642">    return new BigInteger(hexString, 16);</span>
  }

  /**
   * Obfuscates a String if it does not already start with &quot;OBF:&quot;.
   *
   * @see #obfuscate(String)
   * @param s string to obfuscate
   * @return an obfuscated string, or the original if it started with OBF:
   */
  public static String obfuscateIfNot(final String s) {
<span class="nc bnc" id="L653" title="All 2 branches missed.">    if (s.startsWith(&quot;OBF:&quot;)) {</span>
<span class="nc" id="L654">      return s;</span>
    }
<span class="nc" id="L656">    return obfuscate(s);</span>
  }
  /**
   * Makes a string &quot;hard&quot; to read. Does not provide any real security, but at
   * least lets you hide passwords so that people with no malicious intent don't
   * accidentally stumble upon information they should not have.
   *
   * @param s string to obfuscate
   * @return an obfuscated string, or same as input if null or empty
   */
  public static String obfuscate(final String s) {
    // Don't try to obfuscate null or empty strings
<span class="fc bfc" id="L668" title="All 2 branches covered.">    if (StringUtils.isEmpty(s)) {</span>
<span class="fc" id="L669">      return s;</span>
    }
<span class="fc" id="L671">    final StringBuilder buf = new StringBuilder(&quot;OBF:&quot;);</span>
<span class="fc" id="L672">    final byte[] b = s.getBytes();</span>

<span class="fc bfc" id="L674" title="All 2 branches covered.">    for (int i = 0; i &lt; b.length; i++) {</span>
<span class="fc" id="L675">      final byte b1 = b[i];</span>
<span class="fc" id="L676">      final byte b2 = b[s.length() - (i + 1)];</span>
<span class="fc" id="L677">      final int i1 = b1 + b2 + 127;</span>
<span class="fc" id="L678">      final int i2 = b1 - b2 + 127;</span>
<span class="fc" id="L679">      final int i0 = i1 * 256 + i2;</span>
<span class="fc" id="L680">      final String x = Integer.toString(i0, 36);</span>

<span class="pc bpc" id="L682" title="1 of 2 branches missed.">      switch (x.length()) {</span>
        case 1:
        case 2:
        case 3:
<span class="nc" id="L686">          buf.append('0');</span>
<span class="nc" id="L687">          break;</span>
        default:
<span class="fc" id="L689">          buf.append(x);</span>
          break;
      }
    }
<span class="fc" id="L693">    return buf.toString();</span>
  }

  /**
   * Deobfuscates a String if it does start with &quot;OBF:&quot;.
   *
   * @see #deobfuscate(String)
   * @param s string to deobfuscate
   * @return a deobfuscated string, or the original if it does not start with
   *     OBF:
   */
  public static String deobfuscateIf(final String s) {
<span class="fc bfc" id="L705" title="All 4 branches covered.">    if (s != null &amp;&amp; s.startsWith(&quot;OBF:&quot;)) {</span>
<span class="fc" id="L706">      return deobfuscate(s);</span>
    }
<span class="fc" id="L708">    return s;</span>
  }
  /**
   * Retrieves the clear text from a string obfuscated with the obfuscate
   * methods.
   *
   * @param in obfuscated string, usually (but not necessarily) starts with OBF:
   * @return plain text string, or original if it was empty
   */
  public static String deobfuscate(final String in) {
<span class="fc" id="L718">    String s = in;</span>
<span class="pc bpc" id="L719" title="1 of 4 branches missed.">    if (s != null &amp;&amp; s.startsWith(&quot;OBF:&quot;)) {</span>
<span class="fc" id="L720">      s = s.substring(4);</span>
    }
<span class="fc bfc" id="L722" title="All 2 branches covered.">    if (StringUtils.isEmpty(s)) {</span>
<span class="fc" id="L723">      return s;</span>
    }
<span class="fc" id="L725">    final int length = 4;</span>
<span class="fc" id="L726">    byte[] b = new byte[s.length() / 2];</span>
<span class="fc" id="L727">    int l = 0;</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">    for (int i = 0; i &lt; s.length(); i += length) {</span>
<span class="fc" id="L729">      final int size = 256;</span>
<span class="fc" id="L730">      final String x = s.substring(i, i + length);</span>
<span class="fc" id="L731">      final int i0 = Integer.parseInt(x, 36);</span>
<span class="fc" id="L732">      final int i1 = (i0 / size);</span>
<span class="fc" id="L733">      final int i2 = (i0 % size);</span>
<span class="fc" id="L734">      b[l++] = (byte) ((i1 + i2 - (size - 2)) / 2);</span>
    }

<span class="fc" id="L737">    return new String(b, 0, l);</span>
  }

  private static String getEncryptionVersion() {
<span class="fc" id="L741">    return &quot;encv1&quot;;</span>
  }

  /**
   * Method takes an encrypted string (by using the methods in this class) and
   * returns the method used to encrypt the string with.
   *
   * @param in indata that is encrypted/obfuscated
   * @return &quot;legacy&quot; for old data, &quot;encv1&quot; or later to describe a specific
   *     version
   */
  public static String getEncryptVersionFromString(final String in) {
<span class="pc bpc" id="L753" title="1 of 4 branches missed.">    if (in != null &amp;&amp; in.contains(&quot;:&quot;)) {</span>
      // this is a newer version that has encryption version and parameters in
      // it
<span class="fc" id="L756">      final int length  = 4;</span>
<span class="fc" id="L757">      String[] strs = StringUtils.split(in, ':');</span>
<span class="pc bpc" id="L758" title="2 of 4 branches missed.">      if (strs == null || strs.length != length) {</span>
<span class="nc" id="L759">        LOG.warn(</span>
            &quot;Input contains : but is not an encryption string from EJBCA (with&quot;
                + &quot; 4 fields).&quot;);
      } else {
<span class="fc" id="L763">        return strs[0];</span>
      }
<span class="nc" id="L765">    } else {</span>
      try {
<span class="fc" id="L767">        Hex.decode(in);</span>
<span class="fc" id="L768">      } catch (DecoderException e) {</span>
        // it means it was not hex encoded
<span class="fc" id="L770">        return &quot;none&quot;;</span>
<span class="fc" id="L771">      }</span>
    }
<span class="fc" id="L773">    return &quot;legacy&quot;;</span>
  }

  private static byte[] getSalt() {
<span class="fc" id="L777">    final boolean legacy =</span>
<span class="fc" id="L778">        DEAULT_P.equals(</span>
<span class="fc" id="L779">            ConfigurationHolder.getString(&quot;password.encryption.key&quot;));</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">    if (legacy) {</span>
<span class="fc" id="L781">      LOG.debug(&quot;Using legacy password encryption/decryption&quot;);</span>
<span class="fc" id="L782">      return getDefaultSalt();</span>
    } else {
      // Generate 32 random bytes
<span class="fc" id="L785">        final int size = 32;</span>
<span class="fc" id="L786">      final SecureRandom random = new SecureRandom();</span>
<span class="fc" id="L787">      byte[] bytes = new byte[size];</span>
<span class="fc" id="L788">      random.nextBytes(bytes);</span>
<span class="fc" id="L789">      return bytes;</span>
    }
  }

  private static byte[] getDefaultSalt() {
<span class="fc" id="L794">    return &quot;1958473059684739584hfurmaqiekcmq&quot;.getBytes(StandardCharsets.UTF_8);</span>
  }

  /** Default. */
<span class="fc" id="L798">  private static final String DEAULT_P =</span>
<span class="fc" id="L799">      deobfuscate(</span>
          &quot;OBF:1m0r1kmo1ioe1ia01j8z17y41l0q1abo1abm1abg&quot;
          + &quot;1abe1kyc17ya1j631i5y1ik01kjy1lxf&quot;);
  /** Default count. */
  private static final int DEFAULT_COUNT = 100;

  /** @return Default count. */
  private static int getDefaultCount() {
<span class="fc" id="L807">    return DEFAULT_COUNT;</span>
  }

  /**
   * number of rounds for password based encryption. TODO: 100 is not secure and
   * can easily be broken.
   *
   * @return count
   */
  private static int getCount() {
<span class="fc" id="L817">    final String str =</span>
<span class="fc" id="L818">        ConfigurationHolder.getString(&quot;password.encryption.count&quot;);</span>
<span class="fc" id="L819">    final boolean legacy =</span>
<span class="fc" id="L820">        DEAULT_P.equals(</span>
<span class="fc" id="L821">            ConfigurationHolder.getString(&quot;password.encryption.key&quot;));</span>
<span class="pc bpc" id="L822" title="1 of 4 branches missed.">    if (StringUtils.isNumeric(str) &amp;&amp; !legacy) {</span>
<span class="fc" id="L823">      return Integer.valueOf(str);</span>
    } else {
<span class="fc" id="L825">      return getDefaultCount(); // Old default value before EJBCA 6.8.0</span>
    }
  }

  /**
   * Method used for encrypting a string.
   *
   * &lt;p&gt;Note that this method does provide limited security (e.g. DBA's won't be
   * able to access encrypted passwords in database) as long as the
   * 'password.encryption.key' is set, otherwise, it won't provide any real
   * encryption more than obfuscation.
   *
   * @param in string
   * @return encrypted string
   * @throws InvalidKeyException if key invalid
   * @throws InvalidAlgorithmParameterException if algo invalid
   * @throws IllegalBlockSizeException if block size invalid
   * @throws BadPaddingException if padding invalid
   * @throws InvalidKeySpecException if spec invalis
   */
  public static String pbeEncryptStringWithSha256Aes192(final String in)
      throws InvalidKeyException, InvalidAlgorithmParameterException,
          IllegalBlockSizeException, BadPaddingException,
          InvalidKeySpecException {
<span class="fc" id="L849">    char[] p =</span>
<span class="fc" id="L850">        ConfigurationHolder.getString(&quot;password.encryption.key&quot;).toCharArray();</span>
<span class="fc" id="L851">    return pbeEncryptStringWithSha256Aes192(in, p);</span>
  }

  /**
   * @param in clear text string to encrypt
   * @param p encryption passphrase
   * @return hex encoded encrypted data in form
   *     &quot;encryption_version:salt:count:encrypted_data&quot; or clear text string if
   *     no strong crypto is available (Oracle JVM without unlimited strength
   *     crypto policy files)
   * @throws InvalidKeyException if key invalid
   * @throws IllegalBlockSizeException if block size invalid
   * @throws BadPaddingException if padding invalid
   * @throws InvalidKeySpecException if spec invalis
   */
  public static String pbeEncryptStringWithSha256Aes192(
      final String in, final char[] p)
      throws InvalidKeyException, IllegalBlockSizeException,
          BadPaddingException, InvalidKeySpecException {
<span class="fc" id="L870">    CryptoProviderTools.installBCProviderIfNotAvailable();</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">    if (CryptoProviderTools.isUsingExportableCryptography()) {</span>
<span class="nc" id="L872">      LOG.warn(&quot;Encryption not possible due to weak crypto policy.&quot;);</span>
<span class="nc" id="L873">      return in;</span>
    }
<span class="fc" id="L875">    final byte[] salt = getSalt();</span>
<span class="fc" id="L876">    final int count = getCount();</span>

<span class="fc" id="L878">    final PBEKeySpec keySpec = new PBEKeySpec(p, salt, count);</span>
    final Cipher c;
<span class="fc" id="L880">    final String algorithm = &quot;PBEWithSHA256And192BitAES-CBC-BC&quot;;</span>
    try {
<span class="fc" id="L882">      c = Cipher.getInstance(algorithm, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="fc" id="L883">      final SecretKeyFactory fact =</span>
<span class="fc" id="L884">          SecretKeyFactory.getInstance(</span>
              algorithm, BouncyCastleProvider.PROVIDER_NAME);
<span class="fc" id="L886">      c.init(Cipher.ENCRYPT_MODE, fact.generateSecret(keySpec));</span>
<span class="nc" id="L887">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L888">      throw new IllegalStateException(</span>
          &quot;Hard coded algorithm &quot; + algorithm + &quot; was not found.&quot;, e);
<span class="nc" id="L890">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L891">      throw new IllegalStateException(</span>
          &quot;BouncyCastle provider was not installed.&quot;, e);
<span class="nc" id="L893">    } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L894">      throw new IllegalStateException(</span>
          &quot;Padding for hard coded algorithm &quot; + algorithm + &quot; was not found.&quot;,
          e);
<span class="fc" id="L897">    }</span>
<span class="fc" id="L898">    final byte[] enc = c.doFinal(in.getBytes(StandardCharsets.UTF_8));</span>
    // Create a return value which is
    // &quot;encryption_version:salt:count:encrypted_data&quot;
<span class="fc" id="L901">    final int size = 64;</span>
<span class="fc" id="L902">    StringBuilder ret = new StringBuilder(size);</span>
<span class="fc" id="L903">    final boolean legacy =</span>
<span class="fc" id="L904">        DEAULT_P.equals(</span>
<span class="fc" id="L905">            ConfigurationHolder.getString(&quot;password.encryption.key&quot;));</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">    if (legacy) {</span>
      // In the old legacy system we only return the encrypted data without
      // extra info
<span class="fc" id="L909">      ret.append(Hex.toHexString(enc));</span>
    } else {
<span class="fc" id="L911">      ret.append(getEncryptionVersion())</span>
<span class="fc" id="L912">          .append(':')</span>
<span class="fc" id="L913">          .append(Hex.toHexString(salt))</span>
<span class="fc" id="L914">          .append(':')</span>
<span class="fc" id="L915">          .append(count)</span>
<span class="fc" id="L916">          .append(':')</span>
<span class="fc" id="L917">          .append(Hex.toHexString(enc));</span>
    }
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L920">      LOG.trace(&quot;Encrypted data: &quot; + ret.toString());</span>
    }
<span class="fc" id="L922">    return ret.toString();</span>
  }

  /**
   * @param in hex encoded encrypted string in form
   *     &quot;encryption_version:salt:count:encrypted_data&quot;, or just
   *     &quot;encrypted_data&quot; for older versions
   * @return decrypted clear text string
   * @throws InvalidKeyException if key invalid
   * @throws IllegalBlockSizeException if block size invalid
   * @throws BadPaddingException if padding invalid
   * @throws InvalidKeySpecException if spec invalis
   */
  public static String pbeDecryptStringWithSha256Aes192(final String in)
      throws InvalidKeyException, IllegalBlockSizeException,
          BadPaddingException, InvalidKeySpecException {
<span class="nc" id="L938">    char[] p =</span>
<span class="nc" id="L939">        ConfigurationHolder.getString(&quot;password.encryption.key&quot;).toCharArray();</span>
<span class="nc" id="L940">    return pbeDecryptStringWithSha256Aes192(in, p);</span>
  }

  /**
   * @param in hex encoded encrypted string in form
   *     &quot;encryption_version:salt:count:encrypted_data&quot;, or just
   *     &quot;encrypted_data&quot; for older versions
   * @param p decryption passphrase
   * @return decrypted clear text string
   * @throws InvalidKeyException if key invalid
   * @throws IllegalBlockSizeException if block size invalid
   * @throws BadPaddingException if padding invalid
   * @throws InvalidKeySpecException if spec invalis
   */
  public static String pbeDecryptStringWithSha256Aes192(
      final String in, final char[] p)
      throws IllegalBlockSizeException, BadPaddingException,
          InvalidKeyException, InvalidKeySpecException {
<span class="fc" id="L958">    CryptoProviderTools.installBCProviderIfNotAvailable();</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">    if (CryptoProviderTools.isUsingExportableCryptography()) {</span>
<span class="nc" id="L960">      LOG.warn(&quot;Decryption not possible due to weak crypto policy.&quot;);</span>
<span class="nc" id="L961">      return in;</span>
    }
    final byte[] salt;
<span class="fc" id="L964">    String data = in;</span>
    int count;
<span class="pc bpc" id="L966" title="1 of 4 branches missed.">    if (in != null &amp;&amp; in.contains(&quot;:&quot;)) {</span>
      // this is a newer version that has encryption version and parameters in
      // it
<span class="fc" id="L969">      String[] strs = StringUtils.split(in, ':');</span>
<span class="pc bpc" id="L970" title="2 of 4 branches missed.">      if (strs == null || strs.length != 4) {</span>
<span class="nc" id="L971">        LOG.warn(</span>
            &quot;Input contains : but is not an encryption string from EJBCA (with&quot;
                + &quot; 4 fields).&quot;);
<span class="nc" id="L974">        return in;</span>
      }
<span class="fc" id="L976">      salt = Hex.decode(strs[1].getBytes(StandardCharsets.UTF_8));</span>
<span class="fc" id="L977">      count = Integer.valueOf(strs[2]);</span>
<span class="fc" id="L978">      data = strs[3];</span>
<span class="fc" id="L979">    } else {</span>
<span class="fc" id="L980">      salt = getDefaultSalt();</span>
<span class="fc" id="L981">      count = getDefaultCount();</span>
    }
    // We can do different handling here depending on version, but currently we
    // only have one so.
<span class="fc" id="L985">    final String algorithm = &quot;PBEWithSHA256And192BitAES-CBC-BC&quot;;</span>
    try {
<span class="fc" id="L987">      final Cipher c =</span>
<span class="fc" id="L988">          Cipher.getInstance(algorithm, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="fc" id="L989">      final PBEKeySpec keySpec = new PBEKeySpec(p, salt, count);</span>
<span class="fc" id="L990">      final SecretKeyFactory fact =</span>
<span class="fc" id="L991">          SecretKeyFactory.getInstance(</span>
              algorithm, BouncyCastleProvider.PROVIDER_NAME);
<span class="fc" id="L993">      c.init(Cipher.DECRYPT_MODE, fact.generateSecret(keySpec));</span>
<span class="fc" id="L994">      final byte[] dec =</span>
<span class="fc" id="L995">          c.doFinal(Hex.decode(data.getBytes(StandardCharsets.UTF_8)));</span>
<span class="fc" id="L996">      return new String(dec);</span>
<span class="nc" id="L997">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L998">      throw new IllegalStateException(</span>
          &quot;Hard coded algorithm &quot; + algorithm + &quot; was not found.&quot;, e);
<span class="nc" id="L1000">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L1001">      throw new IllegalStateException(</span>
          &quot;BouncyCastle provider was not installed.&quot;, e);
<span class="nc" id="L1003">    } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L1004">      throw new IllegalStateException(</span>
          &quot;Padding for hard coded algorithm &quot; + algorithm + &quot; was not found.&quot;,
          e);
    }
  }

  /**
   * Method to handle different versions of password encryption transparently.
   *
   * @param in The encrypted or clear text password to try to decrypt
   * @param sDebug A message to put in the debug log indicating where the
   *     password came from, for example 'autoactivation pin', do NOT put the
   *     password itself here
   * @return The decrypted password, or same as input if it was not encrypted
   */
  public static String passwordDecryption(
      final String in, final String sDebug) {
    try {
<span class="fc" id="L1022">      final String tmp =</span>
<span class="fc" id="L1023">          pbeDecryptStringWithSha256Aes192(</span>
              in,
<span class="fc" id="L1025">              ConfigurationHolder.getString(&quot;password.encryption.key&quot;)</span>
<span class="fc" id="L1026">                  .toCharArray());</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1028">        LOG.debug(&quot;Using encrypted &quot; + sDebug);</span>
      }
<span class="fc" id="L1030">      return tmp;</span>
<span class="fc" id="L1031">    } catch (Throwable t) { // NOPMD: we want to catch everything here</span>
      try {
<span class="fc" id="L1033">        final String tmp =</span>
<span class="nc" id="L1034">            pbeDecryptStringWithSha256Aes192(</span>
                in,
<span class="fc" id="L1036">                ConfigurationHolder.getDefaultValue(&quot;password.encryption.key&quot;)</span>
<span class="fc" id="L1037">                    .toCharArray());</span>
<span class="nc" id="L1038">        LOG.warn(</span>
            &quot;Using encrypted &quot;
                + sDebug
                + &quot; (falling back to default 'password.encryption.key')&quot;);
<span class="nc" id="L1042">        return tmp;</span>
<span class="fc" id="L1043">      } catch (Throwable t2) { // NOPMD: we want to catch everything here</span>
<span class="fc" id="L1044">          final int aesSize = 32;</span>
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">        if (in.matches(&quot;[0-9a-fA-F]+&quot;)</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            &amp;&amp; in.length() % aesSize</span>
                == 0) { // If input is hexadecimal and its length is multiple of
          // 32 (i.e. 16 bytes, AES block size) we assume it is an
          // encrypted password.
<span class="nc" id="L1050">          LOG.error(</span>
              &quot;Password decryption failed. 'password.encryption.key' might&quot;
                  + &quot; have been modified more than once.&quot;);
        }
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1055">          LOG.debug(&quot;Using cleartext &quot; + sDebug);</span>
        }
<span class="fc" id="L1057">        return in;</span>
      }
    }
  }

  /**
   * @param keySequenceFormat Format
   * @param oldSequence seq
   * @return seq+1
   */
  public static String incrementKeySequence(
      final int keySequenceFormat, final String oldSequence) {
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1070">      LOG.trace(</span>
          &quot;&gt;incrementKeySequence: &quot; + keySequenceFormat + &quot;, &quot; + oldSequence);
    }
    // If the sequence does not contain any number in it at all, we can only
    // return the same
<span class="fc" id="L1075">    String ret = null;</span>
    // If the sequence starts with a country code we will increment the
    // remaining characters leaving
    // the first two untouched. Per character 10 [0-9] or 36 [0-9A-Z] different
    // values
    // can be coded
<span class="fc bfc" id="L1081" title="All 2 branches covered.">    if (keySequenceFormat == KEY_SEQUENCE_FORMAT_NUMERIC) {</span>
<span class="fc" id="L1082">      ret = incrementNumeric(oldSequence);</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">    } else if (keySequenceFormat == KEY_SEQUENCE_FORMAT_ALPHANUMERIC) {</span>
<span class="fc" id="L1084">      ret = incrementAlphaNumeric(oldSequence);</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">    } else if (keySequenceFormat</span>
        == KEY_SEQUENCE_FORMAT_COUNTRY_CODE_PLUS_NUMERIC) {
<span class="fc" id="L1087">      final String countryCode =</span>
<span class="fc" id="L1088">          oldSequence.substring(0, Math.min(2, oldSequence.length()));</span>
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1090">        LOG.debug(&quot;countryCode: &quot; + countryCode);</span>
      }
<span class="fc" id="L1092">      final String inc = incrementNumeric(oldSequence.substring(2));</span>
      // Cut off the country code
<span class="pc bpc" id="L1094" title="2 of 4 branches missed.">      if (oldSequence.length() &gt; 2 &amp;&amp; inc != null) {</span>
<span class="fc" id="L1095">        ret = countryCode + inc;</span>
      }
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">    } else if (keySequenceFormat</span>
        == KEY_SEQUENCE_FORMAT_COUNTRY_CODE_PLUS_ALPHANUMERIC) {
<span class="fc" id="L1099">      final String countryCode =</span>
<span class="fc" id="L1100">          oldSequence.substring(0, Math.min(2, oldSequence.length()));</span>
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1102">        LOG.debug(&quot;countryCode: &quot; + countryCode);</span>
      }
<span class="fc" id="L1104">      final String inc = incrementAlphaNumeric(oldSequence.substring(2));</span>
      // Cut off the country code
<span class="pc bpc" id="L1106" title="2 of 4 branches missed.">      if (oldSequence.length() &gt; 2 &amp;&amp; inc != null) {</span>
<span class="fc" id="L1107">        ret = countryCode + inc;</span>
      }
    }
    // unknown, fall back to old implementation
<span class="fc bfc" id="L1111" title="All 2 branches covered.">    if (ret == null) {</span>
<span class="fc" id="L1112">      ret = oldSequence;</span>
      // A sequence can be 00001, or SE001 for example
      // Here we will strip any sequence number at the end of the key label and
      // add the new sequence there
      // We will only count decimal (0-9) to ensure that we will not
      // accidentally update the first to
      // characters to the provided country code
<span class="fc" id="L1119">      final StringBuilder buf = new StringBuilder();</span>
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">      for (int i = oldSequence.length() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1121">        final char c = oldSequence.charAt(i);</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">        if (CharUtils.isAsciiNumeric(c)) {</span>
<span class="fc" id="L1123">          buf.insert(0, c);</span>
        } else {
          break; // at first non numeric character we break
        }
      }
<span class="fc" id="L1128">      final int restlen = oldSequence.length() - buf.length();</span>
<span class="fc" id="L1129">      final String rest = oldSequence.substring(0, restlen);</span>

<span class="fc" id="L1131">      final String intStr = buf.toString();</span>
<span class="fc bfc" id="L1132" title="All 2 branches covered.">      if (StringUtils.isNotEmpty(intStr)) {</span>
<span class="fc" id="L1133">        Integer seq = Integer.valueOf(intStr);</span>
<span class="fc" id="L1134">        seq = seq + 1;</span>
        // We want this to be the same number of numbers as we converted and
        // incremented
<span class="fc" id="L1137">        final DecimalFormat df =</span>
<span class="fc" id="L1138">            new DecimalFormat(&quot;0000000000&quot;.substring(0, intStr.length()));</span>
<span class="fc" id="L1139">        final String fseq = df.format(seq);</span>
<span class="fc" id="L1140">        ret = rest + fseq;</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1142">          LOG.trace(&quot;&lt;incrementKeySequence: &quot; + ret);</span>
        }
<span class="fc" id="L1144">      } else {</span>
<span class="fc" id="L1145">        LOG.info(</span>
            &quot;incrementKeySequence - Sequence does not contain any nummeric&quot;
                + &quot; part: &quot;
                + ret);
      }
    }
<span class="fc" id="L1151">    return ret;</span>
  }

  private static String incrementNumeric(final String s) {
    // check if input is valid, if not return null
<span class="fc bfc" id="L1156" title="All 2 branches covered.">    if (!s.matches(&quot;[0-9]{1,5}&quot;)) {</span>
<span class="fc" id="L1157">      return null;</span>
    }
<span class="fc" id="L1159">    final int len = s.length();</span>
    // Parse to int and increment by 1
<span class="fc" id="L1161">    int incrSeq = Integer.parseInt(s, 10) + 1;</span>
    // Reset if the maximum value is exceeded
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">    if (incrSeq == Math.pow(10, len)) {</span>
<span class="nc" id="L1164">      incrSeq = 0;</span>
    }
    // Make a nice String again
<span class="fc" id="L1167">    String newSeq = &quot;00000&quot; + Integer.toString(incrSeq, 10);</span>
<span class="fc" id="L1168">    newSeq = newSeq.substring(newSeq.length() - len);</span>
<span class="fc" id="L1169">    return newSeq.toUpperCase(Locale.ENGLISH);</span>
  }

  private static String incrementAlphaNumeric(final String s) {
<span class="fc" id="L1173">    final int base = 36;</span>
    // check if input is valid, if not return null
<span class="pc bpc" id="L1175" title="1 of 2 branches missed.">    if (!s.matches(&quot;[0-9A-Z]{1,5}&quot;)) {</span>
<span class="nc" id="L1176">      return null;</span>
    }
<span class="fc" id="L1178">    final int len = s.length();</span>
    // Parse to int and increment by 1
<span class="fc" id="L1180">    int incrSeq = Integer.parseInt(s, base) + 1;</span>
    // Reset if the maximum value is exceeded
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">    if (incrSeq == Math.pow(base, len)) {</span>
<span class="nc" id="L1183">      incrSeq = 0;</span>
    }
    // Make a nice String again
<span class="fc" id="L1186">    String newSeq = &quot;00000&quot; + Integer.toString(incrSeq, base);</span>
<span class="fc" id="L1187">    newSeq = newSeq.substring(newSeq.length() - len);</span>
<span class="fc" id="L1188">    return newSeq.toUpperCase(Locale.ENGLISH);</span>
  }

  /**
   * Splits a string with semicolon separated and optionally double-quoted
   * strings into a collection of strings.
   *
   * &lt;p&gt;Strings that contains semicolon has to be quoted. Unbalanced quotes (the
   * end quote is missing) is handled as if there was a quote at the end of the
   * string.
   *
   * &lt;pre&gt;
   * Examples:
   * splitURIs(&quot;a;b;c&quot;) =&amp;gt; [a, b, c]
   * splitURIs(&quot;a;\&quot;b;c\&quot;;d&quot;) =&amp;gt; [a, b;c, d]
   * splitURIs(&quot;a;\&quot;b;c;d&quot;) =&amp;gt; [a, b;c;d]
   * &lt;/pre&gt;
   *
   * &lt;p&gt;See
   * org.ejbca.core.model.ca.certextensions.TestCertificateExtensionManager#test03TestSplitURIs()
   * for more examples.
   *
   * @param dPoints The semicolon separated string and which optionally uses
   *     double-quotes
   * @return A collection of strings
   */
  public static Collection&lt;String&gt; splitURIs(final String dPoints) {

<span class="fc" id="L1216">    String dispPoints = dPoints.trim();</span>

<span class="fc" id="L1218">    final LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;();</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">    for (int i = 0; i &lt; dispPoints.length(); i++) {</span>
<span class="fc" id="L1220">      int nextQ = dispPoints.indexOf('&quot;', i);</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">      if (nextQ == i) {</span>
<span class="fc" id="L1222">        nextQ = dispPoints.indexOf('&quot;', i + 1);</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        if (nextQ == -1) {</span>
<span class="fc" id="L1224">          nextQ = dispPoints.length(); // unbalanced so eat(the rest)</span>
        }
        // eat(to quote)
<span class="fc" id="L1227">        result.add(dispPoints.substring(i + 1, nextQ).trim());</span>
<span class="fc" id="L1228">        i = nextQ;</span>
      } else {
<span class="fc" id="L1230">        final int nextSep = dispPoints.indexOf(';', i);</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">        if (nextSep != i) {</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">          if (nextSep != -1) { // eat(to sep)</span>
<span class="fc" id="L1233">            result.add(dispPoints.substring(i, nextSep).trim());</span>
<span class="fc" id="L1234">            i = nextSep;</span>
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">          } else if (i &lt; dispPoints.length()) { // eat(the rest)</span>
<span class="fc" id="L1236">            result.add(dispPoints.substring(i).trim());</span>
<span class="fc" id="L1237">            break;</span>
          }
        } // Else skip
      }
    }
<span class="fc" id="L1242">    return result;</span>
  }

  /**
   * Parses the given string according to a specific format based on the
   * certificate-data stored in the LogEntryData table in the database.
   *
   * @param certdata the string containing the certificate details
   * @return a String array with two elements, the first is the certificate
   *     serialnumber and the second one is the certificate issuerDN
   */
  public static String[] parseCertData(final String certdata) {
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">    if (certdata == null) {</span>
<span class="nc" id="L1255">      return null;</span>
    }

<span class="fc" id="L1258">    final String dnStrings = &quot;([a-zA-Z0-9]+|(([0-9]+\\.)*[0-9]+))&quot;;</span>
<span class="fc" id="L1259">    final String[] formats = {</span>
      &quot;(^[0-9A-Fa-f]+), ?((&quot;
          + dnStrings
          + &quot;=[^,]+,)*(&quot;
          + dnStrings
          + &quot;=[^,]+)*)&quot;,
      &quot;(^[0-9A-Fa-f]+) : DN : \&quot;([^\&quot;]*)\&quot;( ?: SubjectDN : \&quot;[^\&quot;]*\&quot;)?&quot;
    };

<span class="fc" id="L1268">    String[] ret = null;</span>

<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">    for (int i = 0; i &lt; formats.length; i++) {</span>
<span class="fc" id="L1271">      final Pattern p = Pattern.compile(formats[i]);</span>
<span class="fc" id="L1272">      final Matcher m = p.matcher(certdata);</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">      if (m.find()) {</span>
<span class="fc" id="L1274">        ret = new String[2];</span>
<span class="fc" id="L1275">        ret[0] = m.group(1);</span>
<span class="fc" id="L1276">        ret[1] = m.group(2);</span>
<span class="fc" id="L1277">        break;</span>
      }
    }
<span class="fc" id="L1280">    return ret;</span>
  }

  /**
   * @param rawHeaderValue value
   * @return the IP address of the X-Forwarded-For HTTP header with illegal
   *     chars replaced with '?'. IPv6 address hex chars are converted to lower
   *     case.
   */
  public static String getCleanXForwardedFor(final String rawHeaderValue) {
<span class="fc bfc" id="L1290" title="All 2 branches covered.">    if (rawHeaderValue == null) {</span>
<span class="fc" id="L1291">      return null;</span>
    }
    /*
     * In EJBCA 6.3.2 and earlier we allowed &quot;[^a-zA-Z0-9.:-_]&quot;.
     * There is however no source
     * that non IP-addresses would be allowed.
     *
     * Closest thing to a standardized example is available in
     * RFC 7239 where the example
     *  &quot;X-Forwarded-For: 192.0.2.43, 2001:db8:cafe::17&quot;
     * is used.
     */
<span class="fc" id="L1303">    return rawHeaderValue.trim().toLowerCase().replaceAll(&quot;[^0-9a-f.,: ]&quot;, &quot;?&quot;);</span>
  }

  /**
   * @param separator sep
   * @param values values
   * @return the items as a String separated by the provided separator.
   */
  public static String getAsStringWithSeparator(
      final String separator, final Collection&lt;?&gt; values) {
<span class="nc" id="L1313">    final StringBuilder names = new StringBuilder();</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">    for (final Object value : values) {</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">      if (names.length() != 0) {</span>
<span class="nc" id="L1316">        names.append(separator);</span>
      }
<span class="nc" id="L1318">      names.append(value);</span>
<span class="nc" id="L1319">    }</span>
<span class="nc" id="L1320">    return names.toString();</span>
  }

  /**
   * Method that checks if an array contains a string, ignoring case.
   *
   * @param l array that we hope contains the string s (ignoring case)
   * @param s string that we hope is in the array l (ignoring case)
   * @return true if the string (ignoring case) is contained in the array
   */
  public static boolean containsCaseInsensitive(
          final String[] l, final String s) {
<span class="nc bnc" id="L1332" title="All 2 branches missed.">    for (String string : l) {</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">      if (string.equalsIgnoreCase(s)) {</span>
<span class="nc" id="L1334">        return true;</span>
      }
    }
<span class="nc" id="L1337">    return false;</span>
  }
  //    /** Method that parses a date by format strings.
  //     * @param dateString the date string.
  //     * @param formatStrings the format strings.
  //     * @return the date if it as possible to parse it, otherwise null. */
  //    public static final Date tryParseDate(final String dateString, final
  // List &lt;String&gt; formatStrings) {
  //        Date result = null;
  //        for (String formatString : formatStrings) {
  //            try {
  //                return new SimpleDateFormat(formatString).parse(
  // dateString);
  //            } catch(ParseException e) {
  //                // NOOP
  //                if (log.isTraceEnabled()) {
  //                    log.trace(&quot;Coild not parse date &quot; + dateString + &quot; with
  // format &quot; + formatString);
  //                }
  //            }
  //        }
  //        return result;
  //    }

  /**
   * Transforms a string of ids into a list of integer.
   *
   * @param ids the id string
   * @param listSeparator the list separator.
   * @return a list of Integer.
   */
  public static List&lt;Integer&gt; idStringToListOfInteger(
      final String ids, final String listSeparator) {
<span class="nc" id="L1370">    final ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">    if (ids != null) {</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">      for (final String id : ids.split(listSeparator)) {</span>
<span class="nc" id="L1373">        result.add(Integer.valueOf(id));</span>
      }
    }
<span class="nc" id="L1376">    return result;</span>
  }

  /**
   * Checks a string for legal chars (not containing
   * &quot;/[^\\u0041-\\u005a\\u0061-\\u007a\\u00a1-\\ud7ff\\ue000-\\uffff_
   * 0-9@\\.\\*\\,\\-:\\/\\?\\'\\=\\(\\)\\|.]/g&quot;).
   *
   * @param value the string value
   * @return true if the string only contains legal characters.
   */
  public static boolean checkFieldForLegalChars(final String value) {
<span class="nc" id="L1388">    final String blackList =</span>
        &quot;/[^\\u0041-\\u005a\\u0061-\\u007a\\u00a1-\\ud7ff\\ue000-\\uffff_&quot;
            + &quot; 0-9@\\.\\*\\,\\-:\\/\\?\\'\\=\\(\\)\\|.]/g&quot;;
<span class="nc" id="L1391">    return Pattern.matches(blackList, value);</span>
  }

  /**
   * @param str string
   * @return false of if the string contains any characters that are neither a
   *     letter (unicode) or an asciiPrintable character
   */
  public static boolean isAlphaOrAsciiPrintable(final String str) {
<span class="pc bpc" id="L1400" title="1 of 2 branches missed.">    if (str == null) {</span>
<span class="nc" id="L1401">      return false;</span>
    }
<span class="fc" id="L1403">    int sz = str.length();</span>
<span class="fc bfc" id="L1404" title="All 2 branches covered.">    for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">      if (!Character.isLetter(str.charAt(i))</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">          &amp;&amp; !CharUtils.isAsciiPrintable(str.charAt(i))) {</span>
<span class="fc" id="L1407">        return false;</span>
      }
    }
<span class="fc" id="L1410">    return true;</span>
  }

  /**
   * Takes two versions and compares the first and the second versions to each
   * other Compares the max amount of numbers on both. So 6.1.2.3,6.1.2 will try
   * to compare 4 numbers, adding a 0, i.e. 6.1.2.3,6.1.2.0
   *
   * @param first a version number
   * @param second a version number
   * @return true of the first version is lower (1.0 &amp;lt; 2.0) than the second,
   *     false otherwise.
   */
  public static boolean isLesserThan(final String first, final String second) {
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1425">      LOG.trace(&quot;isLesserThan(&quot; + first + &quot;, &quot; + second + &quot;)&quot;);</span>
    }
<span class="fc" id="L1427">    final String delimiter = &quot;\\.&quot;;</span>
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">    if (first == null) {</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">      if (second != null) {</span>
<span class="nc" id="L1430">        return true; // No version is before a specified version</span>
      }
<span class="nc" id="L1432">      throw new IllegalArgumentException(</span>
          &quot;First version argument may not be null&quot;);
    }
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">    if (second == null) {</span>
<span class="nc" id="L1436">      throw new IllegalArgumentException(</span>
          &quot;Second version argument may not be null&quot;);
    }
<span class="fc" id="L1439">    String[] firstSplit = first.split(delimiter);</span>
<span class="fc" id="L1440">    String[] secondSplit = second.split(delimiter);</span>
<span class="fc bfc" id="L1441" title="All 2 branches covered.">    for (int i = 0; i &lt; Math.max(firstSplit.length, secondSplit.length); i++) {</span>
      String firstString;
      String secondString;
<span class="fc bfc" id="L1444" title="All 2 branches covered.">      if (i &gt;= firstSplit.length) {</span>
        // We've gotten this far and passed the number of digits in first, so
        // treat next first as a 0
<span class="fc" id="L1447">        firstString = &quot;0&quot;;</span>
<span class="fc" id="L1448">        secondString = secondSplit[i].replaceAll(&quot;[^0-9].*&quot;, &quot;&quot;);</span>
<span class="fc bfc" id="L1449" title="All 2 branches covered.">      } else if (i &gt;= secondSplit.length) {</span>
        // We've gotten this far and passed the number of digits in second, so
        // treat next second as a 0
<span class="fc" id="L1452">        firstString =</span>
<span class="fc" id="L1453">            firstSplit[i].replaceAll(</span>
                &quot;[^0-9].*&quot;, &quot;&quot;); // Remove trailing Beta2, _alpha1 etc
<span class="fc" id="L1455">        secondString = &quot;0&quot;;</span>
      } else {
<span class="fc" id="L1457">        firstString =</span>
<span class="fc" id="L1458">            firstSplit[i].replaceAll(</span>
                &quot;[^0-9].*&quot;, &quot;&quot;); // Remove trailing Beta2, _alpha1 etc
<span class="fc" id="L1460">        secondString = secondSplit[i].replaceAll(&quot;[^0-9].*&quot;, &quot;&quot;);</span>
      }
<span class="fc bfc" id="L1462" title="All 2 branches covered.">      if (firstString.isEmpty()) {</span>
<span class="fc" id="L1463">        firstString = &quot;0&quot;; // Treat &quot;.x&quot; as &quot;.0&quot;</span>
      }
<span class="fc bfc" id="L1465" title="All 2 branches covered.">      if (secondString.isEmpty()) {</span>
<span class="fc" id="L1466">        secondString = &quot;0&quot;;</span>
      }
<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">      if (StringUtils.isNumeric(firstString)</span>
<span class="pc bpc" id="L1469" title="1 of 2 branches missed.">          &amp;&amp; StringUtils.isNumeric(secondString)) {</span>
<span class="fc" id="L1470">        final int firstNumber = Integer.valueOf(firstString);</span>
<span class="fc" id="L1471">        final int secondNumber = Integer.valueOf(secondString);</span>
<span class="fc bfc" id="L1472" title="All 2 branches covered.">        if (firstNumber != secondNumber) {</span>
<span class="fc bfc" id="L1473" title="All 2 branches covered.">          return firstNumber &lt; secondNumber;</span>
        }
<span class="fc" id="L1475">      } else {</span>
<span class="nc" id="L1476">        throw new IllegalArgumentException(&quot;Unable to parse version numbers.&quot;);</span>
      }
    }
    // Versions must be the same then
<span class="fc" id="L1480">    return false;</span>
  }

  /**
   * Changes Windows (\r\n) and Mac (\r) line endings into \n line endings.
   *
   * @param s Input string. May be null
   * @return Output string, or null if input string was null
   */
  public static String normalizeNewlines(final String s) {
<span class="fc bfc" id="L1490" title="All 2 branches covered.">    return s != null ? windowsOrMacNewlines.matcher(s).replaceAll(&quot;\n&quot;) : null;</span>
  }

  /**
   * Splits a string by newlines (may be \n, \r\n or \r).
   *
   * @param s Input string. May &lt;b&gt;not&lt;/b&gt; be null.
   * @return Array of lines, never null. May be an empty list and may contains
   *     empty strings.
   */
  public static String[] splitByNewlines(final String s) {
<span class="fc" id="L1501">    return normalizeNewlines(s).split(&quot;\n&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>