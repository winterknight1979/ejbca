<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RFC4683Tools.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util</a> &gt; <span class="el_source">RFC4683Tools.java</span></div><h1>RFC4683Tools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.util;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.DERTaggedObject;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.tsp.TSPAlgorithms;
import org.cesecore.certificates.ca.internal.SernoGeneratorRandom;
import org.cesecore.certificates.util.DnComponents;

/**
 * Helper class to handle operations for RFC4683 certificate extension Subject
 * Identification method (SIM) for including a privacy-sensitive identifier in
 * the subjectAltName extension of a certificate. The SIM is an optional feature
 * that may be used by relying parties to determine whether the subject of a
 * particular certificate is also the person corresponding to a particular
 * sensitive identifier (@see &lt;a
 * href=&quot;https://tools.ietf.org/html/rfc4683&quot;&gt;RFC4683&lt;/a&gt;.)
 *
 * @version $Id: RFC4683Tools.java 31882 2019-03-18 13:50:56Z anatom $
 */
public final class RFC4683Tools {

  /**
   * List separator to separate the SIM tokens in the internal storage format
   * (also has to be entered by the user).
   */
  public static final String LIST_SEPARATOR = &quot;::&quot;;

  /** Label for SIM rendered in the certificate. */
  public static final String SUBJECTIDENTIFICATIONMETHOD =
      &quot;subjectIdentificationMethod&quot;;

  /** OID for SIM written into the certificate. */
  public static final String SUBJECTIDENTIFICATIONMETHOD_OBJECTID =
      &quot;1.3.6.1.5.5.7.8.6&quot;;

  /** Logger. */
<span class="fc" id="L66">  private static final Logger LOG = Logger.getLogger(RFC4683Tools.class);</span>

  /**
   * Gets the allowed hash algorithm object identifiers (@see &lt;a
   * href=&quot;https://tools.ietf.org/html/rfc4683#section-4.3&quot;&gt;RFC4683&lt;/a&gt;).
   *
   * @return a list of ASN1ObjectIdentifier {@link TSPAlgorithms#ALLOWED}.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static List&lt;ASN1ObjectIdentifier&gt; getAllowedHashAlgorithms() {
<span class="fc" id="L76">    return new ArrayList&lt;ASN1ObjectIdentifier&gt;(TSPAlgorithms.ALLOWED);</span>
  }

  /**
   * Gets the allowed hash algorithm OID strings.
   *
   * @return a list of OID strings {@link TSPAlgorithms#ALLOWED}.
   */
  public static List&lt;String&gt; getAllowedHashAlgorithmOidStrings() {
<span class="fc" id="L85">    final List&lt;ASN1ObjectIdentifier&gt; identifiers = getAllowedHashAlgorithms();</span>
<span class="fc" id="L86">    final List&lt;String&gt; result = new ArrayList&lt;String&gt;(identifiers.size());</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">    for (ASN1ObjectIdentifier identifier : identifiers) {</span>
<span class="fc" id="L88">      result.add(identifier.getId());</span>
<span class="fc" id="L89">    }</span>
<span class="fc" id="L90">    return result;</span>
  }

  /**
   * This method reads the internal storage format for SAN. If the SAN contains
   * SIM parameters (list of 4 tokens, separated by '::'), the parameters are
   * replaced by the generated SIM strings (list of 3 tokens, separated by '::')
   * {@link RFC4683Tools#generateInternalSimString(String, String, String,
   * String)}
   *
   * @param osan the SAN string in internal storage format with SIM as user
   *     parameters.
   * @return SAN string in internal storage format with generated SIM strings.
   * @throws IllegalArgumentException on illegal request
   * @throws NoSuchProviderException If provider not found
   * @throws NoSuchAlgorithmException If algorithm not found
   */
  public static String generateSimForInternalSanFormat(final String osan)
      throws IllegalArgumentException, NoSuchProviderException,
          NoSuchAlgorithmException {
<span class="fc" id="L110">      final int hashIdx = 0;</span>
<span class="fc" id="L111">      final int tokIdx = 1;</span>
<span class="fc" id="L112">      final int typeIdx = 2;</span>
<span class="fc" id="L113">      final int ssiIdx = 3;</span>
<span class="fc" id="L114">      final int length = 4;</span>
<span class="fc" id="L115">      String san = osan;</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">    if (StringUtils.isNotBlank(san)</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        &amp;&amp; san.contains(DnComponents.SUBJECTIDENTIFICATIONMETHOD)) {</span>
<span class="fc" id="L118">      final List&lt;String&gt; sims =</span>
<span class="fc" id="L119">          CertTools.getPartsFromDN(</span>
              san, DnComponents.SUBJECTIDENTIFICATIONMETHOD);
<span class="fc bfc" id="L121" title="All 2 branches covered.">      for (String sim : sims) {</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L123">          LOG.info(&quot;Store user SIM strings: &quot; + sims);</span>
        }
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (StringUtils.isNotBlank(sim)) {</span>
<span class="fc" id="L126">          final String[] tokens = sim.split(LIST_SEPARATOR);</span>
          // was entered as hash, password, SSIType and SSI, so generate the SIM
<span class="fc bfc" id="L128" title="All 2 branches covered.">          if (tokens.length == length) {</span>
<span class="fc" id="L129">            final String newSim =</span>
<span class="fc" id="L130">                generateInternalSimString(</span>
                    tokens[hashIdx], tokens[tokIdx],
                    tokens[typeIdx], tokens[ssiIdx]);
<span class="fc" id="L133">            san = san.replace(sim, newSim);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">          } else if (tokens.length == length - 1) {</span>
            // NOOP
          } else {
<span class="fc" id="L137">            throw new IllegalArgumentException(</span>
                &quot;Wrong SIM input string with &quot; + tokens.length + &quot; tokens.&quot;);
          }
        }
<span class="fc" id="L141">      }</span>
    }
<span class="fc" id="L143">    return san;</span>
  }

  /**
   * Creates a '::' separated string of hashAlogrithmOidString, Authority Random
   * (R) and Privacy-Enhanced Protected Subject Information (PEPSI). Note:
   * RFC4683 Subject Identification Method (SIM = R || PEPSI), and PEPSI = H(H(
   * P || R || SIItype || SII)). The resulting String is used for internal
   * storage.
   *
   * &lt;p&gt;Where R is the Authority Random hash and PEPSI the Privacy-Enhanced
   * Protected Subject Information: PEPSI = H(H( P || R || SIItype || SII))
   * Where P is the user chosen password, SSI the Sensitive Identification
   * Information and SIIType its type.
   *
   * @param hashAlogrithmOidString i.e '1.3.14.3.2.26' for SHA-1
   * @param userChosenPassword (P) FIPS 112 and FIPS 180-1 compliant password up
   *     to 28 characters (see https://tools.ietf.org/html/rfc4683#section-4.2)
   * @param ssiType OID string of an SSI type (see
   *     https://tools.ietf.org/html/rfc4683#section-4.1).
   * @param ssi Sensitive Identification Information (SII) (see
   *     https://tools.ietf.org/html/rfc4683#section-4.1).
   * @return a '::' separated string of hashAlogrithmOidString, R and PEPSI.
   * @throws IllegalArgumentException on illegal request
   * @throws NoSuchProviderException If provider not found
   * @throws NoSuchAlgorithmException If algorithm not found
   */
  public static String generateInternalSimString(
      final String hashAlogrithmOidString,
      final String userChosenPassword,
      final String ssiType,
      final String ssi)
      throws IllegalArgumentException, NoSuchProviderException,
          NoSuchAlgorithmException {
<span class="fc bfc" id="L177" title="All 2 branches covered.">    if (StringUtils.isBlank(hashAlogrithmOidString)) {</span>
<span class="fc" id="L178">      throw new IllegalArgumentException(</span>
          &quot;Hash algorithm OID string must not be null or empty: '&quot;
              + hashAlogrithmOidString
              + &quot;'.&quot;);
    }
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (!getAllowedHashAlgorithmOidStrings().contains(hashAlogrithmOidString)) {</span>
<span class="fc" id="L184">      throw new IllegalArgumentException(</span>
          &quot;Hash algorithm with OID '&quot;
              + hashAlogrithmOidString
              + &quot;' is not supparted for RFC4683 (SIM).&quot;);
    }
    // TODO Insert check for FIPS 180-1 compliant passwords (better current
    // standards ...)
<span class="fc bfc" id="L191" title="All 2 branches covered.">    if (StringUtils.isBlank(userChosenPassword)</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        || userChosenPassword.length() &lt; 8) {</span>
<span class="fc" id="L193">      throw new IllegalArgumentException(</span>
          &quot;The user chosen password must not be null or empty: '&quot;
              + hashAlogrithmOidString
              + &quot;'.&quot;);
    }
<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (StringUtils.isBlank(ssiType)) {</span>
<span class="fc" id="L199">      throw new IllegalArgumentException(</span>
          &quot;The sensitve identification information type must not be null or&quot;
              + &quot; empty: '&quot;
              + ssiType
              + &quot;'.&quot;);
    }
<span class="fc bfc" id="L205" title="All 2 branches covered.">    if (StringUtils.isBlank(ssi)) {</span>
<span class="fc" id="L206">      throw new IllegalArgumentException(</span>
          &quot;The sensitve identification information must not be null or empty: '&quot;
              + ssi
              + &quot;'.&quot;);
    }
<span class="fc" id="L211">    final StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L212">    result.append(hashAlogrithmOidString);</span>

    // 1. Create authority random.
<span class="fc" id="L215">    final String authorityRandomSource =</span>
<span class="fc" id="L216">        Long.toHexString(</span>
<span class="fc" id="L217">            SernoGeneratorRandom.instance(16).getSerno().longValue());</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L219">      LOG.debug(&quot;Authority random source created: &quot; + authorityRandomSource);</span>
    }

    // 1b. Get HEX by hash of authority random.
<span class="fc" id="L223">    final MessageDigest digester =</span>
<span class="fc" id="L224">        MessageDigest.getInstance(</span>
<span class="fc" id="L225">            new ASN1ObjectIdentifier(hashAlogrithmOidString).getId(),</span>
            BouncyCastleProvider.PROVIDER_NAME);
<span class="fc" id="L227">    digester.update(authorityRandomSource.getBytes());</span>
<span class="fc" id="L228">    final String authorityRandom = toHexString(digester.digest());</span>
<span class="fc" id="L229">    result.append(LIST_SEPARATOR).append(authorityRandom);</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L231">      LOG.debug(&quot;Authority random hash created: &quot; + authorityRandom);</span>
    }

    // 2. Create SIM HEX string, and hash 2 times.
<span class="fc" id="L235">    digester.update(</span>
        new StringBuilder()
<span class="fc" id="L237">            .append(userChosenPassword)</span>
<span class="fc" id="L238">            .append(authorityRandomSource)</span>
<span class="fc" id="L239">            .append(ssiType)</span>
<span class="fc" id="L240">            .append(ssi)</span>
<span class="fc" id="L241">            .toString()</span>
<span class="fc" id="L242">            .getBytes());</span>
<span class="fc" id="L243">    digester.update(digester.digest());</span>
<span class="fc" id="L244">    final String pepsi = toHexString(digester.digest());</span>
<span class="fc" id="L245">    result.append(LIST_SEPARATOR).append(pepsi);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L247">      LOG.debug(&quot;SIM string PEPSI created: &quot; + pepsi);</span>
    }
<span class="fc" id="L249">    return result.toString();</span>
  }

  /**
   * Creates a SIM GeneralName by the internal SIM storage format
   * ('hashAlgorithmOIDString::R::PEPSI') SIM ::= SEQUENCE { hashAlg
   * AlgorithmIdentifier, authorityRandom OCTET STRING, -- RA-chosen random
   * number -- used in computation of -- pEPSI pEPSI OCTET STRING -- hash of
   * HashContent -- with algorithm hashAlg }.
   *
   * @param hashAlgorithmIdentifier the OID string for the hash algorithm used
   *     to hash R and PEPSI.
   * @param authorityRandom the registration authority chosen random value,
   *     hashed with hash of hashAlogrithmOidString (see
   *     https://tools.ietf.org/html/rfc4683#section-4.3).
   * @param pepsi Privacy-Enhanced Protected Subject Information (PEPSI), with
   *     SIM = R || PEPSI.
   * @return the RFC4683 SIM GeneralName (@see &lt;a
   *     href=&quot;https://tools.ietf.org/html/rfc4683&quot;&gt;RFC4683&lt;/a&gt;.).
   */
  public static ASN1Primitive createSimGeneralName(
      final String hashAlgorithmIdentifier,
      final String authorityRandom,
      final String pepsi) {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L274">      LOG.debug(</span>
          &quot;Creating SIM with hash algorithem identifier &quot;
              + hashAlgorithmIdentifier
              + &quot;, authority random &quot;
              + authorityRandom
              + &quot; and PEPSI &quot;
              + pepsi);
    }
<span class="fc" id="L282">    final ASN1EncodableVector otherName = new ASN1EncodableVector();</span>
<span class="fc" id="L283">    otherName.add(</span>
        new ASN1ObjectIdentifier(SUBJECTIDENTIFICATIONMETHOD_OBJECTID));
<span class="fc" id="L285">    final ASN1EncodableVector simVector = new ASN1EncodableVector();</span>
<span class="fc" id="L286">    simVector.add(</span>
        new AlgorithmIdentifier(
            new ASN1ObjectIdentifier(
                hashAlgorithmIdentifier))); // new DERTaggedObject(true, 0,
<span class="fc" id="L290">    simVector.add(new DEROctetString((authorityRandom).getBytes()));</span>
<span class="fc" id="L291">    simVector.add(new DEROctetString((pepsi).getBytes()));</span>
<span class="fc" id="L292">    otherName.add(new DERTaggedObject(true, 0, new DERSequence(simVector)));</span>
<span class="fc" id="L293">    final ASN1Primitive generalName =</span>
        new DERTaggedObject(false, 0, new DERSequence(otherName));
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L296">      LOG.debug(</span>
          &quot;GeneralName (type 0 - OtherName) for SIM created &quot;
<span class="nc" id="L298">              + generalName.toString());</span>
    }
<span class="fc" id="L300">    return generalName;</span>
  }

  /**
   * Helper method for getting the SIM name from SAN ASN.1 sequence.
   *
   * @param sequence the OtherName sequence
   * @return the SIM string by the otherName.
   */
  public static String getSimStringSequence(final ASN1Sequence sequence) {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L311">      LOG.debug(&quot;Parsing RFC4683 (SIM) from SAN ASN.1 sequence: &quot; + sequence);</span>
    }
<span class="fc" id="L313">    String result = null;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">    if (sequence != null) {</span>
      // First in sequence is the object identifier, that we must check
<span class="fc" id="L316">      final ASN1ObjectIdentifier id =</span>
<span class="fc" id="L317">          ASN1ObjectIdentifier.getInstance(sequence.getObjectAt(0));</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">      if (SUBJECTIDENTIFICATIONMETHOD_OBJECTID.equals(id.getId())) {</span>
<span class="fc" id="L319">        final ASN1Sequence simVector =</span>
            (ASN1Sequence)
<span class="fc" id="L321">                ((DERTaggedObject) sequence.getObjectAt(1)).getObject();</span>
        // 1. After certificate issuance the method is called with an algorithm
        // identifier in its ASN.1 sequence.
        // 2. But after reading a stored certificate (PEM or DER) the ASN.1
        // sequence contains a DERSeqence instead.
<span class="fc" id="L326">        String algorithmIdentifier = null;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (simVector.getObjectAt(0) instanceof AlgorithmIdentifier) {</span>
<span class="fc" id="L328">          algorithmIdentifier =</span>
<span class="fc" id="L329">              ((AlgorithmIdentifier) simVector.getObjectAt(0))</span>
<span class="fc" id="L330">                  .getAlgorithm()</span>
<span class="fc" id="L331">                  .getId();</span>
        } else {
<span class="fc" id="L333">          final ASN1Encodable encodable =</span>
<span class="fc" id="L334">              ((ASN1Sequence) simVector.getObjectAt(0)).getObjectAt(0);</span>
<span class="fc" id="L335">          algorithmIdentifier = encodable.toASN1Primitive().toString();</span>
        }
<span class="fc" id="L337">        final ASN1OctetString hash = (ASN1OctetString) simVector.getObjectAt(1);</span>
<span class="fc" id="L338">        final ASN1OctetString pepsi =</span>
<span class="fc" id="L339">            (ASN1OctetString) simVector.getObjectAt(2);</span>
<span class="fc" id="L340">        final String hashString = new String(hash.getOctets());</span>
<span class="fc" id="L341">        final String pepsiString = new String(pepsi.getOctets());</span>
<span class="fc" id="L342">        final StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L343">        result =</span>
            builder
<span class="fc" id="L345">                .append(algorithmIdentifier)</span>
<span class="fc" id="L346">                .append(LIST_SEPARATOR)</span>
<span class="fc" id="L347">                .append(hashString)</span>
<span class="fc" id="L348">                .append(LIST_SEPARATOR)</span>
<span class="fc" id="L349">                .append(pepsiString)</span>
<span class="fc" id="L350">                .toString();</span>
      }
    }
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L354">      LOG.debug(&quot;SIM parsed from other name: &quot; + result);</span>
    }
<span class="fc" id="L356">    return result;</span>
  }

  /**
   * The method generates the HEX string by digestResult.
   *
   * @param digestResult the resulting byte[] of the digester.
   * @return the HEX string.
   */
  public static String toHexString(final byte[] digestResult) {
<span class="fc" id="L366">    final StringBuffer buf = new StringBuffer(digestResult.length * 2);</span>
<span class="fc" id="L367">    final int mask = 0xff;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">    for (int i = 0; i &lt; digestResult.length; i++) {</span>
<span class="fc" id="L369">      int intVal = digestResult[i] &amp; mask;</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">      if (intVal &lt; 0x10) {</span>
<span class="fc" id="L371">        buf.append(&quot;0&quot;);</span>
      }
<span class="fc" id="L373">      buf.append(Integer.toHexString(intVal).toUpperCase());</span>
    }
<span class="fc" id="L375">    return buf.toString();</span>
  }

  /** Avoid instantiation. */
  private RFC4683Tools() { }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>