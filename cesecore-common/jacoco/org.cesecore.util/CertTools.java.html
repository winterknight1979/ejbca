<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CertTools.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util</a> &gt; <span class="el_source">CertTools.java</span></div><h1>CertTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.util;

import com.novell.ldap.LDAPDN;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyFactory;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.cert.CRL;
import java.security.cert.CRLException;
import java.security.cert.CertPath;
import java.security.cert.CertPathValidator;
import java.security.cert.CertPathValidatorException;
import java.security.cert.CertPathValidatorResult;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.CertificateParsingException;
import java.security.cert.PKIXCertPathChecker;
import java.security.cert.PKIXCertPathValidatorResult;
import java.security.cert.PKIXParameters;
import java.security.cert.TrustAnchor;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.ECPublicKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang.CharUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.math.NumberUtils;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Encoding;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.ASN1TaggedObject;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.DERGeneralString;
import org.bouncycastle.asn1.DERGeneralizedTime;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.DERTaggedObject;
import org.bouncycastle.asn1.DERUTF8String;
import org.bouncycastle.asn1.pkcs.Attribute;
import org.bouncycastle.asn1.pkcs.CertificationRequest;
import org.bouncycastle.asn1.pkcs.CertificationRequestInfo;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x500.AttributeTypeAndValue;
import org.bouncycastle.asn1.x500.RDN;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x500.X500NameBuilder;
import org.bouncycastle.asn1.x500.X500NameStyle;
import org.bouncycastle.asn1.x500.style.IETFUtils;
import org.bouncycastle.asn1.x509.AccessDescription;
import org.bouncycastle.asn1.x509.AuthorityInformationAccess;
import org.bouncycastle.asn1.x509.AuthorityKeyIdentifier;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralNames;
import org.bouncycastle.asn1.x509.GeneralSubtree;
import org.bouncycastle.asn1.x509.KeyPurposeId;
import org.bouncycastle.asn1.x509.NameConstraints;
import org.bouncycastle.asn1.x509.PolicyInformation;
import org.bouncycastle.asn1.x509.PrivateKeyUsagePeriod;
import org.bouncycastle.asn1.x509.ReasonFlags;
import org.bouncycastle.asn1.x509.SubjectKeyIdentifier;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
import org.bouncycastle.cert.CertIOException;
import org.bouncycastle.cert.X509CRLHolder;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CRLConverter;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;
import org.bouncycastle.cert.jcajce.JcaX509ExtensionUtils;
import org.bouncycastle.cms.CMSAbsentContent;
import org.bouncycastle.cms.CMSException;
import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSSignedDataGenerator;
import org.bouncycastle.jce.X509KeyUsage;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.provider.PKIXNameConstraintValidator;
import org.bouncycastle.jce.provider.PKIXNameConstraintValidatorException;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.operator.BufferingContentSigner;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder;
import org.bouncycastle.pkcs.PKCS10CertificationRequest;
import org.bouncycastle.util.CollectionStore;
import org.bouncycastle.util.encoders.DecoderException;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.certificates.ca.IllegalNameException;
import org.cesecore.certificates.certificate.CertificateWrapper;
import org.cesecore.certificates.crl.RevokedCertInfo;
import org.cesecore.certificates.ocsp.SHA1DigestCalculator;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.DnComponents;
import org.cesecore.config.OcspConfiguration;
import org.cesecore.internal.InternalResources;
import org.ejbca.cvc.AuthorizationRole;
import org.ejbca.cvc.CVCAuthorizationTemplate;
import org.ejbca.cvc.CVCObject;
import org.ejbca.cvc.CVCertificate;
import org.ejbca.cvc.CardVerifiableCertificate;
import org.ejbca.cvc.CertificateParser;
import org.ejbca.cvc.ReferenceField;
import org.ejbca.cvc.exception.ConstructionException;
import org.ejbca.cvc.exception.ParseException;

/**
 * Tools to handle common certificate operations.
 *
 * @version $Id: CertTools.java 30344 2018-11-01 13:10:21Z samuellb $
 */
<span class="nc" id="L174">public abstract class CertTools {</span>
    /** ogger. */
<span class="fc" id="L176">  private static final Logger LOGGER = Logger.getLogger(CertTools.class);</span>

  /** Internal resource. */
  private static final InternalResources INTRES =
<span class="fc" id="L180">      InternalResources.getInstance();</span>

  // Initialize dnComponents
  static {
<span class="fc" id="L184">    DnComponents.getDnObjects(true);</span>
  }


  /** Config. */
  public static final String EMAIL = &quot;rfc822name&quot;;
  /** Config. */
  public static final String EMAIL1 = &quot;email&quot;;
  /** Config. */
  public static final String EMAIL2 = &quot;EmailAddress&quot;;
  /** Config. */
  public static final String EMAIL3 = &quot;E&quot;;
  /** Config. */
  public static final String DNS = &quot;dNSName&quot;;
  /** Config. */
  public static final String URI = &quot;uniformResourceIdentifier&quot;;
  /** Config. */
  public static final String URI1 = &quot;uri&quot;;
  /** Config. */
  public static final String URI2 = &quot;uniformResourceId&quot;;
  /** Config. */
  public static final String IPADDR = &quot;iPAddress&quot;;
  /** Config. */
  public static final String DIRECTORYNAME = &quot;directoryName&quot;;
  /** Config. */
  public static final String REGISTEREDID = &quot;registeredID&quot;;
  /** Config. */
  public static final String XMPPADDR = &quot;xmppAddr&quot;;
  /** Config. */
  public static final String SRVNAME = &quot;srvName&quot;;
  /** Config. */
  public static final String FASCN = &quot;fascN&quot;;

  /** Kerberos altName for smart card logon. */
  public static final String KRB5PRINCIPAL = &quot;krb5principal&quot;;
  /** OID for Kerberos altName for smart card logon. */
  public static final String KRB5PRINCIPAL_OBJECTID = &quot;1.3.6.1.5.2.2&quot;;
  /** Microsoft altName for windows smart card logon. */
  public static final String UPN = &quot;upn&quot;;
  /** ObjectID for upn altName for windows smart card logon.*/
  public static final String UPN_OBJECTID = &quot;1.3.6.1.4.1.311.20.2.3&quot;;
  /** ObjectID for XmppAddr, rfc6120#section-13.7.1.4. */
  public static final String XMPPADDR_OBJECTID = &quot;1.3.6.1.5.5.7.8.5&quot;;
  /** ObjectID for srvName, rfc4985. */
  public static final String SRVNAME_OBJECTID = &quot;1.3.6.1.5.5.7.8.7&quot;;
  /** ID. */
  public static final String PERMANENTIDENTIFIER = &quot;permanentIdentifier&quot;;
  /** ASN.i ID. */
  public static final String PERMANENTIDENTIFIER_OBJECTID = &quot;1.3.6.1.5.5.7.8.3&quot;;
  /** Separator. */
  public static final String PERMANENTIDENTIFIER_SEP = &quot;/&quot;;
  /** ASN.i ID. */
  public static final String FASCN_OBJECTID = &quot;2.16.840.1.101.3.6.6&quot;;

  /** Microsoft altName for windows domain controller guid. */
  public static final String GUID = &quot;guid&quot;;
  /** ObjectID for upn altName for windows domain controller guid. */
  public static final String GUID_OBJECTID = &quot;1.3.6.1.4.1.311.25.1&quot;;
  /**
   * ObjectID for Microsoft Encrypted File System Certificates extended key
   * usage.
   */
  public static final String EFS_OBJECTID = &quot;1.3.6.1.4.1.311.10.3.4&quot;;
  /**
   * ObjectID for Microsoft Encrypted File System Recovery Certificates extended
   * key usage.
   */
  public static final String EFSR_OBJECTID = &quot;1.3.6.1.4.1.311.10.3.4.1&quot;;
  /** ObjectID for Microsoft Signer of documents extended key usage. */
  public static final String MS_DOCUMENT_SIGNING_OBJECTID =
      &quot;1.3.6.1.4.1.311.10.3.12&quot;;
  /** Object id id-pkix. */
  public static final String ID_PKIX = &quot;1.3.6.1.5.5.7&quot;;
  /** Object id id-kp. */
  public static final String ID_KP = ID_PKIX + &quot;.3&quot;;
  /** Object id id-pda. */
  public static final String ID_PDA = ID_PKIX + &quot;.9&quot;;
  /** Object id id-pda-dateOfBirth DateOfBirth ::= GeneralizedTime .*/
  public static final String ID_PDA_DATE_OF_BIRTH = ID_PDA + &quot;.1&quot;;
  /** Object id id-pda-placeOfBirth PlaceOfBirth ::= DirectoryString. */
  public static final String ID_PDA_PLACE_OF_BIRTH = ID_PDA + &quot;.2&quot;;
  /**
   * Object id id-pda-gender Gender ::= PrintableString (SIZE(1)) -- &quot;M&quot;, &quot;F&quot;,
   * &quot;m&quot; or &quot;f&quot;.
   */
  public static final String ID_PDA_GENDER = ID_PDA + &quot;.3&quot;;
  /**
   * Object id id-pda-countryOfCitizenship CountryOfCitizenship ::=
   * PrintableString (SIZE (2)) -- ISO 3166 Country Code.
   */
  public static final String ID_PDA_COUNTRY_OF_CITIZENSHIP = ID_PDA + &quot;.4&quot;;
  /**
   * Object id id-pda-countryOfResidence CountryOfResidence ::= PrintableString
   * (SIZE (2)) -- ISO 3166 Country Code.
   */
  public static final String ID_PDA_COUNTRY_OF_RESIDENCE = ID_PDA + &quot;.5&quot;;
  /** OID used for creating MS Templates certificate extension .*/
  public static final String OID_MSTEMPLATE = &quot;1.3.6.1.4.1.311.20.2&quot;;
  /** extended key usage OID Intel AMT (out of band) network management. */
  public static final String INTEL_AMT = &quot;2.16.840.1.113741.1.2.3&quot;;

  /** Object ID for CT (Certificate Transparency) specific extensions. */
  public static final String ID_CT_REDACTED_DOMAINS = &quot;1.3.6.1.4.1.11129.2.4.6&quot;;
 /** IDs. */
<span class="fc" id="L288">  private static final String[] EMAILIDS = {EMAIL, EMAIL1, EMAIL2, EMAIL3};</span>
 /** Regex. */
<span class="fc" id="L290">  private static final Pattern UNESCAPE_FIELD_REGEX =</span>
<span class="fc" id="L291">      Pattern.compile(&quot;\\\\([,+\&quot;\\\\&lt;&gt;; ])&quot;);</span>

  /** delimiter. */
  public static final String BEGIN_CERTIFICATE_REQUEST =
      &quot;-----BEGIN CERTIFICATE REQUEST-----&quot;;
  /** delimiter. */
  public static final String END_CERTIFICATE_REQUEST =
      &quot;-----END CERTIFICATE REQUEST-----&quot;;
  /** delimiter. */
  public static final String BEGIN_KEYTOOL_CERTIFICATE_REQUEST =
      &quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;;
  /** delimiter. */
  public static final String END_KEYTOOL_CERTIFICATE_REQUEST =
      &quot;-----END NEW CERTIFICATE REQUEST-----&quot;;
  /** delimiter. */
  public static final String BEGIN_CERTIFICATE = &quot;-----BEGIN CERTIFICATE-----&quot;;
  /** delimiter. */
  public static final String END_CERTIFICATE = &quot;-----END CERTIFICATE-----&quot;;
  /** delimiter. */
  public static final String BEGIN_CERTIFICATE_WITH_NL =
      &quot;-----BEGIN CERTIFICATE-----\n&quot;;
  /** delimiter. */
  public static final String END_CERTIFICATE_WITH_NL =
      &quot;\n-----END CERTIFICATE-----\n&quot;;
  /** delimiter. */
  public static final String BEGIN_PUBLIC_KEY = &quot;-----BEGIN PUBLIC KEY-----&quot;;
  /** delimiter. */
  public static final String END_PUBLIC_KEY = &quot;-----END PUBLIC KEY-----&quot;;
  /** delimiter. */
  public static final String BEGIN_PRIVATE_KEY = &quot;-----BEGIN PRIVATE KEY-----&quot;;
  /** delimiter. */
  public static final String END_PRIVATE_KEY = &quot;-----END PRIVATE KEY-----&quot;;
  /** delimiter. */
  public static final String BEGIN_X509_CRL_KEY = &quot;-----BEGIN X509 CRL-----&quot;;
  /** delimiter. */
  public static final String END_X509_CRL_KEY = &quot;-----END X509 CRL-----&quot;;
  /** delimiter. */
  public static final String BEGIN_PKCS7 = &quot;-----BEGIN PKCS7-----&quot;;
  /** delimiter. */
  public static final String END_PKCS7 = &quot;-----END PKCS7-----&quot;;

  /**
   * See stringToBcX500Name(String, X500NameStyle, boolean), this method uses
   * the default name style (CeSecoreNameStyle) and ldap order.
   *
   * @see #stringToBcX500Name(String, X500NameStyle, boolean)
   * @param dn String containing DN that will be transformed into X500Name, The
   *     DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in the
   *     string will be added to the end positions of OID array.
   * @return X500Name, which can be empty if dn does not contain any real DN
   *     components, or null if input is null
   */
  public static X500Name stringToBcX500Name(final String dn) {
<span class="fc" id="L344">    final X500NameStyle nameStyle = CeSecoreNameStyle.INSTANCE;</span>
<span class="fc" id="L345">    return stringToBcX500Name(dn, nameStyle, true);</span>
  }

  /**
   * See stringToBcX500Name(String, X500NameStyle, boolean), this method uses
   * the default name style (CeSecoreNameStyle) and ldap order.
   *
   * @see #stringToBcX500Name(String, X500NameStyle, boolean)
   * @param dn String containing DN that will be transformed into X500Name, The
   *     DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in the
   *     string will be added to the end positions of OID array.
   * @param ldapOrder true if X500Name should be in Ldap Order
   * @return X500Name, which can be empty if dn does not contain any real DN
   *     components, or null if input is null
   */
  public static X500Name stringToBcX500Name(
      final String dn, final boolean ldapOrder) {
<span class="fc" id="L362">    final X500NameStyle nameStyle = CeSecoreNameStyle.INSTANCE;</span>
<span class="fc" id="L363">    return stringToBcX500Name(dn, nameStyle, ldapOrder);</span>
  }

  /**
   * Creates a (Bouncycastle) X500Name object from a string with a DN. Known OID
   * (with order) are: &lt;code&gt;
   *  EmailAddress, UID, CN, SN (SerialNumber),
   *   GivenName, Initials, SurName, T, OU,
   * O, L, ST, DC, C &lt;/code&gt; To change order edit 'dnObjects' in this source
   * file. Important NOT to mess with the ordering within this class, since cert
   * vierification on some clients (IE :-() might depend on order.
   *
   * @param dn String containing DN that will be transformed into X500Name, The
   *     DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in the
   *     string will be added to the end positions of OID array.
   * @param nameStyle Controls how the name is encoded. Usually it should be a
   *     CeSecoreNameStyle.
   * @param ldaporder true if LDAP ordering of DN should be used (default in
   *     EJBCA), false for X.500 order, ldap order is CN=A,OU=B,O=C,C=SE, x.500
   *     order is the reverse
   * @return X500Name, which can be empty if dn does not contain any real DN
   *     components, or null if input is null
   * @throws IllegalArgumentException if DN is not valid
   */
  public static X500Name stringToBcX500Name(
      final String dn, final X500NameStyle nameStyle, final boolean ldaporder) {
<span class="fc" id="L389">    return stringToBcX500Name(dn, nameStyle, ldaporder, null);</span>
  }
  /**
   * Same as @see {@link CertTools#stringToBcX500Name(String, X500NameStyle,
   * boolean)} but with the possibility of specifying a custom order. ONLY to be
   * used when creating names that are transient, never for storing in the
   * database.
   *
   * @param dn String containing DN that will be transformed into X500Name, The
   *     DN string has the format &quot;CN=zz,OU=yy,O=foo,C=SE&quot;. Unknown OIDs in the
   *     string will be added to the end positions of OID array.
   * @param nameStyle Controls how the name is encoded. Usually it should be a
   *     CeSecoreNameStyle.
   * @param ldaporder true if LDAP ordering of DN should be used (default in
   *     EJBCA), false for X.500 order, ldap order is CN=A,OU=B,O=C,C=SE, x.500
   *     order is the reverse
   * @param order specified order, which overrides 'ldaporder', care must be
   *     taken constructing this String array, ignored if null or empty
   * @return X500Name, which can be empty if dn does not contain any real DN
   *     components, or null if input is null
   */
  public static X500Name stringToBcX500Name(
      final String dn,
      final X500NameStyle nameStyle,
      final boolean ldaporder,
      final String[] order) {
<span class="fc" id="L415">    return stringToBcX500Name(dn, nameStyle, ldaporder, order, true);</span>
  }

  /**
   * @param dn DN
   * @param nameStyle Style
   * @param ldaporder Order
   * @param order Order
   * @param applyLdapToCustomOrder Bool
   * @return Name
   */
  public static X500Name stringToBcX500Name(
      final String dn,
      final X500NameStyle nameStyle,
      final boolean ldaporder,
      final String[] order,
      final boolean applyLdapToCustomOrder) {
<span class="fc" id="L432">    final X500Name x500Name = stringToUnorderedX500Name(dn, nameStyle);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">    if (x500Name == null) {</span>
<span class="fc" id="L434">      return null;</span>
    }
    // -- Reorder fields
<span class="fc" id="L437">    final X500Name orderedX500Name =</span>
<span class="fc" id="L438">        getOrderedX500Name(</span>
            x500Name, ldaporder, order, applyLdapToCustomOrder, nameStyle);
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L441">      LOGGER.trace(</span>
          &quot;&gt;stringToBcX500Name: x500Name=&quot;
<span class="nc" id="L443">              + x500Name.toString()</span>
              + &quot; orderedX500Name=&quot;
<span class="nc" id="L445">              + orderedX500Name.toString());</span>
    }
<span class="fc" id="L447">    return orderedX500Name;</span>
  }

  /**
   * @param odn DN
   * @param nameStyle Style
   * @return Name
   */
  public static X500Name stringToUnorderedX500Name(
      final String odn, final X500NameStyle nameStyle) {
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L458">      LOGGER.trace(&quot;&gt;stringToUnorderedX500Name: &quot; + odn);</span>
    }
<span class="fc bfc" id="L460" title="All 2 branches covered.">    if (odn == null) {</span>
<span class="fc" id="L461">      return null;</span>
    }
    // If the entire DN is quoted (which is strange but legacy), we just remove
    // these quotes and carry on
   String dn;
<span class="fc bfc" id="L466" title="All 2 branches covered.">    if (odn.length() &gt; 2</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        &amp;&amp; odn.charAt(0) == '&quot;'</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        &amp;&amp; odn.charAt(odn.length() - 1) == '&quot;') {</span>
<span class="nc" id="L469">      dn = odn.substring(1, odn.length() - 1);</span>
    } else {
<span class="fc" id="L471">        dn = odn;</span>
    }
<span class="fc" id="L473">    final X500NameBuilder nameBuilder = new X500NameBuilder(nameStyle);</span>
<span class="fc" id="L474">    boolean quoted = false;</span>
<span class="fc" id="L475">    boolean escapeNext = false;</span>
<span class="fc" id="L476">    int currentStartPosition = -1;</span>
<span class="fc" id="L477">    String currentPartName = null;</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">    for (int i = 0; i &lt; dn.length(); i++) {</span>
<span class="fc" id="L479">      final char current = dn.charAt(i);</span>
      // Toggle quoting for every non-escaped &quot;-char
<span class="fc bfc" id="L481" title="All 4 branches covered.">      if (!escapeNext &amp;&amp; current == '&quot;') {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        quoted = !quoted;</span>
      }
      // If there is an unescaped and unquoted =-char the proceeding chars is a
      // part name
<span class="pc bpc" id="L486" title="3 of 10 branches missed.">      if (currentStartPosition == -1</span>
          &amp;&amp; !quoted
          &amp;&amp; !escapeNext
          &amp;&amp; current == '='
          &amp;&amp; 1 &lt;= i) {
        // Trim spaces (e.g. &quot;O =value&quot;)
<span class="fc" id="L492">        int endIndexOfPartName = i;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        while (endIndexOfPartName &gt; 0</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">            &amp;&amp; dn.charAt(endIndexOfPartName - 1) == ' ') {</span>
<span class="fc" id="L495">          endIndexOfPartName--;</span>
        }
<span class="fc" id="L497">        int startIndexOfPartName = endIndexOfPartName - 1;</span>
<span class="fc" id="L498">        final String endOfPartNameSearchChars = &quot;, +&quot;;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">        while (startIndexOfPartName &gt; 0</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            &amp;&amp; (endOfPartNameSearchChars.indexOf(</span>
<span class="fc" id="L501">                    dn.charAt(startIndexOfPartName - 1))</span>
                == -1)) {
<span class="fc" id="L503">          startIndexOfPartName--;</span>
        }
<span class="fc" id="L505">        currentPartName =</span>
<span class="fc" id="L506">            dn.substring(startIndexOfPartName, endIndexOfPartName);</span>
<span class="fc" id="L507">        currentStartPosition = i + 1;</span>
      }
      // When we have found a start marker, we need to be on the lookout for the
      // ending marker
<span class="pc bpc" id="L511" title="1 of 10 branches missed.">      if (currentStartPosition != -1</span>
          &amp;&amp; ((!quoted &amp;&amp; !escapeNext &amp;&amp; (current == ',' || current == '+'))
<span class="fc bfc" id="L513" title="All 2 branches covered.">              || i == dn.length() - 1)) {</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        int endPosition = (i == dn.length() - 1) ? dn.length() - 1 : i - 1;</span>
        // Remove white spaces from the end of the value
<span class="fc bfc" id="L516" title="All 2 branches covered.">        while (endPosition &gt; currentStartPosition</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">            &amp;&amp; dn.charAt(endPosition) == ' ') {</span>
<span class="fc" id="L518">          endPosition--;</span>
        }
        // Remove white spaces from the beginning of the value
<span class="fc bfc" id="L521" title="All 2 branches covered.">        while (endPosition &gt; currentStartPosition</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">            &amp;&amp; dn.charAt(currentStartPosition) == ' ') {</span>
<span class="fc" id="L523">          currentStartPosition++;</span>
        }
        // Only return the inner value if the part is quoted
<span class="fc bfc" id="L526" title="All 2 branches covered.">        if (currentStartPosition &lt; dn.length()</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">            &amp;&amp; dn.charAt(currentStartPosition) == '&quot;'</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">            &amp;&amp; dn.charAt(endPosition) == '&quot;') {</span>
<span class="fc" id="L529">          currentStartPosition++;</span>
<span class="fc" id="L530">          endPosition--;</span>
        }
<span class="fc" id="L532">        String currentValue =</span>
<span class="fc" id="L533">            dn.substring(currentStartPosition, endPosition + 1);</span>
        // Unescape value (except escaped #) since the nameBuilder will double
        // each escape
<span class="fc" id="L536">        currentValue =</span>
<span class="fc" id="L537">            unescapeValue(new StringBuilder(currentValue)).toString();</span>
        try {
          // -- First search the OID by name in declared OID's
<span class="fc" id="L540">          ASN1ObjectIdentifier oid = DnComponents.getOid(currentPartName);</span>
          // -- If isn't declared, we try to create it
<span class="fc bfc" id="L542" title="All 2 branches covered.">          if (oid == null) {</span>
<span class="fc" id="L543">            oid = new ASN1ObjectIdentifier(currentPartName);</span>
          }
<span class="fc" id="L545">          nameBuilder.addRDN(oid, currentValue);</span>
<span class="fc" id="L546">        } catch (final IllegalArgumentException e) {</span>
          // If it is not an OID we will ignore it
<span class="fc" id="L548">          LOGGER.warn(</span>
              &quot;Unknown DN component ignored and silently dropped: &quot;
                  + currentPartName);
<span class="fc" id="L551">        }</span>
        // Reset markers
<span class="fc" id="L553">        currentStartPosition = -1;</span>
<span class="fc" id="L554">        currentPartName = null;</span>
      }
<span class="fc bfc" id="L556" title="All 2 branches covered.">      if (escapeNext) {</span>
        // This character was escaped, so don't escape the next one
<span class="fc" id="L558">        escapeNext = false;</span>
      } else {
<span class="fc bfc" id="L560" title="All 4 branches covered.">        if (!quoted &amp;&amp; current == '\\') {</span>
          // This escape character is not escaped itself, so the next one should
          // be
<span class="fc" id="L563">          escapeNext = true;</span>
        }
      }
    }
<span class="fc" id="L567">    final X500Name x500Name = nameBuilder.build();</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L569">      LOGGER.trace(&quot;&lt;stringToUnorderedX500Name: x500Name=&quot;</span>
<span class="nc" id="L570">              + x500Name.toString());</span>
    }
<span class="fc" id="L572">    return x500Name;</span>
  }

  /**
   * Removes any unescaped '\' character from the provided StringBuilder.
   * Assumes that escaping quotes have been stripped. Special treatment of the #
   * sign, which if not escaped will be treated as hex encoded DER value by BC.
   *
   * @param sb unescaped StringBuilder
   * @return escaped StringBuilder
   */
  private static StringBuilder unescapeValue(final StringBuilder sb) {
<span class="fc" id="L584">    boolean esq = false;</span>
<span class="fc" id="L585">    int index = 0;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">    while (index &lt; (sb.length() - 1)) {</span>
<span class="fc bfc" id="L587" title="All 6 branches covered.">      if (!esq &amp;&amp; sb.charAt(index) == '\\' &amp;&amp; sb.charAt(index + 1) != '#') {</span>
<span class="fc" id="L588">        esq = true;</span>
<span class="fc" id="L589">        sb.deleteCharAt(index);</span>
      } else {
<span class="fc" id="L591">        esq = false;</span>
<span class="fc" id="L592">        index++;</span>
      }
    }
<span class="fc" id="L595">    return sb;</span>
  }

/** Remove extra '+' character escaping.
 *
 * @param value value
 * @return unescaped
 */
  public static String getUnescapedPlus(final String value) {
<span class="nc" id="L604">    final StringBuilder buf = new StringBuilder(value);</span>
<span class="nc" id="L605">    int index = 0;</span>
<span class="nc" id="L606">    int end = buf.length();</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">    while (index &lt; end) {</span>
<span class="nc bnc" id="L608" title="All 4 branches missed.">      if (buf.charAt(index) == '\\' &amp;&amp; index + 1 != end) {</span>
<span class="nc" id="L609">        final char c = buf.charAt(index + 1);</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (c == '+') {</span>
<span class="nc" id="L611">          buf.deleteCharAt(index);</span>
<span class="nc" id="L612">          end--;</span>
        }
      }
<span class="nc" id="L615">      index++;</span>
    }
<span class="nc" id="L617">    return buf.toString();</span>
  }

  /**
   * Check if the String contains any unescaped '+'. RFC 2253, section 2.2
   * states that '+' is used for multi-valued RelativeDistinguishedName. BC
   * (version 1.45) did not support multi-valued RelativeDistinguishedName, and
   * automatically escaped them instead. Even though it is now (BC 1.49b15)
   * supported, we want to keep ecaping '+' chars and warn that this might not
   * be supported in the future.
   *
   * @param dn DN
   * @return escaped DN
   */
  public static String handleUnescapedPlus(final String dn) {
<span class="fc bfc" id="L632" title="All 2 branches covered.">    if (dn == null) {</span>
<span class="fc" id="L633">      return dn;</span>
    }
<span class="fc" id="L635">    final StringBuilder buf = new StringBuilder(dn);</span>
<span class="fc" id="L636">    int index = 0;</span>
<span class="fc" id="L637">    final int end = buf.length();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">    while (index &lt; end) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">      if (buf.charAt(index) == '+') {</span>
        // Found an unescaped '+' character.
<span class="fc" id="L641">        LOGGER.warn(</span>
            &quot;DN \&quot;&quot;
                + dn
                + &quot;\&quot; contains an unescaped '+'-character that will be&quot;
                + &quot; automatically escaped. RFC 2253 reservs this for&quot;
                + &quot; multi-valued RelativeDistinguishedNames. Encourage clients&quot;
                + &quot; to use '\\+' instead, since future behaviour might&quot;
                + &quot; change.&quot;);
<span class="fc" id="L649">        buf.insert(index, '\\');</span>
<span class="fc" id="L650">        index++;</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">      } else if (buf.charAt(index) == '\\') {</span>
        // Found an escape character.
<span class="fc" id="L653">        index++;</span>
      }
<span class="fc" id="L655">      index++;</span>
    }
<span class="fc" id="L657">    return buf.toString();</span>
  }

  /**
   * Every DN-string should look the same. Creates a name string ordered and
   * looking like we want it...
   *
   * @param odn String containing DN
   * @return String containing DN, or empty string if dn does not contain any
   *     real DN components, or null if input is null
   */
  public static String stringToBCDNString(final String odn) {
    // BC now seem to handle multi-valued RDNs, but we keep escaping this for
    // now to keep the behavior until support is required
<span class="fc" id="L671">    String dn = handleUnescapedPlus(odn);</span>
        // Log warning if dn contains unescaped '+'
<span class="fc bfc" id="L673" title="All 2 branches covered.">    if (isDNReversed(dn)) {</span>
<span class="fc" id="L674">      dn = reverseDN(dn);</span>
    }
<span class="fc" id="L676">    String ret = null;</span>
<span class="fc" id="L677">    final X500Name name = stringToBcX500Name(dn);</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">    if (name != null) {</span>
<span class="fc" id="L679">      ret = name.toString();</span>
    }
    /*
     * For some databases (MySQL for instance) the database column
     *  holding subjectDN is only 250 chars long. There have been strange error
     * reported (clipping DN naturally) that is hard to debug if DN is
     *  more than 250 chars and we don't have a good message
     */
<span class="fc" id="L687">    final int maxLength = 250;</span>
<span class="pc bpc" id="L688" title="1 of 4 branches missed.">    if ((ret != null) &amp;&amp; (ret.length() &gt; maxLength)) {</span>
<span class="nc" id="L689">      LOGGER.info(</span>
          &quot;Warning! DN is more than 250 characters long. Some databases have&quot;
              + &quot; only 250 characters in the database for SubjectDN. Clipping&quot;
              + &quot; may occur! DN (&quot;
<span class="nc" id="L693">              + ret.length()</span>
              + &quot; chars): &quot;
              + ret);
    }
<span class="fc" id="L697">    return ret;</span>
  }

  /**
   * Convenience method for getting an email addresses from a DN. Uses {@link
   * #getPartsFromDN(String,String)} internally, and searches for {@link
   * #EMAIL}, {@link #EMAIL1}, {@link #EMAIL2}, {@link #EMAIL3} and returns the
   * first one found.
   *
   * @param dn the DN
   * @return ArrayList containing email or empty list if email is not present
   */
  public static ArrayList&lt;String&gt; getEmailFromDN(final String dn) {
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L711">      LOGGER.trace(&quot;&gt;getEmailFromDN(&quot; + dn + &quot;)&quot;);</span>
    }
<span class="fc" id="L713">    final ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">    for (int i = 0; i &lt; EMAILIDS.length; i++) {</span>
<span class="fc" id="L715">      final List&lt;String&gt; emails = getPartsFromDN(dn, EMAILIDS[i]);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">      if (!emails.isEmpty()) {</span>
<span class="fc" id="L717">        ret.addAll(emails);</span>
      }
    }
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L721">      LOGGER.trace(&quot;&lt;getEmailFromDN(&quot; + dn + &quot;): &quot; + ret.size());</span>
    }
<span class="fc" id="L723">    return ret;</span>
  }

  /**
   * Search for e-mail address, first in SubjectAltName (as in PKIX
   * recommendation) then in subject DN. Original author: Marco Ferrante, (c)
   * 2005 CSITA - University of Genoa (Italy)
   *
   * @param certificate certificate
   * @return subject email or null if not present in certificate
   */
  public static String getEMailAddress(final Certificate certificate) {
<span class="fc" id="L735">    LOGGER.debug(&quot;Searching for EMail Address in SubjectAltName&quot;);</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">    if (certificate == null) {</span>
<span class="fc" id="L737">      return null;</span>
    }
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">    if (certificate instanceof X509Certificate) {</span>
<span class="fc" id="L740">      final X509Certificate x509cert = (X509Certificate) certificate;</span>
      try {
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if (x509cert.getSubjectAlternativeNames() != null) {</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">          for (final List&lt;?&gt; item : x509cert.getSubjectAlternativeNames()) {</span>
<span class="fc" id="L744">            final Integer type = (Integer) item.get(0);</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">            if (type.intValue() == 1) {</span>
<span class="fc" id="L746">              return (String) item.get(1);</span>
            }
<span class="fc" id="L748">          }</span>
        }
<span class="nc" id="L750">      } catch (final CertificateParsingException e) {</span>
<span class="nc" id="L751">        LOGGER.error(&quot;Error parsing certificate: &quot;, e);</span>
<span class="fc" id="L752">      }</span>
<span class="fc" id="L753">      LOGGER.debug(&quot;Searching for EMail Address in Subject DN&quot;);</span>
<span class="fc" id="L754">      final ArrayList&lt;String&gt; emails =</span>
<span class="fc" id="L755">          CertTools.getEmailFromDN(x509cert.getSubjectDN().getName());</span>
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">      if (!emails.isEmpty()) {</span>
<span class="nc" id="L757">        return emails.get(0);</span>
      }
    }
<span class="fc" id="L760">    return null;</span>
  }

  /**
   * Takes a DN and reverses it completely so the first attribute ends up last.
   * C=SE,O=Foo,CN=Bar becomes CN=Bar,O=Foo,C=SE.
   *
   * @param dn String containing DN to be reversed, The DN string has the format
   *     &quot;C=SE, O=xx, OU=yy, CN=zz&quot;.
   * @return String containing reversed DN
   */
  public static String reverseDN(final String dn) {
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L773">      LOGGER.trace(&quot;&gt;reverseDN: dn: &quot; + dn);</span>
    }
<span class="fc" id="L775">    String ret = null;</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">    if (dn != null) {</span>
      String o;
<span class="fc" id="L778">      final BasicX509NameTokenizer xt = new BasicX509NameTokenizer(dn);</span>
<span class="fc" id="L779">      final StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L780">      boolean first = true;</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">      while (xt.hasMoreTokens()) {</span>
<span class="fc" id="L782">        o = xt.nextToken();</span>
        // log.debug(&quot;token: &quot;+o);
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (!first) {</span>
<span class="fc" id="L785">          buf.insert(0, &quot;,&quot;);</span>
        } else {
<span class="fc" id="L787">          first = false;</span>
        }
<span class="fc" id="L789">        buf.insert(0, o);</span>
      }
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">      if (buf.length() &gt; 0) {</span>
<span class="fc" id="L792">        ret = buf.toString();</span>
      }
    }
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L796">      LOGGER.trace(&quot;&lt;reverseDN: resulting dn: &quot; + ret);</span>
    }
<span class="fc" id="L798">    return ret;</span>
  }

  /**
   * Tries to determine if a DN is in reversed form. It does this by taking the
   * last attribute and the first attribute. If the last attribute comes before
   * the first in the dNObjects array the DN is assumed to be in reversed order.
   *
   * &lt;p&gt;The default ordering is: &quot;CN=Tomas, O=PrimeKey, C=SE&quot; (dNObjectsForward
   * ordering in EJBCA) a dn or form &quot;C=SE, O=PrimeKey, CN=Tomas&quot; is reversed.
   *
   * &lt;p&gt;If the string has only one component (e.g. &quot;CN=example.com&quot;) then this
   * method returns false. If the string does not contain any real DN
   * components, it returns false.
   *
   * @param dn String containing DN to be checked, The DN string has the format
   *     &quot;C=SE, O=xx, OU=yy, CN=zz&quot;.
   * @return true if the DN is believed to be in reversed order, false otherwise
   */
  public static boolean isDNReversed(final String dn) {
    /*
     * if (log.isTraceEnabled()) { log.trace(&quot;&gt;isDNReversed: dn: &quot; + dn); }
     */
<span class="fc" id="L821">    boolean ret = false;</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">    if (dn != null) {</span>
<span class="fc" id="L823">      String first = null;</span>
<span class="fc" id="L824">      String last = null;</span>
<span class="fc" id="L825">      final X509NameTokenizer xt = new X509NameTokenizer(dn);</span>
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">      if (xt.hasMoreTokens()) {</span>
<span class="fc" id="L827">        first = xt.nextToken().trim();</span>
      }
<span class="fc bfc" id="L829" title="All 2 branches covered.">      while (xt.hasMoreTokens()) {</span>
<span class="fc" id="L830">        last = xt.nextToken().trim();</span>
      }
<span class="fc" id="L832">      final String[] dNObjects = DnComponents.getDnObjects(true);</span>
<span class="pc bpc" id="L833" title="1 of 4 branches missed.">      if ((first != null) &amp;&amp; (last != null)) {</span>
        // Be careful for bad input, that may not have any = sign in it
<span class="fc" id="L835">        final int fi = first.indexOf('=');</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">        first = first.substring(0, (fi != -1 ? fi : (first.length() - 1)));</span>
<span class="fc" id="L837">        final int li = last.indexOf('=');</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        last = last.substring(0, (li != -1 ? li : (last.length() - 1)));</span>
<span class="fc" id="L839">        int firsti = 0;</span>
<span class="fc" id="L840">        int lasti = 0;</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">        for (int i = 0; i &lt; dNObjects.length; i++) {</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">          if (first.equalsIgnoreCase(dNObjects[i])) {</span>
<span class="fc" id="L843">            firsti = i;</span>
          }
<span class="fc bfc" id="L845" title="All 2 branches covered.">          if (last.equalsIgnoreCase(dNObjects[i])) {</span>
<span class="fc" id="L846">            lasti = i;</span>
          }
        }
<span class="fc bfc" id="L849" title="All 2 branches covered.">        if (lasti &lt; firsti) {</span>
<span class="fc" id="L850">          ret = true;</span>
        }
      }
    }
    /*
     * if (log.isTraceEnabled()) { log.trace(&quot;&lt;isDNReversed: &quot; + ret); }
     */
<span class="fc" id="L857">    return ret;</span>
  } // isDNReversed

  /**
   * Checks if a DN has at least two components. Then the DN can be in either
   * LDAP or X500 order. Otherwise it's not possible to determine the order.
   *
   * @param dn DN
   * @return boolean
   */
  public static boolean dnHasMultipleComponents(final String dn) {
<span class="fc" id="L868">    final X509NameTokenizer xt = new X509NameTokenizer(dn);</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">    if (xt.hasMoreTokens()) {</span>
<span class="fc" id="L870">      xt.nextToken();</span>
<span class="fc" id="L871">      return xt.hasMoreTokens();</span>
    }
<span class="nc" id="L873">    return false;</span>
  }

  /**
   * Gets a specified part of a DN. Specifically the first occurrence it the DN
   * contains several instances of a part (i.e. cn=x, cn=y returns x).
   *
   * @param dn String containing DN, The DN string has the format &quot;C=SE, O=xx,
   *     OU=yy, CN=zz&quot;.
   * @param dnpart String specifying which part of the DN to get, should be &quot;CN&quot;
   *     or &quot;OU&quot; etc.
   * @return String containing dnpart or null if dnpart is not present
   */
  public static String getPartFromDN(final String dn, final String dnpart) {
<span class="fc" id="L887">    String part = null;</span>
<span class="fc" id="L888">    final List&lt;String&gt; dnParts = getPartsFromDNInternal(dn, dnpart, true);</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">    if (!dnParts.isEmpty()) {</span>
<span class="fc" id="L890">      part = dnParts.get(0);</span>
    }
<span class="fc" id="L892">    return part;</span>
  }

  /**
   * Gets a specified parts of a DN. Returns all occurrences as an ArrayList,
   * also works if DN contains several instances of a part (i.e. cn=x, cn=y
   * returns {x, y, null}).
   *
   * @param dn String containing DN, The DN string has the format &quot;C=SE, O=xx,
   *     OU=yy, CN=zz&quot;.
   * @param dnpart String specifying which part of the DN to get, should be &quot;CN&quot;
   *     or &quot;OU&quot; etc.
   * @return ArrayList containing dnparts or empty list if dnpart is not present
   */
  public static List&lt;String&gt; getPartsFromDN(
          final String dn, final String dnpart) {
<span class="fc" id="L908">    return getPartsFromDNInternal(dn, dnpart, false);</span>
  }

  /**
   * @param dn DN
   * @param dnPart Part
   * @param onlyReturnFirstMatch bool
   * @return parts
   */
  public static List&lt;String&gt; getPartsFromDNInternal(
      final String dn,
      final String dnPart,
      final boolean onlyReturnFirstMatch) {
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L922">      LOGGER.trace(</span>
          &quot;&gt;getPartsFromDNInternal: dn:'&quot;
              + dn
              + &quot;', dnpart=&quot;
              + dnPart
              + &quot;, onlyReturnFirstMatch=&quot;
              + onlyReturnFirstMatch);
    }
<span class="fc" id="L930">    final List&lt;String&gt; parts = new ArrayList&lt;String&gt;();</span>
<span class="pc bpc" id="L931" title="1 of 4 branches missed.">    if (dn != null &amp;&amp; dnPart != null) {</span>
<span class="fc" id="L932">      final String dnPartLowerCase = dnPart.toLowerCase();</span>
<span class="fc" id="L933">      final int dnPartLenght = dnPart.length();</span>
<span class="fc" id="L934">      boolean quoted = false;</span>
<span class="fc" id="L935">      boolean escapeNext = false;</span>
<span class="fc" id="L936">      int currentStartPosition = -1;</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">      for (int i = 0; i &lt; dn.length(); i++) {</span>
<span class="fc" id="L938">        final char current = dn.charAt(i);</span>
        // Toggle quoting for every non-escaped &quot;-char
<span class="fc bfc" id="L940" title="All 4 branches covered.">        if (!escapeNext &amp;&amp; current == '&quot;') {</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">          quoted = !quoted;</span>
        }
        // If there is an unescaped and unquoted =-char we need to investigate
        // if it is a match for the sought after part
<span class="fc bfc" id="L945" title="All 8 branches covered.">        if (!quoted &amp;&amp; !escapeNext &amp;&amp; current == '=' &amp;&amp; dnPartLenght &lt;= i) {</span>
          // Check that the character before our expected partName isn't a
          // letter (e.g. dnsName=.. should not match E=..)
<span class="fc bfc" id="L948" title="All 2 branches covered.">          if (i - dnPartLenght - 1 &lt; 0</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">              || !Character.isLetter(dn.charAt(i - dnPartLenght - 1))) {</span>
<span class="fc" id="L950">            boolean match = true;</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">            for (int j = 0; j &lt; dnPartLenght; j++) {</span>
<span class="fc" id="L952">              if (Character.toLowerCase(dn.charAt(i - dnPartLenght + j))</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">                  != dnPartLowerCase.charAt(j)) {</span>
<span class="fc" id="L954">                match = false;</span>
<span class="fc" id="L955">                break;</span>
              }
            }
<span class="fc bfc" id="L958" title="All 2 branches covered.">            if (match) {</span>
<span class="fc" id="L959">              currentStartPosition = i + 1;</span>
            }
          }
        }
        // When we have found a start marker, we need to be on the lookout for
        // the ending marker
<span class="pc bpc" id="L965" title="1 of 10 branches missed.">        if (currentStartPosition != -1</span>
            &amp;&amp; ((!quoted &amp;&amp; !escapeNext &amp;&amp; (current == ',' || current == '+'))
<span class="fc bfc" id="L967" title="All 2 branches covered.">                || i == dn.length() - 1)) {</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">          int endPosition = (i == dn.length() - 1) ? dn.length() - 1 : i - 1;</span>
          // Remove white spaces from the end of the value
<span class="fc bfc" id="L970" title="All 2 branches covered.">          while (endPosition &gt; currentStartPosition</span>
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">              &amp;&amp; dn.charAt(endPosition) == ' ') {</span>
<span class="nc" id="L972">            endPosition--;</span>
          }
          // Remove white spaces from the beginning of the value
<span class="fc bfc" id="L975" title="All 2 branches covered.">          while (endPosition &gt; currentStartPosition</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">              &amp;&amp; dn.charAt(currentStartPosition) == ' ') {</span>
<span class="nc" id="L977">            currentStartPosition++;</span>
          }
          // Only return the inner value if the part is quoted
<span class="fc bfc" id="L980" title="All 2 branches covered.">          if (currentStartPosition != dn.length()</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">              &amp;&amp; dn.charAt(currentStartPosition) == '&quot;'</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">              &amp;&amp; dn.charAt(endPosition) == '&quot;') {</span>
<span class="fc" id="L983">            currentStartPosition++;</span>
<span class="fc" id="L984">            endPosition--;</span>
          }
<span class="fc" id="L986">          parts.add(</span>
<span class="fc" id="L987">              unescapeFieldValue(</span>
<span class="fc" id="L988">                  dn.substring(currentStartPosition, endPosition + 1)));</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">          if (onlyReturnFirstMatch) {</span>
<span class="fc" id="L990">            break;</span>
          }
<span class="fc" id="L992">          currentStartPosition = -1;</span>
        }
<span class="fc bfc" id="L994" title="All 2 branches covered.">        if (escapeNext) {</span>
          // This character was escaped, so don't escape the next one
<span class="fc" id="L996">          escapeNext = false;</span>
        } else {
<span class="fc bfc" id="L998" title="All 4 branches covered.">          if (!quoted &amp;&amp; current == '\\') {</span>
            // This escape character is not escaped itself, so the next one
            // should be
<span class="fc" id="L1001">            escapeNext = true;</span>
          }
        }
      }
    }
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1007">      LOGGER.trace(</span>
<span class="nc" id="L1008">          &quot;&lt;getPartsFromDNInternal: resulting DN part=&quot; + parts.toString());</span>
    }
<span class="fc" id="L1010">    return parts;</span>
  }

  /**
   * Gets a list of all custom OIDs defined in the string. A custom OID is
   * defined as an OID, simply as that. Otherwise, if it is not a custom oid,
   * the DNpart is defined by a name such as CN och rfc822Name. This method only
   * returns a oid once, so if the input string has multiple of the same oid,
   * only one value is returned.
   *
   * @param dn String containing DN, The DN string has the format &quot;C=SE, O=xx,
   *     OU=yy, CN=zz&quot;, or &quot;rfc822Name=foo@bar.com&quot;, etc.
   * @return ArrayList containing unique oids or empty list if no custom OIDs
   *     are present
   */
  public static ArrayList&lt;String&gt; getCustomOids(final String dn) {
<span class="pc bpc" id="L1026" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1027">      LOGGER.trace(&quot;&gt;getCustomOids: dn:'&quot; + dn);</span>
    }
<span class="fc" id="L1029">    final ArrayList&lt;String&gt; parts = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">    if (dn != null) {</span>
      String o;
<span class="fc" id="L1032">      final X509NameTokenizer xt = new X509NameTokenizer(dn);</span>
<span class="fc bfc" id="L1033" title="All 2 branches covered.">      while (xt.hasMoreTokens()) {</span>
<span class="fc" id="L1034">        o = xt.nextToken().trim();</span>
        // Try to see if it is a valid OID
        try {
<span class="fc" id="L1037">          final int i = o.indexOf('=');</span>
          // An oid is never shorter than 3 chars and must start with 1.
<span class="fc bfc" id="L1039" title="All 4 branches covered.">          if ((i &gt; 2) &amp;&amp; (o.charAt(1) == '.')) {</span>
<span class="fc" id="L1040">            final String oid = o.substring(0, i);</span>
            // If we have multiple of the same custom oid, don't claim that we
            // have more
            // This method will only return &quot;unique&quot; custom oids.
<span class="fc bfc" id="L1044" title="All 2 branches covered.">            if (!parts.contains(oid)) {</span>
              // Check if it is a real oid, if it is not we will ignore it
              // (IllegalArgumentException will be thrown)
<span class="fc" id="L1047">              new ASN1ObjectIdentifier(oid);</span>
<span class="fc" id="L1048">              parts.add(oid);</span>
            }
          }
<span class="nc" id="L1051">        } catch (final IllegalArgumentException e) {</span>
          // Not a valid oid
<span class="pc" id="L1053">        }</span>
      }
    }
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1057">      LOGGER.trace(&quot;&lt;getCustomOids: resulting DN part=&quot; + parts.toString());</span>
    }
<span class="fc" id="L1059">    return parts;</span>
  }

  /**
   * Gets subject DN in the format we are sure about (BouncyCastle),supporting
   * UTF8.
   *
   * @param cert Certificate
   * @return String containing the subjects DN.
   */
  public static String getSubjectDN(final Certificate cert) {
<span class="fc" id="L1070">    return getDN(cert, 1);</span>
  }

  /**
   * @param value String to enescape
   * @return value in unescaped RDN format
   */
  public static String getUnescapedRdnValue(final String value) {
<span class="nc bnc" id="L1078" title="All 2 branches missed.">    if (StringUtils.isNotEmpty(value)) {</span>
<span class="nc" id="L1079">      return org.ietf.ldap.LDAPDN.unescapeRDN(value);</span>
    } else {
<span class="nc" id="L1081">      return value;</span>
    }
  }

  /**
   * Gets issuer DN in the format we are sure about (BouncyCastle),supporting
   * UTF8.
   *
   * @param cert Certificate
   * @return String containing the issuers DN.
   */
  public static String getIssuerDN(final Certificate cert) {
<span class="fc" id="L1093">    return getDN(cert, 2);</span>
  }

  /**
   * Gets subject or issuer DN in the format we are sure about
   * (BouncyCastle),supporting UTF8.
   *
   * @param cert X509Certificate
   * @param which 1 = subjectDN, anything else = issuerDN
   * @return String containing the DN.
   */
  private static String getDN(final Certificate cert, final int which) {
<span class="fc" id="L1105">    String ret = null;</span>
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L1107">      return null;</span>
    }
<span class="fc bfc" id="L1109" title="All 2 branches covered.">    if (cert instanceof X509Certificate) {</span>
      // cert.getType=X.509
      try {
<span class="fc" id="L1112">        final String clazz = cert.getClass().getName();</span>
        // The purpose of the below generateCertificate is to create a BC
        // certificate object, because there we know how DN components
        // are handled. If we already have a BC certificate however, we can save
        // a lot of time to not have to encode/decode it.
        final X509Certificate x509cert;
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">        if (clazz.contains(&quot;org.bouncycastle&quot;)) {</span>
<span class="fc" id="L1119">          x509cert = (X509Certificate) cert;</span>
        } else {
<span class="nc" id="L1121">          final CertificateFactory cf = CertTools.getCertificateFactory();</span>
<span class="nc" id="L1122">          x509cert =</span>
              (X509Certificate)
<span class="nc" id="L1124">                  cf.generateCertificate(</span>
<span class="nc" id="L1125">                      new ByteArrayInputStream(cert.getEncoded()));</span>
        }
<span class="fc" id="L1127">        String dn = null;</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        if (which == 1) {</span>
<span class="fc" id="L1129">          dn = x509cert.getSubjectDN().toString();</span>
        } else {
<span class="fc" id="L1131">          dn = x509cert.getIssuerDN().toString();</span>
        }
<span class="fc" id="L1133">        ret = stringToBCDNString(dn);</span>
<span class="nc" id="L1134">      } catch (final CertificateException ce) {</span>
<span class="nc" id="L1135">        LOGGER.info(&quot;Could not get DN from X509Certificate. &quot;</span>
<span class="nc" id="L1136">                + ce.getMessage());</span>
<span class="nc" id="L1137">        LOGGER.debug(&quot;&quot;, ce);</span>
<span class="nc" id="L1138">        return null;</span>
<span class="fc" id="L1139">      }</span>
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">    } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1141">      final CardVerifiableCertificate cvccert =</span>
          (CardVerifiableCertificate) cert;
      try {
<span class="fc" id="L1144">        ReferenceField rf = null;</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">        if (which == 1) {</span>
<span class="fc" id="L1146">          rf =</span>
              cvccert
<span class="fc" id="L1148">                  .getCVCertificate()</span>
<span class="fc" id="L1149">                  .getCertificateBody()</span>
<span class="fc" id="L1150">                  .getHolderReference();</span>
        } else {
<span class="fc" id="L1152">          rf =</span>
              cvccert
<span class="fc" id="L1154">                  .getCVCertificate()</span>
<span class="fc" id="L1155">                  .getCertificateBody()</span>
<span class="fc" id="L1156">                  .getAuthorityReference();</span>
        }
<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">        if (rf != null) {</span>
          // Construct a &quot;fake&quot; DN which can be used in EJBCA
          // Use only mnemonic and country, since sequence is more of a
          // serialnumber than a DN part
<span class="fc" id="L1162">          String dn = &quot;&quot;;</span>
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">          if (rf.getMnemonic() != null) {</span>
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">            if (StringUtils.isNotEmpty(dn)) {</span>
<span class="nc" id="L1165">              dn += &quot;, &quot;;</span>
            }
<span class="fc" id="L1167">            dn += &quot;CN=&quot; + rf.getMnemonic();</span>
          }
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">          if (rf.getCountry() != null) {</span>
<span class="pc bpc" id="L1170" title="1 of 2 branches missed.">            if (StringUtils.isNotEmpty(dn)) {</span>
<span class="fc" id="L1171">              dn += &quot;, &quot;;</span>
            }
<span class="fc" id="L1173">            dn += &quot;C=&quot; + rf.getCountry();</span>
          }
<span class="fc" id="L1175">          ret = stringToBCDNString(dn);</span>
        }
<span class="nc" id="L1177">      } catch (final NoSuchFieldException e) {</span>
<span class="nc" id="L1178">        LOGGER.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L1179">        return null;</span>
<span class="fc" id="L1180">      }</span>
    }
<span class="fc" id="L1182">    return ret;</span>
  }

  /**
   * Gets Serial number of the certificate.
   *
   * @param cert Certificate
   * @return BigInteger containing the certificate serial number. Can be 0 for
   *     CVC certificates with alphanumeric serial numbers if the sequence does
   *     not contain any number characters at all.
   * @throws IllegalArgumentException if null input of certificate type is not
   *     handled
   */
  public static BigInteger getSerialNumber(final Certificate cert) {
<span class="fc bfc" id="L1196" title="All 2 branches covered.">    if (cert == null) {</span>
<span class="fc" id="L1197">      throw new IllegalArgumentException(&quot;Null input&quot;);</span>
    }
<span class="fc" id="L1199">    BigInteger ret = null;</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1201">      final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1202">      ret = xcert.getSerialNumber();</span>
<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">    } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
      // For CVC certificates the sequence field of the HolderReference is kind
      // of a serial number,
      // but if can be alphanumeric which means it can not be made into a
      // BigInteger
<span class="fc" id="L1208">      final CardVerifiableCertificate cvccert =</span>
              (CardVerifiableCertificate) cert;
      try {
<span class="fc" id="L1211">        final String sequence =</span>
            cvccert
<span class="fc" id="L1213">                .getCVCertificate()</span>
<span class="fc" id="L1214">                .getCertificateBody()</span>
<span class="fc" id="L1215">                .getHolderReference()</span>
<span class="fc" id="L1216">                .getSequence();</span>
<span class="fc" id="L1217">        ret = getSerialNumberFromString(sequence);</span>
<span class="nc" id="L1218">      } catch (final NoSuchFieldException e) {</span>
<span class="nc" id="L1219">        LOGGER.error(&quot;getSerialNumber: NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L1220">        ret = BigInteger.valueOf(0);</span>
<span class="fc" id="L1221">      }</span>
<span class="fc" id="L1222">    } else {</span>
<span class="nc" id="L1223">      throw new IllegalArgumentException(</span>
          &quot;getSerialNumber: Certificate of type &quot;
<span class="nc" id="L1225">              + cert.getType()</span>
              + &quot; is not implemented&quot;);
    }
<span class="fc" id="L1228">    return ret;</span>
  }

  /**
   * Gets a serial number in numeric form, it takes - either a hex encoded
   * integer with length != 5 (x.509 certificate) - 5 letter numeric string
   * (cvc), will convert the number to an int - 5 letter alfanumeric string vi
   * some numbers in it (cvc), will convert the numbers in it to a numeric
   * string (remove the letters) and convert to int - 5 letter alfanumeric
   * string with only letters (cvc), will convert to integer from string with
   * radix 36.
   *
   * @param sernoString serial
   * @return BigInteger
   */
  public static BigInteger getSerialNumberFromString(final String sernoString) {
<span class="fc bfc" id="L1244" title="All 2 branches covered.">    if (sernoString == null) {</span>
<span class="fc" id="L1245">      throw new IllegalArgumentException(</span>
          &quot;getSerialNumberFromString: cert is null&quot;);
    }
    BigInteger ret;
    try {
<span class="fc" id="L1250">        final int cvcLength = 5;</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">      if (sernoString.length() != cvcLength) {</span>
        // This can not be a CVC certificate sequence, so it must be a hex
        // encoded regular certificate serial number
<span class="fc" id="L1254">        ret = new BigInteger(sernoString, 16);</span>
      } else {
        // We try to handle the different cases of CVC certificate sequences,
        // see StringTools.KEY_SEQUENCE_FORMAT
<span class="fc bfc" id="L1258" title="All 2 branches covered.">        if (NumberUtils.isNumber(sernoString)) {</span>
<span class="fc" id="L1259">          ret = NumberUtils.createBigInteger(sernoString);</span>
        } else {
          // check if input is hexadecimal
<span class="fc" id="L1262">          LOGGER.info(</span>
              &quot;getSerialNumber: Sequence is not a numeric string, trying to&quot;
                  + &quot; extract numerical sequence part.&quot;);
<span class="fc" id="L1265">          final StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L1266" title="All 2 branches covered.">          for (int i = 0; i &lt; sernoString.length(); i++) {</span>
<span class="fc" id="L1267">            final char c = sernoString.charAt(i);</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">            if (CharUtils.isAsciiNumeric(c)) {</span>
<span class="fc" id="L1269">              buf.append(c);</span>
            }
          }
<span class="fc bfc" id="L1272" title="All 2 branches covered.">          if (buf.length() &gt; 0) {</span>
<span class="fc" id="L1273">            ret = NumberUtils.createBigInteger(buf.toString());</span>
          } else {
<span class="fc" id="L1275">            LOGGER.info(</span>
                &quot;getSerialNumber: can not extract numeric sequence part,&quot;
                    + &quot; trying alfanumeric value (radix 36).&quot;);
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">            if (sernoString.matches(&quot;[0-9A-Z]{1,5}&quot;)) {</span>
<span class="fc" id="L1279">              final int numSeq = Integer.parseInt(sernoString, 36);</span>
<span class="fc" id="L1280">              ret = BigInteger.valueOf(numSeq);</span>
<span class="fc" id="L1281">            } else {</span>
<span class="nc" id="L1282">              LOGGER.info(</span>
                  &quot;getSerialNumber: Sequence does not contain any numeric&quot;
                      + &quot; parts, returning 0.&quot;);
<span class="nc" id="L1285">              ret = BigInteger.valueOf(0);</span>
            }
          }
        }
      }
<span class="nc" id="L1290">    } catch (final NumberFormatException e) {</span>
      // If we can't make the sequence into a serial number big integer, set it
      // to 0
<span class="nc" id="L1293">      LOGGER.debug(</span>
          &quot;getSerialNumber: NumberFormatException for sequence: &quot;
              + sernoString);
<span class="nc" id="L1296">      ret = BigInteger.valueOf(0);</span>
<span class="fc" id="L1297">    }</span>
<span class="fc" id="L1298">    return ret;</span>
  }

  /**
   * Gets Serial number of the certificate as a string. For X509 Certificate
   * this means a HEX encoded BigInteger, and for CVC certificate is means the
   * sequence field of the holder reference.
   *
   * &lt;p&gt;For X509 certificates, the value is normalized (uppercase without
   * leading zeros), so there's no need to normalize the returned value.
   *
   * @param cert Certificate
   * @return String to be displayed, or used in RoleMember objects
   */
  public static String getSerialNumberAsString(final Certificate cert) {
<span class="fc" id="L1313">    String ret = null;</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">    if (cert == null) {</span>
<span class="fc" id="L1315">      throw new IllegalArgumentException(&quot;getSerialNumber: cert is null&quot;);</span>
    }
<span class="fc bfc" id="L1317" title="All 2 branches covered.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1318">      final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1319">      ret = xcert.getSerialNumber().toString(16).toUpperCase();</span>
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">    } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
      // For CVC certificates the sequence field of the HolderReference is kind
      // of a serial number,
      // but if can be alphanumeric which means it can not be made into a
      // BigInteger
<span class="fc" id="L1325">      final CardVerifiableCertificate cvccert =</span>
              (CardVerifiableCertificate) cert;
      try {
<span class="fc" id="L1328">        ret =</span>
            cvccert
<span class="fc" id="L1330">                .getCVCertificate()</span>
<span class="fc" id="L1331">                .getCertificateBody()</span>
<span class="fc" id="L1332">                .getHolderReference()</span>
<span class="fc" id="L1333">                .getSequence();</span>
<span class="nc" id="L1334">      } catch (final NoSuchFieldException e) {</span>
<span class="nc" id="L1335">        LOGGER.error(&quot;getSerialNumber: NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L1336">        ret = &quot;N/A&quot;;</span>
<span class="fc" id="L1337">      }</span>
<span class="fc" id="L1338">    } else {</span>
<span class="nc" id="L1339">      throw new IllegalArgumentException(</span>
          &quot;getSerialNumber: Certificate of type &quot;
<span class="nc" id="L1341">              + cert.getType()</span>
              + &quot; is not implemented&quot;);
    }
<span class="fc" id="L1344">    return ret;</span>
  }

  /**
   * Gets the signature value (the raw signature bits) from the certificate. For
   * an X509 certificate this is the ASN.1 definition which is: signature BIT
   * STRING
   *
   * @param cert Certificate
   * @return byte[] containing the certificate signature bits, if cert is null a
   *     byte[] of size 0 is returned.
   */
  public static byte[] getSignature(final Certificate cert) {
<span class="fc" id="L1357">    byte[] ret = null;</span>
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L1359">      ret = new byte[0];</span>
    } else {
<span class="fc bfc" id="L1361" title="All 2 branches covered.">      if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1362">        final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1363">        ret = xcert.getSignature();</span>
<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">      } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1365">        final CardVerifiableCertificate cvccert =</span>
                (CardVerifiableCertificate) cert;
        try {
<span class="fc" id="L1368">          ret = cvccert.getCVCertificate().getSignature();</span>
<span class="nc" id="L1369">        } catch (final NoSuchFieldException e) {</span>
<span class="nc" id="L1370">          LOGGER.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="nc" id="L1371">          return null;</span>
<span class="fc" id="L1372">        }</span>
      }
    }
<span class="fc" id="L1375">    return ret;</span>
  }

  /**
   * Gets issuer DN for CRL in the format we are sure about
   * (BouncyCastle),supporting UTF8.
   *
   * @param crl X509RL
   * @return String containing the DN.
   */
  public static String getIssuerDN(final X509CRL crl) {
<span class="fc" id="L1386">    String dn = null;</span>
    try {
<span class="fc" id="L1388">      final CertificateFactory cf = CertTools.getCertificateFactory();</span>
<span class="fc" id="L1389">      final X509CRL x509crl =</span>
<span class="fc" id="L1390">          (X509CRL) cf.generateCRL(new ByteArrayInputStream(crl.getEncoded()));</span>
      // log.debug(&quot;Created certificate of class: &quot; +
      // x509crl.getClass().getName());
<span class="fc" id="L1393">      dn = x509crl.getIssuerDN().toString();</span>
<span class="nc" id="L1394">    } catch (final CRLException ce) {</span>
<span class="nc" id="L1395">      LOGGER.error(&quot;CRLException: &quot;, ce);</span>
<span class="nc" id="L1396">      return null;</span>
<span class="fc" id="L1397">    }</span>
<span class="fc" id="L1398">    return stringToBCDNString(dn);</span>
  }

  /**
   * @param cert Cert
   * @return Start date
   */
  public static Date getNotBefore(final Certificate cert) {
<span class="fc" id="L1406">    Date ret = null;</span>
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L1408">      throw new IllegalArgumentException(&quot;getNotBefore: cert is null&quot;);</span>
    }
<span class="fc bfc" id="L1410" title="All 2 branches covered.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1411">      final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1412">      ret = xcert.getNotBefore();</span>
<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">    } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1414">      final CardVerifiableCertificate cvccert =</span>
              (CardVerifiableCertificate) cert;
      try {
<span class="fc" id="L1417">        ret = cvccert.getCVCertificate().getCertificateBody().getValidFrom();</span>
<span class="nc" id="L1418">      } catch (final NoSuchFieldException e) {</span>
        // it is not uncommon that this field is missing in CVC certificate
        // requests (it's not in the EAC standard so)
<span class="nc" id="L1421">        LOGGER.debug(&quot;NoSuchFieldException: &quot; + e.getMessage());</span>
<span class="nc" id="L1422">        return null;</span>
<span class="fc" id="L1423">      }</span>
    }
<span class="fc" id="L1425">    return ret;</span>
  }

  /**
   * @param cert Cert
   * @return Expiry
   */
  public static Date getNotAfter(final Certificate cert) {
<span class="fc" id="L1433">    Date ret = null;</span>
<span class="pc bpc" id="L1434" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L1435">      throw new IllegalArgumentException(&quot;getNotAfter: cert is null&quot;);</span>
    }
<span class="fc bfc" id="L1437" title="All 2 branches covered.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L1438">      final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L1439">      ret = xcert.getNotAfter();</span>
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">    } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L1441">      final CardVerifiableCertificate cvccert =</span>
          (CardVerifiableCertificate) cert;
      try {
<span class="fc" id="L1444">        ret = cvccert.getCVCertificate().getCertificateBody().getValidTo();</span>
<span class="nc" id="L1445">      } catch (final NoSuchFieldException e) {</span>
        // it is not uncommon that this field is missing in CVC certificate
        // requests (it's not in the EAC standard so)
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L1449">          LOGGER.debug(&quot;NoSuchFieldException: &quot; + e.getMessage());</span>
        }
<span class="nc" id="L1451">        return null;</span>
<span class="fc" id="L1452">      }</span>
    }
<span class="fc" id="L1454">    return ret;</span>
  }

  /**
   * Returns a CertificateFactory that can be used to create certificates from
   * byte arrays and such.
   *
   * @param provider Security provider that should be used to create
   *     certificates, default BC is null is passed.
   * @return CertificateFactory
   */
  public static CertificateFactory getCertificateFactory(
      final String provider) {
    final String prov;
<span class="pc bpc" id="L1468" title="1 of 2 branches missed.">    if (provider == null) {</span>
<span class="nc" id="L1469">      prov = BouncyCastleProvider.PROVIDER_NAME;</span>
    } else {
<span class="fc" id="L1471">      prov = provider;</span>
    }
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">    if (BouncyCastleProvider.PROVIDER_NAME.equals(prov)) {</span>
<span class="fc" id="L1474">      CryptoProviderTools.installBCProviderIfNotAvailable();</span>
    }
    try {
<span class="fc" id="L1477">      return CertificateFactory.getInstance(&quot;X.509&quot;, prov);</span>
<span class="nc" id="L1478">    } catch (final NoSuchProviderException nspe) {</span>
<span class="nc" id="L1479">      LOGGER.error(&quot;NoSuchProvider: &quot;, nspe);</span>
<span class="nc" id="L1480">    } catch (final CertificateException ce) {</span>
<span class="nc" id="L1481">      LOGGER.error(&quot;CertificateException: &quot;, ce);</span>
<span class="nc" id="L1482">    }</span>
<span class="nc" id="L1483">    return null;</span>
  }

  /**
   * @return factory
   */
  public static CertificateFactory getCertificateFactory() {
<span class="fc" id="L1490">    return getCertificateFactory(BouncyCastleProvider.PROVIDER_NAME);</span>
  }

  /**
   * Reads certificates in PEM-format from a filename. The stream may contain
   * other things between the different certificates.
   *
   * @param certFilename filename of the file containing the certificates in
   *     PEM-format
   * @return Ordered List of Certificates, first certificate first, or empty
   *     List
   * @throws FileNotFoundException if certFile was not found
   * @throws CertificateParsingException if the file contains an incorrect
   *     certificate.
   * @deprecated Use org.cesecore.util.CertTools.getCertsFromPEM(String,
   *     Class&amp;lt;T&amp;gt;) instead
   */
  @Deprecated
  public static List&lt;Certificate&gt; getCertsFromPEM(final String certFilename)
      throws FileNotFoundException, CertificateParsingException {
<span class="nc" id="L1510">    return getCertsFromPEM(certFilename, Certificate.class);</span>
  }

  /**
   * Reads certificates in PEM-format from a filename. The stream may contain
   * other things between the different certificates.
   *
   * @param certFilename filename of the file containing the certificates in
   *     PEM-format
   * @param returnType a Class specifying the desired return type. Certificate
   *     can be used if return type is unknown.
   * @param &lt;T&gt; type
   * @return Ordered List of Certificates, first certificate first, or empty
   *     List
   * @throws FileNotFoundException if certFile was not found
   * @throws CertificateParsingException if the file contains an incorrect
   *     certificate.
   */
  public static &lt;T extends Certificate&gt; List&lt;T&gt; getCertsFromPEM(
      final String certFilename, final Class&lt;T&gt; returnType)
      throws FileNotFoundException, CertificateParsingException {
<span class="nc bnc" id="L1531" title="All 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1532">      LOGGER.trace(&quot;&gt;getCertfromPEM: certFilename=&quot; + certFilename);</span>
    }
<span class="nc" id="L1534">    InputStream inStrm = null;</span>
    final List&lt;T&gt; certs;
    try {
<span class="nc" id="L1537">      inStrm = new FileInputStream(certFilename);</span>
<span class="nc" id="L1538">      certs = getCertsFromPEM(inStrm, returnType);</span>
    } finally {
<span class="nc bnc" id="L1540" title="All 2 branches missed.">      if (inStrm != null) {</span>
        try {
<span class="nc" id="L1542">          inStrm.close();</span>
<span class="nc" id="L1543">        } catch (final IOException e) {</span>
<span class="nc" id="L1544">          throw new IllegalStateException(&quot;Could not clode input stream&quot;, e);</span>
<span class="nc" id="L1545">        }</span>
      }
    }
<span class="nc bnc" id="L1548" title="All 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1549">      LOGGER.trace(&quot;&lt;getCertfromPEM: certFile=&quot; + certFilename);</span>
    }
<span class="nc" id="L1551">    return certs;</span>
  }

  /**
   * Reads a CA certificate and its certificate chain by a file. If it is a
   * chain it is a file with multiple PEM encoded certificates. A single
   * certificate is either in PEM or binary format.
   *
   * @param file the full path of the file.
   * @return a byte array containing one PEM or binary certificate, or all
   *     certificates in the chain in PEM format. First is the CA certificate,
   *     followed by its certificate chain.
   * @throws FileNotFoundException if the file cannot be found.
   * @throws IOException on IO error
   * @throws CertificateParsingException if a certificate could not be parsed.
   * @throws CertificateEncodingException if a certificate cannot be encoded.
   */
  public static final byte[] readCertificateChainAsArrayOrThrow(
      final String file)
      throws FileNotFoundException, IOException, CertificateParsingException,
          CertificateEncodingException {

<span class="nc" id="L1573">    final List&lt;byte[]&gt; cachain = new ArrayList&lt;byte[]&gt;();</span>
<span class="nc" id="L1574">    try (FileInputStream fis = new FileInputStream(file)) {</span>
<span class="nc" id="L1575">      final Collection&lt;Certificate&gt; certs =</span>
<span class="nc" id="L1576">          CertTools.getCertsFromPEM(fis, Certificate.class);</span>
<span class="nc" id="L1577">      final Iterator&lt;Certificate&gt; iter = certs.iterator();</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">      while (iter.hasNext()) {</span>
<span class="nc" id="L1579">        final Certificate cert = iter.next();</span>
<span class="nc" id="L1580">        cachain.add(cert.getEncoded());</span>
<span class="nc" id="L1581">      }</span>
<span class="nc" id="L1582">    } catch (final CertificateParsingException e) {</span>
      // It was perhaps not a PEM chain...see if it was a single binary
      // certificate
<span class="nc" id="L1585">      final byte[] certbytes = FileTools.readFiletoBuffer(file);</span>
<span class="nc" id="L1586">      final Certificate cert =</span>
<span class="nc" id="L1587">          CertTools.getCertfromByteArray(</span>
              certbytes,
              Certificate
                  .class); // check if it is a good cert, decode PEM if it is
                           // PEM, etc
<span class="nc" id="L1592">      cachain.add(cert.getEncoded());</span>
<span class="nc" id="L1593">    }</span>

<span class="nc" id="L1595">    try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">      for (final byte[] bytes : cachain) {</span>
<span class="nc" id="L1597">        bos.write(bytes);</span>
<span class="nc" id="L1598">      }</span>
<span class="nc" id="L1599">      final byte[] result = bos.toByteArray();</span>
<span class="nc" id="L1600">      return result;</span>
    }
  }

/**
 * @param bytes Bytes
 * @return Certs
 * @throws CertificateParsingException Fail
 */
  public static final List&lt;CertificateWrapper&gt;
      bytesToListOfCertificateWrapperOrThrow(final byte[] bytes)
          throws CertificateParsingException {
<span class="nc" id="L1612">    Collection&lt;java.security.cert.Certificate&gt; certs = null;</span>
    try {
<span class="nc" id="L1614">      certs =</span>
<span class="nc" id="L1615">          CertTools.getCertsFromPEM(</span>
              new ByteArrayInputStream(bytes),
              java.security.cert.Certificate.class);
<span class="nc" id="L1618">    } catch (final CertificateException e) {</span>
<span class="nc" id="L1619">      LOGGER.debug(&quot;Input stream is not PEM certificate(s): &quot; + e.getMessage());</span>
      // See if it is a single binary certificate
<span class="nc" id="L1621">      final java.security.cert.Certificate cert =</span>
<span class="nc" id="L1622">          CertTools.getCertfromByteArray(</span>
              bytes, java.security.cert.Certificate.class);
<span class="nc" id="L1624">      certs = new ArrayList&lt;java.security.cert.Certificate&gt;();</span>
<span class="nc" id="L1625">      certs.add(cert);</span>
<span class="nc" id="L1626">    }</span>
<span class="nc" id="L1627">    return EJBTools.wrapCertCollection(certs);</span>
  }

  /**
   * Reads certificates in PEM-format from an InputStream. The stream may
   * contain other things between the different certificates.
   *
   * @param certstream the input stream containing the certificates in
   *     PEM-format
   * @return Ordered List of Certificates, first certificate first, or empty
   *     List
   * @throws CertificateParsingException if the stream contains an incorrect
   *     certificate.
   * @deprecated Use org.cesecore.util.CertTools.getCertsFromPEM(InputStream,
   *     Class&amp;lt;T&amp;gt;) instead.
   */
  @Deprecated
  public static List&lt;Certificate&gt; getCertsFromPEM(final InputStream certstream)
      throws CertificateParsingException {
<span class="nc" id="L1646">    return getCertsFromPEM(certstream, Certificate.class);</span>
  }

  /**
   * Reads certificates in PEM-format from an InputStream. The stream may
   * contain other things between the different certificates.
   *
   * @param certstream the input stream containing the certificates in
   *     PEM-format
   * @param returnType specifies the desired certificate type. Certificate can
   *     be used if certificate type is unknown.
   * @param &lt;T&gt; type
   * @return Ordered List of Certificates, first certificate first, or empty
   *     List
   * @exception CertificateParsingException if the stream contains an incorrect
   *     certificate.
   */
  public static &lt;T extends Certificate&gt; List&lt;T&gt; getCertsFromPEM(
      final InputStream certstream, final Class&lt;T&gt; returnType)
      throws CertificateParsingException {
<span class="pc bpc" id="L1666" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1667">      LOGGER.trace(&quot;&gt;getCertfromPEM&quot;);</span>
    }
<span class="fc" id="L1669">    final ArrayList&lt;T&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1670">    final String beginKeyTrust = &quot;-----BEGIN TRUSTED CERTIFICATE-----&quot;;</span>
<span class="fc" id="L1671">    final String endKeyTrust = &quot;-----END TRUSTED CERTIFICATE-----&quot;;</span>
<span class="fc" id="L1672">    BufferedReader bufRdr = null;</span>
<span class="fc" id="L1673">    ByteArrayOutputStream ostr = null;</span>
<span class="fc" id="L1674">    PrintStream opstr = null;</span>
    try {
      try {
<span class="fc" id="L1677">        bufRdr =</span>
            new BufferedReader(
                new InputStreamReader(
                    new SecurityFilterInputStream(certstream)));
<span class="fc bfc" id="L1681" title="All 2 branches covered.">        while (bufRdr.ready()) {</span>
<span class="fc" id="L1682">          ostr = new ByteArrayOutputStream();</span>
<span class="fc" id="L1683">          opstr = new PrintStream(ostr);</span>
          String temp;
<span class="pc bpc" id="L1685" title="1 of 2 branches missed.">          while ((temp = bufRdr.readLine()) != null</span>
<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">              &amp;&amp; !(temp.equals(CertTools.BEGIN_CERTIFICATE)</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">                  || temp.equals(beginKeyTrust))) {</span>
<span class="nc" id="L1688">            continue;</span>
          }
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">          if (temp == null) {</span>
<span class="nc bnc" id="L1691" title="All 2 branches missed.">            if (ret.isEmpty()) {</span>
              // There was no certificate in the file
<span class="nc" id="L1693">              throw new CertificateParsingException(</span>
                  &quot;Error in &quot;
<span class="nc" id="L1695">                      + certstream.toString()</span>
                      + &quot;, missing &quot;
                      + CertTools.BEGIN_CERTIFICATE
                      + &quot; boundary&quot;);
            } else {
              // There were certificates, but some blank lines or something in
              // the end
              // anyhow, the file has ended so we can break here.
              break;
            }
          }
<span class="pc bpc" id="L1706" title="1 of 2 branches missed.">          while ((temp = bufRdr.readLine()) != null</span>
<span class="fc bfc" id="L1707" title="All 2 branches covered.">              &amp;&amp; !(temp.equals(CertTools.END_CERTIFICATE)</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">                  || temp.equals(endKeyTrust))) {</span>
<span class="fc" id="L1709">            opstr.print(temp);</span>
          }
<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">          if (temp == null) {</span>
<span class="nc" id="L1712">            throw new IllegalArgumentException(</span>
                &quot;Error in &quot;
<span class="nc" id="L1714">                    + certstream.toString()</span>
                    + &quot;, missing &quot;
                    + CertTools.END_CERTIFICATE
                    + &quot; boundary&quot;);
          }
<span class="fc" id="L1719">          opstr.close();</span>

<span class="fc" id="L1721">          final byte[] certbuf = Base64.decode(ostr.toByteArray());</span>
<span class="fc" id="L1722">          ostr.close();</span>
          // Phweeew, were done, now decode the cert from file back to
          // Certificate object
<span class="fc" id="L1725">          final T cert = getCertfromByteArray(certbuf, returnType);</span>
<span class="fc" id="L1726">          ret.add(cert);</span>
<span class="fc" id="L1727">        }</span>

      } finally {
<span class="pc bpc" id="L1730" title="1 of 2 branches missed.">        if (bufRdr != null) {</span>
<span class="fc" id="L1731">          bufRdr.close();</span>
        }
<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">        if (opstr != null) {</span>
<span class="fc" id="L1734">          opstr.close();</span>
        }
<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">        if (ostr != null) {</span>
<span class="fc" id="L1737">          ostr.close();</span>
        }
      }
<span class="nc" id="L1740">    } catch (final IOException e) {</span>
<span class="nc" id="L1741">      throw new IllegalStateException(</span>
          &quot;Exception caught when attempting to read stream, see underlying&quot;
              + &quot; IOException&quot;,
          e);
<span class="fc" id="L1745">    }</span>
<span class="pc bpc" id="L1746" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1747">      LOGGER.trace(&quot;&lt;getcertfromPEM:&quot; + ret.size());</span>
    }
<span class="fc" id="L1749">    return ret;</span>
  }

  /**
   * Converts a regular array of certificates into an ArrayList, using the
   * provided provided.
   *
   * @param certs Certificate[] of certificates to convert
   * @param provider provider for example &quot;SUN&quot; or &quot;BC&quot;, use null for the
   *     default provider (BC)
   * @return An ArrayList of certificates in the same order as the passed in
   *     array
   * @throws NoSuchProviderException if provider not found
   * @throws CertificateException if certifiate cannot be parsed
   */
  public static List&lt;Certificate&gt; getCertCollectionFromArray(
      final Certificate[] certs, final String provider)
      throws CertificateException, NoSuchProviderException {
<span class="pc bpc" id="L1767" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1768">      LOGGER.trace(&quot;&gt;getCertCollectionFromArray: &quot; + provider);</span>
    }
<span class="fc" id="L1770">    final ArrayList&lt;Certificate&gt; ret = new ArrayList&lt;Certificate&gt;();</span>
<span class="fc" id="L1771">    String prov = provider;</span>
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">    if (prov == null) {</span>
<span class="nc" id="L1773">      prov = &quot;BC&quot;;</span>
    }
<span class="fc bfc" id="L1775" title="All 2 branches covered.">    for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="fc" id="L1776">      final Certificate cert = certs[i];</span>
<span class="fc" id="L1777">      final Certificate newcert = getCertfromByteArray(cert.getEncoded(), prov);</span>
<span class="fc" id="L1778">      ret.add(newcert);</span>
    }
<span class="pc bpc" id="L1780" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L1781">      LOGGER.trace(&quot;&lt;getCertCollectionFromArray: &quot; + ret.size());</span>
    }
<span class="fc" id="L1783">    return ret;</span>
  }

  /**
   * Returns a certificate in PEM-format.
   *
   * @param certs Collection of Certificate to convert to PEM
   * @return byte array containing PEM certificate
   * @exception CertificateException if the stream does not contain a correct
   *     certificate.
   * @deprecated Since 6.0.0, use
   *     org.cesecore.util.CertTools.getPemFromCertificateChain(Collection&amp;lt;Certificate&amp;gt;)
   *     instead
   */
  @Deprecated
  public static byte[] getPEMFromCerts(final Collection&lt;Certificate&gt; certs)
      throws CertificateException {
<span class="nc" id="L1800">    return getPemFromCertificateChain(certs);</span>
  }

  /**
   * Returns a certificate in PEM-format.
   *
   * @param certs Collection of Certificate to convert to PEM
   * @return byte array containing PEM certificate
   * @throws CertificateEncodingException if an encoding error occurred
   */
  public static byte[] getPemFromCertificateChain(
          final Collection&lt;Certificate&gt; certs)
      throws CertificateEncodingException {
<span class="fc" id="L1813">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L1814">    try (PrintStream printStream = new PrintStream(baos)) {</span>
<span class="fc bfc" id="L1815" title="All 2 branches covered.">      for (final Certificate certificate : certs) {</span>
<span class="pc bpc" id="L1816" title="1 of 2 branches missed.">        if (certificate != null) {</span>
<span class="fc" id="L1817">          printStream.println(</span>
<span class="fc" id="L1818">              &quot;Subject: &quot; + CertTools.getSubjectDN(certificate));</span>
<span class="fc" id="L1819">          printStream.println(&quot;Issuer: &quot; + CertTools.getIssuerDN(certificate));</span>
<span class="fc" id="L1820">          writeAsPemEncoded(</span>
              printStream,
<span class="fc" id="L1822">              certificate.getEncoded(),</span>
              BEGIN_CERTIFICATE,
              END_CERTIFICATE);
        }
<span class="fc" id="L1826">      }</span>
    }
<span class="fc" id="L1828">    return baos.toByteArray();</span>
  }
  /**
   * Returns a certificate in PEM-format.
   *
   * @param cacert a Certificate to convert to PEM
   * @return byte array containing PEM certificate
   * @throws CertificateEncodingException if an encoding error occurred
   */
  public static String getPemFromCertificate(final Certificate cacert)
      throws CertificateEncodingException {
<span class="nc" id="L1839">    final byte[] enccert = cacert.getEncoded();</span>
<span class="nc" id="L1840">    final byte[] b64cert = Base64.encode(enccert);</span>
<span class="nc" id="L1841">    String out = BEGIN_CERTIFICATE_WITH_NL;</span>
<span class="nc" id="L1842">    out += new String(b64cert);</span>
<span class="nc" id="L1843">    out += END_CERTIFICATE_WITH_NL;</span>
<span class="nc" id="L1844">    return out;</span>
  }

  /**
   * @param crlBytes CRL
   * @return a CRL in PEM-format as a byte array.
   */
  public static byte[] getPEMFromCrl(final byte[] crlBytes) {
<span class="fc" id="L1852">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L1853">    try (PrintStream printStream = new PrintStream(baos)) {</span>
<span class="fc" id="L1854">      writeAsPemEncoded(</span>
          printStream, crlBytes, BEGIN_X509_CRL_KEY, END_X509_CRL_KEY);
    }
<span class="fc" id="L1857">    return baos.toByteArray();</span>
  }

  /**
   * @param publicKeyBytes key
   * @return a PublicKey in PEM-format as a byte array.
   */
  public static byte[] getPEMFromPublicKey(final byte[] publicKeyBytes) {
<span class="fc" id="L1865">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L1866">    try (PrintStream printStream = new PrintStream(baos)) {</span>
<span class="fc" id="L1867">      writeAsPemEncoded(</span>
          printStream, publicKeyBytes, BEGIN_PUBLIC_KEY, END_PUBLIC_KEY);
    }
<span class="fc" id="L1870">    return baos.toByteArray();</span>
  }

  /**
   * @param privateKeyBytes Bytes
   * @return PEM
   */
  public static byte[] getPEMFromPrivateKey(final byte[] privateKeyBytes) {
<span class="nc" id="L1878">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1879">    try (PrintStream printStream = new PrintStream(baos)) {</span>
<span class="nc" id="L1880">      writeAsPemEncoded(</span>
          printStream, privateKeyBytes, BEGIN_PRIVATE_KEY, END_PRIVATE_KEY);
    }
<span class="nc" id="L1883">    return baos.toByteArray();</span>
  }

  /**
   * @param certificateRequestBytes key
   * @return a PublicKey in PEM-format as a byte array.
   */
  public static byte[] getPEMFromCertificateRequest(
      final byte[] certificateRequestBytes) {
<span class="nc" id="L1892">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1893">    try (PrintStream printStream = new PrintStream(baos)) {</span>
<span class="nc" id="L1894">      writeAsPemEncoded(</span>
          printStream,
          certificateRequestBytes,
          BEGIN_CERTIFICATE_REQUEST,
          END_CERTIFICATE_REQUEST);
    }
<span class="nc" id="L1900">    return baos.toByteArray();</span>
  }

  /**
   * Generates PEM from binary pkcs#7 data.
   *
   * @param pkcs7Binary pkcs#7 binary data
   * @return a pkcs#7 PEM encoded
   */
  public static byte[] getPemFromPkcs7(final byte[] pkcs7Binary) {
<span class="nc" id="L1910">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1911">    try (PrintStream printStream = new PrintStream(baos)) {</span>
<span class="nc" id="L1912">      writeAsPemEncoded(printStream, pkcs7Binary, BEGIN_PKCS7, END_PKCS7);</span>
    }
<span class="nc" id="L1914">    return baos.toByteArray();</span>
  }

  /**
   * Write the supplied bytes to the printstream as Base64 using beginKey and
   * endKey around it.
   *
   * @param printStream stream
   * @param unencodedData data
   * @param beginKey key start
   * @param endKey key end
   */
  private static void writeAsPemEncoded(
      final PrintStream printStream,
      final byte[] unencodedData,
      final String beginKey,
      final String endKey) {
<span class="fc" id="L1931">    printStream.println(beginKey);</span>
<span class="fc" id="L1932">    printStream.println(new String(Base64.encode(unencodedData)));</span>
<span class="fc" id="L1933">    printStream.println(endKey);</span>
<span class="fc" id="L1934">  }</span>

  /**
   * Creates Certificate from byte[], can be either an X509 certificate or a
   * CVCCertificate.
   *
   * @param cert byte array containing certificate in binary (DER) format, or
   *     PEM encoded X.509 certificate
   * @param provider provider for example &quot;SUN&quot; or &quot;BC&quot;, use null for the
   *     default provider (BC)
   * @return a Certificate
   * @throws CertificateParsingException if certificate couldn't be parsed from
   *     cert
   * @deprecated Use org.cesecore.util.CertTools.getCertfromByteArray(byte[],
   *     String, Class&amp;lt;Y&amp;gt;) instead.
   */
  @Deprecated
  public static Certificate getCertfromByteArray(
          final byte[] cert, final String provider)
      throws CertificateParsingException {
<span class="fc" id="L1954">    return getCertfromByteArray(cert, provider, Certificate.class);</span>
  }

  /**
   * Creates Certificate from byte[], can be either an X509 certificate or a
   * CVCCertificate.
   *
   * @param cert byte array containing certificate in binary (DER) format, or
   *     PEM encoded X.509 certificate
   * @param provider provider for example &quot;SUN&quot; or &quot;BC&quot;, use null for the
   *     default provider (BC)
   * @param returnType the type of Certificate to be returned. Certificate can
   *     be used if certificate type is unknown.
   * @param &lt;T&gt; type
   * @return a Certificate
   * @throws CertificateParsingException if certificate couldn't be parsed from
   *     cert, or if the incorrect return type was specified.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T extends Certificate&gt; T getCertfromByteArray(
      final byte[] cert, final String provider, final Class&lt;T&gt; returnType)
      throws CertificateParsingException {
<span class="fc" id="L1976">    T ret = null;</span>
<span class="fc" id="L1977">    String prov = provider;</span>
<span class="pc bpc" id="L1978" title="1 of 2 branches missed.">    if (provider == null) {</span>
<span class="nc" id="L1979">      prov = BouncyCastleProvider.PROVIDER_NAME;</span>
    }

<span class="fc bfc" id="L1982" title="All 2 branches covered.">    if (returnType.equals(X509Certificate.class)) {</span>
<span class="fc" id="L1983">      ret = (T) parseX509Certificate(prov, cert);</span>
<span class="pc bpc" id="L1984" title="1 of 2 branches missed.">    } else if (returnType.equals(CardVerifiableCertificate.class)) {</span>
<span class="nc" id="L1985">      ret = (T) parseCardVerifiableCertificate(prov, cert);</span>
    } else {
      // Let's guess...
      try {
<span class="fc" id="L1989">        ret = (T) parseX509Certificate(prov, cert);</span>
<span class="fc" id="L1990">      } catch (final CertificateParsingException e) {</span>
        try {
<span class="fc" id="L1992">          ret = (T) parseCardVerifiableCertificate(prov, cert);</span>
<span class="nc" id="L1993">        } catch (final CertificateParsingException e1) {</span>
<span class="nc" id="L1994">          throw new CertificateParsingException(</span>
              &quot;No certificate could be parsed from byte array. See debug logs&quot;
                  + &quot; for details.&quot;);
<span class="fc" id="L1997">        }</span>
<span class="fc" id="L1998">      }</span>
    }

<span class="fc" id="L2001">    return ret;</span>
  }

  /**
   * @param provider a provider name
   * @param cert a byte array containing an encoded certificate
   * @return a decoded X509Certificate
   * @throws CertificateParsingException if the byte array wasn't valid, or
   *     contained a certificate other than an X509 Certificate.
   */
  private static X509Certificate parseX509Certificate(
      final String provider, final byte[] cert)
              throws CertificateParsingException {
<span class="fc" id="L2014">    final CertificateFactory cf = CertTools.getCertificateFactory(provider);</span>
    X509Certificate result;
    try {
<span class="fc" id="L2017">      result =</span>
          (X509Certificate)
<span class="fc" id="L2019">              cf.generateCertificate(</span>
                  new SecurityFilterInputStream(
                      new ByteArrayInputStream(cert)));
<span class="fc" id="L2022">    } catch (final CertificateException e) {</span>
<span class="fc" id="L2023">      throw new CertificateParsingException(</span>
          &quot;Could not parse byte array as X509Certificate.&quot;
<span class="fc" id="L2025">              + e.getCause().getMessage(),</span>
          e);
<span class="fc" id="L2027">    }</span>
<span class="fc bfc" id="L2028" title="All 2 branches covered.">    if (result != null) {</span>
<span class="fc" id="L2029">      return result;</span>
    } else {
<span class="fc" id="L2031">      throw new CertificateParsingException(</span>
          &quot;Could not parse byte array as X509Certificate.&quot;);
    }
  }

  private static CardVerifiableCertificate parseCardVerifiableCertificate(
      final String provider, final byte[] cert)
              throws CertificateParsingException {
    // We could not create an X509Certificate, see if it is a CVC certificate
    // instead
    try {
<span class="fc" id="L2042">      final CVCertificate parsedObject =</span>
<span class="fc" id="L2043">          CertificateParser.parseCertificate(cert);</span>
<span class="fc" id="L2044">      return new CardVerifiableCertificate(parsedObject);</span>
<span class="nc" id="L2045">    } catch (final ParseException e) {</span>
<span class="nc" id="L2046">      throw new CertificateParsingException(</span>
          &quot;ParseException trying to read CVCCertificate.&quot;, e);
<span class="nc" id="L2048">    } catch (final ConstructionException e) {</span>
<span class="nc" id="L2049">      throw new CertificateParsingException(</span>
          &quot;ConstructionException trying to read CVCCertificate.&quot;, e);
    }
  }

  /**
   * @param cert vertificate
   * @return certificate
   * @throws CertificateParsingException if the byte array does not contain a
   *     proper certificate.
   * @deprecated Use org.cesecore.util.CertTools.getCertfromByteArray(byte[],
   *     Class&amp;lt;T&amp;gt;) to specify return type instead.
   */
  @Deprecated
  public static Certificate getCertfromByteArray(final byte[] cert)
      throws CertificateParsingException {
<span class="fc" id="L2065">    return getCertfromByteArray(cert, Certificate.class);</span>
  }

  /**
   * @param cert certificate as byte array
   * @param &lt;T&gt; type
   * @param returnType the type of Certificate to be returned, for example
   *     X509Certificate.class. Certificate.class can be used if certificate
   *     type is unknown.
   * @return Certificate
   * @throws CertificateParsingException if the byte array does not contain a
   *     proper certificate.
   */
  public static &lt;T extends Certificate&gt; T getCertfromByteArray(
      final byte[] cert, final Class&lt;T&gt; returnType)
              throws CertificateParsingException {
<span class="fc" id="L2081">    return getCertfromByteArray(</span>
        cert, BouncyCastleProvider.PROVIDER_NAME, returnType);
  }

  /**
   * Creates X509CRL from byte[].
   *
   * @param crl byte array containing CRL in DER-format
   * @return X509CRL
   * @throws CRLException if the byte array does not contain a correct CRL.
   */
  public static X509CRL getCRLfromByteArray(
          final byte[] crl) throws CRLException {
<span class="fc" id="L2094">    LOGGER.trace(&quot;&gt;getCRLfromByteArray&quot;);</span>
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">    if (crl == null) {</span>
<span class="nc" id="L2096">      throw new CRLException(&quot;No content in crl byte array&quot;);</span>
    }
<span class="fc" id="L2098">    final CertificateFactory cf = CertTools.getCertificateFactory();</span>
<span class="fc" id="L2099">    final X509CRL x509crl =</span>
<span class="fc" id="L2100">            (X509CRL) cf.generateCRL(new ByteArrayInputStream(crl));</span>
<span class="fc" id="L2101">    LOGGER.trace(&quot;&lt;getCRLfromByteArray&quot;);</span>

<span class="fc" id="L2103">    return x509crl;</span>
  } // getCRLfromByteArray

  /**
   * Checks if a certificate is self signed by verifying if subject and issuer
   * are the same.
   *
   * @param cert the certificate that shall be checked.
   * @return boolean true if the certificate has the same issuer and subject,
   *     false otherwise.
   */
  public static boolean isSelfSigned(final Certificate cert) {
<span class="pc bpc" id="L2115" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L2116">      LOGGER.trace(</span>
          &quot;&gt;isSelfSigned: cert: &quot;
<span class="nc" id="L2118">              + CertTools.getIssuerDN(cert)</span>
              + &quot;\n&quot;
<span class="nc" id="L2120">              + CertTools.getSubjectDN(cert));</span>
    }
<span class="fc" id="L2122">    final boolean ret =</span>
<span class="fc" id="L2123">        CertTools.getSubjectDN(cert).equals(CertTools.getIssuerDN(cert));</span>
<span class="pc bpc" id="L2124" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L2125">      LOGGER.trace(&quot;&lt;isSelfSigned:&quot; + ret);</span>
    }
<span class="fc" id="L2127">    return ret;</span>
  } // isSelfSigned

  /**
   * Checks if a certificate is valid.
   *
   * @param warnIfAboutToExpire Also print a WARN log message if the certificate
   *     is about to expire. If false, it is still printed at DEBUG level.
   * @param signerCert the certificate to be tested
   * @return true if the certificate is valid
   */
  public static boolean isCertificateValid(
      final X509Certificate signerCert, final boolean warnIfAboutToExpire) {
    try {
<span class="nc" id="L2141">      signerCert.checkValidity();</span>
<span class="nc" id="L2142">    } catch (final CertificateExpiredException e) {</span>
<span class="nc bnc" id="L2143" title="All 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L2144">        LOGGER.debug(</span>
<span class="nc" id="L2145">            INTRES.getLocalizedMessage(</span>
                &quot;ocsp.errorcerthasexpired&quot;,
<span class="nc" id="L2147">                signerCert.getSerialNumber().toString(16),</span>
<span class="nc" id="L2148">                signerCert.getIssuerDN()));</span>
      }
<span class="nc" id="L2150">      return false;</span>
<span class="nc" id="L2151">    } catch (final CertificateNotYetValidException e) {</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L2153">        LOGGER.debug(</span>
<span class="nc" id="L2154">            INTRES.getLocalizedMessage(</span>
                &quot;ocsp.errornotyetvalid&quot;,
<span class="nc" id="L2156">                signerCert.getSerialNumber().toString(16),</span>
<span class="nc" id="L2157">                signerCert.getIssuerDN()));</span>
      }
<span class="nc" id="L2159">      return false;</span>
<span class="nc" id="L2160">    }</span>
    final long warnBeforeExpirationTime =
<span class="nc" id="L2162">        OcspConfiguration.getWarningBeforeExpirationTime();</span>
<span class="nc bnc" id="L2163" title="All 2 branches missed.">    if (warnBeforeExpirationTime &lt; 1) {</span>
<span class="nc" id="L2164">      return true;</span>
    }
<span class="nc" id="L2166">    final Date warnDate =</span>
<span class="nc" id="L2167">        new Date(new Date().getTime() + warnBeforeExpirationTime);</span>
    try {
<span class="nc" id="L2169">      signerCert.checkValidity(warnDate);</span>
<span class="nc" id="L2170">    } catch (final CertificateExpiredException e) {</span>
<span class="nc bnc" id="L2171" title="All 4 branches missed.">      if (warnIfAboutToExpire || LOGGER.isDebugEnabled()) {</span>
<span class="nc bnc" id="L2172" title="All 2 branches missed.">        final Level logLevel = warnIfAboutToExpire ? Level.WARN : Level.DEBUG;</span>
<span class="nc" id="L2173">        LOGGER.log(</span>
            logLevel,
<span class="nc" id="L2175">            INTRES.getLocalizedMessage(</span>
                &quot;ocsp.warncertwillexpire&quot;,
<span class="nc" id="L2177">                signerCert.getSerialNumber().toString(16),</span>
<span class="nc" id="L2178">                signerCert.getIssuerDN(),</span>
<span class="nc" id="L2179">                signerCert.getNotAfter()));</span>
      }
<span class="nc" id="L2181">    } catch (final CertificateNotYetValidException e) {</span>
<span class="nc" id="L2182">      throw new IllegalStateException(&quot;This should never happen.&quot;, e);</span>
<span class="nc" id="L2183">    }</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">    if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L2185">      LOGGER.debug(</span>
          &quot;Time for \&quot;certificate will soon expire\&quot; not yet reached. You will&quot;
              + &quot; be warned after: &quot;
              + new Date(
<span class="nc" id="L2189">                  signerCert.getNotAfter().getTime()</span>
                      - warnBeforeExpirationTime));
    }
<span class="nc" id="L2192">    return true;</span>
  }

  /**
   * Checks if a certificate is a CA certificate according to BasicConstraints
   * (X.509), or role (CVC). If there is no basic constraints extension on a
   * X.509 certificate, false is returned.
   *
   * @param cert the certificate that shall be checked.
   * @return boolean true if the certificate belongs to a CA.
   */
  public static boolean isCA(final Certificate cert) {
<span class="pc bpc" id="L2204" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L2205">      LOGGER.trace(&quot;&gt;isCA&quot;);</span>
    }
<span class="fc" id="L2207">    boolean ret = false;</span>
<span class="fc bfc" id="L2208" title="All 2 branches covered.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L2209">      final X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">      if (x509cert.getBasicConstraints() &gt; -1) {</span>
<span class="fc" id="L2211">        ret = true;</span>
      }
<span class="pc bpc" id="L2213" title="1 of 2 branches missed.">    } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L2214">      final CardVerifiableCertificate cvccert =</span>
              (CardVerifiableCertificate) cert;
      try {
<span class="fc" id="L2217">        final CVCAuthorizationTemplate templ =</span>
            cvccert
<span class="fc" id="L2219">                .getCVCertificate()</span>
<span class="fc" id="L2220">                .getCertificateBody()</span>
<span class="fc" id="L2221">                .getAuthorizationTemplate();</span>
<span class="fc" id="L2222">        final AuthorizationRole role =</span>
<span class="fc" id="L2223">                templ.getAuthorizationField().getAuthRole();</span>
<span class="fc bfc" id="L2224" title="All 4 branches covered.">        if (role.isCVCA() || role.isDV()) {</span>
<span class="fc" id="L2225">          ret = true;</span>
        }
<span class="nc" id="L2227">      } catch (final NoSuchFieldException e) {</span>
<span class="nc" id="L2228">        LOGGER.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="fc" id="L2229">      }</span>
    }
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L2232">      LOGGER.trace(&quot;&lt;isCA:&quot; + ret);</span>
    }
<span class="fc" id="L2234">    return ret;</span>
  }

  /**
   * Is OCSP extended key usage set for a certificate?
   *
   * @param cert to check.
   * @return true if the extended key usage for OCSP is check
   */
  public static boolean isOCSPCert(final X509Certificate cert) {
    final List&lt;String&gt; keyUsages;
    try {
<span class="nc" id="L2246">      keyUsages = cert.getExtendedKeyUsage();</span>
<span class="nc" id="L2247">    } catch (final CertificateParsingException e) {</span>
<span class="nc" id="L2248">      return false;</span>
<span class="nc" id="L2249">    }</span>
<span class="nc bnc" id="L2250" title="All 2 branches missed.">    return keyUsages != null</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">        &amp;&amp; keyUsages.contains(KeyPurposeId.id_kp_OCSPSigning.getId());</span>
  }

  /**
   * Generate a selfsigned certificate.
   *
   * @param dn subject and issuer DN
   * @param validity in days
   * @param policyId policy string ('2.5.29.32.0') or null
   * @param privKey private key
   * @param pubKey public key
   * @param sigAlg signature algorithm, you can use one of the contants
   *     AlgorithmConstants.SIGALG_XXX
   * @param isCA boolean true or false
   * @return X509Certificate, self signed
   * @throws CertificateException If cert cannot be parsed
   * @throws OperatorCreationException if creation fails
   */
  public static X509Certificate genSelfCert(
      final String dn,
      final long validity,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA)
      throws OperatorCreationException, CertificateException {
<span class="fc" id="L2278">    return genSelfCert(</span>
        dn,
        validity,
        policyId,
        privKey,
        pubKey,
        sigAlg,
        isCA,
        BouncyCastleProvider.PROVIDER_NAME);
  }

  /**
   * Generates a self signed certificate with keyUsage X509KeyUsage.keyCertSign
   * + X509KeyUsage.cRLSign, i.e. a CA certificate
   *
   * @param dn subject and issuer DN
   * @param validity in days
   * @param policyId policy string ('2.5.29.32.0') or null
   * @param privKey private key
   * @param pubKey public key
   * @param sigAlg signature algorithm, you can use one of the contants
   *     AlgorithmConstants.SIGALG_XXX
   * @param isCA boolean true or false
   * @param provider jce provider
   * @param ldapOrder true to sort
   * @return X509Certificate, self signed
   * @throws CertificateParsingException If cert cannot be parsed
   * @throws OperatorCreationException if creation fails
   */
  public static X509Certificate genSelfCert(
      final String dn,
      final long validity,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA,
      final String provider,
      final boolean ldapOrder)
      throws CertificateParsingException, OperatorCreationException {
    final int keyUsage;
<span class="fc bfc" id="L2319" title="All 2 branches covered.">    if (isCA) {</span>
<span class="fc" id="L2320">      keyUsage = X509KeyUsage.keyCertSign + X509KeyUsage.cRLSign;</span>
    } else {
<span class="fc" id="L2322">      keyUsage = 0;</span>
    }
<span class="fc" id="L2324">    return genSelfCertForPurpose(</span>
        dn, validity, policyId, privKey, pubKey, sigAlg, isCA, keyUsage, null,
        null, provider, ldapOrder);
  } // genselfCert

  /**
   * Generates a self signed certificate with keyUsage X509KeyUsage.keyCertSign
   * + X509KeyUsage.cRLSign, i.e. a CA certificate
   *
   * @param dn subject and issuer DN
   * @param validity in days
   * @param policyId policy string ('2.5.29.32.0') or null
   * @param privKey private key
   * @param pubKey public key
   * @param sigAlg signature algorithm, you can use one of the contants
   *     AlgorithmConstants.SIGALG_XXX
   * @param isCA boolean true or false
   * @param provider JCE provider
   * @return X509Certificate, self signed
   * @throws CertificateException If cert cannot be parsed
   * @throws OperatorCreationException if creation fails
   */
  public static X509Certificate genSelfCert(
      final String dn,
      final long validity,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA,
      final String provider)
      throws OperatorCreationException, CertificateException {
<span class="fc" id="L2356">    return genSelfCert(</span>
        dn, validity, policyId, privKey, pubKey, sigAlg, isCA, provider, true);
  } // genselfCert

  /**
   * Generate a selfsigned certiicate with possibility to specify key usage.
   *
   * @param dn subject and issuer DN
   * @param validity in days
   * @param policyId policy string ('2.5.29.32.0') or null
   * @param privKey private key
   * @param pubKey public key
   * @param sigAlg signature algorithm, you can use one of the contants
   *     AlgorithmConstants.SIGALG_XXX
   * @param isCA boolean true or false
   * @param keyusage as defined by constants in X509KeyUsage
   * @param ldapOrder set true to sort
   * @return X509Certificate, self signed
   * @throws CertificateParsingException If cert cannot be parsed
   * @throws OperatorCreationException if creation fails
   */
  public static X509Certificate genSelfCertForPurpose(
      final String dn,
      final long validity,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA,
      final int keyusage,
      final boolean ldapOrder)
      throws CertificateParsingException, OperatorCreationException {
<span class="fc" id="L2388">    return genSelfCertForPurpose(</span>
        dn,
        validity,
        policyId,
        privKey,
        pubKey,
        sigAlg,
        isCA,
        keyusage,
        null,
        null,
        BouncyCastleProvider.PROVIDER_NAME,
        ldapOrder);
  }

  /**
   * @param dn DN
   * @param validity Validity
   * @param policyId ID
   * @param privKey Key
   * @param pubKey Key
   * @param sigAlg Alg
   * @param isCA CA
   * @param keyusage Usage
   * @param privateKeyNotBefore Start
   * @param privateKeyNotAfter End
   * @param provider Prov
   * @return Cert
   * @throws CertificateParsingException fail
   * @throws OperatorCreationException fail
   */
  public static X509Certificate genSelfCertForPurpose(
      final String dn,
      final long validity,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA,
      final int keyusage,
      final Date privateKeyNotBefore,
      final Date privateKeyNotAfter,
      final String provider)
      throws CertificateParsingException, OperatorCreationException {
<span class="fc" id="L2432">    return genSelfCertForPurpose(</span>
        dn,
        validity,
        policyId,
        privKey,
        pubKey,
        sigAlg,
        isCA,
        keyusage,
        privateKeyNotBefore,
        privateKeyNotAfter,
        provider,
        true);
  }

  /**
   * @param dn DN
   * @param validity Validity
   * @param policyId Policy
   * @param privKey Key
   * @param pubKey Key
   * @param sigAlg Alg
   * @param isCA CA
   * @param keyusage Usage
   * @param privateKeyNotBefore Stary
   * @param privateKeyNotAfter End
   * @param provider Provider
   * @param ldapOrder Order
   * @return Cert
   * @throws CertificateParsingException fail
   * @throws OperatorCreationException fail
   */
  public static X509Certificate genSelfCertForPurpose(
      final String dn,
      final long validity,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA,
      final int keyusage,
      final Date privateKeyNotBefore,
      final Date privateKeyNotAfter,
      final String provider,
      final boolean ldapOrder)
      throws CertificateParsingException, OperatorCreationException {
    try {
<span class="fc" id="L2479">      return genSelfCertForPurpose(</span>
          dn,
          validity,
          policyId,
          privKey,
          pubKey,
          sigAlg,
          isCA,
          keyusage,
          privateKeyNotBefore,
          privateKeyNotAfter,
          provider,
          ldapOrder,
          null);
<span class="nc" id="L2493">    } catch (final CertIOException e) {</span>
<span class="nc" id="L2494">      throw new IllegalStateException(</span>
          &quot;CertIOException was thrown due to an invalid extension, but no&quot;
              + &quot; extensions were provided.&quot;,
          e);
    }
  }

  /**
   * @param dn DN
   * @param validity Validiy
   * @param policyId Policy
   * @param privKey Key
   * @param pubKey Key
   * @param sigAlg Alg
   * @param isCA CA
   * @param keyusage Usage
   * @param privateKeyNotBefore Start
   * @param privateKeyNotAfter End
   * @param provider Provider
   * @param ldapOrder Order
   * @param additionalExtensions Exts
   * @return Cert
   * @throws CertificateParsingException fail
   * @throws OperatorCreationException fail
   * @throws CertIOException fail
   */
  public static X509Certificate genSelfCertForPurpose(
      final String dn,
      final long validity,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA,
      final int keyusage,
      final Date privateKeyNotBefore,
      final Date privateKeyNotAfter,
      final String provider,
      final boolean ldapOrder,
      final List&lt;Extension&gt; additionalExtensions)
      throws CertificateParsingException, OperatorCreationException,
          CertIOException {
    // Create self signed certificate
<span class="fc" id="L2537">    final Date firstDate = new Date();</span>
<span class="fc" id="L2538">    final int tenMins = 10 * 60 * 1000;</span>
<span class="fc" id="L2539">    final int oneDay = 24 * 60 * 60 * 1000;</span>
    // Set back startdate ten minutes to avoid some problems with wrongly set
    // clocks.
<span class="fc" id="L2542">    firstDate.setTime(firstDate.getTime() - (tenMins));</span>

<span class="fc" id="L2544">    final Date lastDate = new Date();</span>

    // validity in days = validity*24*60*60*1000 milliseconds
<span class="fc" id="L2547">    lastDate.setTime(lastDate.getTime() + (validity * (oneDay)));</span>

<span class="fc" id="L2549">    return genSelfCertForPurpose(</span>
        dn,
        firstDate,
        lastDate,
        policyId,
        privKey,
        pubKey,
        sigAlg,
        isCA,
        keyusage,
        privateKeyNotBefore,
        privateKeyNotAfter,
        provider,
        ldapOrder,
        additionalExtensions);
  }

  /**
   * @param dn DN
   * @param firstDate Start
   * @param lastDate End
   * @param policyId ID
   * @param privKey Key
   * @param pubKey Key
   * @param sigAlg Alg
   * @param isCA CA
   * @param keyusage Usage
   * @param privateKeyNotBefore Start
   * @param privateKeyNotAfter End
   * @param provider Provider
   * @param ldapOrder Order
   * @param additionalExtensions Exyensions
   * @return Cert
   * @throws CertificateParsingException fail
   * @throws OperatorCreationException fail
   * @throws CertIOException fail
   */
  public static X509Certificate genSelfCertForPurpose(
      final String dn,
      final Date firstDate,
      final Date lastDate,
      final String policyId,
      final PrivateKey privKey,
      final PublicKey pubKey,
      final String sigAlg,
      final boolean isCA,
      final int keyusage,
      final Date privateKeyNotBefore,
      final Date privateKeyNotAfter,
      final String provider,
      final boolean ldapOrder,
      final List&lt;Extension&gt; additionalExtensions)
      throws CertificateParsingException, OperatorCreationException,
          CertIOException {
    // Transform the PublicKey to be sure we have it in a format that the X509
    // certificate generator handles, it might be
    // a CVC public key that is passed as parameter
<span class="fc" id="L2606">    PublicKey publicKey = null;</span>
<span class="fc bfc" id="L2607" title="All 2 branches covered.">    if (pubKey instanceof RSAPublicKey) {</span>
<span class="fc" id="L2608">      final RSAPublicKey rsapk = (RSAPublicKey) pubKey;</span>
<span class="fc" id="L2609">      final RSAPublicKeySpec rSAPublicKeySpec =</span>
<span class="fc" id="L2610">          new RSAPublicKeySpec(rsapk.getModulus(), rsapk.getPublicExponent());</span>
      try {
<span class="fc" id="L2612">        publicKey =</span>
<span class="fc" id="L2613">            KeyFactory.getInstance(&quot;RSA&quot;).generatePublic(rSAPublicKeySpec);</span>
<span class="nc" id="L2614">      } catch (final InvalidKeySpecException e) {</span>
<span class="nc" id="L2615">        LOGGER.error(&quot;Error creating RSAPublicKey from spec: &quot;, e);</span>
<span class="nc" id="L2616">        publicKey = pubKey;</span>
<span class="nc" id="L2617">      } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2618">        throw new IllegalStateException(&quot;RSA was not a known algorithm&quot;, e);</span>
<span class="pc" id="L2619">      }</span>
<span class="fc bfc" id="L2620" title="All 2 branches covered.">    } else if (pubKey instanceof ECPublicKey) {</span>
<span class="fc" id="L2621">      final ECPublicKey ecpk = (ECPublicKey) pubKey;</span>
      try {
<span class="fc" id="L2623">        final ECPublicKeySpec ecspec =</span>
            new ECPublicKeySpec(
<span class="fc" id="L2625">                ecpk.getW(),</span>
<span class="fc" id="L2626">                ecpk.getParams()); // will throw NPE if key is &quot;implicitlyCA&quot;</span>
<span class="fc" id="L2627">        final String algo = ecpk.getAlgorithm();</span>
<span class="pc bpc" id="L2628" title="1 of 2 branches missed.">        if (algo.equals(AlgorithmConstants.KEYALGORITHM_ECGOST3410)) {</span>
          try {
<span class="nc" id="L2630">            publicKey =</span>
<span class="nc" id="L2631">                KeyFactory.getInstance(&quot;ECGOST3410&quot;).generatePublic(ecspec);</span>
<span class="nc" id="L2632">          } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2633">            throw new IllegalStateException(</span>
                &quot;ECGOST3410 was not a known algorithm&quot;, e);
<span class="nc" id="L2635">          }</span>
<span class="pc bpc" id="L2636" title="1 of 2 branches missed.">        } else if (algo.equals(AlgorithmConstants.KEYALGORITHM_DSTU4145)) {</span>
          try {
<span class="nc" id="L2638">            publicKey =</span>
<span class="nc" id="L2639">                KeyFactory.getInstance(&quot;DSTU4145&quot;).generatePublic(ecspec);</span>
<span class="nc" id="L2640">          } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2641">            throw new IllegalStateException(</span>
                &quot;DSTU4145 was not a known algorithm&quot;, e);
<span class="nc" id="L2643">          }</span>
        } else {
          try {
<span class="fc" id="L2646">            publicKey = KeyFactory.getInstance(&quot;EC&quot;).generatePublic(ecspec);</span>
<span class="nc" id="L2647">          } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2648">            throw new IllegalStateException(&quot;EC was not a known algorithm&quot;, e);</span>
<span class="fc" id="L2649">          }</span>
        }
<span class="nc" id="L2651">      } catch (final InvalidKeySpecException e) {</span>
<span class="nc" id="L2652">        LOGGER.error(&quot;Error creating ECPublicKey from spec: &quot;, e);</span>
<span class="nc" id="L2653">        publicKey = pubKey;</span>
<span class="fc" id="L2654">      } catch (final NullPointerException e) {</span>
<span class="fc" id="L2655">        LOGGER.debug(</span>
            &quot;NullPointerException, probably it is implicitlyCA generated keys: &quot;
<span class="fc" id="L2657">                + e.getMessage());</span>
<span class="fc" id="L2658">        publicKey = pubKey;</span>
<span class="pc" id="L2659">      }</span>
<span class="fc" id="L2660">    } else {</span>
<span class="fc" id="L2661">      LOGGER.debug(&quot;Not converting key of class. &quot;</span>
<span class="fc" id="L2662">                  + pubKey.getClass().getName());</span>
<span class="fc" id="L2663">      publicKey = pubKey;</span>
    }

    // Serialnumber is random bits, where random generator is initialized with
    // Date.getTime() when this
    // bean is created.
<span class="fc" id="L2669">    final byte[] serno = new byte[8];</span>
    SecureRandom random;
    try {
<span class="fc" id="L2672">      random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span>
<span class="nc" id="L2673">    } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L2674">      throw new IllegalStateException(&quot;SHA1PRNG was not a known algorithm&quot;, e);</span>
<span class="fc" id="L2675">    }</span>
<span class="fc" id="L2676">    random.setSeed(new Date().getTime());</span>
<span class="fc" id="L2677">    random.nextBytes(serno);</span>

<span class="fc" id="L2679">    final SubjectPublicKeyInfo pkinfo =</span>
<span class="fc" id="L2680">        SubjectPublicKeyInfo.getInstance(publicKey.getEncoded());</span>
<span class="fc" id="L2681">    final X509v3CertificateBuilder certbuilder =</span>
        new X509v3CertificateBuilder(
<span class="fc" id="L2683">            CertTools.stringToBcX500Name(dn, ldapOrder),</span>
<span class="fc" id="L2684">            new BigInteger(serno).abs(),</span>
            firstDate,
            lastDate,
<span class="fc" id="L2687">            CertTools.stringToBcX500Name(dn, ldapOrder),</span>
            pkinfo);

    // Basic constranits is always critical and MUST be present at-least in
    // CA-certificates.
<span class="fc" id="L2692">    final BasicConstraints bc = new BasicConstraints(isCA);</span>
<span class="fc" id="L2693">    certbuilder.addExtension(Extension.basicConstraints, true, bc);</span>

    // Put critical KeyUsage in CA-certificates
<span class="fc bfc" id="L2696" title="All 4 branches covered.">    if (isCA || keyusage != 0) {</span>
<span class="fc" id="L2697">      final X509KeyUsage ku = new X509KeyUsage(keyusage);</span>
<span class="fc" id="L2698">      certbuilder.addExtension(Extension.keyUsage, true, ku);</span>
    }

<span class="fc bfc" id="L2701" title="All 4 branches covered.">    if ((privateKeyNotBefore != null) || (privateKeyNotAfter != null)) {</span>
<span class="fc" id="L2702">      final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L2703" title="All 2 branches covered.">      if (privateKeyNotBefore != null) {</span>
<span class="fc" id="L2704">        v.add(</span>
            new DERTaggedObject(
                false, 0, new DERGeneralizedTime(privateKeyNotBefore)));
      }
<span class="fc bfc" id="L2708" title="All 2 branches covered.">      if (privateKeyNotAfter != null) {</span>
<span class="fc" id="L2709">        v.add(</span>
            new DERTaggedObject(
                false, 1, new DERGeneralizedTime(privateKeyNotAfter)));
      }
<span class="fc" id="L2713">      certbuilder.addExtension(</span>
          Extension.privateKeyUsagePeriod, false, new DERSequence(v));
    }

    // Subject and Authority key identifier is always non-critical and MUST be
    // present for certificates to verify in Firefox.
    try {
<span class="fc bfc" id="L2720" title="All 2 branches covered.">      if (isCA) {</span>
<span class="fc" id="L2721">        final JcaX509ExtensionUtils extensionUtils =</span>
<span class="fc" id="L2722">            new JcaX509ExtensionUtils(SHA1DigestCalculator.buildSha1Instance());</span>
<span class="fc" id="L2723">        final SubjectKeyIdentifier ski =</span>
<span class="fc" id="L2724">            extensionUtils.createSubjectKeyIdentifier(publicKey);</span>
<span class="fc" id="L2725">        final AuthorityKeyIdentifier aki =</span>
<span class="fc" id="L2726">            extensionUtils.createAuthorityKeyIdentifier(publicKey);</span>
<span class="fc" id="L2727">        certbuilder.addExtension(Extension.subjectKeyIdentifier, false, ski);</span>
<span class="fc" id="L2728">        certbuilder.addExtension(Extension.authorityKeyIdentifier, false, aki);</span>
      }
<span class="nc" id="L2730">    } catch (final IOException e) { // do nothing</span>
<span class="fc" id="L2731">    }</span>

    // CertificatePolicies extension if supplied policy ID, always non-critical
<span class="pc bpc" id="L2734" title="1 of 2 branches missed.">    if (policyId != null) {</span>
<span class="nc" id="L2735">      final PolicyInformation pi =</span>
          new PolicyInformation(new ASN1ObjectIdentifier(policyId));
<span class="nc" id="L2737">      final DERSequence seq = new DERSequence(pi);</span>
<span class="nc" id="L2738">      certbuilder.addExtension(Extension.certificatePolicies, false, seq);</span>
    }
    // Add any additional
<span class="fc bfc" id="L2741" title="All 2 branches covered.">    if (additionalExtensions != null) {</span>
<span class="fc bfc" id="L2742" title="All 2 branches covered.">      for (final Extension extension : additionalExtensions) {</span>
<span class="fc" id="L2743">        certbuilder.addExtension(</span>
<span class="fc" id="L2744">            extension.getExtnId(),</span>
<span class="fc" id="L2745">            extension.isCritical(),</span>
<span class="fc" id="L2746">            extension.getParsedValue());</span>
<span class="fc" id="L2747">      }</span>
    }
<span class="fc" id="L2749">    final ContentSigner signer =</span>
        new BufferingContentSigner(
            new JcaContentSignerBuilder(sigAlg)
<span class="fc" id="L2752">                .setProvider(provider)</span>
<span class="fc" id="L2753">                .build(privKey),</span>
            20480);
<span class="fc" id="L2755">    final X509CertificateHolder certHolder = certbuilder.build(signer);</span>
    X509Certificate selfcert;
    try {
<span class="fc" id="L2758">      selfcert =</span>
          (X509Certificate)
<span class="fc" id="L2760">              CertTools.getCertfromByteArray(certHolder.getEncoded());</span>
<span class="nc" id="L2761">    } catch (final IOException e) {</span>
<span class="nc" id="L2762">      throw new IllegalStateException(&quot;Unexpected IOException was caught.&quot;, e);</span>
<span class="fc" id="L2763">    }</span>

<span class="fc" id="L2765">    return selfcert;</span>
  } // genselfCertForPurpose

  /**
   * Get the authority key identifier from a certificate extensions.
   *
   * @param certificate certificate containing the extension
   * @return byte[] containing the authority key identifier, or null if it does
   *     not exist
   */
  public static byte[] getAuthorityKeyId(final Certificate certificate) {
<span class="pc bpc" id="L2776" title="2 of 4 branches missed.">    if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2777">      final ASN1Primitive asn1Sequence =</span>
<span class="fc" id="L2778">          getExtensionValue(</span>
              (X509Certificate) certificate,
<span class="fc" id="L2780">              Extension.authorityKeyIdentifier.getId()); // &quot;2.5.29.35&quot;</span>
<span class="pc bpc" id="L2781" title="1 of 2 branches missed.">      if (asn1Sequence != null) {</span>
<span class="fc" id="L2782">        return AuthorityKeyIdentifier.getInstance(asn1Sequence)</span>
<span class="fc" id="L2783">            .getKeyIdentifier();</span>
      }
    }
<span class="nc" id="L2786">    return null;</span>
  }

  /**
   * Get the subject key identifier from a certificate extensions.
   *
   * @param certificate certificate containing the extension
   * @return byte[] containing the subject key identifier, or null if it does
   *     not exist
   */
  public static byte[] getSubjectKeyId(final Certificate certificate) {
<span class="pc bpc" id="L2797" title="2 of 4 branches missed.">    if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2798">      final ASN1Primitive asn1Sequence =</span>
<span class="fc" id="L2799">          getExtensionValue(</span>
              (X509Certificate) certificate,
<span class="fc" id="L2801">              Extension.subjectKeyIdentifier.getId()); // &quot;2.5.29.14&quot;</span>
<span class="pc bpc" id="L2802" title="1 of 2 branches missed.">      if (asn1Sequence != null) {</span>
<span class="fc" id="L2803">        return SubjectKeyIdentifier.getInstance(asn1Sequence)</span>
<span class="fc" id="L2804">            .getKeyIdentifier();</span>
      }
    }
<span class="nc" id="L2807">    return null;</span>
  }

  /**
   * Get a certificate policy ID from a certificate policies extension.
   *
   * @param certificate certificate containing the extension
   * @param pos position of the policy id, if several exist, the first is as pos
   *     0
   * @return String with the certificate policy OID, or null if an id at the
   *     given position does not exist
   * @throws IOException if extension can not be parsed
   */
  public static String getCertificatePolicyId(
          final Certificate certificate, final int pos)
      throws IOException {
<span class="pc bpc" id="L2823" title="2 of 4 branches missed.">    if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2824">      final ASN1Sequence asn1Sequence =</span>
          (ASN1Sequence)
<span class="fc" id="L2826">              getExtensionValue(</span>
                  (X509Certificate) certificate,
<span class="fc" id="L2828">                  Extension.certificatePolicies.getId());</span>
<span class="pc bpc" id="L2829" title="1 of 2 branches missed.">      if (asn1Sequence != null) {</span>
        // Check the size so we don't ArrayIndexOutOfBounds
<span class="fc bfc" id="L2831" title="All 2 branches covered.">        if (asn1Sequence.size() &gt;= pos + 1) {</span>
<span class="fc" id="L2832">          return PolicyInformation.getInstance(asn1Sequence.getObjectAt(pos))</span>
<span class="fc" id="L2833">              .getPolicyIdentifier()</span>
<span class="fc" id="L2834">              .getId();</span>
        }
      }
    }
<span class="fc" id="L2838">    return null;</span>
  }

  /**
   * Get a list of certificate policy IDs from a certificate policies extension.
   *
   * @param certificate certificate containing the extension
   * @return List of ObjectIdentifiers, or empty list if no policies exist
   * @throws IOException if extension can not be parsed
   */
  public static List&lt;ASN1ObjectIdentifier&gt; getCertificatePolicyIds(
      final Certificate certificate) throws IOException {
<span class="fc" id="L2850">    final List&lt;ASN1ObjectIdentifier&gt; ret =</span>
            new ArrayList&lt;ASN1ObjectIdentifier&gt;();
<span class="pc bpc" id="L2852" title="2 of 4 branches missed.">    if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2853">      final ASN1Sequence asn1Sequence =</span>
          (ASN1Sequence)
<span class="fc" id="L2855">              getExtensionValue(</span>
                  (X509Certificate) certificate,
<span class="fc" id="L2857">                  Extension.certificatePolicies.getId());</span>
<span class="fc bfc" id="L2858" title="All 2 branches covered.">      if (asn1Sequence != null) {</span>
<span class="fc bfc" id="L2859" title="All 2 branches covered.">        for (final ASN1Encodable asn1Encodable : asn1Sequence) {</span>
<span class="fc" id="L2860">          final PolicyInformation pi =</span>
<span class="fc" id="L2861">                  PolicyInformation.getInstance(asn1Encodable);</span>
<span class="fc" id="L2862">          ret.add(pi.getPolicyIdentifier());</span>
<span class="fc" id="L2863">        }</span>
      }
    }
<span class="fc" id="L2866">    return ret;</span>
  }

  /**
   * Get a list of certificate policy information from a certificate policies
   * extension.
   *
   * @param certificate certificate containing the extension
   * @return List of PolicyInformation, or empty list if no policies exist
   * @throws IOException if extension can not be parsed
   */
  public static List&lt;PolicyInformation&gt; getCertificatePolicies(
      final Certificate certificate) throws IOException {
<span class="fc" id="L2879">    final List&lt;PolicyInformation&gt; ret = new ArrayList&lt;PolicyInformation&gt;();</span>
<span class="pc bpc" id="L2880" title="2 of 4 branches missed.">    if (certificate != null &amp;&amp; certificate instanceof X509Certificate) {</span>
<span class="fc" id="L2881">      final ASN1Sequence asn1Sequence =</span>
          (ASN1Sequence)
<span class="fc" id="L2883">              getExtensionValue(</span>
                  (X509Certificate) certificate,
<span class="fc" id="L2885">                  Extension.certificatePolicies.getId());</span>
<span class="pc bpc" id="L2886" title="1 of 2 branches missed.">      if (asn1Sequence != null) {</span>
<span class="fc bfc" id="L2887" title="All 2 branches covered.">        for (final ASN1Encodable asn1Encodable : asn1Sequence) {</span>
<span class="fc" id="L2888">          final PolicyInformation pi =</span>
<span class="fc" id="L2889">                  PolicyInformation.getInstance(asn1Encodable);</span>
<span class="fc" id="L2890">          ret.add(pi);</span>
<span class="fc" id="L2891">        }</span>
      }
    }
<span class="fc" id="L2894">    return ret;</span>
  }

  /**
   * Gets the Microsoft specific UPN altName (altName, OtherName).
   *
   * &lt;p&gt;UPN is an OtherName Subject Alternative Name:
   *
   * &lt;p&gt;OtherName ::= SEQUENCE { type-id OBJECT IDENTIFIER, value [0] EXPLICIT
   * ANY DEFINED BY type-id }
   *
   * &lt;p&gt;UPN ::= UTF8String
   *
   * @param cert certificate containing the extension
   * @return String with the UPN name or null if the altName does not exist
   * @throws IOException On disk error
   * @throws CertificateParsingException if cert parse fails
   */
  public static String getUPNAltName(final Certificate cert)
      throws IOException, CertificateParsingException {
<span class="fc" id="L2914">    return getUTF8AltNameOtherName(cert, CertTools.UPN_OBJECTID);</span>
  }

  /**
   * Gets a UTF8 OtherName altName (altName, OtherName).
   *
   * &lt;p&gt;Like UPN and XmpAddr
   *
   * &lt;p&gt;An OtherName Subject Alternative Name:
   *
   * &lt;p&gt;OtherName ::= SEQUENCE { type-id OBJECT IDENTIFIER, value [0] EXPLICIT
   * ANY DEFINED BY type-id }
   *
   * &lt;p&gt;UPN ::= UTF8String
   * (subjectAltName=otherName:1.3.6.1.4.1.311.20.2.3;UTF8:username@some.domain)
   * XmppAddr ::= UTF8String
   * (subjectAltName=otherName:1.3.6.1.5.5.7.8.5;UTF8:username@some.domain)
   *
   * &lt;p&gt;CertTools.UPN_OBJECTID = &quot;1.3.6.1.4.1.311.20.2.3&quot;;
   * CertTools.XMPPADDR_OBJECTID = &quot;1.3.6.1.5.5.7.8.5&quot;;
   * CertTools.SRVNAME_OBJECTID = &quot;1.3.6.1.5.5.7.8.7&quot;;
   *
   * @param cert certificate containing the extension
   * @param oid the OID of the OtherName
   * @return String with the UTF8 name or null if the altName does not exist
   * @throws IOException On disk error
   * @throws CertificateParsingException if cert parse fails
   */
  public static String getUTF8AltNameOtherName(
      final Certificate cert, final String oid)
      throws IOException, CertificateParsingException {
<span class="fc" id="L2945">    String ret = null;</span>
<span class="pc bpc" id="L2946" title="1 of 2 branches missed.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L2947">      final X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L2948">      final Collection&lt;List&lt;?&gt;&gt; altNames =</span>
<span class="fc" id="L2949">              x509cert.getSubjectAlternativeNames();</span>
<span class="pc bpc" id="L2950" title="1 of 2 branches missed.">      if (altNames != null) {</span>
<span class="pc bpc" id="L2951" title="1 of 2 branches missed.">        for (final List&lt;?&gt; next : altNames) {</span>
<span class="fc" id="L2952">          ret = getUTF8StringFromSequence(getAltnameSequence(next), oid);</span>
<span class="fc bfc" id="L2953" title="All 2 branches covered.">          if (ret != null) {</span>
<span class="fc" id="L2954">            break;</span>
          }
<span class="fc" id="L2956">        }</span>
      }
    }
<span class="fc" id="L2959">    return ret;</span>
  }

  /**
   * Helper method for the above method.
   *
   * @param seq the OtherName sequence
   * @param oid OID
   * @return String which is the decoded ASN.1 UTF8 String of the (simple)
   *     OtherName
   */
  private static String getUTF8StringFromSequence(
      final ASN1Sequence seq, final String oid) {
<span class="fc bfc" id="L2972" title="All 2 branches covered.">    if (seq != null) {</span>
      // First in sequence is the object identifier, that we must check
<span class="fc" id="L2974">      final ASN1ObjectIdentifier id =</span>
<span class="fc" id="L2975">          ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L2976" title="1 of 2 branches missed.">      if (id.getId().equals(oid)) {</span>
<span class="fc" id="L2977">        final ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
        // Due to bug in java cert.getSubjectAltName regarding OtherName, it can
        // be tagged an extra time...
<span class="fc" id="L2980">        ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L2981" title="1 of 2 branches missed.">        if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L2982">          obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
        }
<span class="fc" id="L2984">        final DERUTF8String str = DERUTF8String.getInstance(obj);</span>
<span class="fc" id="L2985">        return str.getString();</span>
      }
    }
<span class="fc" id="L2988">    return null;</span>
  }

  /**
   * Helper method.
   *
   * @param seq the OtherName sequence
   * @param oid OID
   * @return String which is the decoded ASN.1 IA5String of the (simple)
   *     OtherName
   */
  private static String getIA5StringFromSequence(
      final ASN1Sequence seq, final String oid) {
<span class="pc bpc" id="L3001" title="1 of 2 branches missed.">    if (seq != null) {</span>
      // First in sequence is the object identifier, that we must check
<span class="fc" id="L3003">      final ASN1ObjectIdentifier id =</span>
<span class="fc" id="L3004">          ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L3005" title="1 of 2 branches missed.">      if (id.getId().equals(oid)) {</span>
<span class="fc" id="L3006">        final ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
        // Due to bug in java cert.getSubjectAltName regarding OtherName, it can
        // be tagged an extra time...
<span class="fc" id="L3009">        ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L3010" title="1 of 2 branches missed.">        if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L3011">          obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
        }
<span class="fc" id="L3013">        final DERIA5String str = DERIA5String.getInstance(obj);</span>
<span class="fc" id="L3014">        return str.getString();</span>
      }
    }
<span class="nc" id="L3017">    return null;</span>
  }

  /**
   * Helper method.
   *
   * @param seq the OtherName sequence
   * @param oid OID
   * @return bytes which is the decoded ASN.1 Octet String of the (simple)
   *     OtherName
   */
  private static byte[] getOctetStringFromSequence(
      final ASN1Sequence seq, final String oid) {
<span class="pc bpc" id="L3030" title="1 of 2 branches missed.">    if (seq != null) {</span>
      // First in sequence is the object identifier, that we must check
<span class="fc" id="L3032">      final ASN1ObjectIdentifier id =</span>
<span class="fc" id="L3033">          ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L3034" title="1 of 2 branches missed.">      if (id.getId().equals(oid)) {</span>
<span class="fc" id="L3035">        final ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
        // Due to bug in java cert.getSubjectAltName regarding OtherName, it can
        // be tagged an extra time...
<span class="fc" id="L3038">        ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L3039" title="1 of 2 branches missed.">        if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L3040">          obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
        }
<span class="fc" id="L3042">        final ASN1OctetString str = ASN1OctetString.getInstance(obj);</span>
<span class="fc" id="L3043">        return str.getOctets();</span>
      }
    }
<span class="nc" id="L3046">    return null;</span>
  }

  /**
   * Gets the Permanent Identifier (altName, OtherName).
   *
   * &lt;p&gt;permanentIdentifier is an OtherName Subject Alternative Name:
   *
   * &lt;p&gt;OtherName ::= SEQUENCE { type-id OBJECT IDENTIFIER, value [0] EXPLICIT
   * ANY DEFINED BY type-id }
   *
   * &lt;p&gt;-- Permanent Identifier
   *
   * &lt;p&gt;permanentIdentifier OTHER-NAME ::= { PermanentIdentifier IDENTIFIED BY
   * id-on-permanentIdentifier }
   *
   * &lt;p&gt;PermanentIdentifier ::= SEQUENCE { identifierValue UTF8String OPTIONAL,
   * -- if absent, use the serialNumber attribute -- if there is a single such
   * attribute present -- in the subject DN assigner OBJECT IDENTIFIER OPTIONAL
   * -- if absent, the assigner is -- the certificate issuer }
   *
   * @param cert certificate containing the extension
   * @return String with the permanentIdentifier name or null if the altName
   *     does not exist
   * @throws IOException On disk error
   * @throws CertificateParsingException if cert parse fails
   */
  public static String getPermanentIdentifierAltName(final Certificate cert)
      throws IOException, CertificateParsingException {
<span class="fc" id="L3075">    String ret = null;</span>
<span class="pc bpc" id="L3076" title="1 of 2 branches missed.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L3077">      final X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L3078">      final Collection&lt;List&lt;?&gt;&gt; altNames =</span>
<span class="fc" id="L3079">              x509cert.getSubjectAlternativeNames();</span>
<span class="pc bpc" id="L3080" title="1 of 2 branches missed.">      if (altNames != null) {</span>
<span class="fc" id="L3081">        final Iterator&lt;List&lt;?&gt;&gt; i = altNames.iterator();</span>
<span class="pc bpc" id="L3082" title="1 of 2 branches missed.">        while (i.hasNext()) {</span>
<span class="fc" id="L3083">          final ASN1Sequence seq = getAltnameSequence(i.next());</span>
<span class="fc" id="L3084">          ret = getPermanentIdentifierStringFromSequence(seq);</span>
<span class="fc bfc" id="L3085" title="All 2 branches covered.">          if (ret != null) {</span>
<span class="fc" id="L3086">            break;</span>
          }
<span class="fc" id="L3088">        }</span>
      }
    }
<span class="fc" id="L3091">    return ret;</span>
  } // getPermanentIdentifierAltName

  /**
   * (This method intentionally has package level visibility to be able to be
   * invoked from JUnit tests).
   *
   * @param seq asn.1 sequence
   * @return The extension values encoded as an permanentIdentifierString
   */
  static String getPermanentIdentifierStringFromSequence(
          final ASN1Sequence seq) {
<span class="pc bpc" id="L3103" title="1 of 2 branches missed.">    if (seq != null) {</span>
      // First in sequence is the object identifier, that we must check
<span class="fc" id="L3105">      final ASN1ObjectIdentifier id =</span>
<span class="fc" id="L3106">          ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="fc bfc" id="L3107" title="All 2 branches covered.">      if (id.getId().equals(CertTools.PERMANENTIDENTIFIER_OBJECTID)) {</span>
<span class="fc" id="L3108">        String identifierValue = null;</span>
<span class="fc" id="L3109">        String assigner = null;</span>

        // Get the PermanentIdentifier sequence
<span class="fc" id="L3112">        final ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
        // Due to bug in java cert.getSubjectAltName regarding OtherName, it can
        // be tagged an extra time...
<span class="fc" id="L3115">        ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L3116" title="1 of 2 branches missed.">        if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L3117">          obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
        }
<span class="fc" id="L3119">        final ASN1Sequence piSeq = ASN1Sequence.getInstance(obj);</span>

<span class="fc" id="L3121">        final Enumeration&lt;?&gt; e = piSeq.getObjects();</span>
<span class="fc bfc" id="L3122" title="All 2 branches covered.">        if (e.hasMoreElements()) {</span>
<span class="fc" id="L3123">          Object element = e.nextElement();</span>
<span class="fc bfc" id="L3124" title="All 2 branches covered.">          if (element instanceof DERUTF8String) {</span>
<span class="fc" id="L3125">            identifierValue = ((DERUTF8String) element).getString();</span>
<span class="fc bfc" id="L3126" title="All 2 branches covered.">            if (e.hasMoreElements()) {</span>
<span class="fc" id="L3127">              element = e.nextElement();</span>
            }
          }
<span class="fc bfc" id="L3130" title="All 2 branches covered.">          if (element instanceof ASN1ObjectIdentifier) {</span>
<span class="fc" id="L3131">            assigner = ((ASN1ObjectIdentifier) element).getId();</span>
          }
        }

<span class="fc" id="L3135">        final StringBuilder buff = new StringBuilder();</span>
<span class="fc bfc" id="L3136" title="All 2 branches covered.">        if (identifierValue != null) {</span>
<span class="fc" id="L3137">          buff.append(escapePermanentIdentifierValue(identifierValue));</span>
        }
<span class="fc" id="L3139">        buff.append(PERMANENTIDENTIFIER_SEP);</span>
<span class="fc bfc" id="L3140" title="All 2 branches covered.">        if (assigner != null) {</span>
<span class="fc" id="L3141">          buff.append(assigner);</span>
        }
<span class="fc" id="L3143">        return buff.toString();</span>
      }
    }
<span class="fc" id="L3146">    return null;</span>
  }

  private static String escapePermanentIdentifierValue(final String realValue) {
<span class="fc" id="L3150">    return realValue.replace(</span>
        PERMANENTIDENTIFIER_SEP, &quot;\\&quot; + PERMANENTIDENTIFIER_SEP);
  }

  private static String unescapePermanentIdentifierValue(
          final String escapedValue) {
<span class="fc" id="L3156">    return escapedValue.replace(</span>
        &quot;\\&quot; + PERMANENTIDENTIFIER, PERMANENTIDENTIFIER);
  }

  /**
   * (This method intentionally has package level visibility to be able to be
   * invoked from JUnit tests).
   *
   * @param permanentIdentifierString filter
   * @return A two elements String array with the extension values
   */
  static String[] getPermanentIdentifierValues(
      final String permanentIdentifierString) {
<span class="fc" id="L3169">    final String[] result = new String[2];</span>
<span class="fc" id="L3170">    final int sepPos = permanentIdentifierString</span>
<span class="fc" id="L3171">            .lastIndexOf(PERMANENTIDENTIFIER_SEP);</span>
<span class="fc bfc" id="L3172" title="All 2 branches covered.">    if (sepPos == -1) {</span>
<span class="fc bfc" id="L3173" title="All 2 branches covered.">      if (!permanentIdentifierString.isEmpty()) {</span>
<span class="fc" id="L3174">        result[0] = unescapePermanentIdentifierValue(permanentIdentifierString);</span>
      }
<span class="fc bfc" id="L3176" title="All 2 branches covered.">    } else if (sepPos == 0) {</span>
<span class="fc bfc" id="L3177" title="All 2 branches covered.">      if (permanentIdentifierString.length() &gt; 1) {</span>
<span class="fc" id="L3178">        result[1] = permanentIdentifierString.substring(1);</span>
      }
<span class="pc bpc" id="L3180" title="1 of 2 branches missed.">    } else if (permanentIdentifierString.charAt(</span>
<span class="fc" id="L3181">            sepPos - PERMANENTIDENTIFIER_SEP.length())</span>
        != '\\') {
<span class="fc" id="L3183">      result[0] =</span>
<span class="fc" id="L3184">          unescapePermanentIdentifierValue(</span>
<span class="fc" id="L3185">              permanentIdentifierString.substring(0, sepPos));</span>
<span class="fc" id="L3186">      if (permanentIdentifierString.length()</span>
<span class="fc bfc" id="L3187" title="All 2 branches covered.">          &gt; sepPos + PERMANENTIDENTIFIER_SEP.length()) {</span>
<span class="fc" id="L3188">        result[1] = permanentIdentifierString.substring(sepPos + 1);</span>
      }
    }
<span class="fc" id="L3191">    return result;</span>
  }

  /**
   * Helper method to get MS GUID from GeneralName otherName sequence.
   *
   * @param seq the OtherName sequence
   * @return GUID
   */
  private static String getGUIDStringFromSequence(final ASN1Sequence seq) {
<span class="fc" id="L3201">    String ret = null;</span>
<span class="pc bpc" id="L3202" title="1 of 2 branches missed.">    if (seq != null) {</span>
      // First in sequence is the object identifier, that we must check
<span class="fc" id="L3204">      final ASN1ObjectIdentifier id =</span>
<span class="fc" id="L3205">          ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="fc bfc" id="L3206" title="All 2 branches covered.">      if (id.getId().equals(CertTools.GUID_OBJECTID)) {</span>
<span class="fc" id="L3207">        final ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
        // Due to bug in java cert.getSubjectAltName regarding OtherName, it can
        // be tagged an extra time...
<span class="fc" id="L3210">        ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L3211" title="1 of 2 branches missed.">        if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L3212">          obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
        }
<span class="fc" id="L3214">        final ASN1OctetString str = ASN1OctetString.getInstance(obj);</span>
<span class="fc" id="L3215">        ret = new String(Hex.encode(str.getOctets()));</span>
      }
    }
<span class="fc" id="L3218">    return ret;</span>
  }

  /**
   * Helper method for getting kerberos 5 principal name (altName, OtherName)
   *
   * &lt;p&gt;Krb5PrincipalName is an OtherName Subject Alternative Name
   *
   * &lt;p&gt;String representation is in form &quot;principalname1/principalname2@realm&quot;
   *
   * &lt;p&gt;KRB5PrincipalName ::= SEQUENCE { realm [0] Realm, principalName [1]
   * PrincipalName }
   *
   * &lt;p&gt;Realm ::= KerberosString
   *
   * &lt;p&gt;PrincipalName ::= SEQUENCE { name-type [0] Int32, name-string [1]
   * SEQUENCE OF KerberosString }
   *
   * &lt;p&gt;The new (post-RFC 1510) type KerberosString, defined below, is a
   * GeneralString that is constrained to contain only characters in IA5String.
   *
   * &lt;p&gt;KerberosString ::= GeneralString (IA5String)
   *
   * &lt;p&gt;Int32 ::= INTEGER (-2147483648..2147483647) -- signed values
   * representable in 32 bits
   *
   * @param seq the OtherName sequence
   * @return String with the krb5 name in the form of
   *     &quot;principal1/principal2@realm&quot; or null if the altName does not exist
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  protected static String getKrb5PrincipalNameFromSequence(
          final ASN1Sequence seq) {
<span class="fc" id="L3251">    String ret = null;</span>
<span class="pc bpc" id="L3252" title="1 of 2 branches missed.">    if (seq != null) {</span>
      // First in sequence is the object identifier, that we must check
<span class="fc" id="L3254">      final ASN1ObjectIdentifier id =</span>
<span class="fc" id="L3255">          ASN1ObjectIdentifier.getInstance(seq.getObjectAt(0));</span>
<span class="pc bpc" id="L3256" title="1 of 2 branches missed.">      if (id.getId().equals(CertTools.KRB5PRINCIPAL_OBJECTID)) {</span>
        // Get the KRB5PrincipalName sequence
<span class="fc" id="L3258">        final ASN1TaggedObject oobj = (ASN1TaggedObject) seq.getObjectAt(1);</span>
        // Due to bug in java cert.getSubjectAltName regarding OtherName, it can
        // be tagged an extra time...
<span class="fc" id="L3261">        ASN1Primitive obj = oobj.getObject();</span>
<span class="pc bpc" id="L3262" title="1 of 2 branches missed.">        if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L3263">          obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
        }
<span class="fc" id="L3265">        final ASN1Sequence krb5Seq = ASN1Sequence.getInstance(obj);</span>
        // Get the Realm tagged as 0
<span class="fc" id="L3267">        final ASN1TaggedObject robj = (ASN1TaggedObject) krb5Seq.getObjectAt(0);</span>
<span class="fc" id="L3268">        final DERGeneralString realmObj =</span>
<span class="fc" id="L3269">            DERGeneralString.getInstance(robj.getObject());</span>
<span class="fc" id="L3270">        final String realm = realmObj.getString();</span>
        // Get the PrincipalName tagged as 1
<span class="fc" id="L3272">        final ASN1TaggedObject pobj = (ASN1TaggedObject) krb5Seq.getObjectAt(1);</span>
        // This is another sequence of type and name
<span class="fc" id="L3274">        final ASN1Sequence nseq = ASN1Sequence.getInstance(pobj.getObject());</span>
        // Get the name tagged as 1
<span class="fc" id="L3276">        final ASN1TaggedObject nobj = (ASN1TaggedObject) nseq.getObjectAt(1);</span>
        // The name is yet another sequence of GeneralString
<span class="fc" id="L3278">        final ASN1Sequence sseq = ASN1Sequence.getInstance(nobj.getObject());</span>
<span class="fc" id="L3279">        final Enumeration&lt;ASN1Object&gt; en = sseq.getObjects();</span>
<span class="fc bfc" id="L3280" title="All 2 branches covered.">        while (en.hasMoreElements()) {</span>
<span class="fc" id="L3281">          final ASN1Primitive o = (ASN1Primitive) en.nextElement();</span>
<span class="fc" id="L3282">          final DERGeneralString str = DERGeneralString.getInstance(o);</span>
<span class="fc bfc" id="L3283" title="All 2 branches covered.">          if (ret != null) {</span>
<span class="fc" id="L3284">            ret += &quot;/&quot; + str.getString();</span>
          } else {
<span class="fc" id="L3286">            ret = str.getString();</span>
          }
<span class="fc" id="L3288">        }</span>
        // Add the realm in the end so we have &quot;principal@realm&quot;
<span class="fc" id="L3290">        ret += &quot;@&quot; + realm;</span>
      }
    }
<span class="fc" id="L3293">    return ret;</span>
  }

  /**
   * Gets the Microsoft specific GUID altName, that is encoded as an octect
   * string.
   *
   * @param cert certificate containing the extension
   * @return String with the hex-encoded GUID byte array or null if the altName
   *     does not exist
   * @throws IOException On disk error
   * @throws CertificateParsingException if cert parse fails
   */
  public static String getGuidAltName(final Certificate cert)
      throws IOException, CertificateParsingException {
<span class="pc bpc" id="L3308" title="1 of 2 branches missed.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L3309">      final X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L3310">      final Collection&lt;List&lt;?&gt;&gt; altNames</span>
<span class="fc" id="L3311">          = x509cert.getSubjectAlternativeNames();</span>
<span class="pc bpc" id="L3312" title="1 of 2 branches missed.">      if (altNames != null) {</span>
<span class="fc" id="L3313">        final Iterator&lt;List&lt;?&gt;&gt; i = altNames.iterator();</span>
<span class="pc bpc" id="L3314" title="1 of 2 branches missed.">        while (i.hasNext()) {</span>
<span class="fc" id="L3315">          final ASN1Sequence seq = getAltnameSequence(i.next());</span>
<span class="fc bfc" id="L3316" title="All 2 branches covered.">          if (seq != null) {</span>
<span class="fc" id="L3317">            final String guid = CertTools.getGUIDStringFromSequence(seq);</span>
<span class="fc bfc" id="L3318" title="All 2 branches covered.">            if (guid != null) {</span>
<span class="fc" id="L3319">              return guid;</span>
            }
          }
<span class="fc" id="L3322">        }</span>
      }
    }
<span class="nc" id="L3325">    return null;</span>
  } // getGuidAltName

  /**
   * Helper for the above methods.
   *
   * @param listitem item
   * @return asn.1
   */
  private static ASN1Sequence getAltnameSequence(final List&lt;?&gt; listitem) {
<span class="fc" id="L3335">    final Integer no = (Integer) listitem.get(0);</span>
<span class="fc bfc" id="L3336" title="All 2 branches covered.">    if (no.intValue() == 0) {</span>
<span class="fc" id="L3337">      final byte[] altName = (byte[]) listitem.get(1);</span>
<span class="fc" id="L3338">      return getAltnameSequence(altName);</span>
    }
<span class="fc" id="L3340">    return null;</span>
  }

  private static ASN1Sequence getAltnameSequence(final byte[] value) {
<span class="fc" id="L3344">    ASN1Primitive oct = null;</span>
    try {
<span class="fc" id="L3346">      oct = ASN1Primitive.fromByteArray(value);</span>
<span class="nc" id="L3347">    } catch (final IOException e) {</span>
<span class="nc" id="L3348">      throw new RuntimeException(&quot;Could not read ASN1InputStream&quot;, e);</span>
<span class="fc" id="L3349">    }</span>
<span class="fc bfc" id="L3350" title="All 2 branches covered.">    if (oct instanceof ASN1TaggedObject) {</span>
<span class="fc" id="L3351">      oct = ((ASN1TaggedObject) oct).getObject();</span>
    }
<span class="fc" id="L3353">    final ASN1Sequence seq = ASN1Sequence.getInstance(oct);</span>
<span class="fc" id="L3354">    return seq;</span>
  }

  /**
   * Gets an altName string from an X509Extension.
   *
   * @param ext X509Extension with AlternativeNames
   * @return String as defined in method getSubjectAlternativeName
   */
  public static String getAltNameStringFromExtension(final Extension ext) {
<span class="fc" id="L3364">    String altName = null;</span>
    // GeneralNames, the actual encoded name
<span class="fc" id="L3366">    final GeneralNames names = getGeneralNamesFromExtension(ext);</span>
<span class="pc bpc" id="L3367" title="1 of 2 branches missed.">    if (names != null) {</span>
      try {
<span class="fc" id="L3369">        final GeneralName[] gns = names.getNames();</span>
<span class="fc bfc" id="L3370" title="All 2 branches covered.">        for (final GeneralName gn : gns) {</span>
<span class="fc" id="L3371">          final int tag = gn.getTagNo();</span>
<span class="fc" id="L3372">          final ASN1Encodable name = gn.getName();</span>
<span class="fc" id="L3373">          final String str = CertTools.getGeneralNameString(tag, name);</span>
<span class="pc bpc" id="L3374" title="1 of 2 branches missed.">          if (str == null) {</span>
<span class="nc" id="L3375">            continue;</span>
          }
<span class="fc bfc" id="L3377" title="All 2 branches covered.">          if (altName == null) {</span>
<span class="fc" id="L3378">            altName = escapeFieldValue(str);</span>
          } else {
<span class="fc" id="L3380">            altName += &quot;, &quot; + escapeFieldValue(str);</span>
          }
        }
<span class="nc" id="L3383">      } catch (final IOException e) {</span>
<span class="nc" id="L3384">        LOGGER.error(&quot;IOException parsing altNames: &quot;, e);</span>
<span class="nc" id="L3385">        return null;</span>
<span class="fc" id="L3386">      }</span>
    }
<span class="fc" id="L3388">    return altName;</span>
  }

  /**
   * Gets GeneralNames from an X509Extension.
   *
   * @param ext X509Extension with AlternativeNames
   * @return GeneralNames with all Alternative Names
   */
  public static GeneralNames getGeneralNamesFromExtension(final Extension ext) {
<span class="fc" id="L3398">    final ASN1Encodable gnames = ext.getParsedValue();</span>
<span class="pc bpc" id="L3399" title="1 of 2 branches missed.">    if (gnames != null) {</span>
<span class="fc" id="L3400">      final GeneralNames names = GeneralNames.getInstance(gnames);</span>
<span class="fc" id="L3401">      return names;</span>
    }
<span class="nc" id="L3403">    return null;</span>
  }

  /**
   * Escapes a value of a field in a DN, SAN or directory attributes. Unlike
   * LDAPDN.escapeRDN, this method allows empty values (e.g. DNSNAME=)
   *
   * @param value Value to escape, with or without the XX=
   * @return Escaped string
   */
  protected static String escapeFieldValue(final String value) {
<span class="fc bfc" id="L3414" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L3415">      return null;</span>
<span class="fc bfc" id="L3416" title="All 2 branches covered.">    } else if (value.indexOf('=') == value.length() - 1) {</span>
<span class="fc" id="L3417">      return value;</span>
    } else {
<span class="fc" id="L3419">      return LDAPDN.escapeRDN(value);</span>
    }
  }

  /**
   * Unescapes a value of a field in a DN, SAN or directory attributes. Unlike
   * LDAPDN.unescapeRDN, this method handles value without the field name (e.g.
   * example.com) and empty values (e.g. DNSNAME=)
   *
   * @param value Value to unescape
   * @return Unescaped string
   */
  protected static String unescapeFieldValue(final String value) {
<span class="fc bfc" id="L3432" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L3433">      return null;</span>
    } else {
<span class="fc" id="L3435">      return UNESCAPE_FIELD_REGEX.matcher(value).replaceAll(&quot;$1&quot;);</span>
    }
  }

  /**
   * SubjectAltName ::= GeneralNames.
   *
   * &lt;p&gt;GeneralNames :: = SEQUENCE SIZE (1..MAX) OF GeneralName
   *
   * &lt;p&gt;GeneralName ::= CHOICE { otherName [0] OtherName, rfc822Name [1]
   * IA5String, dNSName [2] IA5String, x400Address [3] ORAddress, directoryName
   * [4] Name, ediPartyName [5] EDIPartyName, uniformResourceIdentifier [6]
   * IA5String, iPAddress [7] OCTET STRING, registeredID [8] OBJECT IDENTIFIER}
   *
   * &lt;p&gt;SubjectAltName is of form \&quot;rfc822Name=&amp;lt;email&amp;gt;, dNSName=&amp;lt;host
   * name&amp;gt;, uniformResourceIdentifier=&amp;lt;http://host.com/&amp;gt;,
   * iPAddress=&amp;lt;address&amp;gt;, guid=&amp;lt;globally unique id&amp;gt;,
   * directoryName=&amp;lt;CN=testDirName|dir|name&amp;gt;,
   * permanentIdentifier=&amp;lt;identifierValue/assigner|identifierValue|/assigner|/&amp;gt;
   *
   * &lt;p&gt;Supported altNames are upn, krb5principal, rfc822Name,
   * uniformResourceIdentifier, dNSName, iPAddress, directoryName,
   * permanentIdentifier
   *
   * @author Marco Ferrante, (c) 2005 CSITA - University of Genoa (Italy)
   * @author Tomas Gustavsson
   * @param certificate containing alt names
   * @return String containing altNames of form &quot;rfc822Name=email,
   *     dNSName=hostname, uniformResourceIdentifier=uri, iPAddress=ip, upn=upn,
   *     directoryName=CN=testDirName|dir|name&quot;,
   *     permanentIdentifier=identifierValue/assigner or empty string if no
   *     altNames exist. Values in returned String is from CertTools constants.
   *     AltNames not supported are simply not shown in the resulting string.
   */
  public static String getSubjectAlternativeName(
          final Certificate certificate) {
<span class="pc bpc" id="L3471" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L3472">      LOGGER.trace(&quot;&gt;getSubjectAlternativeName&quot;);</span>
    }
<span class="fc" id="L3474">    String result = &quot;&quot;;</span>
<span class="pc bpc" id="L3475" title="1 of 2 branches missed.">    if (certificate instanceof X509Certificate) {</span>
<span class="fc" id="L3476">      final X509Certificate x509cert = (X509Certificate) certificate;</span>

<span class="fc" id="L3478">      Collection&lt;List&lt;?&gt;&gt; altNames = null;</span>

      try {
<span class="fc" id="L3481">        altNames = x509cert.getSubjectAlternativeNames();</span>
<span class="nc" id="L3482">      } catch (final CertificateParsingException e) {</span>
<span class="nc" id="L3483">        throw new RuntimeException(&quot;Could not parse certificate&quot;, e);</span>
<span class="fc" id="L3484">      }</span>

<span class="pc bpc" id="L3486" title="1 of 2 branches missed.">      if (altNames == null) {</span>
<span class="nc" id="L3487">        return null;</span>
      }
<span class="fc" id="L3489">      final Iterator&lt;List&lt;?&gt;&gt; iter = altNames.iterator();</span>
<span class="fc" id="L3490">      String append = new String();</span>
<span class="fc" id="L3491">      List&lt;?&gt; item = null;</span>
<span class="fc" id="L3492">      Integer type = null;</span>
<span class="fc" id="L3493">      Object value = null;</span>
<span class="fc bfc" id="L3494" title="All 2 branches covered.">      while (iter.hasNext()) {</span>
<span class="fc" id="L3495">        item = iter.next();</span>
<span class="fc" id="L3496">        type = (Integer) item.get(0);</span>
<span class="fc" id="L3497">        value = item.get(1);</span>
<span class="fc bfc" id="L3498" title="All 2 branches covered.">        if (!StringUtils.isEmpty(result)) {</span>
          // Result already contains one altname, so we have to add comma if
          // there are more altNames
<span class="fc" id="L3501">          append = &quot;, &quot;;</span>
        }
<span class="fc" id="L3503">        String rdn = null;</span>
<span class="pc bpc" id="L3504" title="3 of 10 branches missed.">        switch (type.intValue()) {</span>
          case 0:
            // OtherName, can be a lot of different things
<span class="fc" id="L3507">            final ASN1Sequence sequence = getAltnameSequence(item);</span>
<span class="fc" id="L3508">            final ASN1ObjectIdentifier oid =</span>
<span class="fc" id="L3509">                ASN1ObjectIdentifier.getInstance(sequence.getObjectAt(0));</span>
<span class="pc bpc" id="L3510" title="2 of 9 branches missed.">            switch (oid.getId()) {</span>
              case CertTools.UPN_OBJECTID:
<span class="fc" id="L3512">                rdn =</span>
                    CertTools.UPN
                        + &quot;=&quot;
<span class="fc" id="L3515">                        + getUTF8StringFromSequence(</span>
                            sequence, CertTools.UPN_OBJECTID);
<span class="fc" id="L3517">                break;</span>
              case CertTools.PERMANENTIDENTIFIER_OBJECTID:
<span class="fc" id="L3519">                rdn =</span>
                    CertTools.PERMANENTIDENTIFIER
                        + &quot;=&quot;
<span class="fc" id="L3522">                        + getPermanentIdentifierStringFromSequence(sequence);</span>
<span class="fc" id="L3523">                break;</span>
              case CertTools.KRB5PRINCIPAL_OBJECTID:
<span class="fc" id="L3525">                rdn =</span>
                    CertTools.KRB5PRINCIPAL
                        + &quot;=&quot;
<span class="fc" id="L3528">                        + getKrb5PrincipalNameFromSequence(sequence);</span>
<span class="fc" id="L3529">                break;</span>
              case RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD_OBJECTID:
<span class="nc" id="L3531">                final String sim = RFC4683Tools.getSimStringSequence(sequence);</span>
<span class="nc" id="L3532">                rdn = RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD + &quot;=&quot; + sim;</span>
<span class="nc" id="L3533">                break;</span>
              case CertTools.GUID_OBJECTID:
<span class="fc" id="L3535">                rdn =</span>
<span class="fc" id="L3536">                    CertTools.GUID + &quot;=&quot; + getGUIDStringFromSequence(sequence);</span>
<span class="fc" id="L3537">                break;</span>
              case CertTools.XMPPADDR_OBJECTID:
<span class="fc" id="L3539">                rdn =</span>
                    CertTools.XMPPADDR
                        + &quot;=&quot;
<span class="fc" id="L3542">                        + getUTF8StringFromSequence(</span>
                            sequence, CertTools.XMPPADDR_OBJECTID);
<span class="fc" id="L3544">                break;</span>
              case CertTools.SRVNAME_OBJECTID:
<span class="fc" id="L3546">                rdn =</span>
                    CertTools.SRVNAME
                        + &quot;=&quot;
<span class="fc" id="L3549">                        + getIA5StringFromSequence(</span>
                            sequence, CertTools.SRVNAME_OBJECTID);
<span class="fc" id="L3551">                break;</span>
              case CertTools.FASCN_OBJECTID:
                // PIV FASC-N (FIPS 201-2) is an OCTET STRING, we'll return if
                // as a hex encoded String
<span class="fc" id="L3555">                rdn =</span>
                    CertTools.FASCN
                        + &quot;=&quot;
                        + new String(
<span class="fc" id="L3559">                            Hex.encode(</span>
<span class="fc" id="L3560">                                getOctetStringFromSequence(</span>
                                    sequence, CertTools.FASCN_OBJECTID)));
<span class="fc" id="L3562">                break;</span>
                default: break; // no-op
            }

<span class="fc" id="L3566">            break;</span>
          case 1:
<span class="fc" id="L3568">            rdn = CertTools.EMAIL + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L3569">            break;</span>
          case 2:
<span class="fc" id="L3571">            rdn = CertTools.DNS + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L3572">            break;</span>
          case 3: // SubjectAltName of type x400Address not supported
<span class="nc" id="L3574">            break;</span>
          case 4:
<span class="fc" id="L3576">            rdn = CertTools.DIRECTORYNAME + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L3577">            break;</span>
          case 5: // SubjectAltName of type ediPartyName not supported
<span class="nc" id="L3579">            break;</span>
          case 6:
<span class="fc" id="L3581">            rdn = CertTools.URI + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L3582">            break;</span>
          case 7:
<span class="fc" id="L3584">            rdn = CertTools.IPADDR + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L3585">            break;</span>
          case 8:
            // OID names are returned as Strings according to the JDK
            // X509Certificate javadoc
<span class="fc" id="L3589">            rdn = CertTools.REGISTEREDID + &quot;=&quot; + (String) value;</span>
<span class="fc" id="L3590">            break;</span>
          default: // SubjectAltName of unknown type
            break;
        }
<span class="pc bpc" id="L3594" title="1 of 2 branches missed.">        if (rdn != null) {</span>
          // The rdn might contain commas, so escape it.
<span class="fc" id="L3596">          result += append + escapeFieldValue(rdn);</span>
        }
<span class="fc" id="L3598">      }</span>
<span class="pc bpc" id="L3599" title="1 of 2 branches missed.">      if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L3600">        LOGGER.trace(&quot;&lt;getSubjectAlternativeName: &quot; + result);</span>
      }
<span class="pc bpc" id="L3602" title="1 of 2 branches missed.">      if (StringUtils.isEmpty(result)) {</span>
<span class="nc" id="L3603">        return null;</span>
      }
    }
<span class="fc" id="L3606">    return result;</span>
  }

  /**
   * From an altName string as defined in getSubjectAlternativeName.
   *
   * @param altName name
   * @return ASN.1 GeneralNames
   * @see #getSubjectAlternativeName
   */
  public static GeneralNames getGeneralNamesFromAltName(final String altName) {
<span class="pc bpc" id="L3617" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L3618">      LOGGER.trace(&quot;&gt;getGeneralNamesFromAltName: &quot; + altName);</span>
    }
<span class="fc" id="L3620">    final ASN1EncodableVector vec = new ASN1EncodableVector();</span>

<span class="fc bfc" id="L3622" title="All 2 branches covered.">    for (final String email : CertTools.getEmailFromDN(altName)) {</span>
<span class="fc" id="L3623">      vec.add(new GeneralName(1, /*new DERIA5String(iter.next())*/ email));</span>
<span class="fc" id="L3624">    }</span>

<span class="fc bfc" id="L3626" title="All 2 branches covered.">    for (final String dns : CertTools.getPartsFromDN(altName, CertTools.DNS)) {</span>
<span class="fc" id="L3627">      vec.add(new GeneralName(2, new DERIA5String(dns)));</span>
<span class="fc" id="L3628">    }</span>

<span class="fc" id="L3630">    final String directoryName = getDirectoryStringFromAltName(altName);</span>
<span class="fc bfc" id="L3631" title="All 2 branches covered.">    if (directoryName != null) {</span>
<span class="fc" id="L3632">      final X500Name x500DirectoryName =</span>
          new X500Name(CeSecoreNameStyle.INSTANCE, directoryName);
<span class="fc" id="L3634">      final GeneralName gn = new GeneralName(4, x500DirectoryName);</span>
<span class="fc" id="L3635">      vec.add(gn);</span>
    }
<span class="fc" id="L3637">    final int uriTag = 6;</span>
<span class="fc bfc" id="L3638" title="All 2 branches covered.">    for (final String uri : CertTools.getPartsFromDN(altName, CertTools.URI)) {</span>
<span class="fc" id="L3639">      vec.add(new GeneralName(uriTag, new DERIA5String(uri)));</span>
<span class="fc" id="L3640">    }</span>
<span class="fc bfc" id="L3641" title="All 2 branches covered.">    for (final String uri : CertTools.getPartsFromDN(altName, CertTools.URI1)) {</span>
<span class="fc" id="L3642">      vec.add(new GeneralName(uriTag, new DERIA5String(uri)));</span>
<span class="fc" id="L3643">    }</span>
<span class="pc bpc" id="L3644" title="1 of 2 branches missed.">    for (final String uri : CertTools.getPartsFromDN(altName, CertTools.URI2)) {</span>
<span class="nc" id="L3645">      vec.add(new GeneralName(uriTag, new DERIA5String(uri)));</span>
<span class="nc" id="L3646">    }</span>

    for (final String addr
<span class="fc bfc" id="L3649" title="All 2 branches covered.">        : CertTools.getPartsFromDN(altName, CertTools.IPADDR)) {</span>
<span class="fc" id="L3650">      final byte[] ipoctets = StringTools.ipStringToOctets(addr);</span>
<span class="pc bpc" id="L3651" title="1 of 2 branches missed.">      if (ipoctets.length &gt; 0) {</span>
<span class="fc" id="L3652">        final GeneralName gn = new GeneralName(7, new DEROctetString(ipoctets));</span>
<span class="fc" id="L3653">        vec.add(gn);</span>
<span class="fc" id="L3654">      } else {</span>
<span class="nc" id="L3655">        LOGGER.error(&quot;Cannot parse/encode ip address, ignoring: &quot; + addr);</span>
      }
<span class="fc" id="L3657">    }</span>
    for (final String oid
<span class="pc bpc" id="L3659" title="1 of 2 branches missed.">        : CertTools.getPartsFromDN(altName, CertTools.REGISTEREDID)) {</span>
<span class="nc" id="L3660">      vec.add(new GeneralName(GeneralName.registeredID, oid));</span>
<span class="nc" id="L3661">    }</span>

    // UPN is an OtherName see method getUpn... for asn.1 definition
<span class="fc bfc" id="L3664" title="All 2 branches covered.">    for (final String upn : CertTools.getPartsFromDN(altName, CertTools.UPN)) {</span>
<span class="fc" id="L3665">      final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="fc" id="L3666">      v.add(new ASN1ObjectIdentifier(CertTools.UPN_OBJECTID));</span>
<span class="fc" id="L3667">      v.add(new DERTaggedObject(true, 0, new DERUTF8String(upn)));</span>
<span class="fc" id="L3668">      vec.add(</span>
<span class="fc" id="L3669">          GeneralName.getInstance(</span>
              new DERTaggedObject(false, 0, new DERSequence(v))));
<span class="fc" id="L3671">    }</span>

    // XmpAddr is an OtherName see method getUTF8String...... for asn.1
    // definition
    for (final String xmppAddr
<span class="pc bpc" id="L3676" title="1 of 2 branches missed.">        : CertTools.getPartsFromDN(altName, CertTools.XMPPADDR)) {</span>
<span class="nc" id="L3677">      final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L3678">      v.add(new ASN1ObjectIdentifier(CertTools.XMPPADDR_OBJECTID));</span>
<span class="nc" id="L3679">      v.add(new DERTaggedObject(true, 0, new DERUTF8String(xmppAddr)));</span>
<span class="nc" id="L3680">      vec.add(</span>
<span class="nc" id="L3681">          GeneralName.getInstance(</span>
              new DERTaggedObject(false, 0, new DERSequence(v))));
<span class="nc" id="L3683">    }</span>

    // srvName is an OtherName see method getIA5String...... for asn.1
    // definition
    for (final String srvName
<span class="pc bpc" id="L3688" title="1 of 2 branches missed.">       :  CertTools.getPartsFromDN(altName, CertTools.SRVNAME)) {</span>
<span class="nc" id="L3689">      final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L3690">      v.add(new ASN1ObjectIdentifier(CertTools.SRVNAME_OBJECTID));</span>
<span class="nc" id="L3691">      v.add(new DERTaggedObject(true, 0, new DERIA5String(srvName)));</span>
<span class="nc" id="L3692">      vec.add(</span>
<span class="nc" id="L3693">          GeneralName.getInstance(</span>
              new DERTaggedObject(false, 0, new DERSequence(v))));
<span class="nc" id="L3695">    }</span>

    // FASC-N is an OtherName see method getOctetString...... for asn.1
    // definition (PIV FIPS 201-2)
    // We take the input as being a hex encoded octet string
    for (final String fascN
<span class="pc bpc" id="L3701" title="1 of 2 branches missed.">        : CertTools.getPartsFromDN(altName, CertTools.FASCN)) {</span>
<span class="nc" id="L3702">      final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L3703">      v.add(new ASN1ObjectIdentifier(CertTools.FASCN_OBJECTID));</span>
<span class="nc" id="L3704">      v.add(</span>
<span class="nc" id="L3705">          new DERTaggedObject(true, 0, new DEROctetString(Hex.decode(fascN))));</span>
<span class="nc" id="L3706">      vec.add(</span>
<span class="nc" id="L3707">          GeneralName.getInstance(</span>
              new DERTaggedObject(false, 0, new DERSequence(v))));
<span class="nc" id="L3709">    }</span>

    // PermanentIdentifier is an OtherName see method
    // getPermananentIdentifier... for asn.1 definition
    for (final String permanentIdentifier
<span class="fc bfc" id="L3714" title="All 2 branches covered.">        : CertTools.getPartsFromDN(altName, CertTools.PERMANENTIDENTIFIER)) {</span>
<span class="fc" id="L3715">      final String[] values = getPermanentIdentifierValues(permanentIdentifier);</span>
<span class="fc" id="L3716">      final ASN1EncodableVector v =</span>
          new ASN1EncodableVector(); // this is the OtherName
<span class="fc" id="L3718">      v.add(new ASN1ObjectIdentifier(CertTools.PERMANENTIDENTIFIER_OBJECTID));</span>
      // First the PermanentIdentifier sequence
<span class="fc" id="L3720">      final ASN1EncodableVector piSeq = new ASN1EncodableVector();</span>
<span class="pc bpc" id="L3721" title="1 of 2 branches missed.">      if (values[0] != null) {</span>
<span class="fc" id="L3722">        piSeq.add(new DERUTF8String(values[0]));</span>
      }
<span class="pc bpc" id="L3724" title="1 of 2 branches missed.">      if (values[1] != null) {</span>
<span class="fc" id="L3725">        piSeq.add(new ASN1ObjectIdentifier(values[1]));</span>
      }
<span class="fc" id="L3727">      v.add(new DERTaggedObject(true, 0, new DERSequence(piSeq)));</span>
      // GeneralName gn = new GeneralName(new DERSequence(v), 0);
<span class="fc" id="L3729">      final ASN1Primitive gn =</span>
          new DERTaggedObject(false, 0, new DERSequence(v));
<span class="fc" id="L3731">      vec.add(gn);</span>
<span class="fc" id="L3732">    }</span>

    for (final String guid
<span class="fc bfc" id="L3735" title="All 2 branches covered.">        : CertTools.getPartsFromDN(altName, CertTools.GUID)) {</span>
<span class="fc" id="L3736">      final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="fc" id="L3737">      final byte[] guidbytes = Hex.decode(guid);</span>
<span class="pc bpc" id="L3738" title="1 of 2 branches missed.">      if (guidbytes != null) {</span>
<span class="fc" id="L3739">        v.add(new ASN1ObjectIdentifier(CertTools.GUID_OBJECTID));</span>
<span class="fc" id="L3740">        v.add(new DERTaggedObject(true, 0, new DEROctetString(guidbytes)));</span>
<span class="fc" id="L3741">        final ASN1Primitive gn =</span>
            new DERTaggedObject(false, 0, new DERSequence(v));
<span class="fc" id="L3743">        vec.add(gn);</span>
<span class="fc" id="L3744">      } else {</span>
<span class="nc" id="L3745">        LOGGER.error(&quot;Cannot decode hexadecimal guid, ignoring: &quot; + guid);</span>
      }
<span class="fc" id="L3747">    }</span>

    // Krb5PrincipalName is an OtherName, see method getKrb5Principal...for
    // ASN.1 definition
    for (final String principalString
<span class="fc bfc" id="L3752" title="All 2 branches covered.">        : CertTools.getPartsFromDN(altName, CertTools.KRB5PRINCIPAL)) {</span>
      // Start by parsing the input string to separate it in different parts
<span class="pc bpc" id="L3754" title="1 of 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L3755">        LOGGER.debug(&quot;principalString: &quot; + principalString);</span>
      }
      // The realm is the last part moving back until an @
<span class="fc" id="L3758">      final int index = principalString.lastIndexOf('@');</span>
<span class="fc" id="L3759">      String realm = &quot;&quot;;</span>
<span class="pc bpc" id="L3760" title="1 of 2 branches missed.">      if (index &gt; 0) {</span>
<span class="fc" id="L3761">        realm = principalString.substring(index + 1);</span>
      }
<span class="pc bpc" id="L3763" title="1 of 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L3764">        LOGGER.debug(&quot;realm: &quot; + realm);</span>
      }
      // Now we can have several principals separated by /
<span class="fc" id="L3767">      final ArrayList&lt;String&gt; principalarr = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L3768">      int jndex = 0;</span>
<span class="fc" id="L3769">      int bindex = 0;</span>
<span class="fc bfc" id="L3770" title="All 2 branches covered.">      while (jndex &lt; index) {</span>
        // Loop and add all strings separated by /
<span class="fc" id="L3772">        jndex = principalString.indexOf('/', bindex);</span>
<span class="fc bfc" id="L3773" title="All 2 branches covered.">        if (jndex == -1) {</span>
<span class="fc" id="L3774">          jndex = index;</span>
        }
<span class="fc" id="L3776">        final String s = principalString.substring(bindex, jndex);</span>
<span class="pc bpc" id="L3777" title="1 of 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L3778">          LOGGER.debug(&quot;adding principal name: &quot; + s);</span>
        }
<span class="fc" id="L3780">        principalarr.add(s);</span>
<span class="fc" id="L3781">        bindex = jndex + 1;</span>
<span class="fc" id="L3782">      }</span>

      // Now we must construct the rather complex asn.1...
<span class="fc" id="L3785">      final ASN1EncodableVector v =</span>
          new ASN1EncodableVector(); // this is the OtherName
<span class="fc" id="L3787">      v.add(new ASN1ObjectIdentifier(CertTools.KRB5PRINCIPAL_OBJECTID));</span>

      // First the Krb5PrincipalName sequence
<span class="fc" id="L3790">      final ASN1EncodableVector krb5p = new ASN1EncodableVector();</span>
      // The realm is the first tagged GeneralString
<span class="fc" id="L3792">      krb5p.add(new DERTaggedObject(true, 0, new DERGeneralString(realm)));</span>
      // Second is the sequence of principal names, which is at tagged position
      // 1 in the krb5p
<span class="fc" id="L3795">      final ASN1EncodableVector principals = new ASN1EncodableVector();</span>
      // According to rfc4210 the type NT-UNKNOWN is 0, and according to some
      // other rfc this type should be used...
<span class="fc" id="L3798">      principals.add(new DERTaggedObject(true, 0, new ASN1Integer(0)));</span>
      // The names themselves are yet another sequence
<span class="fc" id="L3800">      final ASN1EncodableVector names = new ASN1EncodableVector();</span>
<span class="fc bfc" id="L3801" title="All 2 branches covered.">      for (final String principalName : principalarr) {</span>
<span class="fc" id="L3802">        names.add(new DERGeneralString(principalName));</span>
<span class="fc" id="L3803">      }</span>
<span class="fc" id="L3804">      principals.add(new DERTaggedObject(true, 1, new DERSequence(names)));</span>
<span class="fc" id="L3805">      krb5p.add(new DERTaggedObject(true, 1, new DERSequence(principals)));</span>

<span class="fc" id="L3807">      v.add(new DERTaggedObject(true, 0, new DERSequence(krb5p)));</span>
<span class="fc" id="L3808">      final ASN1Primitive gn =</span>
          new DERTaggedObject(false, 0, new DERSequence(v));
<span class="fc" id="L3810">      vec.add(gn);</span>
<span class="fc" id="L3811">    }</span>

    // SIM is an OtherName. See RFC-4683
    for (final String internalSimString
<span class="fc bfc" id="L3815" title="All 2 branches covered.">        : CertTools.getPartsFromDN(</span>
            altName, RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD)) {
<span class="pc bpc" id="L3817" title="1 of 2 branches missed.">      if (StringUtils.isNotBlank(internalSimString)) {</span>
<span class="fc" id="L3818">          final int index = 3;</span>
<span class="fc" id="L3819">        final String[] tokens =</span>
<span class="fc" id="L3820">            internalSimString.split(RFC4683Tools.LIST_SEPARATOR);</span>
<span class="pc bpc" id="L3821" title="1 of 2 branches missed.">        if (tokens.length == index) {</span>
<span class="fc" id="L3822">          final ASN1Primitive gn =</span>
<span class="fc" id="L3823">              RFC4683Tools.createSimGeneralName(</span>
                  tokens[0], tokens[1], tokens[2]);
<span class="fc" id="L3825">          vec.add(gn);</span>
<span class="pc bpc" id="L3826" title="1 of 2 branches missed.">          if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L3827">            LOGGER.debug(&quot;SIM GeneralName added: &quot; + gn.toString());</span>
          }
        }
      }
<span class="fc" id="L3831">    }</span>

    // To support custom OIDs in altNames, they must be added as an OtherName of
    // plain type UTF8String
<span class="pc bpc" id="L3835" title="1 of 2 branches missed.">    for (final String oid : CertTools.getCustomOids(altName)) {</span>
<span class="nc bnc" id="L3836" title="All 2 branches missed.">      for (final String oidValue : CertTools.getPartsFromDN(altName, oid)) {</span>
<span class="nc" id="L3837">        final ASN1EncodableVector v = new ASN1EncodableVector();</span>
<span class="nc" id="L3838">        v.add(new ASN1ObjectIdentifier(oid));</span>
<span class="nc" id="L3839">        v.add(new DERTaggedObject(true, 0, new DERUTF8String(oidValue)));</span>
<span class="nc" id="L3840">        final ASN1Primitive gn =</span>
            new DERTaggedObject(false, 0, new DERSequence(v));
<span class="nc" id="L3842">        vec.add(gn);</span>
<span class="nc" id="L3843">      }</span>
<span class="nc" id="L3844">    }</span>

<span class="fc bfc" id="L3846" title="All 2 branches covered.">    if (vec.size() &gt; 0) {</span>
<span class="fc" id="L3847">      return GeneralNames.getInstance(new DERSequence(vec));</span>
    }
<span class="fc" id="L3849">    return null;</span>
  }

  /**
   * GeneralName ::= CHOICE { otherName [0] OtherName, rfc822Name [1] IA5String,
   * dNSName [2] IA5String, x400Address [3] ORAddress, directoryName [4] Name,
   * ediPartyName [5] EDIPartyName, uniformResourceIdentifier [6] IA5String,
   * iPAddress [7] OCTET STRING, registeredID [8] OBJECT IDENTIFIER}.
   *
   * @param tag the no tag 0-8
   * @param value the ASN1Encodable value as returned by GeneralName.getName()
   * @return String in form rfc822Name=&amp;lt;email&amp;gt; or uri=&amp;lt;uri&amp;gt; etc
   * @throws IOException on disk error
   * @see #getSubjectAlternativeName
   */
  public static String getGeneralNameString(
          final int tag, final ASN1Encodable value)
      throws IOException {
<span class="fc" id="L3867">    String ret = null;</span>
<span class="pc bpc" id="L3868" title="5 of 10 branches missed.">    switch (tag) {</span>
      case 0:

<span class="fc" id="L3871">          final ASN1Sequence sequence =</span>
<span class="fc" id="L3872">              getAltnameSequence(value.toASN1Primitive().getEncoded());</span>
<span class="fc" id="L3873">          ASN1ObjectIdentifier oid =</span>
<span class="fc" id="L3874">              ASN1ObjectIdentifier.getInstance(sequence.getObjectAt(0));</span>
<span class="pc bpc" id="L3875" title="4 of 8 branches missed.">          switch (oid.getId()) {</span>
            case CertTools.UPN_OBJECTID:
<span class="fc" id="L3877">              ret =</span>
                  CertTools.UPN
                      + &quot;=&quot;
<span class="fc" id="L3880">                      + getUTF8StringFromSequence(</span>
                          sequence, CertTools.UPN_OBJECTID);
<span class="fc" id="L3882">              break;</span>
            case CertTools.PERMANENTIDENTIFIER_OBJECTID:
<span class="fc" id="L3884">              ret =</span>
                  CertTools.PERMANENTIDENTIFIER
                      + &quot;=&quot;
<span class="fc" id="L3887">                      + getPermanentIdentifierStringFromSequence(sequence);</span>
<span class="fc" id="L3888">              break;</span>
            case CertTools.KRB5PRINCIPAL_OBJECTID:
<span class="fc" id="L3890">              ret =</span>
                  CertTools.KRB5PRINCIPAL
                      + &quot;=&quot;
<span class="fc" id="L3893">                      + getKrb5PrincipalNameFromSequence(sequence);</span>
<span class="fc" id="L3894">              break;</span>
            case RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD_OBJECTID:
<span class="fc" id="L3896">              ret =</span>
                  RFC4683Tools.SUBJECTIDENTIFICATIONMETHOD
                      + &quot;=&quot;
<span class="fc" id="L3899">                      + RFC4683Tools.getSimStringSequence(sequence);</span>
<span class="fc" id="L3900">              break;</span>
            case CertTools.XMPPADDR_OBJECTID:
<span class="nc" id="L3902">              ret =</span>
                  CertTools.XMPPADDR
                      + &quot;=&quot;
<span class="nc" id="L3905">                      + getUTF8StringFromSequence(</span>
                          sequence, CertTools.XMPPADDR_OBJECTID);
<span class="nc" id="L3907">              break;</span>
            case CertTools.SRVNAME_OBJECTID:
<span class="nc" id="L3909">              ret =</span>
                  CertTools.SRVNAME
                      + &quot;=&quot;
<span class="nc" id="L3912">                      + getIA5StringFromSequence(</span>
                          sequence, CertTools.SRVNAME_OBJECTID);
<span class="nc" id="L3914">              break;</span>
            case CertTools.FASCN_OBJECTID:
<span class="nc" id="L3916">              ret =</span>
                  CertTools.FASCN
                      + &quot;=&quot;
                      + new String(
<span class="nc" id="L3920">                          Hex.encode(</span>
<span class="nc" id="L3921">                              getOctetStringFromSequence(</span>
                                  sequence, CertTools.FASCN_OBJECTID)));
<span class="nc" id="L3923">              break;</span>
              default: break; //no-op
          }

<span class="fc" id="L3927">          break;</span>

      case 1:
<span class="fc" id="L3930">        ret =</span>
<span class="fc" id="L3931">            CertTools.EMAIL + &quot;=&quot; + DERIA5String.getInstance(value).getString();</span>
<span class="fc" id="L3932">        break;</span>
      case 2:
<span class="fc" id="L3934">        ret = CertTools.DNS + &quot;=&quot; + DERIA5String.getInstance(value).getString();</span>
<span class="fc" id="L3935">        break;</span>
      case 3: // SubjectAltName of type x400Address not supported
<span class="nc" id="L3937">        break;</span>
      case 4:
<span class="fc" id="L3939">        final X500Name name = X500Name.getInstance(value);</span>
<span class="fc" id="L3940">        ret = CertTools.DIRECTORYNAME + &quot;=&quot; + name.toString();</span>
<span class="fc" id="L3941">        break;</span>
      case 5: // SubjectAltName of type ediPartyName not supported
<span class="nc" id="L3943">        break;</span>
      case 6:
<span class="nc" id="L3945">        ret = CertTools.URI + &quot;=&quot; + DERIA5String.getInstance(value).getString();</span>
<span class="nc" id="L3946">        break;</span>
      case 7:
<span class="fc" id="L3948">        final ASN1OctetString oct = ASN1OctetString.getInstance(value);</span>
<span class="fc" id="L3949">        ret =</span>
            CertTools.IPADDR
                + &quot;=&quot;
<span class="fc" id="L3952">                + StringTools.ipOctetsToString(oct.getOctets());</span>
<span class="fc" id="L3953">        break;</span>
      case 8:
        // BC GeneralName stores the actual object value, which is an OID
<span class="nc" id="L3956">        oid = ASN1ObjectIdentifier.getInstance(value);</span>
<span class="nc" id="L3957">        ret = CertTools.REGISTEREDID + &quot;=&quot; + oid.getId();</span>
<span class="nc" id="L3958">        break;</span>
      default: // SubjectAltName of unknown type
        break;
    }
<span class="fc" id="L3962">    return ret;</span>
  }

  /**
   * Check the certificate with CA certificate.
   *
   * @param certificate certificate to verify
   * @param caCertChain collection of X509Certificates
   * @param date Date to verify at, or null to use current time.
   * @param pkixCertPathCheckers optional PKIXCertPathChecker implementations to
   *     use during cert path validation
   * @return true if verified OK
   * @throws CertPathValidatorException if certificate could not be validated
   */
  public static boolean verify(
      final X509Certificate certificate,
      final Collection&lt;X509Certificate&gt; caCertChain,
      final Date date,
      final PKIXCertPathChecker... pkixCertPathCheckers)
      throws CertPathValidatorException {
    try {
<span class="fc" id="L3983">      final ArrayList&lt;X509Certificate&gt; certlist = new ArrayList&lt;&gt;();</span>
      // Create CertPath
<span class="fc" id="L3985">      certlist.add(certificate);</span>
      // Add other certs...
<span class="fc" id="L3987">      final CertPath cp =</span>
<span class="fc" id="L3988">          CertificateFactory.getInstance(</span>
                  &quot;X.509&quot;, BouncyCastleProvider.PROVIDER_NAME)
<span class="fc" id="L3990">              .generateCertPath(certlist);</span>

      // Create TrustAnchor. Since EJBCA use BouncyCastle provider, we assume
      // certificate already in correct order
<span class="fc" id="L3994">      final X509Certificate[] cac =</span>
<span class="fc" id="L3995">          caCertChain.toArray(new X509Certificate[caCertChain.size()]);</span>
<span class="fc" id="L3996">      final TrustAnchor anchor = new TrustAnchor(cac[0], null);</span>
      // Set the PKIX parameters
<span class="fc" id="L3998">      final PKIXParameters params =</span>
<span class="fc" id="L3999">              new PKIXParameters(Collections.singleton(anchor));</span>
      for (final PKIXCertPathChecker pkixCertPathChecker
<span class="fc bfc" id="L4001" title="All 2 branches covered.">          : pkixCertPathCheckers) {</span>
<span class="fc" id="L4002">        params.addCertPathChecker(pkixCertPathChecker);</span>
      }
<span class="fc" id="L4004">      params.setRevocationEnabled(false);</span>
<span class="fc" id="L4005">      params.setDate(date);</span>
<span class="fc" id="L4006">      final CertPathValidator cpv =</span>
<span class="fc" id="L4007">          CertPathValidator.getInstance(</span>
              &quot;PKIX&quot;, BouncyCastleProvider.PROVIDER_NAME);
<span class="fc" id="L4009">      final PKIXCertPathValidatorResult result =</span>
<span class="fc" id="L4010">          (PKIXCertPathValidatorResult) cpv.validate(cp, params);</span>
<span class="pc bpc" id="L4011" title="1 of 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L4012">        LOGGER.debug(&quot;Certificate verify result: &quot; + result.toString());</span>
      }
<span class="fc" id="L4014">    } catch (final CertPathValidatorException cpve) {</span>
<span class="fc" id="L4015">      throw new CertPathValidatorException(</span>
          &quot;Invalid certificate or certificate not issued by specified CA: &quot;
<span class="fc" id="L4017">              + cpve.getMessage());</span>
<span class="nc" id="L4018">    } catch (final CertificateException e) {</span>
<span class="nc" id="L4019">      throw new IllegalArgumentException(</span>
          &quot;Something was wrong with the supplied certificate&quot;, e);
<span class="nc" id="L4021">    } catch (final NoSuchProviderException e) {</span>
<span class="nc" id="L4022">      throw new IllegalStateException(&quot;BouncyCastle provider not found.&quot;, e);</span>
<span class="nc" id="L4023">    } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L4024">      throw new IllegalStateException(&quot;Algorithm PKIX was not found.&quot;, e);</span>
<span class="nc" id="L4025">    } catch (final InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L4026">      throw new IllegalArgumentException(</span>
          &quot;Either ca certificate chain was empty, or the certificate was on an&quot;
              + &quot; inappropraite type for a PKIX path checker.&quot;,
          e);
<span class="fc" id="L4030">    }</span>
<span class="fc" id="L4031">    return true;</span>
  }

  /**
   * Check the certificate with CA certificate.
   *
   * @param certificate certificate to verify
   * @param caCertChain collection of X509Certificates
   * @return true if verified OK
   * @throws CertPathValidatorException if verification failed
   */
  public static boolean verify(
      final X509Certificate certificate,
      final Collection&lt;X509Certificate&gt; caCertChain)
      throws CertPathValidatorException {
<span class="nc" id="L4046">    return verify(certificate, caCertChain, null);</span>
  }

  /**
   * Check the certificate with a list of trusted certificates. The trusted
   * certificates list can either be end entity certificates, in this case, only
   * this certificate by this issuer is trusted; or it could be CA certificates,
   * in this case, all certificates issued by this CA are trusted.
   *
   * @param certificate certificate to verify
   * @param trustedCertificates collection of trusted X509Certificates
   * @param pkixCertPathCheckers optional PKIXCertPathChecker implementations to
   *     use during cert path validation
   * @return true if verified OK
   */
  public static boolean verifyWithTrustedCertificates(
      final X509Certificate certificate,
      final List&lt;Collection&lt;X509Certificate&gt;&gt; trustedCertificates,
      final PKIXCertPathChecker... pkixCertPathCheckers) {

<span class="pc bpc" id="L4066" title="1 of 2 branches missed.">    if (trustedCertificates == null) {</span>
<span class="nc bnc" id="L4067" title="All 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L4068">        LOGGER.debug(</span>
                &quot;Input of trustedCertificates was null. Trusting nothing.&quot;);
      }
<span class="nc" id="L4071">      return false;</span>
    }

<span class="pc bpc" id="L4074" title="1 of 2 branches missed.">    if (trustedCertificates.size() == 0) {</span>
<span class="nc bnc" id="L4075" title="All 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L4076">        LOGGER.debug(</span>
            &quot;Input of trustedCertificates was empty. Trusting everything.&quot;);
      }
<span class="nc" id="L4079">      return true;</span>
    }

<span class="fc" id="L4082">    final BigInteger certSN = getSerialNumber(certificate);</span>
    for (final Collection&lt;X509Certificate&gt; trustedCertChain
<span class="fc bfc" id="L4084" title="All 2 branches covered.">            : trustedCertificates) {</span>
<span class="fc" id="L4085">      final X509Certificate trustedCert = trustedCertChain.iterator().next();</span>
<span class="fc" id="L4086">      final BigInteger trustedCertSN = getSerialNumber(trustedCert);</span>
<span class="fc bfc" id="L4087" title="All 2 branches covered.">      if (certSN.equals(trustedCertSN)) {</span>
        // If the serial number of the certificate matches the serial number of
        // a certificate in the list, make sure that it in
        // fact is the same certificate by verifying that they were issued by
        // the same issuer.
        // Removing this trusted certificate from the trustedCertChain will
        // leave only the CA's certificate chain, which will be
        // used to verify the issuer.
<span class="pc bpc" id="L4095" title="1 of 2 branches missed.">        if (trustedCertChain.size() &gt; 1) {</span>
<span class="nc" id="L4096">          trustedCertChain.remove(trustedCert);</span>
        }
      }
      try {
<span class="fc" id="L4100">        verify(certificate, trustedCertChain, null, pkixCertPathCheckers);</span>
<span class="pc bpc" id="L4101" title="1 of 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L4102">          LOGGER.debug(</span>
              &quot;Trusting certificate with SubjectDN '&quot;
<span class="nc" id="L4104">                  + getSubjectDN(certificate)</span>
                  + &quot;' and issuerDN '&quot;
<span class="nc" id="L4106">                  + getIssuerDN(certificate)</span>
                  + &quot;'.&quot;);
        }
<span class="fc" id="L4109">        return true;</span>
<span class="fc" id="L4110">      } catch (final CertPathValidatorException e) {</span>
        // Do nothing. Just try the next trusted certificate chain in the list
      }
<span class="fc" id="L4113">    }</span>
<span class="fc" id="L4114">    return false;</span>
  }

  /**
   * Checks that the given date is within the certificate's validity period. In
   * other words, this determines whether the certificate would be valid at the
   * given date/time.
   *
   * &lt;p&gt;This utility class is only a helper to get the same behavior as the
   * standard java.security.cert API regardless if using X.509 or CV
   * Certificate.
   *
   * @param cert certificate to verify, if null the method returns immediately,
   *     null does not have a validity to check.
   * @param date the Date to check against to see if this certificate is valid
   *     at that date/time.
   * @throws CertificateExpiredException - if the certificate has expired with
   *     respect to the date supplied.
   * @throws CertificateNotYetValidException - if the certificate is not yet
   *     valid with respect to the date supplied.
   * @see java.security.cert.X509Certificate#checkValidity(Date)
   */
  public static void checkValidity(final Certificate cert, final Date date)
      throws CertificateExpiredException, CertificateNotYetValidException {
<span class="pc bpc" id="L4138" title="1 of 2 branches missed.">    if (cert != null) {</span>
<span class="fc bfc" id="L4139" title="All 2 branches covered.">      if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L4140">        final X509Certificate xcert = (X509Certificate) cert;</span>
<span class="fc" id="L4141">        xcert.checkValidity(date);</span>
<span class="pc bpc" id="L4142" title="1 of 2 branches missed.">      } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="fc" id="L4143">        final CardVerifiableCertificate cvccert =</span>
            (CardVerifiableCertificate) cert;
        try {
<span class="fc" id="L4146">          final Date start =</span>
<span class="fc" id="L4147">              cvccert.getCVCertificate().getCertificateBody().getValidFrom();</span>
<span class="fc" id="L4148">          final Date end =</span>
<span class="fc" id="L4149">              cvccert.getCVCertificate().getCertificateBody().getValidTo();</span>
<span class="fc bfc" id="L4150" title="All 2 branches covered.">          if (start.after(date)) {</span>
<span class="fc" id="L4151">            final String msg =</span>
                &quot;CV Certificate startDate '&quot;
                    + start
                    + &quot;' is after check date '&quot;
                    + date
                    + &quot;'. Subject: &quot;
<span class="fc" id="L4157">                    + CertTools.getSubjectDN(cert);</span>
<span class="pc bpc" id="L4158" title="1 of 2 branches missed.">            if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L4159">              LOGGER.trace(msg);</span>
            }
<span class="fc" id="L4161">            throw new CertificateNotYetValidException(msg);</span>
          }
<span class="fc bfc" id="L4163" title="All 2 branches covered.">          if (end.before(date)) {</span>
<span class="fc" id="L4164">            final String msg =</span>
                &quot;CV Certificate endDate '&quot;
                    + end
                    + &quot;' is before check date '&quot;
                    + date
                    + &quot;'. Subject: &quot;
<span class="fc" id="L4170">                    + CertTools.getSubjectDN(cert);</span>
<span class="pc bpc" id="L4171" title="1 of 2 branches missed.">            if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L4172">              LOGGER.trace(msg);</span>
            }
<span class="fc" id="L4174">            throw new CertificateExpiredException(msg);</span>
          }
<span class="nc" id="L4176">        } catch (final NoSuchFieldException e) {</span>
<span class="nc" id="L4177">          LOGGER.error(&quot;NoSuchFieldException: &quot;, e);</span>
<span class="fc" id="L4178">        }</span>
      }
    }
<span class="fc" id="L4181">  }</span>

  /**
   * Return the first CRL distribution points. The CRL distributions points are
   * URL specified in the certificate extension CRLDistributionPoints with OID
   * 2.5.29.31.
   *
   * &lt;p&gt;The CRLDistributionPoints extension contains a sequece of
   * DistributionPoint, which has the following structure:
   *
   * &lt;p&gt;DistributionPoint ::= SEQUENCE { distributionPoint [0]
   * DistributionPointName OPTIONAL, reasons [1] ReasonFlags OPTIONAL, cRLIssuer
   * [2] GeneralNames OPTIONAL }
   *
   * &lt;p&gt;This method extracts &quot;distributionPoint&quot; (tag 0) from the first
   * DistributionPoint included in the extension. No other tags are read.
   *
   * @param certificate certificate
   * @return A URL, or null if no CRL distribution points were found
   */
  public static URL getCrlDistributionPoint(final Certificate certificate) {
<span class="pc bpc" id="L4202" title="1 of 2 branches missed.">    if (certificate instanceof X509Certificate) {</span>
<span class="fc" id="L4203">      final X509Certificate x509cert = (X509Certificate) certificate;</span>
<span class="fc" id="L4204">      final Collection&lt;URL&gt; cdps = getCrlDistributionPoints(x509cert, true);</span>
<span class="fc bfc" id="L4205" title="All 2 branches covered.">      if (!cdps.isEmpty()) {</span>
<span class="fc" id="L4206">        return cdps.iterator().next();</span>
      }
    }
<span class="fc" id="L4209">    return null;</span>
  }

  /**
   * Return a list of CRL distribution points. The CRL distributions points are
   * URL specified in the certificate extension CRLDistributionPoints with OID
   * 2.5.29.31.
   *
   * &lt;p&gt;The CRLDistributionPoints extension contains a sequece of
   * DistributionPoint, which has the following structure:
   *
   * &lt;p&gt;DistributionPoint ::= SEQUENCE { distributionPoint [0]
   * DistributionPointName OPTIONAL, reasons [1] ReasonFlags OPTIONAL, cRLIssuer
   * [2] GeneralNames OPTIONAL }
   *
   * &lt;p&gt;This method extracts &quot;distributionPoint&quot; (tag 0) from every
   * DistributionPoint included in the extension. No other tags are read.
   *
   * @param x509cert X.509 cert
   * @return A list of URLs
   */
  public static Collection&lt;URL&gt; getCrlDistributionPoints(
      final X509Certificate x509cert) {
<span class="nc" id="L4232">    return getCrlDistributionPoints(x509cert, false);</span>
  }

  private static Collection&lt;URL&gt; getCrlDistributionPoints(
      final X509Certificate x509cert, final boolean onlyfirst) {
<span class="fc" id="L4237">    final ArrayList&lt;URL&gt; cdps = new ArrayList&lt;URL&gt;();</span>
<span class="fc" id="L4238">    final ASN1Primitive obj =</span>
<span class="fc" id="L4239">        getExtensionValue(x509cert, Extension.cRLDistributionPoints.getId());</span>
<span class="pc bpc" id="L4240" title="1 of 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L4241">      return cdps;</span>
    }

<span class="fc" id="L4244">    final ASN1Sequence crlDistributionPoints = (ASN1Sequence) obj;</span>
<span class="pc bpc" id="L4245" title="1 of 2 branches missed.">    for (int i = 0; i &lt; crlDistributionPoints.size(); i++) {</span>
<span class="fc" id="L4246">      final ASN1Sequence distributionPoint =</span>
<span class="fc" id="L4247">          (ASN1Sequence) crlDistributionPoints.getObjectAt(i);</span>
<span class="pc bpc" id="L4248" title="1 of 2 branches missed.">      for (int j = 0; j &lt; distributionPoint.size(); j++) {</span>
<span class="fc" id="L4249">        final ASN1TaggedObject tagged =</span>
<span class="fc" id="L4250">            (ASN1TaggedObject) distributionPoint.getObjectAt(j);</span>
<span class="pc bpc" id="L4251" title="1 of 2 branches missed.">        if (tagged.getTagNo() == 0) {</span>
<span class="fc" id="L4252">          final String url = getStringFromGeneralNames(tagged.getObject());</span>
<span class="fc bfc" id="L4253" title="All 2 branches covered.">          if (url != null) {</span>
            try {
<span class="fc" id="L4255">              cdps.add(new URL(url));</span>
<span class="nc" id="L4256">            } catch (final MalformedURLException e) {</span>
<span class="nc bnc" id="L4257" title="All 2 branches missed.">              if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L4258">                LOGGER.debug(</span>
                    &quot;Error parsing '&quot;
                        + url
                        + &quot;' as a URL. &quot;
<span class="nc" id="L4262">                        + e.getLocalizedMessage());</span>
              }
<span class="fc" id="L4264">            }</span>
          }
<span class="pc bpc" id="L4266" title="1 of 2 branches missed.">          if (onlyfirst) {</span>
<span class="fc" id="L4267">            return cdps; // returning only the first URL</span>
          }
        }
      }
    }
<span class="nc" id="L4272">    return cdps;</span>
  }

  /**
   * This utility method extracts the Authority Information Access Extention's
   * URLs.
   *
   * @param crl a CRL to parse
   * @return the Authority Information Access Extention's URLs, or an empty
   *     Collection if none were found
   */
  public static Collection&lt;String&gt; getAuthorityInformationAccess(
          final CRL crl) {
<span class="nc" id="L4285">    final Collection&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L4286" title="All 2 branches missed.">    if (crl instanceof X509CRL) {</span>
<span class="nc" id="L4287">      final X509CRL x509crl = (X509CRL) crl;</span>
<span class="nc" id="L4288">      final ASN1Primitive derObject =</span>
<span class="nc" id="L4289">          getExtensionValue(x509crl, Extension.authorityInfoAccess.getId());</span>
<span class="nc bnc" id="L4290" title="All 2 branches missed.">      if (derObject != null) {</span>
<span class="nc" id="L4291">        final AuthorityInformationAccess authorityInformationAccess =</span>
<span class="nc" id="L4292">            AuthorityInformationAccess.getInstance(derObject);</span>
<span class="nc" id="L4293">        final AccessDescription[] accessDescriptions =</span>
<span class="nc" id="L4294">            authorityInformationAccess.getAccessDescriptions();</span>
<span class="nc bnc" id="L4295" title="All 4 branches missed.">        if ((accessDescriptions != null) &amp;&amp; (accessDescriptions.length &gt; 0)) {</span>
<span class="nc bnc" id="L4296" title="All 2 branches missed.">          for (final AccessDescription accessDescription : accessDescriptions) {</span>
<span class="nc" id="L4297">            if (accessDescription</span>
<span class="nc" id="L4298">                .getAccessMethod()</span>
<span class="nc bnc" id="L4299" title="All 2 branches missed.">                .equals(X509ObjectIdentifiers.id_ad_caIssuers)) {</span>
<span class="nc" id="L4300">              final GeneralName generalName =</span>
<span class="nc" id="L4301">                      accessDescription.getAccessLocation();</span>
<span class="nc bnc" id="L4302" title="All 2 branches missed.">              if (generalName.getTagNo()</span>
                  == GeneralName.uniformResourceIdentifier) {
                // Due to bug in java getting some ASN.1 objects, it can be
                // tagged an extra time...
<span class="nc" id="L4306">                ASN1Primitive obj = generalName.toASN1Primitive();</span>
<span class="nc bnc" id="L4307" title="All 2 branches missed.">                if (obj instanceof ASN1TaggedObject) {</span>
<span class="nc" id="L4308">                  obj = ASN1TaggedObject.getInstance(obj).getObject();</span>
                }
<span class="nc" id="L4310">                final DERIA5String deria5String = DERIA5String.getInstance(obj);</span>
<span class="nc" id="L4311">                result.add(deria5String.getString());</span>
              }
            }
          }
        }
      }
    }
<span class="nc" id="L4318">    return result;</span>
  }

  /**
   * @param cert cert
   * @return all CA issuer URI that are inside AuthorityInformationAccess
   *     extension or an empty list
   */
  public static List&lt;String&gt; getAuthorityInformationAccessCAIssuerUris(
      final Certificate cert) {
<span class="fc" id="L4328">    return getAuthorityInformationAccessCaIssuerUris(cert, false);</span>
  }

  /**
   * @return the first OCSP URL that is inside AuthorityInformationAccess
   *     extension, or null.
   * @param cert is the certificate to parse
   */
  public static String getAuthorityInformationAccessOcspUrl(
          final Certificate cert) {
<span class="fc" id="L4338">    final Collection&lt;String&gt; urls = getAuthorityInformationAccessOcspUrls(cert);</span>
<span class="pc bpc" id="L4339" title="1 of 2 branches missed.">    if (!urls.isEmpty()) {</span>
<span class="fc" id="L4340">      return urls.iterator().next();</span>
    }
<span class="nc" id="L4342">    return null;</span>
  }

  /**
   * @param cert cert
   * @return all OCSP URL that is inside AuthorityInformationAccess extension or
   *     an empty list
   */
  public static List&lt;String&gt; getAuthorityInformationAccessOcspUrls(
      final Certificate cert) {
<span class="fc" id="L4352">    return getAuthorityInformationAccessOcspUrls(cert, false);</span>
  }

  /**
   * @param cert cert
   * @param onlyfirst only return first result if true
   * @return all CA issuer URI that are inside AuthorityInformationAccess
   *     extension or an empty list.
   */
  private static List&lt;String&gt; getAuthorityInformationAccessCaIssuerUris(
      final Certificate cert, final boolean onlyfirst) {
<span class="fc" id="L4363">    final List&lt;String&gt; urls = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L4364" title="1 of 2 branches missed.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L4365">      final X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L4366">      final ASN1Primitive obj =</span>
<span class="fc" id="L4367">          getExtensionValue(x509cert, Extension.authorityInfoAccess.getId());</span>
<span class="pc bpc" id="L4368" title="1 of 2 branches missed.">      if (obj != null) {</span>
<span class="fc" id="L4369">        final AccessDescription[] accessDescriptions =</span>
<span class="fc" id="L4370">            AuthorityInformationAccess.getInstance(obj).getAccessDescriptions();</span>
<span class="pc bpc" id="L4371" title="1 of 2 branches missed.">        if (accessDescriptions != null) {</span>
<span class="fc bfc" id="L4372" title="All 2 branches covered.">          for (final AccessDescription accessDescription : accessDescriptions) {</span>
            // OID 1.3.6.1.5.5.7.48.2: 2 times in Bouncy Castle
            // X509ObjectIdentifiers class.
            // X509ObjectIdentifiers.id_ad_caIssuers =
            // X509ObjectIdentifiers.crlAccessMethod
<span class="fc" id="L4377">            if (accessDescription</span>
<span class="fc" id="L4378">                .getAccessMethod()</span>
<span class="fc bfc" id="L4379" title="All 2 branches covered.">                .equals(X509ObjectIdentifiers.id_ad_caIssuers)) {</span>
<span class="fc" id="L4380">              final GeneralName generalName =</span>
<span class="fc" id="L4381">                  accessDescription.getAccessLocation();</span>
<span class="pc bpc" id="L4382" title="1 of 2 branches missed.">              if (generalName.getTagNo()</span>
                  == GeneralName.uniformResourceIdentifier) {
                // After encoding in a cert, it is tagged an extra time...
<span class="fc" id="L4385">                ASN1Primitive gnobj = generalName.toASN1Primitive();</span>
<span class="pc bpc" id="L4386" title="1 of 2 branches missed.">                if (gnobj instanceof ASN1TaggedObject) {</span>
<span class="fc" id="L4387">                  gnobj = ASN1TaggedObject.getInstance(gnobj).getObject();</span>
                }
<span class="fc" id="L4389">                final DERIA5String str = DERIA5String.getInstance(gnobj);</span>
<span class="pc bpc" id="L4390" title="1 of 2 branches missed.">                if (str != null) {</span>
<span class="fc" id="L4391">                  urls.add(str.getString());</span>
                }
<span class="pc bpc" id="L4393" title="1 of 2 branches missed.">                if (onlyfirst) {</span>
<span class="nc" id="L4394">                  return urls; // returning only the first URL</span>
                }
              }
            }
          }
        }
      }
    }
<span class="fc" id="L4402">    return urls;</span>
  }

  /**
   * @param cert cert
   * @param onlyfirst only return first result if true
   * @return all OCSP URL that is inside AuthorityInformationAccess extension or
   *     an empty list
   */
  private static List&lt;String&gt; getAuthorityInformationAccessOcspUrls(
      final Certificate cert, final boolean onlyfirst) {
<span class="fc" id="L4413">    final List&lt;String&gt; urls = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L4414" title="1 of 2 branches missed.">    if (cert instanceof X509Certificate) {</span>
<span class="fc" id="L4415">      final X509Certificate x509cert = (X509Certificate) cert;</span>
<span class="fc" id="L4416">      final ASN1Primitive obj =</span>
<span class="fc" id="L4417">          getExtensionValue(x509cert, Extension.authorityInfoAccess.getId());</span>
<span class="pc bpc" id="L4418" title="1 of 2 branches missed.">      if (obj != null) {</span>
<span class="fc" id="L4419">        final AccessDescription[] accessDescriptions =</span>
<span class="fc" id="L4420">            AuthorityInformationAccess.getInstance(obj).getAccessDescriptions();</span>
<span class="pc bpc" id="L4421" title="1 of 2 branches missed.">        if (accessDescriptions != null) {</span>
<span class="fc bfc" id="L4422" title="All 2 branches covered.">          for (final AccessDescription accessDescription : accessDescriptions) {</span>
            // OID 1.3.6.1.5.5.7.48.1: 2 times in Bouncy Castle
            // X509ObjectIdentifiers class.
            // X509ObjectIdentifiers.id_ad_ocsp =
            // X509ObjectIdentifiers.ocspAccessMethod
<span class="fc" id="L4427">            if (accessDescription</span>
<span class="fc" id="L4428">                .getAccessMethod()</span>
<span class="fc bfc" id="L4429" title="All 2 branches covered.">                .equals(X509ObjectIdentifiers.ocspAccessMethod)) {</span>
<span class="fc" id="L4430">              final GeneralName generalName =</span>
<span class="fc" id="L4431">                  accessDescription.getAccessLocation();</span>
<span class="pc bpc" id="L4432" title="1 of 2 branches missed.">              if (generalName.getTagNo()</span>
                  == GeneralName.uniformResourceIdentifier) {
                // After encoding in a cert, it is tagged an extra time...
<span class="fc" id="L4435">                ASN1Primitive gnobj = generalName.toASN1Primitive();</span>
<span class="pc bpc" id="L4436" title="1 of 2 branches missed.">                if (gnobj instanceof ASN1TaggedObject) {</span>
<span class="fc" id="L4437">                  gnobj = ASN1TaggedObject.getInstance(gnobj).getObject();</span>
                }
<span class="fc" id="L4439">                final DERIA5String str = DERIA5String.getInstance(gnobj);</span>
<span class="pc bpc" id="L4440" title="1 of 2 branches missed.">                if (str != null) {</span>
<span class="fc" id="L4441">                  urls.add(str.getString());</span>
                }
<span class="pc bpc" id="L4443" title="1 of 2 branches missed.">                if (onlyfirst) {</span>
<span class="nc" id="L4444">                  return urls; // returning only the first URL</span>
                }
              }
            }
          }
        }
      }
    }
<span class="fc" id="L4452">    return urls;</span>
  }

  /**
   * @param cert cert
   * @return PrivateKeyUsagePeriod extension from a certificate
   */
  public static PrivateKeyUsagePeriod getPrivateKeyUsagePeriod(
      final X509Certificate cert) {
<span class="fc" id="L4461">    PrivateKeyUsagePeriod res = null;</span>
<span class="fc" id="L4462">    final byte[] extvalue =</span>
<span class="fc" id="L4463">        cert.getExtensionValue(Extension.privateKeyUsagePeriod.getId());</span>
<span class="pc bpc" id="L4464" title="1 of 4 branches missed.">    if (extvalue != null &amp;&amp; extvalue.length &gt; 0) {</span>
<span class="pc bpc" id="L4465" title="1 of 2 branches missed.">      if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L4466">        LOGGER.trace(</span>
            &quot;Found a PrivateKeyUsagePeriod in the certificate with subject: &quot;
<span class="nc" id="L4468">                + cert.getSubjectDN().toString());</span>
      }
<span class="fc" id="L4470">      res =</span>
<span class="fc" id="L4471">          PrivateKeyUsagePeriod.getInstance(</span>
<span class="fc" id="L4472">              DEROctetString.getInstance(extvalue).getOctets());</span>
    }
<span class="fc" id="L4474">    return res;</span>
  }

  /**
   * @param cert An X509Certificate
   * @param oid An OID for an extension
   * @return an Extension ASN1Primitive from a certificate, or null
   */
  protected static ASN1Primitive getExtensionValue(
      final X509Certificate cert, final String oid) {
<span class="pc bpc" id="L4484" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L4485">      return null;</span>
    }
<span class="fc" id="L4487">    return getDerObjectFromByteArray(cert.getExtensionValue(oid));</span>
  }

  /**
   * @param crl an X509CRL
   * @param oid An OID for an extension
   * @return an Extension ASN1Primitive from a CRL
   */
  protected static ASN1Primitive getExtensionValue(
          final X509CRL crl, final String oid) {
<span class="nc bnc" id="L4497" title="All 4 branches missed.">    if (crl == null || oid == null) {</span>
<span class="nc" id="L4498">      return null;</span>
    }
<span class="nc" id="L4500">    return getDerObjectFromByteArray(crl.getExtensionValue(oid));</span>
  }

  /**
   * @param pkcs10CertificateRequest PKCS10 Request
   * @param oid OID
   * @return the PKCS#10's extension of the specified OID or null if no such
   *     extension exists
   */
  public static Extension getExtension(
      final PKCS10CertificationRequest pkcs10CertificateRequest,
      final String oid) {
<span class="nc bnc" id="L4512" title="All 4 branches missed.">    if (pkcs10CertificateRequest != null &amp;&amp; oid != null) {</span>
<span class="nc" id="L4513">      final Extensions extensions =</span>
<span class="nc" id="L4514">          getPKCS10Extensions(pkcs10CertificateRequest);</span>
<span class="nc bnc" id="L4515" title="All 2 branches missed.">      if (extensions != null) {</span>
<span class="nc" id="L4516">        return extensions.getExtension(new ASN1ObjectIdentifier(oid));</span>
      }
    }
<span class="nc" id="L4519">    return null;</span>
  }

  /**
   * @param pkcs10CertificateRequest PKCS10 request
   * @return the first found extensions or null if
   *     PKCSObjectIdentifiers.pkcs_9_at_extensionRequest was not present in the
   *     PKCS#10
   */
  private static Extensions getPKCS10Extensions(
      final PKCS10CertificationRequest pkcs10CertificateRequest) {
<span class="nc" id="L4530">    final Attribute[] attributes =</span>
<span class="nc" id="L4531">        pkcs10CertificateRequest.getAttributes(</span>
            PKCSObjectIdentifiers.pkcs_9_at_extensionRequest);
<span class="nc bnc" id="L4533" title="All 2 branches missed.">    for (final Attribute attribute : attributes) {</span>
<span class="nc" id="L4534">      final ASN1Set attributeValues = attribute.getAttrValues();</span>
<span class="nc bnc" id="L4535" title="All 2 branches missed.">      if (attributeValues.size() &gt; 0) {</span>
<span class="nc" id="L4536">        return Extensions.getInstance(attributeValues.getObjectAt(0));</span>
      }
    }
<span class="nc" id="L4539">    return null;</span>
  }

  private static ASN1Primitive getDerObjectFromByteArray(final byte[] bytes) {
<span class="fc bfc" id="L4543" title="All 2 branches covered.">    if (bytes == null) {</span>
<span class="fc" id="L4544">      return null;</span>
    }
    try {
<span class="fc" id="L4547">      return ASN1Primitive.fromByteArray(</span>
<span class="fc" id="L4548">          ASN1OctetString.getInstance(bytes).getOctets());</span>
<span class="nc" id="L4549">    } catch (final IOException e) {</span>
<span class="nc" id="L4550">      throw new RuntimeException(&quot;Caught an unexected IOException&quot;, e);</span>
    }
  }

  /**
   * Gets a URI string from a GeneralNames structure.
   *
   * @param names DER GeneralNames object, that is a sequence of DERTaggedObject
   * @return String with URI if tagNo is 6 (uniformResourceIdentifier), null
   *     otherwise
   */
  private static String getStringFromGeneralNames(final ASN1Primitive names) {
<span class="fc" id="L4562">    final ASN1Sequence namesSequence =</span>
<span class="fc" id="L4563">        ASN1Sequence.getInstance((ASN1TaggedObject) names, false);</span>
<span class="pc bpc" id="L4564" title="1 of 2 branches missed.">    if (namesSequence.size() == 0) {</span>
<span class="nc" id="L4565">      return null;</span>
    }
<span class="fc" id="L4567">    final DERTaggedObject taggedObject =</span>
<span class="fc" id="L4568">        (DERTaggedObject) namesSequence.getObjectAt(0);</span>
<span class="fc bfc" id="L4569" title="All 2 branches covered.">    if (taggedObject.getTagNo()</span>
        != GeneralName
            .uniformResourceIdentifier) { // uniformResourceIdentifier [6]
                                          // IA5String,
<span class="fc" id="L4573">      return null;</span>
    }
<span class="fc" id="L4575">    return new String(</span>
<span class="fc" id="L4576">        ASN1OctetString.getInstance(taggedObject, false).getOctets());</span>
  } // getStringFromGeneralNames

  /**
   * Generate SHA1 fingerprint of certificate in string representation.
   *
   * @param cert Certificate.
   * @return String containing hex format of SHA1 fingerprint (lower case), or
   *     null if input is null.
   */
  public static String getFingerprintAsString(final Certificate cert) {
<span class="pc bpc" id="L4587" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L4588">      return null;</span>
    }
    try {
<span class="fc" id="L4591">      final byte[] res = generateSHA1Fingerprint(cert.getEncoded());</span>

<span class="fc" id="L4593">      return new String(Hex.encode(res));</span>
<span class="nc" id="L4594">    } catch (final CertificateEncodingException cee) {</span>
<span class="nc" id="L4595">      LOGGER.error(&quot;Error encoding certificate.&quot;, cee);</span>
    }

<span class="nc" id="L4598">    return null;</span>
  }

  /**
   * Generate SHA1 fingerprint of CRL in string representation.
   *
   * @param crl X509CRL.
   * @return String containing hex format of SHA1 fingerprint.
   */
  public static String getFingerprintAsString(final X509CRL crl) {
    try {
<span class="nc" id="L4609">      final byte[] res = generateSHA1Fingerprint(crl.getEncoded());</span>

<span class="nc" id="L4611">      return new String(Hex.encode(res));</span>
<span class="nc" id="L4612">    } catch (final CRLException ce) {</span>
<span class="nc" id="L4613">      LOGGER.error(&quot;Error encoding CRL.&quot;, ce);</span>
    }

<span class="nc" id="L4616">    return null;</span>
  }

  /**
   * Generate SHA1 fingerprint of byte array in string representation.
   *
   * @param in byte array to fingerprint.
   * @return String containing hex format of SHA1 fingerprint.
   */
  public static String getFingerprintAsString(final byte[] in) {
<span class="fc" id="L4626">    final byte[] res = generateSHA1Fingerprint(in);</span>
<span class="fc" id="L4627">    return new String(Hex.encode(res));</span>
  }

  /**
   * Generate SHA256 fingerprint of byte array in string representation.
   *
   * @param in byte array to fingerprint.
   * @return String containing hex format of SHA256 fingerprint.
   */
  public static String getSHA256FingerprintAsString(final byte[] in) {
<span class="nc" id="L4637">    final byte[] res = generateSHA256Fingerprint(in);</span>
<span class="nc" id="L4638">    return new String(Hex.encode(res));</span>
  }

  /**
   * Generate a SHA1 fingerprint from a byte array containing a certificate.
   *
   * @param ba Byte array containing DER encoded Certificate or CRL.
   * @return Byte array containing SHA1 hash of DER encoded certificate.
   */
  public static byte[] generateSHA1Fingerprint(final byte[] ba) {
    // log.trace(&quot;&gt;generateSHA1Fingerprint&quot;);
    try {
<span class="fc" id="L4650">      final MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;);</span>
<span class="fc" id="L4651">      return md.digest(ba);</span>
<span class="nc" id="L4652">    } catch (final NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L4653">      LOGGER.error(&quot;SHA1 algorithm not supported&quot;, nsae);</span>
    }
    // log.trace(&quot;&lt;generateSHA1Fingerprint&quot;);
<span class="nc" id="L4656">    return null;</span>
  } // generateSHA1Fingerprint

  /**
   * Generate a SHA256 fingerprint from a byte array containing a certificate.
   *
   * @param ba Byte array containing DER encoded Certificate or CRL.
   * @return Byte array containing SHA256 hash of DER encoded certificate.
   */
  public static byte[] generateSHA256Fingerprint(final byte[] ba) {
    try {
<span class="nc" id="L4667">      final MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="nc" id="L4668">      return md.digest(ba);</span>
<span class="nc" id="L4669">    } catch (final NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L4670">      LOGGER.error(&quot;SHA-256 algorithm not supported&quot;, nsae);</span>
    }
<span class="nc" id="L4672">    return null;</span>
  } // generateSHA256Fingerprint

  /**
   * Generate a MD5 fingerprint from a byte array containing a certificate.
   *
   * @param ba Byte array containing DER encoded Certificate.
   * @return Byte array containing MD5 hash of DER encoded certificate (raw
   *     binary hash).
   */
  public static byte[] generateMD5Fingerprint(final byte[] ba) {
    try {
<span class="fc" id="L4684">      final MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="fc" id="L4685">      return md.digest(ba);</span>
<span class="nc" id="L4686">    } catch (final NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L4687">      LOGGER.error(&quot;MD5 algorithm not supported&quot;, nsae);</span>
    }

<span class="nc" id="L4690">    return null;</span>
  } // generateMD5Fingerprint

  /**
   * Converts Sun Key usage bits to Bouncy castle key usage kits.
   *
   * @param sku key usage bit fields according to
   *     java.security.cert.X509Certificate#getKeyUsage, must be a boolean aray
   *     of size 9.
   * @return key usage int according to
   *     org.bouncycastle.jce.X509KeyUsage#X509KeyUsage, or -1 if input is null.
   * @see java.security.cert.X509Certificate#getKeyUsage
   * @see org.bouncycastle.jce.X509KeyUsage#X509KeyUsage
   */
  public static int sunKeyUsageToBC(final boolean[] sku) {
<span class="nc bnc" id="L4705" title="All 2 branches missed.">    if (sku == null) {</span>
<span class="nc" id="L4706">      return -1;</span>
    }
<span class="nc" id="L4708">    int bcku = 0;</span>
<span class="nc bnc" id="L4709" title="All 2 branches missed.">    if (sku[0]) {</span>
<span class="nc" id="L4710">      bcku = bcku | X509KeyUsage.digitalSignature;</span>
    }
<span class="nc bnc" id="L4712" title="All 2 branches missed.">    if (sku[1]) {</span>
<span class="nc" id="L4713">      bcku = bcku | X509KeyUsage.nonRepudiation;</span>
    }
<span class="nc bnc" id="L4715" title="All 2 branches missed.">    if (sku[2]) {</span>
<span class="nc" id="L4716">      bcku = bcku | X509KeyUsage.keyEncipherment;</span>
    }
<span class="nc bnc" id="L4718" title="All 2 branches missed.">    if (sku[3]) {</span>
<span class="nc" id="L4719">      bcku = bcku | X509KeyUsage.dataEncipherment;</span>
    }
<span class="nc bnc" id="L4721" title="All 2 branches missed.">    if (sku[4]) {</span>
<span class="nc" id="L4722">      bcku = bcku | X509KeyUsage.keyAgreement;</span>
    }
<span class="nc bnc" id="L4724" title="All 2 branches missed.">    if (sku[5]) {</span>
<span class="nc" id="L4725">      bcku = bcku | X509KeyUsage.keyCertSign;</span>
    }
<span class="nc bnc" id="L4727" title="All 2 branches missed.">    if (sku[6]) {</span>
<span class="nc" id="L4728">      bcku = bcku | X509KeyUsage.cRLSign;</span>
    }
<span class="nc bnc" id="L4730" title="All 2 branches missed.">    if (sku[7]) {</span>
<span class="nc" id="L4731">      bcku = bcku | X509KeyUsage.encipherOnly;</span>
    }
<span class="nc bnc" id="L4733" title="All 2 branches missed.">    if (sku[8]) {</span>
<span class="nc" id="L4734">      bcku = bcku | X509KeyUsage.decipherOnly;</span>
    }
<span class="nc" id="L4736">    return bcku;</span>
  }

  /**
   * Converts DERBitString ResonFlags to a RevokedCertInfo constant.
   *
   * @param reasonFlags DERBITString received from
   *     org.bouncycastle.asn1.x509.ReasonFlags.
   * @return int according to org.cesecore.certificates.crl.RevokedCertInfo
   */
  public static int bitStringToRevokedCertInfo(final DERBitString reasonFlags) {
<span class="nc" id="L4747">    int ret = RevokedCertInfo.REVOCATION_REASON_UNSPECIFIED;</span>
<span class="nc bnc" id="L4748" title="All 2 branches missed.">    if (reasonFlags == null) {</span>
<span class="nc" id="L4749">      return ret;</span>
    }
<span class="nc" id="L4751">    final int val = reasonFlags.intValue();</span>
<span class="nc bnc" id="L4752" title="All 2 branches missed.">    if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L4753">      LOGGER.debug(&quot;Int value of bitString revocation reason: &quot; + val);</span>
    }
<span class="nc bnc" id="L4755" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.aACompromise) != 0) {</span>
<span class="nc" id="L4756">      ret = RevokedCertInfo.REVOCATION_REASON_AACOMPROMISE;</span>
    }
<span class="nc bnc" id="L4758" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.affiliationChanged) != 0) {</span>
<span class="nc" id="L4759">      ret = RevokedCertInfo.REVOCATION_REASON_AFFILIATIONCHANGED;</span>
    }
<span class="nc bnc" id="L4761" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.cACompromise) != 0) {</span>
<span class="nc" id="L4762">      ret = RevokedCertInfo.REVOCATION_REASON_CACOMPROMISE;</span>
    }
<span class="nc bnc" id="L4764" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.certificateHold) != 0) {</span>
<span class="nc" id="L4765">      ret = RevokedCertInfo.REVOCATION_REASON_CERTIFICATEHOLD;</span>
    }
<span class="nc bnc" id="L4767" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.cessationOfOperation) != 0) {</span>
<span class="nc" id="L4768">      ret = RevokedCertInfo.REVOCATION_REASON_CESSATIONOFOPERATION;</span>
    }
<span class="nc bnc" id="L4770" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.keyCompromise) != 0) {</span>
<span class="nc" id="L4771">      ret = RevokedCertInfo.REVOCATION_REASON_KEYCOMPROMISE;</span>
    }
<span class="nc bnc" id="L4773" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.privilegeWithdrawn) != 0) {</span>
<span class="nc" id="L4774">      ret = RevokedCertInfo.REVOCATION_REASON_PRIVILEGESWITHDRAWN;</span>
    }
<span class="nc bnc" id="L4776" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.superseded) != 0) {</span>
<span class="nc" id="L4777">      ret = RevokedCertInfo.REVOCATION_REASON_SUPERSEDED;</span>
    }
<span class="nc bnc" id="L4779" title="All 2 branches missed.">    if ((val &amp; ReasonFlags.unused) != 0) {</span>
<span class="nc" id="L4780">      ret = RevokedCertInfo.REVOCATION_REASON_UNSPECIFIED;</span>
    }
<span class="nc" id="L4782">    return ret;</span>
  }

  /**
   * Method used to insert a CN postfix into DN by extracting the first found CN
   * appending cnpostfix and then replacing the original CN with the new one in
   * DN.
   *
   * &lt;p&gt;If no CN could be found in DN then should the given DN be returned
   * untouched
   *
   * @param dn the DN to manipulate, cannot be null
   * @param cnpostfix the postfix to insert, cannot be null
   * @param nameStyle Controls how the name is encoded. Usually it should be a
   *     CeSecoreNameStyle.
   * @return the new DN
   */
  public static String insertCNPostfix(
      final String dn, final String cnpostfix, final X500NameStyle nameStyle) {
<span class="pc bpc" id="L4801" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L4802">      LOGGER.trace(&quot;&gt;insertCNPostfix: dn=&quot; + dn + &quot;, cnpostfix=&quot; + cnpostfix);</span>
    }
<span class="pc bpc" id="L4804" title="1 of 2 branches missed.">    if (dn == null) {</span>
<span class="nc" id="L4805">      return null;</span>
    }
<span class="fc" id="L4807">    final RDN[] rdns = IETFUtils.rDNsFromString(dn, nameStyle);</span>
<span class="fc" id="L4808">    final X500NameBuilder nameBuilder = new X500NameBuilder(nameStyle);</span>
<span class="fc" id="L4809">    boolean replaced = false;</span>
<span class="fc bfc" id="L4810" title="All 2 branches covered.">    for (final RDN rdn : rdns) {</span>
<span class="fc" id="L4811">      final AttributeTypeAndValue[] attributeTypeAndValues =</span>
<span class="fc" id="L4812">          rdn.getTypesAndValues();</span>
<span class="fc bfc" id="L4813" title="All 2 branches covered.">      for (final AttributeTypeAndValue atav : attributeTypeAndValues) {</span>
<span class="pc bpc" id="L4814" title="1 of 2 branches missed.">        if (atav.getType() != null) {</span>
<span class="fc" id="L4815">          final String currentSymbol =</span>
<span class="fc" id="L4816">              CeSecoreNameStyle.DEFAULT_SYMBOLS.get(atav.getType());</span>
<span class="fc bfc" id="L4817" title="All 4 branches covered.">          if (!replaced &amp;&amp; &quot;CN&quot;.equals(currentSymbol)) {</span>
<span class="fc" id="L4818">            nameBuilder.addRDN(</span>
<span class="fc" id="L4819">                atav.getType(),</span>
<span class="fc" id="L4820">                IETFUtils.valueToString(atav.getValue()) + cnpostfix);</span>
<span class="fc" id="L4821">            replaced = true;</span>
          } else {
<span class="fc" id="L4823">            nameBuilder.addRDN(atav);</span>
          }
        }
      }
    }
<span class="fc" id="L4828">    final String ret = nameBuilder.build().toString();</span>
<span class="pc bpc" id="L4829" title="1 of 2 branches missed.">    if (LOGGER.isTraceEnabled()) {</span>
<span class="nc" id="L4830">      LOGGER.trace(&quot;&lt;reverseDN: &quot; + ret);</span>
    }
<span class="fc" id="L4832">    return ret;</span>
  }

  /**
   * Splits a DN into components.
   *
   * @param dn DN
   * @return DN components
   * @see X509NameTokenizer
   */
  public static List&lt;String&gt; getX500NameComponents(final String dn) {
<span class="nc" id="L4843">    final List&lt;String&gt; ret = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L4844">    final X509NameTokenizer tokenizer = new X509NameTokenizer(dn);</span>
<span class="nc bnc" id="L4845" title="All 2 branches missed.">    while (tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L4846">      ret.add(tokenizer.nextToken());</span>
    }
<span class="nc" id="L4848">    return ret;</span>
  }

  /**
   * Returns the parent DN of a DN string, e.g. if the input is
   * &quot;cn=User,dc=example,dc=com&quot; then it would return &quot;dc=example,dc=com&quot;.
   * Returns an empty string if there is no parent DN.
   *
   * @param dn DN
   * @return Parent DN
   */
  public static String getParentDN(final String dn) {
<span class="nc" id="L4860">    final X509NameTokenizer tokenizer = new X509NameTokenizer(dn);</span>
<span class="nc" id="L4861">    tokenizer.nextToken();</span>
<span class="nc" id="L4862">    return tokenizer.getRemainingString();</span>
  }

  /**
   * class for breaking up an X500 Name into it's component tokens, ala
   * java.util.StringTokenizer.
   */
  private static class X509NameTokenizer {
      /** Value. */
    private final String value;
    /** Index. */
    private int index;
    /** Sep. */
    private final char separator;
    /** Buffer. */
<span class="fc" id="L4877">    private final StringBuffer buf = new StringBuffer();</span>

    /**
     * Creates the object, using the default comma (,) as separator for
     * tokenization.
     *
     * @param oid OID
     */
    X509NameTokenizer(final String oid) {
<span class="fc" id="L4886">      this(oid, ',');</span>
<span class="fc" id="L4887">    }</span>

<span class="fc" id="L4889">    X509NameTokenizer(final String oid, final char aSeparator) {</span>
<span class="fc" id="L4890">      this.value = oid;</span>
<span class="fc" id="L4891">      this.index = -1;</span>
<span class="fc" id="L4892">      this.separator = aSeparator;</span>
<span class="fc" id="L4893">    }</span>

    public boolean hasMoreTokens() {
<span class="fc bfc" id="L4896" title="All 2 branches covered.">      return (index != value.length());</span>
    }

    public String nextToken() {
<span class="pc bpc" id="L4900" title="1 of 2 branches missed.">      if (index == value.length()) {</span>
<span class="nc" id="L4901">        return null;</span>
      }

<span class="fc" id="L4904">      int end = index + 1;</span>
<span class="fc" id="L4905">      boolean quoted = false;</span>
<span class="fc" id="L4906">      boolean escaped = false;</span>

<span class="fc" id="L4908">      buf.setLength(0);</span>

<span class="fc bfc" id="L4910" title="All 2 branches covered.">      while (end != value.length()) {</span>
<span class="fc" id="L4911">        final char c = value.charAt(end);</span>

<span class="fc bfc" id="L4913" title="All 2 branches covered.">        if (c == '&quot;') {</span>
<span class="fc bfc" id="L4914" title="All 2 branches covered.">          if (!escaped) {</span>
<span class="fc bfc" id="L4915" title="All 2 branches covered.">            quoted = !quoted;</span>
          } else {
<span class="pc bpc" id="L4917" title="3 of 4 branches missed.">            if (c == '#' &amp;&amp; buf.charAt(buf.length() - 1) == '=') {</span>
<span class="nc" id="L4918">              buf.append('\\');</span>
<span class="pc bpc" id="L4919" title="3 of 4 branches missed.">            } else if (c == '+' &amp;&amp; separator != '+') {</span>
<span class="nc" id="L4920">              buf.append('\\');</span>
            }
<span class="fc" id="L4922">            buf.append(c);</span>
          }
<span class="fc" id="L4924">          escaped = false;</span>
        } else {
<span class="fc bfc" id="L4926" title="All 4 branches covered.">          if (escaped || quoted) {</span>
<span class="pc bpc" id="L4927" title="1 of 4 branches missed.">            if (c == '#' &amp;&amp; buf.charAt(buf.length() - 1) == '=') {</span>
<span class="fc" id="L4928">              buf.append('\\');</span>
<span class="pc bpc" id="L4929" title="1 of 4 branches missed.">            } else if (c == '+' &amp;&amp; separator != '+') {</span>
<span class="fc" id="L4930">              buf.append('\\');</span>
            }
<span class="fc" id="L4932">            buf.append(c);</span>
<span class="fc" id="L4933">            escaped = false;</span>
<span class="fc bfc" id="L4934" title="All 2 branches covered.">          } else if (c == '\\') {</span>
<span class="fc" id="L4935">            escaped = true;</span>
<span class="fc bfc" id="L4936" title="All 2 branches covered.">          } else if (c == separator) {</span>
<span class="fc" id="L4937">            break;</span>
          } else {
<span class="fc" id="L4939">            buf.append(c);</span>
          }
        }
<span class="fc" id="L4942">        end++;</span>
<span class="fc" id="L4943">      }</span>

<span class="fc" id="L4945">      index = end;</span>
<span class="fc" id="L4946">      return buf.toString().trim();</span>
    }

    /** @return the remaining (not yet tokenized) part of the DN. */
    String getRemainingString() {
<span class="nc bnc" id="L4951" title="All 2 branches missed.">      return index + 1 &lt; value.length() ? value.substring(index + 1) : &quot;&quot;;</span>
    }
  }

  /**
   * class for breaking up an X500 Name into it's component tokens, ala
   * java.util.StringTokenizer. Taken from BouncyCastle, but does NOT use or
   * consider escaped characters. Used for reversing DNs without unescaping.
   */
  private static class BasicX509NameTokenizer {
      /** OID. */
    private final String oid;
    /** Index. */
<span class="fc" id="L4964">    private int index = -1;</span>
    /**
     * Since this class isn't thread safe anyway, we can use the slightly faster
     * StringBuilder instead of StringBuffer.
     */
<span class="fc" id="L4969">    private final StringBuilder buf = new StringBuilder();</span>

<span class="fc" id="L4971">    BasicX509NameTokenizer(final String anOid) {</span>
<span class="fc" id="L4972">      this.oid = anOid;</span>
<span class="fc" id="L4973">    }</span>

    public boolean hasMoreTokens() {
<span class="fc bfc" id="L4976" title="All 2 branches covered.">      return (index != oid.length());</span>
    }

    public String nextToken() {
<span class="pc bpc" id="L4980" title="1 of 2 branches missed.">      if (index == oid.length()) {</span>
<span class="nc" id="L4981">        return null;</span>
      }

<span class="fc" id="L4984">      int end = index + 1;</span>
<span class="fc" id="L4985">      boolean quoted = false;</span>
<span class="fc" id="L4986">      boolean escaped = false;</span>

<span class="fc" id="L4988">      buf.setLength(0);</span>

<span class="fc bfc" id="L4990" title="All 2 branches covered.">      while (end != oid.length()) {</span>
<span class="fc" id="L4991">        final char c = oid.charAt(end);</span>

<span class="fc bfc" id="L4993" title="All 2 branches covered.">        if (c == '&quot;') {</span>
<span class="pc bpc" id="L4994" title="1 of 2 branches missed.">          if (!escaped) {</span>
<span class="fc" id="L4995">            buf.append(c);</span>
<span class="fc" id="L4996">            quoted ^= true; // Faster than &quot;quoted = !quoted;&quot;</span>
          } else {
<span class="nc" id="L4998">            buf.append(c);</span>
          }
<span class="fc" id="L5000">          escaped = false;</span>
        } else {
<span class="fc bfc" id="L5002" title="All 4 branches covered.">          if (escaped || quoted) {</span>
<span class="fc" id="L5003">            buf.append(c);</span>
<span class="fc" id="L5004">            escaped = false;</span>
<span class="fc bfc" id="L5005" title="All 2 branches covered.">          } else if (c == '\\') {</span>
<span class="fc" id="L5006">            buf.append(c);</span>
<span class="fc" id="L5007">            escaped = true;</span>
<span class="pc bpc" id="L5008" title="1 of 4 branches missed.">          } else if ((c == ',') &amp;&amp; (!escaped)) {</span>
<span class="fc" id="L5009">            break;</span>
          } else {
<span class="fc" id="L5011">            buf.append(c);</span>
          }
        }
<span class="fc" id="L5014">        end++;</span>
<span class="fc" id="L5015">      }</span>

<span class="fc" id="L5017">      index = end;</span>
<span class="fc" id="L5018">      return buf.toString().trim();</span>
    }
  } // BasicX509NameTokenizer

  /**
   * Obtains a List with the ASN1ObjectIdentifiers for dNObjects names, in the
   * specified order.
   *
   * @param order an array of DN objects.
   * @return a List with ASN1ObjectIdentifiers defining the known order we
   *     require
   * @see org.cesecore.certificates.util.DnComponents#getDnObjects(boolean) for
   *     definition of the contents of the input array
   */
  private static List&lt;ASN1ObjectIdentifier&gt; getX509FieldOrder(
          final String[] order) {
<span class="fc" id="L5034">    final List&lt;ASN1ObjectIdentifier&gt; fieldOrder =</span>
        new ArrayList&lt;ASN1ObjectIdentifier&gt;();
<span class="fc bfc" id="L5036" title="All 2 branches covered.">    for (final String dNObject : order) {</span>
<span class="fc" id="L5037">      fieldOrder.add(DnComponents.getOid(dNObject));</span>
    }
<span class="fc" id="L5039">    return fieldOrder;</span>
  }
  /**
   * Obtains a List with the ASN1ObjectIdentifiers for dNObjects names, in the
   * specified pre-defined order.
   *
   * @param ldaporder if true the returned order are as defined in LDAP RFC
   *     (CN=foo,O=bar,C=SE), otherwise the order is a defined in X.500
   *     (C=SE,O=bar,CN=foo).
   * @return a List with ASN1ObjectIdentifiers defining the known order we
   *     require
   * @see org.cesecore.certificates.util.DnComponents#getDnObjects(boolean)
   */
  public static List&lt;ASN1ObjectIdentifier&gt; getX509FieldOrder(
      final boolean ldaporder) {
<span class="fc" id="L5054">    return getX509FieldOrder(DnComponents.getDnObjects(ldaporder));</span>
  }

  /**
   * EJBCA accepts extension OIDs on different formats, e.g. &quot;1.2.3.4&quot; and
   * &quot;1.2.3.4.value&quot;. Method returns the OID only given any OID string
   *
   * @param oidString to parse
   * @return String containing OID only
   */
  public static String getOidFromString(final String oidString) {
<span class="fc" id="L5065">    String retval = oidString;</span>
    // Matches anything but numerical and dots
<span class="fc" id="L5067">    final Pattern pattern = Pattern.compile(&quot;[^0-9.]&quot;);</span>
<span class="fc" id="L5068">    final Matcher matcher = pattern.matcher(oidString);</span>
<span class="pc bpc" id="L5069" title="1 of 2 branches missed.">    if (matcher.find()) {</span>
<span class="fc" id="L5070">      final int endIndex = matcher.start();</span>
<span class="fc" id="L5071">      retval = oidString.substring(0, endIndex - 1);</span>
    }
<span class="fc" id="L5073">    return retval;</span>
  }

  /**
   * Returns the regex match pattern given an OID wildcard.
   *
   * @param oidWildcard wildcard. E.g. 1.2.*.3
   * @return regex match pattern
   */
  public static String getOidWildcardPattern(final String oidWildcard) {
    // First escape all '.' which are interpreted as regex wildcards themselves.
    // Secondly, generate the pattern where '*' is the wildcard character
<span class="fc" id="L5085">    final String wildcardMatchPattern =</span>
<span class="fc" id="L5086">        oidWildcard.replaceAll(&quot;\\.&quot;, &quot;\\\\.&quot;).replaceAll(&quot;\\*&quot;, &quot;([0-9.]*)&quot;);</span>
<span class="fc" id="L5087">    return wildcardMatchPattern;</span>
  }

  /**
   * Obtain a X500Name reordered, if some fields from original X500Name doesn't
   * appear in &quot;ordering&quot; parameter, they will be added at end in the original
   * order.
   *
   * @param x500Name the X500Name that is unordered
   * @param ldaporder true if LDAP ordering of DN should be used (default in
   *     EJBCA), false for X.500 order, ldap order is CN=A,OU=B,O=C,C=SE, x.500
   *     order is the reverse
   * @param order specified order, which overrides 'ldaporder', care must be
   *     taken constructing this String array, ignored if null or empty
   * @param applyLdapToCustomOrder specifies if the ldaporder setting should
   *     apply to an order (custom order) if this is not empty
   * @param nameStyle Controls how the name is encoded. Usually it should be a
   *     CeSecoreNameStyle.
   * @return X500Name with ordered conmponents according to the orcering vector
   */
  private static X500Name getOrderedX500Name(
      final X500Name x500Name,
      final boolean ldaporder,
      final String[] order,
      final boolean applyLdapToCustomOrder,
      final X500NameStyle nameStyle) {
    // -- New order for the X509 Fields
<span class="fc" id="L5114">    final List&lt;ASN1ObjectIdentifier&gt; newOrdering =</span>
        new ArrayList&lt;ASN1ObjectIdentifier&gt;();
<span class="fc" id="L5116">    final List&lt;ASN1Encodable&gt; newValues = new ArrayList&lt;ASN1Encodable&gt;();</span>
    // -- Add ordered fields
<span class="fc" id="L5118">    final ASN1ObjectIdentifier[] allOids = x500Name.getAttributeTypes();</span>

    // Guess order of the input name
<span class="fc bfc" id="L5121" title="All 2 branches covered.">    final boolean isLdapOrder = !isDNReversed(x500Name.toString());</span>
    // If we think the DN is in LDAP order, first order it as a LDAP DN, if we
    // don't think it's LDAP order
    // order it as a X.500 DN. If we haven't specified our own ordering
    final List&lt;ASN1ObjectIdentifier&gt; ordering;
<span class="pc bpc" id="L5126" title="1 of 4 branches missed.">    final boolean useCustomOrder = (order != null) &amp;&amp; (order.length &gt; 0);</span>
<span class="fc bfc" id="L5127" title="All 2 branches covered.">    if (useCustomOrder) {</span>
<span class="fc" id="L5128">      LOGGER.debug(&quot;Using custom DN order&quot;);</span>
<span class="fc" id="L5129">      ordering = getX509FieldOrder(order);</span>
    } else {
<span class="fc" id="L5131">      ordering = getX509FieldOrder(isLdapOrder);</span>
    }

<span class="fc" id="L5134">    final HashSet&lt;ASN1ObjectIdentifier&gt; hs =</span>
<span class="fc" id="L5135">        new HashSet&lt;ASN1ObjectIdentifier&gt;(allOids.length + ordering.size());</span>
<span class="fc bfc" id="L5136" title="All 2 branches covered.">    for (final ASN1ObjectIdentifier oid : ordering) {</span>
<span class="fc bfc" id="L5137" title="All 2 branches covered.">      if (!hs.contains(oid)) {</span>
<span class="fc" id="L5138">        hs.add(oid);</span>
<span class="fc" id="L5139">        final RDN[] valueList = x500Name.getRDNs(oid);</span>
        // -- Only add the OID if has not null value
<span class="fc bfc" id="L5141" title="All 2 branches covered.">        for (final RDN value : valueList) {</span>
<span class="fc" id="L5142">          newOrdering.add(oid);</span>
<span class="fc" id="L5143">          newValues.add(value.getFirst().getValue());</span>
        }
      }
<span class="fc" id="L5146">    }</span>
    // -- Add unexpected fields to the end
<span class="fc bfc" id="L5148" title="All 2 branches covered.">    for (final ASN1ObjectIdentifier oid : allOids) {</span>
<span class="fc bfc" id="L5149" title="All 2 branches covered.">      if (!hs.contains(oid)) {</span>
<span class="fc" id="L5150">        hs.add(oid);</span>
<span class="fc" id="L5151">        final RDN[] valueList = x500Name.getRDNs(oid);</span>
        // -- Only add the OID if has not null value
<span class="fc bfc" id="L5153" title="All 2 branches covered.">        for (final RDN value : valueList) {</span>
<span class="fc" id="L5154">          newOrdering.add(oid);</span>
<span class="fc" id="L5155">          newValues.add(value.getFirst().getValue());</span>
<span class="pc bpc" id="L5156" title="1 of 2 branches missed.">          if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L5157">            LOGGER.debug(&quot;added --&gt; &quot; + oid + &quot; val: &quot; + value);</span>
          }
        }
      }
    }
    // If the requested ordering was the reverse of the ordering the input
    // string was in (by our guess in the beginning)
    // we have to reverse the vectors.
    // Unless we have specified a custom order, and choose to not apply LDAP
    // Order to this custom order, in which case we will not change the order
    // from the custom
<span class="fc bfc" id="L5168" title="All 6 branches covered.">    if ((useCustomOrder &amp;&amp; applyLdapToCustomOrder) || !useCustomOrder) {</span>
<span class="fc bfc" id="L5169" title="All 2 branches covered.">      if (ldaporder != isLdapOrder) {</span>
<span class="pc bpc" id="L5170" title="1 of 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L5171">          LOGGER.debug(</span>
              &quot;Reversing order of DN, ldaporder=&quot;
                  + ldaporder
                  + &quot;, isLdapOrder=&quot;
                  + isLdapOrder);
        }
<span class="fc" id="L5177">        Collections.reverse(newOrdering);</span>
<span class="fc" id="L5178">        Collections.reverse(newValues);</span>
      }
    }

<span class="fc" id="L5182">    final X500NameBuilder nameBuilder = new X500NameBuilder(nameStyle);</span>
<span class="fc bfc" id="L5183" title="All 2 branches covered.">    for (int i = 0; i &lt; newOrdering.size(); i++) {</span>
<span class="fc" id="L5184">      nameBuilder.addRDN(newOrdering.get(i), newValues.get(i));</span>
    }
    // -- Return X500Name with the ordered fields
<span class="fc" id="L5187">    return nameBuilder.build();</span>
  } //

  /**
   * Obtain the directory string for the directoryName generation form the
   * Subject Alternative Name String.
   *
   * @param altName name
   * @return directory
   */
  private static String getDirectoryStringFromAltName(final String altName) {
<span class="fc" id="L5198">    final String directoryName =</span>
<span class="fc" id="L5199">        CertTools.getPartFromDN(altName, CertTools.DIRECTORYNAME);</span>
    // DNFieldExtractor dnfe = new DNFieldExtractor(altName,
    // DNFieldExtractor.TYPE_SUBJECTALTNAME);
    // String directoryName = dnfe.getField(DNFieldExtractor.DIRECTORYNAME, 0);
    /* TODO: Validate or restrict the directoryName Fields? */
<span class="pc bpc" id="L5204" title="1 of 2 branches missed.">    return (&quot;&quot;.equals(directoryName) ? null : directoryName);</span>
  } // getDirectoryStringFromAltName

  /**
   * Method to create certificate path and to check it's validity from a list of
   * certificates. The list of certificates should only contain one root
   * certificate. The created certificate chain is checked to be valid at the
   * current date and time.
   *
   * @param certlistin List of certificates to create certificate chain from.
   * @return the certificatepath with the root CA at the end
   * @throws CertPathValidatorException if the certificate chain can not be
   *     constructed or validated
   * @throws InvalidAlgorithmParameterException If params are invalid
   * @throws NoSuchProviderException If provider not found
   * @throws NoSuchAlgorithmException If algorithm not found
   * @throws CertificateException If certificate cannot be parsed
   */
  public static List&lt;Certificate&gt; createCertChain(
          final Collection&lt;?&gt; certlistin)
      throws CertPathValidatorException, InvalidAlgorithmParameterException,
          NoSuchAlgorithmException, NoSuchProviderException,
          CertificateException {
<span class="fc" id="L5227">    return createCertChain(certlistin, new Date());</span>
  }

  /**
   * Method to create certificate path and to check it's validity from a list of
   * certificates. The list of certificates should only contain one root
   * certificate.
   *
   * @param certlistin List of certificates (X.509, CVC, or other supported) to
   *     create certificate chain from.
   * @param now Date to use when checking if the CAs chain is valid.
   * @return the certificate path with the root CA at the end
   * @throws CertPathValidatorException if the certificate chain can not be
   *     constructed
   * @throws InvalidAlgorithmParameterException If params are invalid
   * @throws NoSuchProviderException If provider not found
   * @throws NoSuchAlgorithmException If algorithm not found
   * @throws CertificateException If certificate cannot be parsed
   */
  public static List&lt;Certificate&gt; createCertChain(
      final Collection&lt;?&gt; certlistin, final Date now)
      throws CertPathValidatorException, InvalidAlgorithmParameterException,
          NoSuchAlgorithmException, NoSuchProviderException,
          CertificateException {
<span class="fc" id="L5251">    final List&lt;Certificate&gt; returnval = new ArrayList&lt;Certificate&gt;();</span>

<span class="fc" id="L5253">    final Collection&lt;Certificate&gt; certlist = orderCertificateChain(certlistin);</span>
    // Verify that the chain contains a Root CA certificate
<span class="fc" id="L5255">    Certificate rootca = null;</span>
<span class="fc bfc" id="L5256" title="All 2 branches covered.">    for (final Certificate crt : certlist) {</span>
<span class="fc bfc" id="L5257" title="All 2 branches covered.">      if (CertTools.isSelfSigned(crt)) {</span>
<span class="fc" id="L5258">        rootca = crt;</span>
      }
<span class="fc" id="L5260">    }</span>
<span class="pc bpc" id="L5261" title="1 of 2 branches missed.">    if (rootca == null) {</span>
<span class="nc" id="L5262">      throw new CertPathValidatorException(</span>
          &quot;No root CA certificate found in certificate list&quot;);
    }

    // set certificate chain
<span class="fc" id="L5267">    Certificate rootcert = null;</span>
<span class="fc" id="L5268">    final ArrayList&lt;Certificate&gt; calist = new ArrayList&lt;Certificate&gt;();</span>
<span class="fc bfc" id="L5269" title="All 2 branches covered.">    for (final Certificate next : certlist) {</span>
<span class="fc bfc" id="L5270" title="All 2 branches covered.">      if (CertTools.isSelfSigned(next)) {</span>
<span class="fc" id="L5271">        rootcert = next;</span>
      } else {
<span class="fc" id="L5273">        calist.add(next);</span>
      }
<span class="fc" id="L5275">    }</span>

<span class="pc bpc" id="L5277" title="1 of 2 branches missed.">    if (calist.isEmpty()) {</span>
      // only one root cert, no certchain
<span class="nc" id="L5279">      returnval.add(rootcert);</span>
    } else {
      // We need a bit special handling for CV certificates because those can
      // not be handled using a PKIX CertPathValidator
<span class="fc" id="L5283">      final Certificate test = calist.get(0);</span>
<span class="fc bfc" id="L5284" title="All 2 branches covered.">      if (test.getType().equals(&quot;CVC&quot;)) {</span>
<span class="pc bpc" id="L5285" title="1 of 2 branches missed.">        if (calist.size() == 1) {</span>
<span class="fc" id="L5286">          returnval.add(test);</span>
<span class="fc" id="L5287">          returnval.add(rootcert);</span>
        } else {
<span class="nc" id="L5289">          throw new CertPathValidatorException(</span>
              &quot;CVC certificate chain can not be of length longer than two.&quot;);
        }
      } else {
        // Normal X509 certificates
<span class="fc" id="L5294">        final HashSet&lt;TrustAnchor&gt; trustancors = new HashSet&lt;TrustAnchor&gt;();</span>
<span class="fc" id="L5295">        TrustAnchor trustanchor = null;</span>
<span class="fc" id="L5296">        trustanchor = new TrustAnchor((X509Certificate) rootcert, null);</span>
<span class="fc" id="L5297">        trustancors.add(trustanchor);</span>

        // Create the parameters for the validator
<span class="fc" id="L5300">        final PKIXParameters params = new PKIXParameters(trustancors);</span>

        // Disable CRL checking since we are not supplying any CRLs
<span class="fc" id="L5303">        params.setRevocationEnabled(false);</span>
<span class="fc" id="L5304">        params.setDate(now);</span>

        // Create the validator and validate the path
        final CertPathValidator certPathValidator =
<span class="fc" id="L5308">            CertPathValidator.getInstance(</span>
<span class="fc" id="L5309">                CertPathValidator.getDefaultType(), &quot;BC&quot;);</span>
<span class="fc" id="L5310">        final CertificateFactory fact = CertTools.getCertificateFactory();</span>
<span class="fc" id="L5311">        final CertPath certpath = fact.generateCertPath(calist);</span>

<span class="fc" id="L5313">        final CertPathValidatorResult result =</span>
<span class="fc" id="L5314">            certPathValidator.validate(certpath, params);</span>

        // Get the certificates validate in the path
<span class="fc" id="L5317">        final PKIXCertPathValidatorResult pkixResult =</span>
            (PKIXCertPathValidatorResult) result;
<span class="fc" id="L5319">        returnval.addAll(certpath.getCertificates());</span>

        // Get the CA used to validate this path
<span class="fc" id="L5322">        final TrustAnchor ta = pkixResult.getTrustAnchor();</span>
<span class="fc" id="L5323">        final X509Certificate cert = ta.getTrustedCert();</span>
<span class="fc" id="L5324">        returnval.add(cert);</span>
      }
    }
<span class="fc" id="L5327">    return returnval;</span>
  } // createCertChain

  /**
   * Method ordering a list of certificate (X.509, CVC, or other supported type)
   * into a certificate path with the root CA at the end. Does not check
   * validity or verification of any kind, just ordering by issuerdn.
   *
   * @param certlist list of certificates to order can be collection of
   *     Certificate or byte[] (der encoded certs), must contain a full chain.
   * @return List with certificatechain, Root CA last.
   * @throws CertPathValidatorException if validation fails
   */
  private static List&lt;Certificate&gt; orderCertificateChain(
          final Collection&lt;?&gt; certlist)
      throws CertPathValidatorException {
<span class="fc" id="L5343">    final ArrayList&lt;Certificate&gt; returnval = new ArrayList&lt;Certificate&gt;();</span>
<span class="fc" id="L5344">    Certificate rootca = null;</span>
<span class="fc" id="L5345">    final HashMap&lt;String, Certificate&gt; cacertmap</span>
        = new HashMap&lt;String, Certificate&gt;();
<span class="fc bfc" id="L5347" title="All 2 branches covered.">    for (final Object possibleCertificate : certlist) {</span>
<span class="fc" id="L5348">      Certificate cert = null;</span>
      try {
<span class="fc" id="L5350">        cert = (Certificate) possibleCertificate;</span>
<span class="nc" id="L5351">      } catch (final ClassCastException e) {</span>
        // This was not a certificate, is it byte encoded?
<span class="nc" id="L5353">        final byte[] certBytes = (byte[]) possibleCertificate;</span>
        try {
<span class="nc" id="L5355">          cert = CertTools.getCertfromByteArray(certBytes);</span>
<span class="nc" id="L5356">        } catch (final CertificateParsingException e1) {</span>
<span class="nc" id="L5357">          throw new CertPathValidatorException(e1);</span>
<span class="nc" id="L5358">        }</span>
<span class="fc" id="L5359">      }</span>
<span class="fc bfc" id="L5360" title="All 2 branches covered.">      if (CertTools.isSelfSigned(cert)) {</span>
<span class="fc" id="L5361">        rootca = cert;</span>
      } else {
<span class="fc" id="L5363">        LOGGER.debug(</span>
            &quot;Adding to cacertmap with index '&quot;
<span class="fc" id="L5365">                + CertTools.getIssuerDN(cert)</span>
                + &quot;'&quot;);
<span class="fc" id="L5367">        cacertmap.put(CertTools.getIssuerDN(cert), cert);</span>
      }
<span class="fc" id="L5369">    }</span>

<span class="pc bpc" id="L5371" title="1 of 2 branches missed.">    if (rootca == null) {</span>
<span class="nc" id="L5372">      throw new CertPathValidatorException(</span>
          &quot;No root CA certificate found in certificatelist&quot;);
    }
<span class="fc" id="L5375">    returnval.add(0, rootca);</span>
<span class="fc" id="L5376">    Certificate currentcert = rootca;</span>
<span class="fc" id="L5377">    int i = 0;</span>
<span class="pc bpc" id="L5378" title="1 of 4 branches missed.">    while (certlist.size() != returnval.size() &amp;&amp; i &lt;= certlist.size()) {</span>
<span class="pc bpc" id="L5379" title="1 of 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L5380">        LOGGER.debug(</span>
            &quot;Looking in cacertmap for '&quot;
<span class="nc" id="L5382">                + CertTools.getSubjectDN(currentcert)</span>
                + &quot;'&quot;);
      }
<span class="fc" id="L5385">      final Certificate nextcert = cacertmap.get(</span>
<span class="fc" id="L5386">              CertTools.getSubjectDN(currentcert));</span>
<span class="pc bpc" id="L5387" title="1 of 2 branches missed.">      if (nextcert == null) {</span>
<span class="nc bnc" id="L5388" title="All 2 branches missed.">        if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L5389">          LOGGER.debug(&quot;Dumping keys of CA certificate map:&quot;);</span>
<span class="nc bnc" id="L5390" title="All 2 branches missed.">          for (final String issuerDn : cacertmap.keySet()) {</span>
<span class="nc" id="L5391">            LOGGER.debug(issuerDn);</span>
<span class="nc" id="L5392">          }</span>
        }
<span class="nc" id="L5394">        throw new CertPathValidatorException(</span>
            &quot;Error building certificate path. Could find certificate with&quot;
                + &quot; SubjectDN &quot;
<span class="nc" id="L5397">                + CertTools.getSubjectDN(currentcert)</span>
                + &quot; in certificate map. See debug log for details.&quot;);
      }
<span class="fc" id="L5400">      returnval.add(0, nextcert);</span>
<span class="fc" id="L5401">      currentcert = nextcert;</span>
<span class="fc" id="L5402">      i++;</span>
<span class="fc" id="L5403">    }</span>

<span class="pc bpc" id="L5405" title="1 of 2 branches missed.">    if (i &gt; certlist.size()) {</span>
<span class="nc" id="L5406">      throw new CertPathValidatorException(&quot;Error building certificate path&quot;);</span>
    }

<span class="fc" id="L5409">    return returnval;</span>
  } // orderCertificateChain

  /**
   * Method ordering a list of X509 certificate into a certificate path with the
   * root CA, or topmost Sub CA at the end. Does not check validity or
   * verification of any kind, just ordering by issuerdn/keyId. This is mostly a
   * wrapper around CertPath.generateCertPath, but we do regression test this
   * ordering.
   *
   * @param certlist list of certificates to order can be collection of
   *     Certificate or byte[] (der encoded certs).
   * @return List with certificate chain with leaf certificate first, and root
   *     CA, or last sub CA, in the end, does not have to contain a Root CA is
   *     input does not.
   * @throws CertPathValidatorException if validation fails
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static List&lt;X509Certificate&gt; orderX509CertificateChain(
      final List&lt;X509Certificate&gt; certlist) throws CertPathValidatorException {
    CertPath cp;
    try {
<span class="fc" id="L5431">      cp =</span>
<span class="fc" id="L5432">          CertificateFactory.getInstance(</span>
                  &quot;X.509&quot;, BouncyCastleProvider.PROVIDER_NAME)
<span class="fc" id="L5434">              .generateCertPath(certlist);</span>
<span class="nc" id="L5435">    } catch (final CertificateException e) {</span>
      // Wasn't a certificate after all?
<span class="nc" id="L5437">      throw new CertPathValidatorException(e);</span>
<span class="nc" id="L5438">    } catch (final NoSuchProviderException e) {</span>
      // This is really bad
<span class="nc" id="L5440">      throw new IllegalStateException(</span>
          &quot;BouncyCastle was not found as a provider.&quot;, e);
<span class="fc" id="L5442">    }</span>
<span class="fc" id="L5443">    return (List&lt;X509Certificate&gt;) cp.getCertificates();</span>
  } // orderX509CertificateChain

  /**
   * @param chainA first chain
   * @param chainB second chain
   * @return true if the chains are nonempty, contain the same certificates in
   *     the same order
   */
  public static boolean compareCertificateChains(
      final Certificate[] chainA, final Certificate[] chainB) {
<span class="nc bnc" id="L5454" title="All 4 branches missed.">    if (chainA == null || chainB == null) {</span>
<span class="nc" id="L5455">      return false;</span>
    }
<span class="nc bnc" id="L5457" title="All 2 branches missed.">    if (chainA.length != chainB.length) {</span>
<span class="nc" id="L5458">      return false;</span>
    }
<span class="nc bnc" id="L5460" title="All 2 branches missed.">    for (int i = 0; i &lt; chainA.length; i++) {</span>
<span class="nc bnc" id="L5461" title="All 4 branches missed.">      if (chainA[i] == null || !chainA[i].equals(chainB[i])) {</span>
<span class="nc" id="L5462">        return false;</span>
      }
    }
<span class="nc" id="L5465">    return true;</span>
  }

  /**
   * Dumps a certificate (cvc or x.509) to string format, suitable for manual
   * inspection/debugging.
   *
   * @param cert Certificate
   * @return String with cvc or asn.1 dump.
   */
  public static String dumpCertificateAsString(final Certificate cert) {
<span class="nc" id="L5476">    String ret = null;</span>
<span class="nc bnc" id="L5477" title="All 2 branches missed.">    if (cert instanceof X509Certificate) {</span>
      try {
<span class="nc" id="L5479">        final Certificate c = getCertfromByteArray(cert.getEncoded());</span>
<span class="nc" id="L5480">        ret = c.toString();</span>
        // ASN1InputStream ais = new ASN1InputStream(new
        // ByteArrayInputStream(cert.getEncoded()));
        // ASN1Primitive obj = ais.readObject();
        // ret = ASN1Dump.dumpAsString(obj);
<span class="nc" id="L5485">      } catch (final CertificateException e) {</span>
<span class="nc" id="L5486">        ret = e.getMessage();</span>
<span class="nc" id="L5487">      }</span>
<span class="nc bnc" id="L5488" title="All 2 branches missed.">    } else if (StringUtils.equals(cert.getType(), &quot;CVC&quot;)) {</span>
<span class="nc" id="L5489">      final CardVerifiableCertificate cvccert =</span>
          (CardVerifiableCertificate) cert;
<span class="nc" id="L5491">      final CVCObject obj = cvccert.getCVCertificate();</span>
<span class="nc" id="L5492">      ret = obj.getAsText(&quot;&quot;);</span>
<span class="nc" id="L5493">    } else {</span>
<span class="nc" id="L5494">      throw new IllegalArgumentException(</span>
          &quot;dumpCertificateAsString: Certificate of type &quot;
<span class="nc" id="L5496">              + cert.getType()</span>
              + &quot; is not implemented&quot;);
    }
<span class="nc" id="L5499">    return ret;</span>
  }

  /**
   * Creates PKCS10CertificateRequest object from PEM encoded certificate
   * request.
   *
   * @param pemEncodedCsr PEM encoded CSR
   * @return PKCS10CertificateRequest object
   */
  public static PKCS10CertificationRequest getCertificateRequestFromPem(
      final String pemEncodedCsr) {
<span class="nc bnc" id="L5511" title="All 2 branches missed.">    if (pemEncodedCsr == null) {</span>
<span class="nc" id="L5512">      return null;</span>
    }
<span class="nc" id="L5514">    PKCS10CertificationRequest csr = null;</span>
<span class="nc" id="L5515">    final ByteArrayInputStream pemStream =</span>
        new ByteArrayInputStream(
<span class="nc" id="L5517">            pemEncodedCsr.getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L5518">    try (PEMParser pemParser =</span>
        new PEMParser(new BufferedReader(new InputStreamReader(pemStream))); ) {
<span class="nc" id="L5520">      final Object parsedObj = pemParser.readObject();</span>
<span class="nc bnc" id="L5521" title="All 2 branches missed.">      if (parsedObj instanceof PKCS10CertificationRequest) {</span>
<span class="nc" id="L5522">        csr = (PKCS10CertificationRequest) parsedObj;</span>
      }
<span class="nc" id="L5524">    } catch (IOException</span>
        | DecoderException
            e) { // IOException that will be wrapped as (runtime)
                 // DecoderException
<span class="nc" id="L5528">      LOGGER.info(</span>
          &quot;IOException while decoding certificate request from PEM: &quot;
<span class="nc" id="L5530">              + e.getMessage());</span>
<span class="nc" id="L5531">      LOGGER.debug(&quot;IOException while decoding certificate request from PEM.&quot;,</span>
              e);
<span class="nc" id="L5533">    }</span>
<span class="nc" id="L5534">    return csr;</span>
  }

  /**
   * Generates a PKCS10CertificationRequest.
   *
   * &lt;p&gt;Code Example: ------------- An example of putting AltName and a password
   * challenge in an 'attributes' set (taken from
   * RequestMessageTest.test01Pkcs10RequestMessage() ):
   *
   * &lt;p&gt;{@code // Create a P10 with extensions, in this case altNames with a DNS
   * name ASN1EncodableVector altnameattr = new ASN1EncodableVector();
   * altnameattr.add(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest); //
   * AltNames GeneralNames san =
   * CertTools.getGeneralNamesFromAltName(&quot;dNSName=foo1.bar.com&quot;);
   * ExtensionsGenerator extgen = new ExtensionsGenerator();
   * extgen.addExtension(Extension.subjectAlternativeName, false, san );
   * Extensions exts = extgen.generate(); altnameattr.add(new DERSet(exts));
   *
   * &lt;p&gt;// Add a challenge password as well ASN1EncodableVector pwdattr = new
   * ASN1EncodableVector();
   * pwdattr.add(PKCSObjectIdentifiers.pkcs_9_at_challengePassword);
   * ASN1EncodableVector pwdvalues = new ASN1EncodableVector();
   * pwdvalues.add(new DERUTF8String(&quot;foo123&quot;)); pwdattr.add(new
   * DERSet(pwdvalues));
   *
   * &lt;p&gt;// Complete the Attribute section of the request, the set (Attributes)
   * // contains one sequence (Attribute) ASN1EncodableVector v = new
   * ASN1EncodableVector(); v.add(new DERSequence(altnameattr)); v.add(new
   * DERSequence(pwdattr)); DERSet attributes = new DERSet(v); }
   *
   * @param signatureAlgorithm the signature algorithm to sign the CSR.
   * @param subject the request's subject DN.
   * @param publickey the public key of the CSR.
   * @param attributes a set of attributes, for example, extensions, challenge
   *     password, etc.
   * @param privateKey the private key used to sign the CSR.
   * @param oprovider the JCA/JCE provider to use.
   * @return a PKCS10CertificateRequest based on the input parameters.
   * @throws OperatorCreationException if an error occurred while creating the
   *     signing key
   */
  // Should sign with. other private as well!
  public static PKCS10CertificationRequest genPKCS10CertificationRequest(
      final String signatureAlgorithm,
      final X500Name subject,
      final PublicKey publickey,
      final ASN1Set attributes,
      final PrivateKey privateKey,
      final String oprovider)
      throws OperatorCreationException {

    ContentSigner signer;
    CertificationRequestInfo reqInfo;
    try {
<span class="fc" id="L5589">      final SubjectPublicKeyInfo pkinfo =</span>
<span class="fc" id="L5590">          SubjectPublicKeyInfo.getInstance(publickey.getEncoded());</span>
<span class="fc" id="L5591">      reqInfo = new CertificationRequestInfo(subject, pkinfo, attributes);</span>

      String provider;
<span class="pc bpc" id="L5594" title="1 of 2 branches missed.">      if (oprovider == null) {</span>
<span class="fc" id="L5595">        provider = BouncyCastleProvider.PROVIDER_NAME;</span>
      } else {
<span class="nc" id="L5597">          provider = oprovider;</span>
      }
<span class="fc" id="L5599">      final int bufferSize = 20480;</span>
<span class="fc" id="L5600">      signer =</span>
          new BufferingContentSigner(
              new JcaContentSignerBuilder(signatureAlgorithm)
<span class="fc" id="L5603">                  .setProvider(provider)</span>
<span class="fc" id="L5604">                  .build(privateKey),</span>
              bufferSize);
<span class="fc" id="L5606">      signer.getOutputStream().write(reqInfo.getEncoded(ASN1Encoding.DER));</span>
<span class="fc" id="L5607">      signer.getOutputStream().flush();</span>
<span class="nc" id="L5608">    } catch (final IOException e) {</span>
<span class="nc" id="L5609">      throw new IllegalStateException(&quot;Unexpected IOException was caught.&quot;, e);</span>
<span class="fc" id="L5610">    }</span>
<span class="fc" id="L5611">    final byte[] sig = signer.getSignature();</span>
<span class="fc" id="L5612">    final DERBitString sigBits = new DERBitString(sig);</span>

<span class="fc" id="L5614">    final CertificationRequest req =</span>
        new CertificationRequest(
<span class="fc" id="L5616">            reqInfo, signer.getAlgorithmIdentifier(), sigBits);</span>
<span class="fc" id="L5617">    return new PKCS10CertificationRequest(req);</span>
  }

  /**
   * Create a &quot;certs-only&quot; PKCS#7 / CMS from the provided chain.
   *
   * @param x509CertificateChain chain of certificates with the leaf in the
   *     first position and root in the last or just a leaf certificate.
   * @return a byte array containing the CMS
   * @throws CertificateEncodingException if the provided list of certificates
   *     could not be parsed correctly
   * @throws CMSException if there was a problem creating the certs-only CMS
   *     message
   */
  public static byte[] createCertsOnlyCMS(
      final List&lt;X509Certificate&gt; x509CertificateChain)
      throws CertificateEncodingException, CMSException {
<span class="nc bnc" id="L5634" title="All 2 branches missed.">    if (LOGGER.isDebugEnabled()) {</span>
      final String subjectdn =
<span class="nc bnc" id="L5636" title="All 4 branches missed.">          ((x509CertificateChain != null &amp;&amp; x509CertificateChain.size() &gt; 0)</span>
<span class="nc" id="L5637">              ? x509CertificateChain.get(0).getSubjectDN().toString()</span>
<span class="nc" id="L5638">              : &quot;null&quot;);</span>
<span class="nc" id="L5639">      LOGGER.debug(&quot;Creating a certs-only CMS for &quot; + subjectdn);</span>
    }
<span class="nc" id="L5641">    final List&lt;JcaX509CertificateHolder&gt; certList =</span>
<span class="nc" id="L5642">        CertTools.convertToX509CertificateHolder(x509CertificateChain);</span>
<span class="nc" id="L5643">    final CMSSignedDataGenerator cmsSignedDataGenerator =</span>
        new CMSSignedDataGenerator();
<span class="nc" id="L5645">    cmsSignedDataGenerator.addCertificates(</span>
        new CollectionStore&lt;JcaX509CertificateHolder&gt;(certList));
<span class="nc" id="L5647">    final CMSSignedData cmsSignedData =</span>
<span class="nc" id="L5648">        cmsSignedDataGenerator.generate(new CMSAbsentContent(), true);</span>
    try {
<span class="nc" id="L5650">      return cmsSignedData.getEncoded();</span>
<span class="nc" id="L5651">    } catch (final IOException e) {</span>
<span class="nc" id="L5652">      throw new CMSException(e.getMessage());</span>
    }
  }

  /**
   * Generated Generates a ContentVerifierProvider.
   *
   * @param pubkey Key
   * @return a JcaContentVerifierProvider. Useful for verifying the signiture in
   *     a PKCS10CertificationRequest
   * @throws OperatorCreationException On fail
   */
  public static ContentVerifierProvider genContentVerifierProvider(
      final PublicKey pubkey) throws OperatorCreationException {
<span class="fc" id="L5666">    return new JcaContentVerifierProviderBuilder()</span>
<span class="fc" id="L5667">        .setProvider(BouncyCastleProvider.PROVIDER_NAME)</span>
<span class="fc" id="L5668">        .build(pubkey);</span>
  }

  /**
   * @param chain cert chain
   * @return a Certificate Collection as a X509Certificate list
   * @throws ClassCastException if one of the Certificates in the collection is
   *     not an X509Certificate
   */
  public static final List&lt;X509Certificate&gt; convertCertificateChainToX509Chain(
      final Collection&lt;Certificate&gt; chain) throws ClassCastException {
<span class="nc" id="L5679">    final List&lt;X509Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L5680" title="All 2 branches missed.">    for (final Certificate certificate : chain) {</span>
<span class="nc" id="L5681">      ret.add((X509Certificate) certificate);</span>
<span class="nc" id="L5682">    }</span>
<span class="nc" id="L5683">    return ret;</span>
  }

  /**
   * @param chain cert chain
   * @return a X509Certificate Collection as a Certificate list
   */
  public static final List&lt;Certificate&gt; convertCertificateChainToGenericChain(
      final Collection&lt;X509Certificate&gt; chain) {
<span class="nc" id="L5692">    final List&lt;Certificate&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L5693" title="All 2 branches missed.">    for (final Certificate certificate : chain) {</span>
<span class="nc" id="L5694">      ret.add(certificate);</span>
<span class="nc" id="L5695">    }</span>
<span class="nc" id="L5696">    return ret;</span>
  }

  /**
   * Converts a X509Certificate chain into a JcaX509CertificateHolder chain.
   *
   * @param certificateChain input chain to be converted
   * @return the result
   * @throws CertificateEncodingException if there is a problem extracting the
   *     certificate information.
   */
  public static final JcaX509CertificateHolder[] convertToX509CertificateHolder(
      final X509Certificate[] certificateChain)
              throws CertificateEncodingException {
<span class="nc" id="L5710">    final JcaX509CertificateHolder[] certificateHolderChain =</span>
        new JcaX509CertificateHolder[certificateChain.length];
<span class="nc bnc" id="L5712" title="All 2 branches missed.">    for (int i = 0; i &lt; certificateChain.length; ++i) {</span>
<span class="nc" id="L5713">      certificateHolderChain[i] =</span>
          new JcaX509CertificateHolder(certificateChain[i]);
    }
<span class="nc" id="L5716">    return certificateHolderChain;</span>
  }

  /**
   * Converts a X509Certificate chain into a JcaX509CertificateHolder chain.
   *
   * @param certificateChain input chain to be converted
   * @return the result
   * @throws CertificateEncodingException if there is a problem extracting the
   *     certificate information.
   */
  public static final List&lt;JcaX509CertificateHolder&gt;
      convertToX509CertificateHolder(
              final List&lt;X509Certificate&gt; certificateChain)
          throws CertificateEncodingException {
<span class="nc" id="L5731">    final List&lt;JcaX509CertificateHolder&gt; certificateHolderChain =</span>
        new ArrayList&lt;JcaX509CertificateHolder&gt;();
<span class="nc bnc" id="L5733" title="All 2 branches missed.">    for (final X509Certificate certificate : certificateChain) {</span>
<span class="nc" id="L5734">      certificateHolderChain.add(new JcaX509CertificateHolder(certificate));</span>
<span class="nc" id="L5735">    }</span>
<span class="nc" id="L5736">    return certificateHolderChain;</span>
  }

  /**
   * Converts a X509CertificateHolder chain into a X509Certificate chain.
   *
   * @param certificateHolderChain input chain to be converted
   * @return the result
   * @throws CertificateException if there is a problem extracting the
   *     certificate information.
   */
  public static final List&lt;X509Certificate&gt; convertToX509CertificateList(
      final Collection&lt;X509CertificateHolder&gt; certificateHolderChain)
      throws CertificateException {
<span class="nc" id="L5750">    final List&lt;X509Certificate&gt; ret = new ArrayList&lt;X509Certificate&gt;();</span>
<span class="nc" id="L5751">    final JcaX509CertificateConverter jcaX509CertificateConverter =</span>
        new JcaX509CertificateConverter();
    for (final X509CertificateHolder certificateHolder
<span class="nc bnc" id="L5754" title="All 2 branches missed.">        : certificateHolderChain) {</span>
<span class="nc" id="L5755">      ret.add(jcaX509CertificateConverter.getCertificate(certificateHolder));</span>
<span class="nc" id="L5756">    }</span>
<span class="nc" id="L5757">    return ret;</span>
  }

  /**
   * Converts a X509CertificateHolder chain into a X509Certificate chain.
   *
   * @param certificateHolderChain input chain to be converted
   * @return the result
   * @throws CertificateException if there is a problem extracting the
   *     certificate information.
   */
  public static final X509Certificate[] convertToX509CertificateArray(
      final Collection&lt;X509CertificateHolder&gt; certificateHolderChain)
      throws CertificateException {
<span class="nc" id="L5771">    return convertToX509CertificateList(certificateHolderChain)</span>
<span class="nc" id="L5772">        .toArray(new X509Certificate[0]);</span>
  }

  /**
   * Converts a X509CertificateHolder chain into a X509Certificate chain.
   *
   * @param crlHolders input chain to be converted
   * @return the result
   * @throws CRLException if there is a problem extracting the CRL information.
   */
  public static final List&lt;X509CRL&gt; convertToX509CRLList(
      final Collection&lt;X509CRLHolder&gt; crlHolders) throws CRLException {
<span class="nc" id="L5784">    final List&lt;X509CRL&gt; ret = new ArrayList&lt;X509CRL&gt;();</span>
<span class="nc" id="L5785">    final JcaX509CRLConverter jcaX509CRLConverter = new JcaX509CRLConverter();</span>
<span class="nc bnc" id="L5786" title="All 2 branches missed.">    for (final X509CRLHolder crlHolder : crlHolders) {</span>
<span class="nc" id="L5787">      ret.add(jcaX509CRLConverter.getCRL(crlHolder));</span>
<span class="nc" id="L5788">    }</span>
<span class="nc" id="L5789">    return ret;</span>
  }

  /**
   * Checks that the given SubjectDN / SAN satisfies the Name Constraints of the
   * given issuer (if there are any). This method checks the Name Constraints in
   * the given issuer only. A complete implementation of name constraints should
   * check the whole certificate chain.
   *
   * @param issuer Issuing CA.
   * @param subjectDNName Subject DN to check. Optional.
   * @param subjectAltName Subject Alternative Name to check. Optional.
   * @throws IllegalNameException if the name(s) didn't pass naming constraints
   */
  public static void checkNameConstraints(
      final X509Certificate issuer,
      final X500Name subjectDNName,
      final GeneralNames subjectAltName)
      throws IllegalNameException {
<span class="fc" id="L5808">    final byte[] ncbytes =</span>
<span class="fc" id="L5809">        issuer.getExtensionValue(Extension.nameConstraints.getId());</span>
    final ASN1OctetString ncstr =
<span class="pc bpc" id="L5811" title="1 of 2 branches missed.">        (ncbytes != null ? DEROctetString.getInstance(ncbytes) : null);</span>
    final ASN1Sequence ncseq =
<span class="pc bpc" id="L5813" title="1 of 2 branches missed.">        (ncbytes != null ? DERSequence.getInstance(ncstr.getOctets()) : null);</span>
    final NameConstraints nc =
<span class="pc bpc" id="L5815" title="1 of 2 branches missed.">        (ncseq != null ? NameConstraints.getInstance(ncseq) : null);</span>

<span class="pc bpc" id="L5817" title="1 of 2 branches missed.">    if (nc != null) {</span>
<span class="pc bpc" id="L5818" title="1 of 2 branches missed.">      if (subjectDNName != null) {</span>
        // Skip check for root CAs
<span class="fc" id="L5820">        final X500Name issuerDNName =</span>
<span class="fc" id="L5821">            X500Name.getInstance(issuer.getSubjectX500Principal().getEncoded());</span>
<span class="pc bpc" id="L5822" title="1 of 2 branches missed.">        if (issuerDNName.equals(subjectDNName)) {</span>
<span class="nc" id="L5823">          return;</span>
        }
      }

<span class="fc" id="L5827">      final PKIXNameConstraintValidator validator =</span>
          new PKIXNameConstraintValidator();

<span class="fc" id="L5830">      final GeneralSubtree[] permitted = nc.getPermittedSubtrees();</span>
<span class="fc" id="L5831">      final GeneralSubtree[] excluded = nc.getExcludedSubtrees();</span>

<span class="pc bpc" id="L5833" title="1 of 2 branches missed.">      if (permitted != null) {</span>
<span class="fc" id="L5834">        validator.intersectPermittedSubtree(permitted);</span>
      }
<span class="pc bpc" id="L5836" title="1 of 2 branches missed.">      if (excluded != null) {</span>
<span class="fc bfc" id="L5837" title="All 2 branches covered.">        for (final GeneralSubtree subtree : excluded) {</span>
<span class="fc" id="L5838">          validator.addExcludedSubtree(subtree);</span>
        }
      }

<span class="pc bpc" id="L5842" title="1 of 2 branches missed.">      if (subjectDNName != null) {</span>
<span class="fc" id="L5843">        final GeneralName dngn = new GeneralName(subjectDNName);</span>
        try {
<span class="fc" id="L5845">          validator.checkPermitted(dngn);</span>
<span class="fc" id="L5846">          validator.checkExcluded(dngn);</span>
<span class="fc" id="L5847">        } catch (final PKIXNameConstraintValidatorException e) {</span>
<span class="fc" id="L5848">          final String dnStr = subjectDNName.toString();</span>
<span class="fc" id="L5849">          final boolean isLdapOrder =</span>
<span class="pc bpc" id="L5850" title="1 of 4 branches missed.">              dnHasMultipleComponents(dnStr) &amp;&amp; !isDNReversed(dnStr);</span>
<span class="fc bfc" id="L5851" title="All 2 branches covered.">          if (isLdapOrder) {</span>
<span class="fc" id="L5852">            final String msg =</span>
<span class="fc" id="L5853">                INTRES.getLocalizedMessage(</span>
                    &quot;nameconstraints.x500dnorderrequired&quot;);
<span class="fc" id="L5855">            throw new IllegalNameException(msg);</span>
          } else {
<span class="fc" id="L5857">            final String msg =</span>
<span class="fc" id="L5858">                INTRES.getLocalizedMessage(</span>
                    &quot;nameconstraints.forbiddensubjectdn&quot;, subjectDNName);
<span class="fc" id="L5860">            throw new IllegalNameException(msg, e);</span>
          }
<span class="fc" id="L5862">        }</span>
      }

<span class="fc bfc" id="L5865" title="All 2 branches covered.">      if (subjectAltName != null) {</span>
<span class="fc bfc" id="L5866" title="All 2 branches covered.">        for (final GeneralName sangn : subjectAltName.getNames()) {</span>
          try {
<span class="fc" id="L5868">            validator.checkPermitted(sangn);</span>
<span class="fc" id="L5869">            validator.checkExcluded(sangn);</span>
<span class="fc" id="L5870">          } catch (final PKIXNameConstraintValidatorException e) {</span>
<span class="fc" id="L5871">            final String msg =</span>
<span class="fc" id="L5872">                INTRES.getLocalizedMessage(</span>
                    &quot;nameconstraints.forbiddensubjectaltname&quot;, sangn);
<span class="fc" id="L5874">            throw new IllegalNameException(msg, e);</span>
<span class="fc" id="L5875">          }</span>
        }
      }
    }
<span class="fc" id="L5879">  }</span>

  /**
   * Creates a public key fingerprint with the given digest algorithm.
   *
   * @param publicKey the public key.
   * @param algorithm the digest algorithm (i.e. MD-5, SHA-1, SHA-256, etc.)
   * @return the public key fingerprint or null.
   */
  public static final String createPublicKeyFingerprint(
      final PublicKey publicKey, final String algorithm) {
    try {
<span class="nc" id="L5891">      final MessageDigest digest = MessageDigest.getInstance(algorithm);</span>
<span class="nc" id="L5892">      digest.reset();</span>
<span class="nc" id="L5893">      digest.update(publicKey.getEncoded());</span>
<span class="nc" id="L5894">      final String result = Hex.toHexString(digest.digest());</span>
<span class="nc bnc" id="L5895" title="All 2 branches missed.">      if (LOGGER.isDebugEnabled()) {</span>
<span class="nc" id="L5896">        LOGGER.debug(</span>
            &quot;Fingerprint &quot;
                + result
                + &quot; created for public key: &quot;
<span class="nc" id="L5900">                + new String(Base64.encode(publicKey.getEncoded())));</span>
      }
<span class="nc" id="L5902">      return result;</span>
<span class="nc" id="L5903">    } catch (final NoSuchAlgorithmException e) {</span>
<span class="nc" id="L5904">      LOGGER.warn(&quot;Could not create fingerprint for public key &quot;, e);</span>
<span class="nc" id="L5905">      return null;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>