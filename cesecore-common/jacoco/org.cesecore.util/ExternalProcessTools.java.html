<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExternalProcessTools.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util</a> &gt; <span class="el_source">ExternalProcessTools.java</span></div><h1>ExternalProcessTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateParsingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;
import org.apache.log4j.Logger;
import org.cesecore.internal.InternalResources;

/**
 * Tools to handle calls with &lt;a
 * href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html&quot;&gt;Java
 * Process API&lt;/a&gt;.
 *
 * @version $Id: ExternalProcessTools.java 27126 2017-12-16 09:28:54Z anjakobs $
 */
public final class ExternalProcessTools {

  /** Class logger. */
<span class="nc" id="L44">  private static final Logger LOG =</span>
<span class="nc" id="L45">      Logger.getLogger(ExternalProcessTools.class);</span>

  /** Internal localization of logs and errors. */
  private static final InternalResources INTRES =
<span class="nc" id="L49">      InternalResources.getInstance();</span>

  /** Literal for the (platform dependent) line separator. */
<span class="nc" id="L52">  private static final String LINE_SEPARATOR =</span>
<span class="nc" id="L53">      System.getProperty(&quot;line.separator&quot;);</span>

  /** Literal for place holder for the certificate issued. */
  public static final String PLACE_HOLDER_CERTIFICATE = &quot;%cert%&quot;;

  /** Literal for default MS Windows shell. */
  public static final String WINDOWS_SHELL = &quot;cmd.exe&quot;;

  /** Literal for default MS Windows shell options. */
  public static final String WINDOWS_SHELL_OPTIONS = &quot;/c&quot;;

  /** Literal for default Unix shell. */
  public static final String UNIX_SHELL = &quot;/bin/sh&quot;;

  /** Literal for default Unix shell options. */
  public static final String UNIX_SHELL_OPTIONS = &quot;-c&quot;;

  /** Literal for exit code label / prefix. */
  public static final String EXIT_CODE_PREFIX = &quot;Exit code: &quot;;

  /** Literal for STDOUT label to log the external out streams . */
  public static final String STDOUT_PREFIX = &quot;STDOUT: &quot;;

  /** Literal for ERROUT label to log the external out streams . */
  public static final String ERROUT_PREFIX = &quot;ERROUT: &quot;;

  /**
   * Builds the platform dependent external command array: - field at index 0 is
   * the interpreter, - field at index 1 is the one and only parameter of the
   * interpreter, - field at index 2 must contain the complete external command,
   * including pipes, chains, sub-shells, etc. and is appended later.
   *
   * @param cmd the external command or script
   * @return the command array as list.
   */
  protected static List&lt;String&gt; buildShellCommand(final String cmd) {
<span class="nc" id="L89">    final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">    if (SystemUtils.IS_OS_WINDOWS) {</span>
<span class="nc" id="L91">      result.add(WINDOWS_SHELL);</span>
<span class="nc" id="L92">      result.add(WINDOWS_SHELL_OPTIONS);</span>
    } else {
<span class="nc" id="L94">      result.add(UNIX_SHELL);</span>
<span class="nc" id="L95">      result.add(UNIX_SHELL_OPTIONS);</span>
    }
<span class="nc bnc" id="L97" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L98">      LOG.debug(</span>
          &quot;Use platform shell command for &quot;
              + SystemUtils.OS_NAME
              + &quot; : &quot;
              + result);
    }
<span class="nc bnc" id="L104" title="All 2 branches missed.">    if (result.size() == 2) {</span>
<span class="nc" id="L105">      result.add(cmd);</span>
    }
<span class="nc" id="L107">    return result;</span>
  }

  /**
   * Writes the byte-array to a temporary file or pipes the PEM certificate into
   * the command, and launches the given external command, see {@link
   * ExternalProcessTools#launchExternalCommand(String, byte[], boolean,
   * boolean, boolean, boolean, List, String)}.
   *
   * @param cmd The command to run.
   * @param bytes The buffer with content to write to the file.
   * @param failOnCode Determines if the method should fail on a non-zero exit
   *     code.
   * @param failOnOutput Determines if the method should fail on output to
   *     standard error.
   * @param args Added to the command after the temporary files name
   * @param filePrefix prefix
   * @return output
   * @throws ExternalProcessException if the temporary file could not be written
   *     or the external process fails.
   */
  public static List&lt;String&gt; launchExternalCommand(
      final String cmd,
      final byte[] bytes,
      final boolean failOnCode,
      final boolean failOnOutput,
      final List&lt;String&gt; args,
      final String filePrefix)
      throws ExternalProcessException {
<span class="nc" id="L136">    return launchExternalCommand(</span>
        cmd, bytes, failOnCode, failOnOutput, false, false, args, filePrefix);
  }

  /**
   * Writes the byte-array to a temporary file and launches the given external
   * command with the file as argument at index positional parameter index 1 or
   * the pipes the PEM certificate into the command. The function will,
   * depending on its parameters, fail if output to standard error from the
   * command was detected or the command returns with an non-zero exit code.
   *
   * @param cmd The command to run. If the parameter place holder {@link
   *     #PLACE_HOLDER_CERTIFICATE} is used, the PEM certificate is piped into
   *     the STDIN of the command (i.e. 'openssl x509 -text -noout %cert%').
   * @param bytes The buffer with content to write to the file.
   * @param failOnCode Determines if the method should fail on a non-zero exit
   *     code.
   * @param failOnOutput Determines if the method should fail on output to
   *     standard error.
   * @param logStdOut if the scripts STDOUT should be logged as info.
   * @param logErrOut if the scripts ERROUT should be logged as info.
   * @param arguments Added to the command after the temporary files name
   * @param filePrefix prefix
   * @return output
   * @throws ExternalProcessException if the temporary file could not be written
   *     or the external process fails.
   */
  public static List&lt;String&gt; launchExternalCommand(
      final String cmd,
      final byte[] bytes,
      final boolean failOnCode,
      final boolean failOnOutput,
      final boolean logStdOut,
      final boolean logErrOut,
      final List&lt;String&gt; arguments,
      final String filePrefix)
      throws ExternalProcessException {
<span class="nc" id="L173">    final long startTime = System.currentTimeMillis();</span>
<span class="nc" id="L174">    int exitStatus = -1;</span>
<span class="nc" id="L175">    final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L176">    final boolean writeFileToDisk =</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        !arguments.contains(PLACE_HOLDER_CERTIFICATE);</span>
<span class="nc" id="L178">    File file = null;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (writeFileToDisk) {</span>
<span class="nc" id="L180">      file = writeTemporaryFileToDisk(bytes, filePrefix, &quot;.tmp&quot;);</span>
    }
    // Execute external script or command with PEM in STDIN or full path of
    // temporary file as first argument.
<span class="nc" id="L184">    String filename = null;</span>
    try {
<span class="nc" id="L186">      final List&lt;String&gt; cmdTokens = Arrays.asList(cmd.split(&quot;\\s&quot;));</span>
      // Write file to disk or process place holder with PEM certificates and
      // build shell command.
<span class="nc bnc" id="L189" title="All 2 branches missed.">      if (writeFileToDisk) {</span>
<span class="nc" id="L190">        filename = file.getCanonicalPath();</span>
<span class="nc" id="L191">        arguments.add(0, filename);</span>
      } else {
        // Only works with PEM X.509 certificates at the time as used in
        // ExternalCommandCertificateValidator (not by CRL publishers).
<span class="nc" id="L195">        final List&lt;Certificate&gt; certificates = new ArrayList&lt;Certificate&gt;();</span>
<span class="nc" id="L196">        certificates.add(</span>
<span class="nc" id="L197">            CertTools.getCertfromByteArray(bytes, Certificate.class));</span>
<span class="nc" id="L198">        final byte[] testPemBytes =</span>
<span class="nc" id="L199">            CertTools.getPemFromCertificateChain(certificates);</span>
<span class="nc" id="L200">        String pemString = new String(testPemBytes);</span>
<span class="nc" id="L201">        pemString =</span>
<span class="nc" id="L202">            pemString.substring(</span>
<span class="nc" id="L203">                pemString.indexOf(LINE_SEPARATOR) + 1, pemString.length());</span>
<span class="nc" id="L204">        pemString =</span>
<span class="nc" id="L205">            pemString.substring(</span>
<span class="nc" id="L206">                pemString.indexOf(LINE_SEPARATOR) + 1, pemString.length());</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L208">          LOG.debug(&quot;Using certificates:\n&quot; + pemString);</span>
        }
<span class="nc" id="L210">        arguments.remove(arguments.indexOf(PLACE_HOLDER_CERTIFICATE));</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (SystemUtils.IS_OS_WINDOWS) {</span>
          // Broken. Command cannot be executed.
<span class="nc" id="L214">          cmdTokens.set(0, &quot;echo \&quot;&quot; + pemString + &quot;\&quot; | &quot; + cmdTokens.get(0));</span>
          /*
           * Hack needed for Windows, where Runtime.exec won't consistently
           *  encapsulate arguments, leading to arguments
           * containing spaces (such as Subject DNs) sometimes being parsed
           * as multiple arguments. Bash, on the other hand,
           * won't parse quote surrounded arguments.
           */
<span class="nc" id="L222">          qouteArguments(arguments);</span>
        } else {
<span class="nc" id="L224">          cmdTokens.set(</span>
<span class="nc" id="L225">              0, &quot;echo -n \&quot;&quot; + pemString + &quot;\&quot; | &quot; + cmdTokens.get(0));</span>
        }
      }
<span class="nc" id="L228">      List&lt;String&gt; cmdArray = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L229">      cmdArray.addAll(cmdTokens);</span>
<span class="nc" id="L230">      cmdArray.addAll(arguments);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (!writeFileToDisk) {</span>
<span class="nc" id="L232">        cmdArray = buildShellCommand(StringUtils.join(cmdArray, &quot; &quot;));</span>
      }
<span class="nc bnc" id="L234" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L235">        LOG.debug(</span>
            &quot;Process external command for &quot;
<span class="nc" id="L237">                + getPlatformString()</span>
                + &quot;: &quot;
                + cmdArray);
      }
      // Launch external process.
      final Process externalProcess =
<span class="nc" id="L243">          Runtime.getRuntime()</span>
<span class="nc" id="L244">              .exec(cmdArray.toArray(new String[] {}), null, null);</span>
<span class="nc" id="L245">      externalProcess</span>
<span class="nc" id="L246">          .getOutputStream()</span>
<span class="nc" id="L247">          .close(); // prevent process from trying to wait for user input (e.g.</span>
                    // prompt for overwrite, or similar)
<span class="nc" id="L249">      final BufferedReader stdError =</span>
          new BufferedReader(
<span class="nc" id="L251">              new InputStreamReader(externalProcess.getErrorStream()));</span>
<span class="nc" id="L252">      final BufferedReader stdOut =</span>
          new BufferedReader(
<span class="nc" id="L254">              new InputStreamReader(externalProcess.getInputStream()));</span>
<span class="nc" id="L255">      String line = null;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      while ((line = stdOut.readLine())</span>
          != null) { // NOPMD: Required under win32 to avoid lock
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (logStdOut) {</span>
<span class="nc" id="L259">          result.add(STDOUT_PREFIX + line);</span>
        }
      }
<span class="nc" id="L262">      String stdErrorOutput = null;</span>
      // Check error code and the external applications output to STDERR.
<span class="nc" id="L264">      exitStatus = externalProcess.waitFor();</span>
<span class="nc" id="L265">      result.add(0, EXIT_CODE_PREFIX + exitStatus);</span>
<span class="nc bnc" id="L266" title="All 4 branches missed.">      if (((exitStatus != 0) &amp;&amp; failOnCode)</span>
<span class="nc bnc" id="L267" title="All 4 branches missed.">          || (stdError.ready() &amp;&amp; failOnOutput)) {</span>
<span class="nc bnc" id="L268" title="All 4 branches missed.">        if (writeFileToDisk &amp;&amp; file.exists()) {</span>
<span class="nc" id="L269">          file.delete();</span>
        }
<span class="nc" id="L271">        String errTemp = null;</span>
<span class="nc bnc" id="L272" title="All 4 branches missed.">        while (stdError.ready() &amp;&amp; (errTemp = stdError.readLine()) != null) {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">          if (logErrOut) {</span>
<span class="nc" id="L274">            result.add(ERROUT_PREFIX + errTemp);</span>
          }
<span class="nc bnc" id="L276" title="All 2 branches missed.">          if (stdErrorOutput == null) {</span>
<span class="nc" id="L277">            stdErrorOutput = errTemp;</span>
          } else {
<span class="nc" id="L279">            stdErrorOutput += &quot;\n&quot; + errTemp;</span>
          }
        }
<span class="nc" id="L282">        String msg =</span>
<span class="nc" id="L283">            INTRES.getLocalizedMessage(&quot;process.errorexternalapp&quot;, cmd);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (stdErrorOutput != null) {</span>
<span class="nc" id="L285">          msg += &quot; - &quot; + stdErrorOutput + &quot; - &quot; + filename;</span>
        }
<span class="nc" id="L287">        throw new ExternalProcessException(msg, result);</span>
      }
<span class="nc" id="L289">    } catch (CertificateParsingException</span>
        | CertificateEncodingException
            e) { // Should never happen (is only used for certificates not for
                 // CRL.)
<span class="nc" id="L293">      throw new ExternalProcessException(</span>
          &quot;Certificate could not parsed or encoded.&quot; + cmd, e, result);
<span class="nc" id="L295">    } catch (IOException e) { // if the command could not be found</span>
<span class="nc" id="L296">      result.add(0, EXIT_CODE_PREFIX + exitStatus);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">      if (logErrOut) {</span>
<span class="nc" id="L298">        result.add(ERROUT_PREFIX + e.getMessage());</span>
      }
<span class="nc" id="L300">      throw new ExternalProcessException(</span>
<span class="nc" id="L301">          INTRES.getLocalizedMessage(&quot;process.errorexternalapp&quot;, cmd),</span>
          e,
          result);
<span class="nc" id="L304">    } catch (InterruptedException e) {</span>
<span class="nc" id="L305">      Thread.currentThread().interrupt();</span>
<span class="nc" id="L306">      throw new ExternalProcessException(</span>
<span class="nc" id="L307">          INTRES.getLocalizedMessage(&quot;process.errorexternalapp&quot;, cmd),</span>
          e,
          result);
    } finally {
<span class="nc bnc" id="L311" title="All 8 branches missed.">      if (writeFileToDisk &amp;&amp; file != null &amp;&amp; file.exists() &amp;&amp; !file.delete()) {</span>
        // Remove temporary file or schedule for delete if delete fails.
<span class="nc" id="L313">        file.deleteOnExit();</span>
<span class="nc" id="L314">        LOG.info(</span>
<span class="nc" id="L315">            INTRES.getLocalizedMessage(</span>
                &quot;process.errordeletetempfile&quot;, filename));
      }
    }
<span class="nc bnc" id="L319" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L320">      LOG.trace(</span>
          &quot;Time spent to execute external command (writeFileToDisk=&quot;
              + writeFileToDisk
              + &quot;): &quot;
<span class="nc" id="L324">              + (System.currentTimeMillis() - startTime)</span>
              + &quot;ms.&quot;);
    }
<span class="nc" id="L327">    return result;</span>
  }

  /**
   * @return platform.
   */
  public static String getPlatformString() {
<span class="nc" id="L334">    return SystemUtils.OS_NAME</span>
        + &quot; / &quot;
        + SystemUtils.OS_VERSION
        + &quot; - &quot;
        + SystemUtils.OS_ARCH;
  }

  /**
   * Writes the byte array into a temporary file with the prefix + &quot;-&quot; +
   * System.currentTimeMillies + suffix into the user directory and returns it,
   * or null.
   *
   * @param bytes the bytes to write.
   * @param filePrefix the file prefix.
   * @param fileSuffix the file suffix.
   * @return the file or null.
   * @throws ExternalProcessException any exception.
   */
  public static File writeTemporaryFileToDisk(
      final byte[] bytes, final String filePrefix, final String fileSuffix)
      throws ExternalProcessException {
<span class="nc" id="L355">    File file = null;</span>
    try {
<span class="nc" id="L357">      file =</span>
<span class="nc" id="L358">          File.createTempFile(</span>
<span class="nc" id="L359">              filePrefix + &quot;-&quot; + System.currentTimeMillis(), fileSuffix);</span>
<span class="nc" id="L360">    } catch (IOException e) {</span>
<span class="nc" id="L361">      final String msg = INTRES.getLocalizedMessage(&quot;process.errortempfile&quot;);</span>
<span class="nc" id="L362">      LOG.error(msg, e);</span>
<span class="nc" id="L363">    }</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">    if (file != null) {</span>
<span class="nc" id="L365">      try (FileOutputStream fos = new FileOutputStream(file)) {</span>
<span class="nc" id="L366">        fos.write(bytes);</span>
<span class="nc" id="L367">      } catch (FileNotFoundException e) {</span>
<span class="nc" id="L368">        final String msg = INTRES.getLocalizedMessage(&quot;process.errortempfile&quot;);</span>
<span class="nc" id="L369">        LOG.error(msg, e);</span>
<span class="nc" id="L370">        throw new ExternalProcessException(msg);</span>
<span class="nc" id="L371">      } catch (IOException e) {</span>
        try {
<span class="nc" id="L373">          file.delete();</span>
<span class="nc" id="L374">        } catch (Exception e1) {</span>
          // NOOP
<span class="nc" id="L376">        }</span>
<span class="nc" id="L377">        final String msg = INTRES.getLocalizedMessage(&quot;process.errortempfile&quot;);</span>
<span class="nc" id="L378">        LOG.error(msg, e);</span>
<span class="nc" id="L379">        throw new ExternalProcessException(msg);</span>
<span class="nc" id="L380">      }</span>
    }
    // Delete temp file on JVM exit.
<span class="nc" id="L383">    file.deleteOnExit();</span>
<span class="nc" id="L384">    return file;</span>
  }

  /**
   * Extracts the exit code in the list (at index 0 prefixed with
   * #EXIT_CODE_PREFIX).
   *
   * @param out the output of the external process.
   * @return the exit code.
   */
  public static Integer extractExitCode(final List&lt;String&gt; out) {
<span class="nc" id="L395">    Integer result = null;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (CollectionUtils.isNotEmpty(out)) {</span>
<span class="nc" id="L397">      result =</span>
<span class="nc" id="L398">          Integer.parseInt(</span>
<span class="nc" id="L399">              out.get(0)</span>
<span class="nc" id="L400">                  .replaceFirst(</span>
                      ExternalProcessTools.EXIT_CODE_PREFIX,
                      StringUtils.EMPTY));
    }
<span class="nc" id="L404">    return result;</span>
  }

  /**
   * Checks if the list contains logging to ERROUT.
   *
   * @param out the output of the external process.
   * @return true if the list contains logging to ERROUT.
   */
  public static boolean containsErrout(final List&lt;String&gt; out) {
<span class="nc bnc" id="L414" title="All 4 branches missed.">    if (CollectionUtils.isNotEmpty(out) &amp;&amp; out.size() &gt; 1) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">      for (int i = 1, j = out.size(); i &lt; j; i++) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (out.get(i).startsWith(ERROUT_PREFIX)) {</span>
<span class="nc" id="L417">          return true;</span>
        }
      }
    }
<span class="nc" id="L421">    return false;</span>
  }

  /**
   * Quotes the arguments list.
   *
   * @param arguments the arguments list.
   */
  private static void qouteArguments(final List&lt;String&gt; arguments) {
<span class="nc bnc" id="L430" title="All 2 branches missed.">    for (int i = 0; i &lt; arguments.size(); i++) {</span>
<span class="nc" id="L431">      String argument = arguments.get(i);</span>
      // Add quotes to encapsulate argument.
<span class="nc bnc" id="L433" title="All 4 branches missed.">      if (!argument.startsWith(&quot;\&quot;&quot;) &amp;&amp; !argument.endsWith(&quot;\&quot;&quot;)) {</span>
<span class="nc" id="L434">        arguments.set(i, &quot;\&quot;&quot; + argument + &quot;\&quot;&quot;);</span>
      }
    }
<span class="nc" id="L437">  }</span>

  /** Avoid instantiation. */
  private ExternalProcessTools() { }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>