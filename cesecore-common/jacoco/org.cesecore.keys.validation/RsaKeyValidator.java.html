<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RsaKeyValidator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.validation</a> &gt; <span class="el_source">RsaKeyValidator.java</span></div><h1>RsaKeyValidator.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General                  *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.keys.validation;

import java.math.BigInteger;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.math.Primes;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.certificateprofile.CertificateProfileConstants;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.profiles.Profile;
import org.cesecore.util.ui.DynamicUiActionCallback;
import org.cesecore.util.ui.DynamicUiCallbackException;
import org.cesecore.util.ui.DynamicUiModel;
import org.cesecore.util.ui.DynamicUiProperty;

/**
 * Default RSA key validator.
 *
 * &lt;p&gt;The key validator is used to implement the CA/B-Forum requirements for RSA
 * public key quality requirements, including FIPS 186-4 and NIST (SP 800-89 and
 * NIST SP 56A: Revision 2) requirements. See:
 * https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.4.2.pdf section
 * 6.1.6
 *
 * @version $Id: RsaKeyValidator.java 29467 2018-07-05 16:23:04Z mikekushner $
 */
public class RsaKeyValidator extends KeyValidatorBase {

  private static final long serialVersionUID = -335429118359811926L;

  /** Class logger. */
<span class="fc" id="L57">  private static final Logger LOG = Logger.getLogger(RsaKeyValidator.class);</span>

  /** MUST be at least 2048 bits key size. */
  public static final int CAB_FORUM_BLR_142_KEY_SIZE_MIN = 2048;

  /** SHOULD be odd exponent. */
  public static final boolean CAB_FORUM_BLR_142_PUBLIC_EXPONENT_ONLY_ALLOW_ODD =
      true;

  /** MUST be &amp;gt;= 3, SHOULD be &amp;gt; 2^16+1 = 65.536+1. */
  public static final String CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MIN = &quot;65537&quot;;

  /**
   * SHOULD be &amp;lt;= 2^256-1 =
   * 115792089237316195423570985008687907853269984665640564039457584007913129639936-1
   * = 2^64*2^4-1.
   */
  public static final String CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MAX =
          &quot;1157920892373161954235709850086879078532699&quot;
          + &quot;84665640564039457584007913129639935&quot;;

  /** SHOULD be odd modulus. */
  public static final boolean CAB_FORUM_BLR_142_PUBLIC_MODULUS_ONLY_ALLOW_ODD =
      true;

  /** SHOULD not be the power of a prime. */
  public static final boolean
      CAB_FORUM_BLR_142_PUBLIC_MODULUS_DONT_ALLOW_POWER_OF_PRIME = true;

  /** SHOULD be with smallest factor &amp;gt;= 752. */
  public static final int CAB_FORUM_BLR_142_PUBLIC_MODULUS_SMALLEST_FACTOR =
      752;

  /** The key validator type. */
  private static final String TYPE_IDENTIFIER = &quot;RSA_KEY_VALIDATOR&quot;;
/** Lengths. */
  protected static final String BIT_LENGTHS = &quot;bitLengths&quot;;
  /** bool. */
  protected static final String PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD =
      &quot;publicKeyExponentOnlyAllowOdd&quot;;

  /** min exponent. */
  protected static final String PUBLIC_KEY_EXPONENT_MIN =
      &quot;publicKeyExponentMin&quot;;
/** max exponent. */
  protected static final String PUBLIC_KEY_EXPONENT_MAX =
      &quot;publicKeyExponentMax&quot;;
  /** bool. */
  protected static final String PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD =
      &quot;publicKeyModulusOnlyAllowOdd&quot;;
  /** bool. */
  protected static final String PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME =
      &quot;publicKeyModulusDontAllowPowerOfPrime&quot;;

  /** bool. */
  protected static final String PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS =
      &quot;publicKeyModulusDontAllowRocaWeakKeys&quot;;

  /** min factor. */
  protected static final String PUBLIC_KEY_MODULUS_MIN_FACTOR =
      &quot;publicKeyModulusMinFactor&quot;;
  /** min modulud. */
  protected static final String PUBLIC_KEY_MODULUS_MIN = &quot;publicKeyModulusMin&quot;;
  /** Max modulus. */
  protected static final String PUBLIC_KEY_MODULUS_MAX = &quot;publicKeyModulusMax&quot;;

  /** Threshholds for MRT. */
<span class="fc" id="L124">  private static final SortedMap&lt;Integer, Integer&gt; MILLER_RABIN_THRESHOLDS</span>
          = new TreeMap&lt;&gt;();
   static {
<span class="fc" id="L127">       MILLER_RABIN_THRESHOLDS.put(1536, 3);</span>
<span class="fc" id="L128">       MILLER_RABIN_THRESHOLDS.put(1024, 4);</span>
<span class="fc" id="L129">       MILLER_RABIN_THRESHOLDS.put(512, 7);</span>
<span class="fc" id="L130">       MILLER_RABIN_THRESHOLDS.put(0, 50);</span>
<span class="fc" id="L131">   }</span>

  /**
   * Tests if the factors of the BigInteger modulus are prime.
   *
   * @param modulus the big integer modulus to test
   * @return true if the modulus is power of a prime, false otherwise.
   */
  protected static boolean isPowerOfPrime(final BigInteger modulus) {
    // The isPowerOfPrime test is copied from
    // org.bouncycastle.crypto.asymmetric.KeyUtils in the BC-FIPS package.
    // If we move to use the FIPS provider we can use the methods directly
    // instead
    // --- Begin BC code
    // Use the same iterations as if we were testing a candidate p or q value
    // with error probability 2^-100
<span class="fc" id="L147">    int bits = modulus.bitLength();</span>
<span class="fc" id="L148">    int iterations = 0;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">    for (int its : MILLER_RABIN_THRESHOLDS.keySet()) {</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (bits &gt;= its) {</span>
<span class="fc" id="L151">            iterations = MILLER_RABIN_THRESHOLDS.get(its);</span>
        }
<span class="fc" id="L153">    }</span>
    // SP 800-89 requires use of an approved DRBG.
    //        SecureRandom testRandom = FipsDRBG.SHA256.fromEntropySource(new
    // SecureRandom(), false)
    //            .build(Pack.longToBigEndian(System.currentTimeMillis()),
    // false, Strings.toByteArray(Thread.currentThread().toString()));
<span class="fc" id="L159">    SecureRandom testRandom =</span>
        new SecureRandom(); // we cheat a little and use regular SecureRandom,
                            // which is good
<span class="fc" id="L162">    Primes.MROutput mr =</span>
<span class="fc" id="L163">        Primes.enhancedMRProbablePrimeTest(modulus, testRandom, iterations);</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">    if (!mr.isProvablyComposite()) {</span>
      // FSM_TRANS:5.16, &quot;FIPS 186-3/SP 800-89 ASSURANCES CHECK&quot;, &quot;CONDITIONAL
      // TEST&quot;, &quot;FIPS 186-3/SP 800-89 Assurances test failed&quot;
<span class="nc" id="L167">      LOG.debug(&quot;RSA modulus is not composite&quot;);</span>
<span class="nc" id="L168">      return true;</span>
    }
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">    if (!mr.isNotPrimePower()) {</span>
      // FSM_TRANS:5.16, &quot;FIPS 186-3/SP 800-89 ASSURANCES CHECK&quot;, &quot;CONDITIONAL
      // TEST&quot;, &quot;FIPS 186-3/SP 800-89 Assurances test failed&quot;
<span class="fc" id="L173">      LOG.debug(&quot;RSA modulus is a power of a prime&quot;);</span>
<span class="fc" id="L174">      return true;</span>
    }
    // --- end BC code
<span class="nc" id="L177">    return false;</span>
  }
  //    public static boolean isPowerOfPrime(BigInteger modulus) {
  //        BigInteger n = modulus;
  //        final Set&lt;BigInteger&gt; result = new TreeSet&lt;BigInteger&gt;();
  //        for (BigInteger i = BigInteger.valueOf(2);
  // i.compareTo(n.divide(i).add(BigInteger.ONE)) == -1; i =
  // i.add(BigInteger.ONE)) {
  //            while (n.mod(i).compareTo(BigInteger.ZERO) == 0) {
  //                if (result.contains(i)) { // is power of a prime.
  //                    return true;
  //                }
  //                result.add(i);
  //                n = n.divide(i);
  //            }
  //        }
  //        if (n.compareTo(BigInteger.ONE) == 1) {
  //            if (result.contains(n)) { // is power of a prime.
  //                return true;
  //            }
  //            result.add(n);
  //        }
  //        return false;
  //    }

  //  /**
  //     * Checks if the given value is a prime.
  //     * @param value the positive integer value.
  //     * @return true if the value is a prime.
  //     */
  //    public static final boolean isPrime(BigInteger value) {
  //        if (!value.isProbablePrime(5)) {
  //            return false;
  //        }
  //        final BigInteger two = BigInteger.valueOf(2);
  //        if (!two.equals(value) &amp;&amp; BigInteger.ZERO.equals(value.mod(two))) {
  //            return false;
  //        }
  //        for (BigInteger i = BigInteger.valueOf(3);
  // i.multiply(i).compareTo(value) &lt; 1; i = i.add(two)) {
  //            if (value.mod(i).equals(BigInteger.ZERO)) {
  //                return false;
  //            }
  //        }
  //        return true;
  //    }

  /**
   * Gets the smallest factor of the positive natural number greater than 2.
   *
   * @param n the number
   * @param intFactor factor
   * @return the smallest factor or 2 for n=0.
   */
  protected static final boolean hasSmallerFactorThan(
      final BigInteger n, final int intFactor) {
    //        BigInteger factor = BigInteger.valueOf(intFactor);
<span class="fc" id="L234">    final BigInteger two = new BigInteger(&quot;2&quot;);</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (intFactor &lt; 3) {</span>
<span class="fc" id="L236">      return false;</span>
    }
<span class="pc bpc" id="L238" title="1 of 4 branches missed.">    if (n.mod(two).equals(BigInteger.ZERO) &amp;&amp; intFactor &gt; 2) {</span>
<span class="fc" id="L239">      return true;</span>
    }
<span class="fc bfc" id="L241" title="All 2 branches covered.">    for (int i = intFactor; i &gt; 2; i = i - 2) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">      if (n.mod(BigInteger.valueOf(i)).equals(BigInteger.ZERO)) {</span>
<span class="fc" id="L243">        return true;</span>
      }
    }
<span class="fc" id="L246">    return false;</span>
  }

  /** Public constructor needed for deserialization. */
  public RsaKeyValidator() {
<span class="fc" id="L251">    super();</span>
<span class="fc" id="L252">  }</span>

  /**
   * Creates a new instance.
   *
   * @param name name
   */
  public RsaKeyValidator(final String name) {
<span class="nc" id="L260">    super(name);</span>
<span class="nc" id="L261">  }</span>

  @Override
  public void init() {
<span class="fc" id="L265">    super.init();</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">    if (null == data.get(BIT_LENGTHS)) {</span>
<span class="fc" id="L267">      setBitLengths(new ArrayList&lt;String&gt;());</span>
    }
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">    if (null == data.get(PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD)) {</span>
<span class="fc" id="L270">      setPublicKeyExponentOnlyAllowOdd(false);</span>
    }
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">    if (null == data.get(PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD)) {</span>
<span class="fc" id="L273">      setPublicKeyModulusOnlyAllowOdd(false);</span>
    }
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    if (null == data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME)) {</span>
<span class="fc" id="L276">      setPublicKeyModulusDontAllowPowerOfPrime(false);</span>
    }
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">    if (null == data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS)) {</span>
<span class="fc" id="L279">      setPublicKeyModulusDontAllowRocaWeakKeys(true);</span>
    }
<span class="fc" id="L281">  }</span>

  @Override
  @SuppressWarnings({&quot;serial&quot;, &quot;unchecked&quot;})
  public void initDynamicUiModel() {
<span class="nc" id="L286">    uiModel = new DynamicUiModel(data);</span>
<span class="nc" id="L287">    uiModel.add(new DynamicUiProperty&lt;String&gt;(&quot;settings&quot;));</span>
<span class="nc" id="L288">    final DynamicUiProperty&lt;Integer&gt; settingsTemplate =</span>
        new DynamicUiProperty&lt;Integer&gt;(
            Integer.class,
            SETTINGS_TEMPLATE,
<span class="nc" id="L292">            getSettingsTemplate(),</span>
<span class="nc" id="L293">            KeyValidatorSettingsTemplate.types());</span>
<span class="nc" id="L294">    settingsTemplate.setRenderingHint(DynamicUiProperty.RENDER_SELECT_ONE);</span>
<span class="nc" id="L295">    settingsTemplate.setLabels(KeyValidatorSettingsTemplate.map());</span>
<span class="nc" id="L296">    settingsTemplate.setRequired(true);</span>
<span class="nc" id="L297">    settingsTemplate.setActionCallback(</span>
<span class="nc" id="L298">        new DynamicUiActionCallback() {</span>
          @Override
          public void action(final Object parameter)
              throws DynamicUiCallbackException {
<span class="nc" id="L302">            final Map&lt;Object, Object&gt; oldValues =</span>
<span class="nc" id="L303">                (Map&lt;Object, Object&gt;) data.clone();</span>
<span class="nc" id="L304">            setKeyValidatorSettingsTemplate(</span>
<span class="nc" id="L305">                KeyValidatorSettingsTemplate.optionOf(</span>
<span class="nc" id="L306">                    Integer.parseInt((String) parameter)));</span>
<span class="nc" id="L307">            uiModel.firePropertyChange(oldValues, data);</span>
<span class="nc" id="L308">          }</span>

          @Override
          public List&lt;String&gt; getRender() {
<span class="nc" id="L312">            return null;</span>
          }
        });
<span class="nc" id="L315">    uiModel.add(settingsTemplate);</span>
<span class="nc" id="L316">    final DynamicUiProperty&lt;String&gt; bitLengths =</span>
        new DynamicUiProperty&lt;String&gt;(
            String.class,
            BIT_LENGTHS,
<span class="nc" id="L320">            getBitLengthsAsString(),</span>
<span class="nc" id="L321">            getAvailableBitLengths(0)) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L324">            return isBitLengthsDisabled();</span>
          }
        };
<span class="nc" id="L327">    bitLengths.setHasMultipleValues(true);</span>
<span class="nc" id="L328">    bitLengths.setLabels(getAvailableBitLengthsAsMap(0));</span>
<span class="nc" id="L329">    bitLengths.setRequired(true);</span>
<span class="nc" id="L330">    uiModel.add(bitLengths);</span>
<span class="nc" id="L331">    uiModel.add(</span>
        new DynamicUiProperty&lt;Boolean&gt;(
            Boolean.class,
            PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD,
<span class="nc" id="L335">            isPublicKeyExponentOnlyAllowOdd()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L338">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L341">    uiModel.add(</span>
        new DynamicUiProperty&lt;BigInteger&gt;(
            BigInteger.class,
            PUBLIC_KEY_EXPONENT_MIN,
<span class="nc" id="L345">            getPublicKeyExponentMin()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L348">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L351">    uiModel.add(</span>
        new DynamicUiProperty&lt;BigInteger&gt;(
            BigInteger.class,
            PUBLIC_KEY_EXPONENT_MAX,
<span class="nc" id="L355">            getPublicKeyExponentMax()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L358">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L361">    uiModel.add(</span>
        new DynamicUiProperty&lt;Boolean&gt;(
            Boolean.class,
            PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD,
<span class="nc" id="L365">            isPublicKeyModulusOnlyAllowOdd()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L368">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L371">    uiModel.add(</span>
        new DynamicUiProperty&lt;Boolean&gt;(
            Boolean.class,
            PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME,
<span class="nc" id="L375">            isPublicKeyModulusDontAllowPowerOfPrime()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L378">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L381">    uiModel.add(</span>
        new DynamicUiProperty&lt;Boolean&gt;(
            Boolean.class,
            PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS,
<span class="nc" id="L385">            isPublicKeyModulusDontAllowRocaWeakKeys()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L388">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L391">    uiModel.add(</span>
        new DynamicUiProperty&lt;Integer&gt;(
            Integer.class,
            PUBLIC_KEY_MODULUS_MIN_FACTOR,
<span class="nc" id="L395">            getPublicKeyModulusMinFactor()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L398">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L401">    uiModel.add(</span>
        new DynamicUiProperty&lt;BigInteger&gt;(
            BigInteger.class,
            PUBLIC_KEY_MODULUS_MIN,
<span class="nc" id="L405">            getPublicKeyModulusMin()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L408">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L411">    uiModel.add(</span>
        new DynamicUiProperty&lt;BigInteger&gt;(
            BigInteger.class,
            PUBLIC_KEY_MODULUS_MAX,
<span class="nc" id="L415">            getPublicKeyModulusMax()) {</span>
          @Override
          public boolean isDisabled() {
<span class="nc" id="L418">            return isPropertyDisabled();</span>
          }
        });
<span class="nc" id="L421">  }</span>

  /**
   * Returns true if the dynamic property fields for this validator are supposed
   * to be disabled.
   *
   * @return true if disabled.
   */
  private boolean isPropertyDisabled() {
<span class="nc" id="L430">    return KeyValidatorSettingsTemplate.USE_CAB_FORUM_SETTINGS.getOption()</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        == getSettingsTemplate();</span>
  }

  /**
   * Returns true if the dynamic property fields for this validator are supposed
   * to be disabled.
   *
   * @return true if disabled.
   */
  private boolean isBitLengthsDisabled() {
<span class="nc" id="L441">    return KeyValidatorSettingsTemplate.USE_CUSTOM_SETTINGS.getOption()</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        != getSettingsTemplate();</span>
  }

  @Override
  public void setKeyValidatorSettingsTemplate(
      final KeyValidatorSettingsTemplate template) {
<span class="nc" id="L448">    setSettingsTemplate(template.getOption());</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L450">      LOG.debug(</span>
          &quot;Set configuration template for RSA key validator settings option: &quot;
<span class="nc" id="L452">              + template.getOption()</span>
              + &quot;, &quot;
<span class="nc" id="L454">              + INTRES.getLocalizedMessage(template.getLabel()));</span>
    }
<span class="nc bnc" id="L456" title="All 2 branches missed.">    if (KeyValidatorSettingsTemplate.USE_CUSTOM_SETTINGS.equals(template)) {</span>
      // NOOP
<span class="nc bnc" id="L458" title="All 2 branches missed.">    } else if (KeyValidatorSettingsTemplate.USE_CAB_FORUM_SETTINGS.equals(</span>
        template)) {
<span class="nc" id="L460">      setCABForumBaseLineRequirements142Settings();</span>
<span class="nc" id="L461">    } else if (KeyValidatorSettingsTemplate.USE_CERTIFICATE_PROFILE_SETTINGS</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        .equals(template)) {</span>
      // NOOP: In the validation method, the key specification is matched
      // against the certificate profile.
<span class="nc" id="L465">      setCertProfileSettings();</span>
    } else {
      // NOOP
    }
<span class="nc" id="L469">  }</span>

  /**
   * Sets the CA/B Forum requirements chapter 6.1.6 for RSA public keys.
   *
   * @see &lt;a
   *     href=&quot;https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.4.2.pdf&quot;&gt;
   *     CA/B-Forum Baseline Requirements &lt;/a&gt;
   */
  private void setCertProfileSettings() {
<span class="nc" id="L479">    setBitLengths(new ArrayList&lt;String&gt;());</span>
    // We'll only reset the bit lengths, because this is what is passed on to
    // the certificate profiles
    // The other settings must be set manually anyhow and should not be reset
    //        setPublicKeyExponentOnlyAllowOdd(false);
    //        setPublicKeyExponentMin(null);
    //        setPublicKeyExponentMax(null);
    //        setPublicKeyModulusOnlyAllowOdd(false);
    //        setPublicKeyModulusDontAllowPowerOfPrime(false);
    //        setPublicKeyModulusMinFactor(null);
    //        setPublicKeyModulusMin(null);
    //        setPublicKeyModulusMax(null);
<span class="nc" id="L491">  }</span>

  /**
   * Sets the CA/B Forum requirements chapter 6.1.6 for RSA public keys.
   *
   * @see &lt;a
   *     href=&quot;https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.4.2.pdf&quot;&gt;
   *     CA/B-Forum Baseline Requirements &lt;/a&gt;
   */
  public void setCABForumBaseLineRequirements142Settings() {
    // Only apply most important conditions (sequence is Root-CA, Sub-CA,
    // User-Certificate)!
    // But this is not required at the time, because certificate validity
    // conditions are before
    // 2014 (now 2017). The minimal modulus size (2048 bits) is the same for all
    // certificate types!
<span class="nc" id="L507">    setBitLengths(getAvailableBitLengths(MIN_KEY_LENGTH));</span>
<span class="nc" id="L508">    final List&lt;Integer&gt; ids = getCertificateProfileIds();</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">    if (ids.contains(CertificateProfileConstants.CERTPROFILE_FIXED_ROOTCA)) {</span>
      // NOOP
<span class="nc bnc" id="L511" title="All 2 branches missed.">    } else if (ids.contains(</span>
<span class="nc" id="L512">        CertificateProfileConstants.CERTPROFILE_FIXED_SUBCA)) {</span>
      // NOOP
    } else {
      // NOOP
    }
    // Reset to null before setting new values.
<span class="nc" id="L518">    setPublicKeyExponentMin(null);</span>
<span class="nc" id="L519">    setPublicKeyExponentMax(null);</span>

<span class="nc" id="L521">    setPublicKeyExponentOnlyAllowOdd(</span>
        CAB_FORUM_BLR_142_PUBLIC_EXPONENT_ONLY_ALLOW_ODD);
<span class="nc" id="L523">    setPublicKeyExponentMin(</span>
        new BigInteger(CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MIN));
<span class="nc" id="L525">    setPublicKeyExponentMax(</span>
        new BigInteger(CAB_FORUM_BLR_142_PUBLIC_EXPONENT_MAX));
<span class="nc" id="L527">    setPublicKeyModulusOnlyAllowOdd(</span>
        CAB_FORUM_BLR_142_PUBLIC_MODULUS_ONLY_ALLOW_ODD);
<span class="nc" id="L529">    setPublicKeyModulusDontAllowPowerOfPrime(</span>
        CAB_FORUM_BLR_142_PUBLIC_MODULUS_DONT_ALLOW_POWER_OF_PRIME);
<span class="nc" id="L531">    setPublicKeyModulusMinFactor(</span>
<span class="nc" id="L532">        CAB_FORUM_BLR_142_PUBLIC_MODULUS_SMALLEST_FACTOR);</span>
<span class="nc" id="L533">    setPublicKeyModulusMin(null);</span>
<span class="nc" id="L534">    setPublicKeyModulusMax(null);</span>

    // Not strictly a requirement according to the Baseline Requirements, but
    // there is no reason to allow ROCA weak keys
<span class="nc" id="L538">    setPublicKeyModulusDontAllowRocaWeakKeys(true);</span>
<span class="nc" id="L539">  }</span>

  /** bits. */
  private static final int MIN_KEY_LENGTH = 2048;

  /**
   * @return values
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getBitLengths() {
<span class="fc" id="L549">    return (List&lt;String&gt;) data.get(BIT_LENGTHS);</span>
  }

  /**
   * @return values
   */
  public String getBitLengthsAsString() {
<span class="nc bnc" id="L556" title="All 2 branches missed.">    return getBitLengths() != null</span>
<span class="nc" id="L557">        ? StringUtils.join(getBitLengths(), LIST_SEPARATOR)</span>
<span class="nc" id="L558">        : StringUtils.EMPTY;</span>
  }

  /**
   * @param values values
   */
  public void setBitLengths(final List&lt;String&gt; values) {
<span class="fc" id="L565">    Collections.sort(values);</span>
<span class="fc" id="L566">    data.put(BIT_LENGTHS, values);</span>
<span class="fc" id="L567">  }</span>

  /**
   * @return bool
   */
  public boolean isPublicKeyExponentOnlyAllowOdd() {
<span class="fc" id="L573">    return ((Boolean) data.get(PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD))</span>
<span class="fc" id="L574">        .booleanValue();</span>
  }

  /**
   * @param allowed bool
   */
  public void setPublicKeyExponentOnlyAllowOdd(final boolean allowed) {
<span class="fc" id="L581">    data.put(PUBLIC_KEY_EXPONENT_ONLY_ALLOW_ODD, Boolean.valueOf(allowed));</span>
<span class="fc" id="L582">  }</span>

  /**
   * @return min exponent
   */
  public BigInteger getPublicKeyExponentMin() {
<span class="fc bfc" id="L588" title="All 2 branches covered.">    if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_EXPONENT_MIN))) {</span>
<span class="fc" id="L589">      return new BigInteger(((String) data.get(PUBLIC_KEY_EXPONENT_MIN)));</span>
    } else {
<span class="fc" id="L591">      return null;</span>
    }
  }

  /**
   * @return min exponent
   */
  public String getPublicKeyExponentMinAsString() {
<span class="fc" id="L599">    return (String) data.get(PUBLIC_KEY_EXPONENT_MIN);</span>
  }

  /**
   * Sets the validator minimum allowed public key exponent.
   *
   * @param value The new minimum public key exponent as BigInteger
   */
  public void setPublicKeyExponentMin(final BigInteger value) {
<span class="fc bfc" id="L608" title="All 2 branches covered.">    if (null == value) {</span>
<span class="fc" id="L609">      data.put(PUBLIC_KEY_EXPONENT_MIN, null);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">    } else if (!(value.compareTo(BigInteger.ZERO) == -1)) {</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">      if (getPublicKeyExponentMax() == null</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">          || value.compareTo(getPublicKeyExponentMax()) &lt; 1) {</span>
<span class="fc" id="L613">        data.put(PUBLIC_KEY_EXPONENT_MIN, value.toString());</span>
      } else {
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L616">          final String message =</span>
<span class="nc" id="L617">              INTRES.getLocalizedMessage(</span>
                  &quot;validator.error.minimum_bigger_log&quot;,
                  value,
<span class="nc" id="L620">                  getPublicKeyExponentMax());</span>
<span class="nc" id="L621">          LOG.debug(message);</span>
<span class="nc" id="L622">        }</span>
      }
    } else {
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L626">        LOG.debug(</span>
<span class="nc" id="L627">            INTRES.getLocalizedMessage(</span>
                &quot;validator.error.set_key_validator_exp_min&quot;, value));
      }
    }
<span class="fc" id="L631">  }</span>

  /**
   * Setting value for PublicKeyExponentMinAsString.
   *
   * @param value the string value for PublicKeyExponentMin
   */
  public void setPublicKeyExponentMinAsString(final String value) {
<span class="fc" id="L639">    setPublicKeyExponentMin(new BigInteger(value));</span>
<span class="fc" id="L640">  }</span>

  /**
   * @return Max exponent
   */
  public BigInteger getPublicKeyExponentMax() {
<span class="fc bfc" id="L646" title="All 2 branches covered.">    if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_EXPONENT_MAX))) {</span>
<span class="fc" id="L647">      return new BigInteger(((String) data.get(PUBLIC_KEY_EXPONENT_MAX)));</span>
    } else {
<span class="fc" id="L649">      return null;</span>
    }
  }

  /**
   * @return max exponent
   */
  public String getPublicKeyExponentMaxAsString() {
<span class="fc" id="L657">    return (String) data.get(PUBLIC_KEY_EXPONENT_MAX);</span>
  }

  /**
   * Sets the validator maximum allowed public key exponent.
   *
   * @param value The new maximum public key exponent as BigInteger
   */
  public void setPublicKeyExponentMax(final BigInteger value) {
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">    if (null == value) {</span>
<span class="nc" id="L667">      data.put(PUBLIC_KEY_EXPONENT_MAX, null);</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">    } else if (!(value.compareTo(BigInteger.ZERO) == -1)) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">      if (getPublicKeyExponentMin() == null</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">          || value.compareTo(getPublicKeyExponentMin()) &gt; -1) {</span>
<span class="fc" id="L671">        data.put(PUBLIC_KEY_EXPONENT_MAX, value.toString());</span>
      } else {
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L674">          final String message =</span>
<span class="nc" id="L675">              INTRES.getLocalizedMessage(</span>
                  &quot;validator.error.minimum_bigger_log&quot;,
<span class="nc" id="L677">                  getPublicKeyExponentMin(),</span>
                  value);
<span class="nc" id="L679">          LOG.debug(message);</span>
<span class="nc" id="L680">        }</span>
      }
    } else {
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L684">        LOG.debug(</span>
<span class="nc" id="L685">            INTRES.getLocalizedMessage(</span>
                &quot;validator.error.set_key_validator_exp_max&quot;, value));
      }
    }
<span class="fc" id="L689">  }</span>

  /**
   * Setting value for PublicKeyExponentMaxAsString.
   *
   * @param value the string value for PublicKeyExponentMax
   */
  public void setPublicKeyExponentMaxAsString(final String value) {
<span class="fc" id="L697">    setPublicKeyExponentMax(new BigInteger(value));</span>
<span class="fc" id="L698">  }</span>

  /**
   * @return bool
   */
  public boolean isPublicKeyModulusOnlyAllowOdd() {
<span class="fc" id="L704">    return ((Boolean) data.get(PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD))</span>
<span class="fc" id="L705">        .booleanValue();</span>
  }

  /**
   * @param allowed bool
   */
  public void setPublicKeyModulusOnlyAllowOdd(final boolean allowed) {
<span class="fc" id="L712">    data.put(PUBLIC_KEY_MODULUS_ONLY_ALLOW_ODD, Boolean.valueOf(allowed));</span>
<span class="fc" id="L713">  }</span>

  /**
   * @return bool
   */
  public boolean isPublicKeyModulusDontAllowPowerOfPrime() {
<span class="fc" id="L719">    return ((Boolean) data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME))</span>
<span class="fc" id="L720">        .booleanValue();</span>
  }

  /**
   * @return bool
   */
  public boolean isPublicKeyModulusDontAllowRocaWeakKeys() {
<span class="fc" id="L727">    Boolean ret =</span>
<span class="fc" id="L728">        (Boolean) data.get(PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS);</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">    return ret != null</span>
<span class="fc" id="L730">        ? ret.booleanValue()</span>
<span class="nc" id="L731">        : false; // upgraded value, we must be null safe, default false</span>
  }

  /**
   * @param allowed bool
   */
  public void setPublicKeyModulusDontAllowPowerOfPrime(final boolean allowed) {
<span class="fc" id="L738">    data.put(</span>
<span class="fc" id="L739">        PUBLIC_KEY_MODULUS_DONT_ALLOW_POWER_OF_PRIME, Boolean.valueOf(allowed));</span>
<span class="fc" id="L740">  }</span>

  /**
   * @param allowed bool
   */
  public void setPublicKeyModulusDontAllowRocaWeakKeys(final boolean allowed) {
<span class="fc" id="L746">    data.put(</span>
<span class="fc" id="L747">        PUBLIC_KEY_MODULUS_DONT_ALLOW_ROCA_WEAK_KEYS, Boolean.valueOf(allowed));</span>
<span class="fc" id="L748">  }</span>

  /**
   * @return min factor
   */
  public Integer getPublicKeyModulusMinFactor() {
<span class="fc" id="L754">    return (Integer) data.get(PUBLIC_KEY_MODULUS_MIN_FACTOR);</span>
  }

  /**
   * Setting value for PublicKeyModulusMinFactor.
   *
   * @param type the value for PublicKeyModulusMinFactor
   */
  public void setPublicKeyModulusMinFactor(final Integer type) {
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">    if (null == type) {</span>
<span class="nc" id="L764">      data.put(PUBLIC_KEY_MODULUS_MIN_FACTOR, null);</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">    } else if (!(type &lt; 0)) {</span>
<span class="fc" id="L766">      data.put(PUBLIC_KEY_MODULUS_MIN_FACTOR, type);</span>
    } else {
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L769">        LOG.debug(</span>
<span class="nc" id="L770">            INTRES.getLocalizedMessage(</span>
                &quot;validator.error.set_key_validator_fact_min&quot;, type));
      }
    }
<span class="fc" id="L774">  }</span>

  /**
   * @return min modulus
   */
  public BigInteger getPublicKeyModulusMin() {
<span class="fc bfc" id="L780" title="All 2 branches covered.">    if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_MODULUS_MIN))) {</span>
<span class="fc" id="L781">      return new BigInteger(((String) data.get(PUBLIC_KEY_MODULUS_MIN)));</span>
    } else {
<span class="fc" id="L783">      return null;</span>
    }
  }

  /**
   * @return min modulus
   */
  public String getPublicKeyModulusMinAsString() {
<span class="fc" id="L791">    return (String) data.get(PUBLIC_KEY_MODULUS_MIN);</span>
  }

  /**
   * Setting value for PublicKeyModulusMin.
   *
   * @param value the value for PublicKeyModulusMin
   */
  public void setPublicKeyModulusMin(final BigInteger value) {
<span class="fc bfc" id="L800" title="All 2 branches covered.">    if (null == value) {</span>
<span class="fc" id="L801">      data.put(PUBLIC_KEY_MODULUS_MIN, null);</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">    } else if (!(value.compareTo(BigInteger.ZERO) == -1)) {</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">      if (getPublicKeyModulusMax() == null</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">          || value.compareTo(getPublicKeyModulusMax()) &lt; 1) {</span>
<span class="fc" id="L805">        data.put(PUBLIC_KEY_MODULUS_MIN, value.toString());</span>
      } else {
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L808">          final String message =</span>
<span class="nc" id="L809">              INTRES.getLocalizedMessage(</span>
                  &quot;validator.error.minimum_bigger_log&quot;,
                  value,
<span class="nc" id="L812">                  getPublicKeyModulusMax());</span>
<span class="nc" id="L813">          LOG.debug(message);</span>
<span class="nc" id="L814">        }</span>
      }
    } else {
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L818">        LOG.debug(</span>
<span class="nc" id="L819">            INTRES.getLocalizedMessage(</span>
                &quot;validator.error.set_key_validator_mod_min&quot;, value));
      }
    }
<span class="fc" id="L823">  }</span>

  /**
   * Setting value for PublicKeyModulusMinAsString.
   *
   * @param value the string value for PublicKeyModulusMin
   */
  public void setPublicKeyModulusMinAsString(final String value) {
<span class="fc" id="L831">    setPublicKeyModulusMin(new BigInteger(value));</span>
<span class="fc" id="L832">  }</span>

  /**
   * @return max modulus
   */
  public BigInteger getPublicKeyModulusMax() {
<span class="fc bfc" id="L838" title="All 2 branches covered.">    if (StringUtils.isNotBlank((String) data.get(PUBLIC_KEY_MODULUS_MAX))) {</span>
<span class="fc" id="L839">      return new BigInteger((String) data.get(PUBLIC_KEY_MODULUS_MAX));</span>
    } else {
<span class="fc" id="L841">      return null;</span>
    }
  }

  /**
   * @return modulus
   */
  public String getPublicKeyModulusMaxAsString() {
<span class="fc" id="L849">    return (String) data.get(PUBLIC_KEY_MODULUS_MAX);</span>
  }

  /**
   * Setting value for PublicKeyModulusMax.
   *
   * @param value the value for PublicKeyModulusMax
   */
  public void setPublicKeyModulusMax(final BigInteger value) {
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">    if (null == value) {</span>
<span class="nc" id="L859">      data.put(PUBLIC_KEY_MODULUS_MAX, null);</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">    } else if (!(value.compareTo(BigInteger.ZERO) == -1)) {</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">      if (getPublicKeyModulusMin() == null</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">          || value.compareTo(getPublicKeyModulusMin()) &gt; -1) {</span>
<span class="fc" id="L863">        data.put(PUBLIC_KEY_MODULUS_MAX, value.toString());</span>
      } else {
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L866">          final String message =</span>
<span class="nc" id="L867">              INTRES.getLocalizedMessage(</span>
                  &quot;validator.error.minimum_bigger_log&quot;,
<span class="nc" id="L869">                  getPublicKeyModulusMin(),</span>
                  value);
<span class="nc" id="L871">          LOG.debug(message);</span>
<span class="nc" id="L872">        }</span>
      }
    } else {
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L876">        LOG.debug(</span>
<span class="nc" id="L877">            INTRES.getLocalizedMessage(</span>
                &quot;validator.error.set_key_validator_mod_max&quot;, value));
      }
    }
<span class="fc" id="L881">  }</span>

  /**
   * Setting value for PublicKeyModulusMaxAsString.
   *
   * @param value the string value for PublicKeyModulusMax
   */
  public void setPublicKeyModulusMaxAsString(final String value) {
<span class="fc" id="L889">    setPublicKeyModulusMax(new BigInteger(value));</span>
<span class="fc" id="L890">  }</span>

  @Override
  public void upgrade() {
<span class="nc" id="L894">    super.upgrade();</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L896">      LOG.trace(&quot;&gt;upgrade: &quot; + getLatestVersion() + &quot;, &quot; + getVersion());</span>
    }
<span class="nc bnc" id="L898" title="All 2 branches missed.">    if (Float.compare(LATEST_VERSION, getVersion()) != 0) {</span>
      // New version of the class, upgrade.
<span class="nc" id="L900">      LOG.info(</span>
<span class="nc" id="L901">          INTRES.getLocalizedMessage(</span>
<span class="nc" id="L902">              &quot;rsakeyvalidator.upgrade&quot;, Float.valueOf(getVersion())));</span>
<span class="nc" id="L903">      init();</span>
    }
<span class="nc" id="L905">  }</span>

  @Override
  public List&lt;String&gt; validate(
      final PublicKey publicKey, final CertificateProfile certificateProfile)
      throws ValidatorNotApplicableException, ValidationException {
<span class="fc" id="L911">    List&lt;String&gt; messages = new ArrayList&lt;String&gt;();</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L913">      LOG.debug(</span>
          &quot;Validating public key with algorithm &quot;
<span class="nc" id="L915">              + publicKey.getAlgorithm()</span>
              + &quot;, format &quot;
<span class="nc" id="L917">              + publicKey.getFormat()</span>
              + &quot;, implementation &quot;
<span class="nc" id="L919">              + publicKey.getClass().getName());</span>
    }
<span class="pc bpc" id="L921" title="2 of 4 branches missed.">    if (!AlgorithmConstants.KEYALGORITHM_RSA.equals(publicKey.getAlgorithm())</span>
        || !(publicKey instanceof RSAPublicKey)) {
<span class="nc" id="L923">      final String message =</span>
          &quot;Invalid: Public key algorithm is not RSA or could not be parsed: &quot;
<span class="nc" id="L925">              + publicKey.getAlgorithm()</span>
              + &quot;, format &quot;
<span class="nc" id="L927">              + publicKey.getFormat();</span>
<span class="nc" id="L928">      messages.add(message);</span>
      // Make sure this ends up in the server log
<span class="nc" id="L930">      LOG.info(message + &quot;, &quot; + publicKey.getClass().getName());</span>
<span class="nc" id="L931">      throw new ValidatorNotApplicableException(message);</span>
    }
<span class="fc" id="L933">    final RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;</span>
<span class="fc" id="L934">    final BigInteger publicKeyExponent = rsaPublicKey.getPublicExponent();</span>
<span class="fc" id="L935">    final BigInteger publicKeyModulus = rsaPublicKey.getModulus();</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L937">      LOG.debug(</span>
          &quot;Validate RSA public key with exponent &quot;
              + publicKeyExponent
              + &quot; and modulus &quot;
              + publicKeyModulus);
    }
<span class="fc" id="L943">    final int settingsOption = getSettingsTemplate();</span>
<span class="fc" id="L944">    final int keyLength = KeyTools.getKeyLength(publicKey);</span>
<span class="fc" id="L945">    if (KeyValidatorSettingsTemplate.USE_CERTIFICATE_PROFILE_SETTINGS</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">            .getOption()</span>
        == settingsOption) {
<span class="nc" id="L948">      final List&lt;Integer&gt; bitLengths =</span>
<span class="nc" id="L949">          certificateProfile.getAvailableBitLengthsAsList();</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">      if (!bitLengths.contains(Integer.valueOf(keyLength))) {</span>
        // Invalid Key in request: Illegal key length, not authorized by
        // certificate profile: 2048.. Please supply a correct request.
<span class="nc" id="L953">        messages.add(</span>
            &quot;Invalid: RSA key size/strength: Use one of the following &quot;
                + bitLengths
                + &quot;.&quot;);
      }
<span class="nc" id="L958">    } else {</span>
<span class="fc" id="L959">      final List&lt;String&gt; bitLengths = getBitLengths();</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">      if (!bitLengths.contains(Integer.toString(keyLength))) {</span>
<span class="nc" id="L961">        messages.add(</span>
            &quot;Invalid: RSA key size/strength: Use one of the following &quot;
                + bitLengths
                + &quot;.&quot;);
      }
    }
<span class="fc bfc" id="L967" title="All 2 branches covered.">    if (isPublicKeyExponentOnlyAllowOdd()) {</span>
<span class="fc" id="L968">      if (publicKeyExponent</span>
<span class="fc" id="L969">              .mod(BigInteger.valueOf(2L))</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">              .compareTo(BigInteger.ZERO)</span>
          == 0) {
<span class="fc" id="L972">        messages.add(&quot;Invalid: RSA public key exponent is odd.&quot;);</span>
      } else {
<span class="fc" id="L974">        LOG.trace(&quot;isPublicKeyExponentOnlyAllowOdd passed&quot;);</span>
      }
    }
<span class="fc bfc" id="L977" title="All 2 branches covered.">    if (null != getPublicKeyExponentMin()) {</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">      if (publicKeyExponent.compareTo(getPublicKeyExponentMin()) == -1) {</span>
<span class="fc" id="L979">        messages.add(</span>
            &quot;Invalid: RSA public key exponent is smaller than &quot;
<span class="fc" id="L981">                + getPublicKeyExponentMin());</span>
      } else {
<span class="fc" id="L983">        LOG.trace(&quot;getPublicKeyExponentMin passed&quot;);</span>
      }
    }
<span class="fc bfc" id="L986" title="All 2 branches covered.">    if (null != getPublicKeyExponentMax()) {</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">      if (publicKeyExponent.compareTo(getPublicKeyExponentMax()) == 1) {</span>
<span class="fc" id="L988">        messages.add(</span>
            &quot;Invalid: RSA public key exponent is greater than &quot;
<span class="fc" id="L990">                + getPublicKeyExponentMax());</span>
      }
    }
<span class="fc bfc" id="L993" title="All 2 branches covered.">    if (isPublicKeyModulusOnlyAllowOdd()) {</span>
<span class="fc" id="L994">      if (publicKeyModulus</span>
<span class="fc" id="L995">              .mod(BigInteger.valueOf(2L))</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">              .compareTo(BigInteger.ZERO)</span>
          == 0) {
<span class="fc" id="L998">        messages.add(&quot;Invalid: RSA public key modulus is odd.&quot;);</span>
      } else {
<span class="fc" id="L1000">        LOG.trace(&quot;isPublicKeyModulusOnlyAllowOdd passed&quot;);</span>
      }
    }
<span class="fc bfc" id="L1003" title="All 2 branches covered.">    if (isPublicKeyModulusDontAllowPowerOfPrime()) {</span>
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">      if (isPowerOfPrime(publicKeyModulus)) {</span>
<span class="fc" id="L1005">        messages.add(</span>
            &quot;Invalid: RSA public key modulus is not allowed to be the power of&quot;
                + &quot; a prime.&quot;);
      } else {
<span class="nc" id="L1009">        LOG.trace(&quot;isPublicKeyModulusDontAllowPowerOfPrime passed&quot;);</span>
      }
    }
<span class="fc bfc" id="L1012" title="All 2 branches covered.">    if (isPublicKeyModulusDontAllowRocaWeakKeys()) {</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">      if (RocaBrokenKey.isAffected(publicKeyModulus)) {</span>
<span class="fc" id="L1014">        messages.add(</span>
            &quot;Invalid: RSA public key modulus is a weak key according to&quot;
                + &quot; CVE-2017-15361.&quot;);
      } else {
<span class="fc" id="L1018">        LOG.trace(&quot;isPublicKeyModulusDontAllowRocaWeakKeys passed&quot;);</span>
      }
    }
<span class="fc bfc" id="L1021" title="All 2 branches covered.">    if (null != getPublicKeyModulusMinFactor()) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">      if (hasSmallerFactorThan(</span>
<span class="fc" id="L1023">          publicKeyModulus, getPublicKeyModulusMinFactor() + 1)) {</span>
<span class="fc" id="L1024">        messages.add(</span>
            &quot;Invalid: RSA public key modulus smallest factor is less than &quot;
<span class="fc" id="L1026">                + getPublicKeyModulusMinFactor());</span>
      } else {
<span class="fc" id="L1028">        LOG.trace(&quot;getPublicKeyModulusMinFactor passed&quot;);</span>
      }
    }
<span class="fc bfc" id="L1031" title="All 2 branches covered.">    if (null != getPublicKeyModulusMin()) {</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">      if (publicKeyModulus.compareTo(getPublicKeyModulusMin()) == -1) {</span>
<span class="fc" id="L1033">        messages.add(</span>
            &quot;Invalid: RSA public key modulus is smaller than &quot;
<span class="fc" id="L1035">                + getPublicKeyModulusMin());</span>
      } else {
<span class="nc" id="L1037">        LOG.trace(&quot;getPublicKeyModulusMin passed&quot;);</span>
      }
    }
<span class="fc bfc" id="L1040" title="All 2 branches covered.">    if (null != getPublicKeyModulusMax()) {</span>
<span class="fc bfc" id="L1041" title="All 2 branches covered.">      if (publicKeyModulus.compareTo(getPublicKeyModulusMax()) == 1) {</span>
<span class="fc" id="L1042">        messages.add(</span>
            &quot;Invalid: RSA public key modulus is greater than &quot;
<span class="fc" id="L1044">                + getPublicKeyModulusMax());</span>
      } else {
<span class="fc" id="L1046">        LOG.trace(&quot;getPublicKeyModulusMax passed&quot;);</span>
      }
    }

<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">      for (String message : messages) {</span>
<span class="nc" id="L1052">        LOG.debug(message);</span>
<span class="nc" id="L1053">      }</span>
    }
<span class="fc" id="L1055">    return messages;</span>
  }

  /**
   * Gets the available bit lengths to choose.
   *
   * @return the list of available bit lengths.
   */
  public List&lt;String&gt; getAvailableBitLengths() {
<span class="nc" id="L1064">    final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">    for (int length : CertificateProfile.DEFAULTBITLENGTHS) {</span>
<span class="nc" id="L1066">      result.add(Integer.toString(length));</span>
    }
<span class="nc" id="L1068">    return result;</span>
  }

  /**
   * Gets the available bit lengths to choose.
   *
   * @param minLength minimum length
   * @return the list of available bit lengths.
   */
  public static List&lt;String&gt; getAvailableBitLengths(final int minLength) {
<span class="nc" id="L1078">    final List&lt;String&gt; result = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">    for (int length : CertificateProfile.DEFAULTBITLENGTHS) {</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">      if (length &gt;= minLength) {</span>
<span class="nc" id="L1081">        result.add(Integer.toString(length));</span>
      }
    }
<span class="nc" id="L1084">    return result;</span>
  }

  /**
   * Gets the available bit lengths to choose as map ( key = value).
   *
   * @param minLength minimum length
   * @return the map of available bit lengths.
   */
  public static Map&lt;String, String&gt; getAvailableBitLengthsAsMap(
      final int minLength) {
<span class="nc" id="L1095">    final Map&lt;String, String&gt; result = new LinkedHashMap&lt;String, String&gt;();</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">    for (int length : CertificateProfile.DEFAULTBITLENGTHS) {</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">      if (length &gt;= minLength) {</span>
<span class="nc" id="L1098">        result.put(Integer.toString(length), Integer.toString(length));</span>
      }
    }
<span class="nc" id="L1101">    return result;</span>
  }

  @Override
  public String getLabel() {
<span class="nc" id="L1106">    return INTRES.getLocalizedMessage(&quot;validator.implementation.key.rsa&quot;);</span>
  }

  @Override
  public String getValidatorTypeIdentifier() {
<span class="nc" id="L1111">    return TYPE_IDENTIFIER;</span>
  }

  @Override
  protected Class&lt;? extends Profile&gt; getImplementationClass() {
<span class="fc" id="L1116">    return RsaKeyValidator.class;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>