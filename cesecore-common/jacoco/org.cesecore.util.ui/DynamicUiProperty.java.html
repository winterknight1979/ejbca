<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DynamicUiProperty.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.util.ui</a> &gt; <span class="el_source">DynamicUiProperty.java</span></div><h1>DynamicUiProperty.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.util.ui;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.SerializationUtils;
import org.apache.commons.lang.StringUtils;
import org.cesecore.authorization.user.AccessMatchType;
import org.cesecore.util.Base64;
import org.cesecore.util.LookAheadObjectInputStream;

/**
 * Allows creation of dynamic properties for display in the UI.
 *
 * @version $Id: DynamicUiProperty.java 34324 2020-01-17 12:22:39Z henriks $
 * @param &lt;T&gt; Type
 */
public class DynamicUiProperty&lt;T extends Serializable&gt;
    implements Serializable, Cloneable {

  private static final long serialVersionUID = 1L;

  /** Literal for list separator. */
  public static final String LIST_SEPARATOR = &quot;;&quot;;

  /** Literal for no rendering. */
  public static final String RENDER_NONE = &quot;none&quot;;

  /** Literal for rendering hint for labels. */
  public static final String RENDER_LABEL = &quot;label&quot;;

  /** Literal for rendering hint for text fields. */
  public static final String RENDER_TEXTFIELD = &quot;textfield&quot;;

  /** Literal for rendering hint for text areas. */
  public static final String RENDER_TEXTAREA = &quot;textarea&quot;;

  /** Literal for rendering hint for check boxes. */
  public static final String RENDER_CHECKBOX = &quot;checkbox&quot;;

  /** Literal for rendering hint for buttons. */
  public static final String RENDER_BUTTON = &quot;button&quot;;

  /** Literal for rendering hint for text fields. */
  public static final String RENDER_SELECT_ONE = &quot;selectone&quot;;

  /** Literal for rendering hint for text fields. */
  public static final String RENDER_SELECT_MANY = &quot;selectmany&quot;;

  /** Literal for rendering hint for file chooser. */
  public static final String RENDER_FILE_CHOOSER = &quot;filechooser&quot;;

  /** The name (key) of the property. */
  private String name;

  /** Default value or null. */
  private T defaultValue;

  /** Property values (or value at index 0). */
<span class="pc" id="L88">  private List&lt;T&gt; values = new ArrayList&lt;&gt;();</span>

  /** Value range or null. */
  private Collection&lt;T&gt; possibleValues;

  /** If the UI widget is supposed to be filled with a value. */
<span class="pc" id="L94">  private boolean required = false;</span>

  /** If the UI widget is supposed to be disabled. */
<span class="pc" id="L97">  private boolean disabled = false;</span>

  /** If the value has to be stored in the domain object properties. */
<span class="pc" id="L100">  private boolean transientValue = false;</span>

  /**
   * If a domain object property is stored as semi-colon separated string
   * instead of {@link java.util.List}.
   */
<span class="pc" id="L106">  private boolean saveListAsString = false;</span>

  /** Hint. */
  private String renderingHint;

  /** True if I18N labels has to be rendered. */
<span class="pc" id="L112">  private boolean labeled = false;</span>

  /** List of I18N keys / labels if available. */
<span class="pc" id="L115">  private Map&lt;?, String&gt; labels = new LinkedHashMap&lt;Object, String&gt;();</span>

  /**
   * Flag to indicate that the property is displayed as label in the label
   * column only (there will be no validation if available, etc.).
   */
<span class="pc" id="L121">  private boolean labelOnly = false;</span>

  /** Action callback. */
  private DynamicUiActionCallback actionCallback;

  /** Property callback (default: NONE). */
<span class="pc" id="L127">  private DynamicUiPropertyCallback propertyCallback =</span>
      DynamicUiPropertyCallback.NONE;

  /** Property type. */
  private Class&lt;? extends Serializable&gt; type;

  /** Field validator (will be applied if not null). */
<span class="pc" id="L134">  private DynamicUiPropertyValidator&lt;T&gt; validator = null;</span>

  /** Reference to the holder object (implements coupling to components). */
  private DynamicUiModel dynamicUiModel;

  /** Denotes whether this property can have multiple values. */
<span class="pc" id="L140">  private boolean hasMultipleValues = false;</span>

  /**
   * Constructor required by java.lang.Serializable. Type must be set if this
   * constructor is used.
   */
<span class="nc" id="L146">  public DynamicUiProperty() { }</span>

  /**
   * Constructs a dynamic UI property rendered as a simple label in the UI.
   *
   * @param aName the name of this property, for display in the UI
   */
  @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L154">  public DynamicUiProperty(final String aName) {</span>
<span class="nc" id="L155">    this.name = aName;</span>
<span class="nc" id="L156">    this.type = String.class;</span>
<span class="nc" id="L157">    this.defaultValue = (T) aName;</span>
<span class="nc" id="L158">    this.values.add((T) aName);</span>
<span class="nc" id="L159">    this.possibleValues = null;</span>
<span class="nc" id="L160">    setLabelOnly(true);</span>
<span class="nc" id="L161">    setTransientValue(true);</span>
<span class="nc" id="L162">  }</span>

  /**
   * Constructor. Note the T must implement toString().
   *
   * @param aName the name of this property, for display in the UI.
   * @param aDefaultValue the default value, if any.
   */
<span class="fc" id="L170">  public DynamicUiProperty(final String aName, final T aDefaultValue) {</span>
<span class="fc" id="L171">    this.name = aName;</span>
<span class="fc" id="L172">    this.defaultValue = aDefaultValue;</span>
<span class="fc" id="L173">    this.values.add(aDefaultValue);</span>
<span class="fc" id="L174">    this.possibleValues = null;</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">    if (aDefaultValue != null) {</span>
<span class="fc" id="L176">      this.type = aDefaultValue.getClass();</span>
    }
<span class="fc" id="L178">  }</span>

  /**
   * Constructor. Note the T must implement toString().
   *
   * @param aType Class type (as workaround for forgotten parameter type at
   *     runtime).
   * @param aName the name of this property, for display in the UI.
   * @param aDefaultValue the default value, if any.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public DynamicUiProperty(
<span class="nc" id="L190">      final Class&lt;T&gt; aType, final String aName, final T aDefaultValue) {</span>
<span class="nc" id="L191">    this.name = aName;</span>
<span class="nc" id="L192">    this.defaultValue = aDefaultValue;</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">    if (String.class.equals(aType)</span>
        &amp;&amp; aDefaultValue != null
<span class="nc bnc" id="L195" title="All 2 branches missed.">        &amp;&amp; ((String) aDefaultValue).contains(LIST_SEPARATOR)) {</span>
      for (String value
<span class="nc bnc" id="L197" title="All 2 branches missed.">          : StringUtils.split((String) aDefaultValue, LIST_SEPARATOR)) {</span>
<span class="nc" id="L198">        this.values.add((T) value);</span>
      }
    } else {
<span class="nc" id="L201">      this.values.add(aDefaultValue);</span>
    }
<span class="nc" id="L203">    this.possibleValues = null;</span>
<span class="nc" id="L204">    this.type = aType;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">    if (File.class.getName().equals(getType().getName())</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        || byte[].class.getName().equals(getType().getName())) {</span>
<span class="nc" id="L207">      setRenderingHint(RENDER_FILE_CHOOSER);</span>
    }
<span class="nc" id="L209">  }</span>

  /**
   * Constructor. Note the T must implement toString().
   *
   * @param aName the name of this property, for display in the UI.
   * @param aDefaultValue the default value, if any. May not be null.
   * @param thePossibleValues a Collection of possible values. If set to null no
   *     validation will be performed, if set to an empty list then values are
   *     presumed to be set at runtime.
   */
  public DynamicUiProperty(
      final String aName,
      final T aDefaultValue,
      final Collection&lt;T&gt; thePossibleValues) {
<span class="fc" id="L224">    this(aName, aDefaultValue);</span>
<span class="fc" id="L225">    this.possibleValues = thePossibleValues;</span>
<span class="fc" id="L226">  }</span>

  /**
   * Constructor. Note the T must implement toString().
   *
   * @param aType Class type (as workaround for forgotten parameter type at
   *     runtime).
   * @param aNname The name of this property, for display in the UI
   * @param aDefaultValue the default value, if any.
   * @param thePossibleValues a Collection of possible values. If set to null no
   *     validation will be performed, if set to an empty list then values are
   *     presumed to be set at runtime.
   */
  public DynamicUiProperty(
      final Class&lt;T&gt; aType,
      final String aNname,
      final T aDefaultValue,
      final Collection&lt;T&gt; thePossibleValues) {
<span class="nc" id="L244">    this(aType, aNname, aDefaultValue);</span>
<span class="nc" id="L245">    this.possibleValues = thePossibleValues;</span>
<span class="nc" id="L246">  }</span>

  /**
   * Copy constructor for DynamicUiProperty objects.
   *
   * @param original the original property
   */
  @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L254">  public DynamicUiProperty(final DynamicUiProperty&lt;T&gt; original) {</span>
<span class="fc" id="L255">    this.name = original.getName();</span>
<span class="fc" id="L256">    this.type = original.getType();</span>
<span class="fc" id="L257">    this.required = original.isRequired();</span>
<span class="fc" id="L258">    this.renderingHint = original.getRenderingHint();</span>
<span class="fc" id="L259">    this.labelOnly = original.isLabelOnly();</span>
<span class="fc" id="L260">    this.labeled = original.isI18NLabeled();</span>
<span class="fc" id="L261">    this.defaultValue = original.getDefaultValue();</span>
<span class="fc" id="L262">    this.setHasMultipleValues(original.getHasMultipleValues());</span>
    try {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">      if (!original.getHasMultipleValues()) {</span>
<span class="fc" id="L265">        setValue((T) SerializationUtils.clone(original.getValue()));</span>
      } else {
<span class="nc" id="L267">        final List&lt;T&gt; clonedValues = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        for (T value : original.getValues()) {</span>
<span class="nc" id="L269">          clonedValues.add((T) SerializationUtils.clone(value));</span>
<span class="nc" id="L270">        }</span>
<span class="nc" id="L271">        setValues(clonedValues);</span>
      }
<span class="nc" id="L273">    } catch (PropertyValidationException e) {</span>
<span class="nc" id="L274">      throw new IllegalArgumentException(</span>
          &quot;Invalid value was intercepted in copy constructor, which should not&quot;
              + &quot; happen.&quot;,
          e);
<span class="fc" id="L278">    }</span>
<span class="fc" id="L279">    this.possibleValues = original.getPossibleValues();</span>
<span class="fc" id="L280">    this.propertyCallback = original.getPropertyCallback();</span>
<span class="fc" id="L281">    this.actionCallback = original.getActionCallback();</span>
<span class="fc" id="L282">    this.validator = original.validator;</span>
<span class="fc" id="L283">    this.disabled = original.isDisabled();</span>
<span class="fc" id="L284">    this.dynamicUiModel = original.getDynamicUiModel();</span>
<span class="fc" id="L285">    this.transientValue = original.isTransientValue();</span>
<span class="fc" id="L286">  }</span>

  /**
   * Sets the dynamic UI model reference.
   *
   * @param aDynamicUiModel the dynamic UI model reference.
   */
  public void setDynamicUiModel(final DynamicUiModel aDynamicUiModel) {
<span class="nc" id="L294">    this.dynamicUiModel = aDynamicUiModel;</span>
<span class="nc" id="L295">  }</span>

  /**
   * Gets the dynamic UI model reference.
   *
   * @return the dynamic UI model reference.
   */
  public DynamicUiModel getDynamicUiModel() {
<span class="fc" id="L303">    return dynamicUiModel;</span>
  }

  /**
   * Returns a value of type T from a string. Limited to the basic java types
   * {@link Integer}, {@link String}, {@link Boolean}, {@link Float}, {@link
   * Long}
   *
   * @param value the value to translate
   * @return and Object instantiated as T, or null if value was not of a usable
   *     class or was invalid for T
   */
  public Serializable valueOf(final String value) {
    // ECA-6320 Re-factor: New implementation uses constructor with type
    // parameter (not only Generic Operator because this information is lost at
    // runtime!).
    // The defaultValue of the old implementation MUST NOT be null, the one of
    // the new can be!
<span class="nc bnc" id="L321" title="All 2 branches missed.">    if (defaultValue instanceof MultiLineString) {</span>
<span class="nc" id="L322">      return new MultiLineString(value);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">    } else if (defaultValue instanceof String) {</span>
<span class="nc" id="L324">      return value;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">    } else if (defaultValue instanceof Boolean) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">      if (value.equals(Boolean.TRUE.toString())</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">          || value.equals(Boolean.FALSE.toString())) {</span>
<span class="nc" id="L328">        return Boolean.valueOf(value);</span>
      }
<span class="nc bnc" id="L330" title="All 2 branches missed.">    } else if (defaultValue instanceof Integer) {</span>
      try {
<span class="nc" id="L332">        return Integer.valueOf(value);</span>
<span class="nc" id="L333">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L334">        return null;</span>
      }
<span class="nc bnc" id="L336" title="All 2 branches missed.">    } else if (defaultValue instanceof Long) {</span>
      try {
<span class="nc" id="L338">        return Long.valueOf(value);</span>
<span class="nc" id="L339">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L340">        return null;</span>
      }
<span class="nc bnc" id="L342" title="All 2 branches missed.">    } else if (defaultValue instanceof BigInteger) {</span>
      try {
<span class="nc" id="L344">        return new BigInteger(value);</span>
<span class="nc" id="L345">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L346">        return null;</span>
      }
<span class="nc bnc" id="L348" title="All 2 branches missed.">    } else if (defaultValue instanceof Float) {</span>
      try {
<span class="nc" id="L350">        return Float.valueOf(value);</span>
<span class="nc" id="L351">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L352">        return null;</span>
      }
    }
<span class="nc" id="L355">    return null;</span>
  }

  /**
   * Gets a string representation of the value (for example the string '1' for
   * the Integer with value 1. Value is retrieved inside as getValue()).
   *
   * @return string the string representation.
   */
  public String getValueAsString() {
<span class="nc" id="L365">    Serializable value = getValue();</span>
<span class="nc" id="L366">    String result = StringUtils.EMPTY;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">    if (value instanceof MultiLineString) {</span>
<span class="nc" id="L368">      result = ((MultiLineString) value).getValue();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">    } else if (value instanceof String) {</span>
<span class="nc" id="L370">      result = (String) value;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">    } else if (value instanceof RadioButton) {</span>
<span class="nc" id="L372">      result = ((RadioButton) value).getLabel();</span>
    } else {
<span class="nc" id="L374">      result = ((Object) value).toString();</span>
    }
<span class="nc" id="L376">    return result;</span>
  }

  /**
   * Gets the name (or key) of the property.
   *
   * @return the name.
   */
  public String getName() {
<span class="fc" id="L385">    return name;</span>
  }

  /**
   * Gets if the UI widget is supposed to be filled with a value.
   *
   * @return true if is required.
   */
  public boolean isRequired() {
<span class="fc" id="L394">    return required;</span>
  }

  /**
   * Sets if the UI widget is supposed to be filled with a value.
   *
   * @param isRequired true if required.
   */
  public void setRequired(final boolean isRequired) {
<span class="nc" id="L403">    this.required = isRequired;</span>
<span class="nc" id="L404">  }</span>

  /**
   * Gets if the UI widget is supposed to be disabled.
   *
   * @return true if disabled.
   */
  public boolean isDisabled() {
<span class="fc" id="L412">    return disabled;</span>
  }

  /**
   * Sets if the UI widget is supposed to be disabled.
   *
   * @param isDisabled true if disabled.
   */
  public void setDisabled(final boolean isDisabled) {
<span class="nc" id="L421">    this.disabled = isDisabled;</span>
<span class="nc" id="L422">  }</span>

  /**
   * Gets weather the value has to be stored in the domain objects properties.
   *
   * @return true if transient.
   */
  public boolean isTransientValue() {
<span class="fc" id="L430">    return transientValue;</span>
  }

  /**
   * Sets weather the value has to be stored in the domain objects properties.
   *
   * @param isTransientValue true if transient.
   */
  public void setTransientValue(final boolean isTransientValue) {
<span class="nc" id="L439">    this.transientValue = isTransientValue;</span>
<span class="nc" id="L440">  }</span>

  /**
   * Is set to true if I18N labels has to be rendered (mainly used in facelets).
   *
   * @return true if I18N labels has to be rendered.
   */
  public boolean isI18NLabeled() {
<span class="fc" id="L448">    return labeled;</span>
  }

  /**
   * Gets if only the label has to be rendered.
   *
   * @return if the entry has to be rendered as label only (first column only).
   */
  public boolean isLabelOnly() {
<span class="fc" id="L457">    return labelOnly;</span>
  }

  /**
   * Sets if only the label has to be rendered.
   *
   * @param isLabelOnly true if the entry has to be rendered as label only
   * (first column only)
   */
  public void setLabelOnly(final boolean isLabelOnly) {
<span class="nc" id="L467">    this.labelOnly = isLabelOnly;</span>
<span class="nc" id="L468">  }</span>

  /**
   * @return the type class of this property, based on the default value. If the
   *     default was null, then the type has to be set explicitly.
   */
  public Class&lt;? extends Serializable&gt; getType() {
<span class="fc" id="L475">    return type;</span>
  }

  /**
   * @param aType type
   */
  public void setType(final Class&lt;? extends Serializable&gt; aType) {
<span class="nc" id="L482">    this.type = aType;</span>
<span class="nc" id="L483">  }</span>

  /**
   * Gets the given value of type &amp;lt;T&amp;gt;.
   *
   * @return the value.
   */
  public T getDefaultValue() {
<span class="fc" id="L491">    return defaultValue;</span>
  }

  /**
   * Sets the given value of type &amp;lt;T&amp;gt;.
   *
   * @param theDefaultValue the value.
   */
  public void setDefaultValue(final T theDefaultValue) {
<span class="nc" id="L500">    this.defaultValue = theDefaultValue;</span>
<span class="nc" id="L501">  }</span>

  /**
   * Gets the list of current values.
   *
   * @return the list.
   */
  public List&lt;T&gt; getValues() {
<span class="nc bnc" id="L509" title="All 2 branches missed.">    if (!hasMultipleValues) {</span>
<span class="nc" id="L510">      throw new IllegalStateException(</span>
          &quot;Attempted to draw multiple values from a dynamic property with a&quot;
              + &quot; single value for &quot;
<span class="nc" id="L513">              + getName());</span>
    }
<span class="nc" id="L515">    return values;</span>
  }

  /**
   * Gets the current value.
   *
   * @return the value.
   */
  public T getValue() {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">    if (hasMultipleValues) {</span>
<span class="nc" id="L525">      throw new IllegalStateException(</span>
          &quot;Attempted to draw single value from a dynamic property with&quot;
              + &quot; multiple value for &quot;
<span class="nc" id="L528">              + getName());</span>
    }
<span class="fc" id="L530">    return values.get(0);</span>
  }

  /**
   * @return values
   */
  public List&lt;String&gt; getPossibleValuesAsStrings() {
<span class="nc" id="L537">    final List&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">    for (final T possibleValue : getPossibleValues()) {</span>
<span class="nc" id="L539">      strings.add(possibleValue.toString());</span>
<span class="nc" id="L540">    }</span>
<span class="nc" id="L541">    return strings;</span>
  }

  /**
   * @return values
   */
  public List&lt;String&gt; getValuesAsStrings() {
<span class="nc" id="L548">    final List&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">    for (final T value : getValues()) {</span>
<span class="nc" id="L550">      strings.add(value.toString());</span>
<span class="nc" id="L551">    }</span>
<span class="nc" id="L552">    return strings;</span>
  }

  /**
   * Gets a list of all possible values.
   *
   * @return the list.
   */
  public Collection&lt;T&gt; getPossibleValues() {
<span class="fc" id="L561">    return possibleValues;</span>
  }

  /**
   * Sets the list of possible values.
   *
   * @param collection the collection of values.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setPossibleValues(
          final Collection&lt;? extends Serializable&gt; collection) {
<span class="nc" id="L572">    this.possibleValues = (Collection&lt;T&gt;) collection;</span>
<span class="nc" id="L573">  }</span>

  /**
   * Sets the current value of type &amp;lt;T&amp;gt;.
   *
   * @param object a value for this property.
   * @throws PropertyValidationException if the validation of the value failed.
   */
  public void setValue(final T object) throws PropertyValidationException {
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">    if (hasMultipleValues) {</span>
<span class="nc" id="L583">      throw new IllegalStateException(</span>
          &quot;Attempted to set multiple values from a dynamic property with&quot;
              + &quot; single value.&quot;);
    }
<span class="fc" id="L587">    final List&lt;T&gt; newValues = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">    if (object == null) {</span>
<span class="nc" id="L589">      newValues.add(defaultValue);</span>
    } else {
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">      if (validator != null) {</span>
<span class="nc" id="L592">        validator.validate(object);</span>
      }
<span class="pc bpc" id="L594" title="3 of 4 branches missed.">      if (possibleValues != null &amp;&amp; !possibleValues.contains(object)) {</span>
<span class="nc" id="L595">        throw new IllegalArgumentException(</span>
            object
                + &quot; (class=&quot;
<span class="nc" id="L598">                + object.getClass().getSimpleName()</span>
                + &quot;) is not in the list of approved objects (class=&quot;
<span class="nc" id="L600">                + possibleValues.getClass().getSimpleName()</span>
                + &quot;&lt;&quot;
<span class="nc" id="L602">                + possibleValues.getClass().getSimpleName()</span>
                + &quot;&gt;): &quot;
                + possibleValues);
      }
<span class="fc" id="L606">      newValues.add(object);</span>
    }
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">    if (dynamicUiModel != null) {</span>
<span class="nc" id="L609">      dynamicUiModel.setProperty(name, newValues.get(0));</span>
    }
<span class="fc" id="L611">    this.values = newValues;</span>
<span class="fc" id="L612">  }</span>

  /**
   * Sets the list of current values of type &amp;lt;T&amp;gt;.
   *
   * @param objects a list of values to set.
   * @throws PropertyValidationException if any one of the values didn't pass
   *     validation.
   */
  public void setValues(final List&lt;T&gt; objects)
          throws PropertyValidationException {
<span class="nc bnc" id="L623" title="All 2 branches missed.">    if (!hasMultipleValues) {</span>
<span class="nc" id="L624">      throw new IllegalStateException(</span>
          &quot;Attempted to set single value from a dynamic property with multiple&quot;
              + &quot; values.&quot;);
    }
<span class="nc" id="L628">    final List&lt;T&gt; objectsCopy =</span>
        new ArrayList&lt;&gt;(
            objects); // extra safety in case list is modified during function
                      // call
    final List&lt;T&gt; newValues;
<span class="nc bnc" id="L633" title="All 2 branches missed.">    if (CollectionUtils.isEmpty(objectsCopy)) {</span>
<span class="nc" id="L634">      newValues = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L635">      newValues.add(defaultValue);</span>
    } else {
<span class="nc bnc" id="L637" title="All 2 branches missed.">      if (!CollectionUtils.isEmpty(possibleValues)) {</span>
<span class="nc" id="L638">        newValues = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">        for (final T object : objectsCopy) {</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">          if (validator != null) {</span>
<span class="nc" id="L641">            validator.validate(object);</span>
          }
<span class="nc bnc" id="L643" title="All 2 branches missed.">          if (possibleValues.contains(object)) {</span>
<span class="nc" id="L644">            newValues.add(object);</span>
          } else {
<span class="nc" id="L646">            throw new IllegalArgumentException(</span>
                object
                    + &quot; (class=&quot;
<span class="nc" id="L649">                    + object.getClass().getSimpleName()</span>
                    + &quot;) is not in the list of approved objects (class=&quot;
<span class="nc" id="L651">                    + possibleValues.getClass().getSimpleName()</span>
                    + &quot;&lt;&quot;
<span class="nc" id="L653">                    + possibleValues.getClass().getSimpleName()</span>
                    + &quot;&gt;): &quot;
                    + possibleValues);
          }
<span class="nc" id="L657">        }</span>
      } else {
<span class="nc" id="L659">        newValues = objectsCopy;</span>
      }
    }
<span class="nc bnc" id="L662" title="All 2 branches missed.">    if (dynamicUiModel != null) {</span>
<span class="nc" id="L663">      dynamicUiModel.setProperty(</span>
<span class="nc" id="L664">          name, StringUtils.join(newValues, LIST_SEPARATOR));</span>
    }
<span class="nc" id="L666">    this.values = newValues;</span>
<span class="nc" id="L667">  }</span>

  /**
   * Gets the current value of type &amp;lt;T&amp;gt; as base 64 encoded string.
   *
   * @return the base 64 encoded string.
   */
  public String getEncodedValue() {
<span class="nc" id="L675">    return getAsEncodedValue(getValue());</span>
  }

  /**
   * Gets the list of current values of type &amp;lt;T&amp;gt; as list of base 64
   * encoded strings.
   *
   * @return the list.
   */
  public List&lt;String&gt; getEncodedValues() {
<span class="nc" id="L685">    return getAsEncodedValues(getValues());</span>
  }

  /**
   * Gets the base 64 encoded string of the value.
   *
   * @param value the value.
   * @return the base 64 encoded string.
   */
  public String getAsEncodedValue(final Serializable value) {
<span class="nc" id="L695">    return new String(Base64.encode(getAsByteArray(value), false));</span>
  }

  /**
   * Gets the list of base 64 encoded strings of the values.
   *
   * @param list the list of values.
   * @return the list of base 64 encoded strings.
   */
  private List&lt;String&gt; getAsEncodedValues(final List&lt;T&gt; list) {
<span class="nc" id="L705">    final List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">    for (final Serializable value : list) {</span>
<span class="nc" id="L707">      result.add(new String(Base64.encode(getAsByteArray(value), false)));</span>
<span class="nc" id="L708">    }</span>
<span class="nc" id="L709">    return result;</span>
  }

  /**
   * Sets the current value of type &amp;lt;T&amp;gt; by the given base 64 encoded
   * string.
   *
   * @param encodedValue the base 64 encoded value.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setEncodedValue(final String encodedValue) {
    try {
<span class="nc" id="L721">      setValue(</span>
<span class="nc" id="L722">          (T) getAsObject(Base64.decode(encodedValue.getBytes()), getType()));</span>
<span class="nc" id="L723">    } catch (PropertyValidationException e) {</span>
<span class="nc" id="L724">      throw new IllegalArgumentException(</span>
          &quot;Invalid value was intercepted from an encoded source, which should&quot;
              + &quot; not happen.&quot;,
          e);
<span class="nc" id="L728">    }</span>
<span class="nc" id="L729">  }</span>

  /**
   * Sets the list of values of type &amp;lt;T&amp;gt; by the given list of base 64
   * encoded strings.
   *
   * @param encodedValues a list of encoded values.
   * @throws PropertyValidationException if any one of the values doesn't pass
   *     validation.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setEncodedValues(final List&lt;String&gt; encodedValues)
      throws PropertyValidationException {
<span class="nc" id="L742">    List&lt;T&gt; decodedValues = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">    for (String encodedValue : encodedValues) {</span>
<span class="nc" id="L744">      decodedValues.add(</span>
<span class="nc" id="L745">          (T) getAsObject(Base64.decode(encodedValue.getBytes()), getType()));</span>
<span class="nc" id="L746">    }</span>
<span class="nc" id="L747">    setValues(decodedValues);</span>
<span class="nc" id="L748">  }</span>

  /**
   * Sets the current value of type &amp;lt;T&amp;gt;.
   *
   * @param object the value.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setValueGeneric(final Serializable object) {
<span class="fc" id="L757">    final List&lt;T&gt; newValues = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">    if (object == null) {</span>
<span class="nc" id="L759">      newValues.add(defaultValue);</span>
    } else {
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">      if (validator != null) {</span>
        try {
<span class="nc" id="L763">          validator.validate((T) object);</span>
<span class="nc" id="L764">        } catch (PropertyValidationException e) {</span>
<span class="nc" id="L765">          throw new IllegalStateException(</span>
              &quot;Generic setter is normally only used internally, so an&quot;
                  + &quot; incorrect value should not be passed.&quot;,
              e);
<span class="nc" id="L769">        }</span>
      }
<span class="fc" id="L771">      newValues.add((T) object);</span>
    }
<span class="fc" id="L773">    this.values = newValues;</span>
<span class="fc" id="L774">  }</span>

  /**
   * Sets the current value of type &amp;lt;T&amp;gt;.
   *
   * @param object the value.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setValueGenericIncludeNull(final Serializable object) {
<span class="nc" id="L783">    final List&lt;T&gt; newValues = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">    if (object == null) {</span>
<span class="nc" id="L785">      newValues.add((T) object);</span>
    } else {
<span class="nc bnc" id="L787" title="All 2 branches missed.">      if (validator != null) {</span>
        try {
<span class="nc" id="L789">          validator.validate((T) object);</span>
<span class="nc" id="L790">        } catch (PropertyValidationException e) {</span>
<span class="nc" id="L791">          throw new IllegalStateException(</span>
              &quot;Generic setter is normally only used internally, so an&quot;
                  + &quot; incorrect value should not be passed.&quot;,
              e);
<span class="nc" id="L795">        }</span>
      }
<span class="nc" id="L797">      newValues.add((T) object);</span>
    }
<span class="nc" id="L799">    this.values = newValues;</span>
<span class="nc" id="L800">  }</span>

  /**
   * Sets the list of current values of type &amp;lt;T&amp;gt;.
   *
   * @param list the list of values.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setValuesGeneric(final List&lt;? extends Serializable&gt; list) {
<span class="nc" id="L809">    final List&lt;? extends Serializable&gt; listCopy =</span>
        new ArrayList&lt;&gt;(
            list); // extra safety in case list is modified during the function
                   // call
<span class="nc" id="L813">    final List&lt;T&gt; newValues = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">    if (CollectionUtils.isEmpty(listCopy)) {</span>
<span class="nc" id="L815">      newValues.add(defaultValue);</span>
    } else {
<span class="nc bnc" id="L817" title="All 2 branches missed.">      for (final Serializable object : listCopy) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (validator != null) {</span>
          try {
<span class="nc" id="L820">            validator.validate((T) object);</span>
<span class="nc" id="L821">          } catch (PropertyValidationException e) {</span>
<span class="nc" id="L822">            throw new IllegalStateException(</span>
                &quot;Generic setter is normally only used internally, so an&quot;
                    + &quot; incorrect value should not be passed.&quot;,
                e);
<span class="nc" id="L826">          }</span>
        }
<span class="nc" id="L828">        newValues.add((T) object);</span>
<span class="nc" id="L829">      }</span>
    }
<span class="nc" id="L831">    this.values = newValues;</span>
<span class="nc" id="L832">  }</span>

  /**
   * Creates a deep clone of this instance.
   *
   * @return the new instance.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public DynamicUiProperty&lt;T&gt; clone() {
<span class="nc" id="L842">    return (DynamicUiProperty&lt;T&gt;) SerializationUtils.clone(this);</span>
  }

  /**
   * Gets the object a byte array stream.
   *
   * @param o the object
   * @return the byte array.
   */
  private byte[] getAsByteArray(final Serializable o) {
<span class="nc" id="L852">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L853">    try (ObjectOutputStream oos = new ObjectOutputStream(baos); ) {</span>
<span class="nc" id="L854">      oos.writeObject(o);</span>
<span class="nc" id="L855">    } catch (IOException e) {</span>
<span class="nc" id="L856">      throw new IllegalStateException(e);</span>
<span class="nc" id="L857">    }</span>
<span class="nc" id="L858">    return baos.toByteArray();</span>
  }

  /**
   * @param &lt;T&gt; Type
   * @param encodedValue Value
   * @param type Type
   * @return T
   */
  public static &lt;T extends Serializable&gt; T getAsObject(
      final String encodedValue, final Class&lt;T&gt; type) {
<span class="nc" id="L869">    return getAsObject(Base64.decode(encodedValue.getBytes()), type);</span>
  }

  /**
   * @param &lt;T&gt; Type
   * @param bytes Bytes
   * @param type Type
   * @return T
   */
  private static &lt;T extends Serializable&gt; T getAsObject(
      final byte[] bytes, final Class&lt;T&gt; type) {
<span class="nc" id="L880">    try (LookAheadObjectInputStream lookAheadObjectInputStream =</span>
        new LookAheadObjectInputStream(new ByteArrayInputStream(bytes))) {
<span class="nc" id="L882">      lookAheadObjectInputStream.setAcceptedClasses(</span>
<span class="nc" id="L883">          Arrays.asList(</span>
              type,
              LinkedHashMap.class,
              HashMap.class,
              HashSet.class,
              DynamicUiPropertyCallback.class,
              AccessMatchType.class,
              MultiLineString.class,
              String.class,
              PositiveIntegerValidator.class,
              RadioButton.class,
              ArrayList.class,
              Enum.class,
<span class="nc" id="L896">              Collections.emptyList().getClass().asSubclass(Serializable.class),</span>
<span class="nc" id="L897">              Class.forName(&quot;org.cesecore.roles.RoleInformation&quot;)</span>
<span class="nc" id="L898">                  .asSubclass(Serializable.class),</span>
<span class="nc" id="L899">              Class.forName(&quot;org.cesecore.roles.RoleData&quot;)</span>
<span class="nc" id="L900">                  .asSubclass(Serializable.class),</span>
<span class="nc" id="L901">              Class.forName(</span>
                      &quot;org.cesecore.authorization.user.AccessUserAspectData&quot;)
<span class="nc" id="L903">                  .asSubclass(Serializable.class)));</span>
<span class="nc" id="L904">      lookAheadObjectInputStream.setEnabledMaxObjects(false);</span>
<span class="nc" id="L905">      lookAheadObjectInputStream.setEnabledSubclassing(false);</span>
<span class="nc" id="L906">      lookAheadObjectInputStream.setEnabledInterfaceImplementations(false);</span>
<span class="nc" id="L907">      return type.cast(lookAheadObjectInputStream.readObject());</span>
<span class="nc" id="L908">    } catch (IOException | ClassNotFoundException e) {</span>
<span class="nc" id="L909">      throw new IllegalStateException(e);</span>
    }
  }

  /**
   * Gets the action callback.
   *
   * @return the callback.
   */
  public DynamicUiActionCallback getActionCallback() {
<span class="fc" id="L919">    return actionCallback;</span>
  }

  /**
   * Sets the action callback.
   *
   * @param anActionCallback the callback.
   */
  public void setActionCallback(
          final DynamicUiActionCallback anActionCallback) {
<span class="nc" id="L929">    this.actionCallback = anActionCallback;</span>
<span class="nc" id="L930">  }</span>

  /**
   * Gets the property call back.
   *
   * @return the call back.
   */
  public DynamicUiPropertyCallback getPropertyCallback() {
<span class="fc" id="L938">    return propertyCallback;</span>
  }

  /**
   * Sets the property call back.
   *
   * @param aPropertyCallback the call back.
   */
  public void setPropertyCallback(
      final DynamicUiPropertyCallback aPropertyCallback) {
<span class="nc" id="L948">    this.propertyCallback = aPropertyCallback;</span>
<span class="nc" id="L949">  }</span>

  /**
   * Gets if the property is allowed to consist of multiple values.
   *
   * @return true if this property can have multiple values.
   */
  public boolean getHasMultipleValues() {
<span class="fc" id="L957">    return hasMultipleValues;</span>
  }

  /**
   * Sets if the property is allowed to consist of multiple values (i.e. list,
   * or LIST_SEPARATOR separated string).
   *
   * @param hasGotMultipleValues true if the property may have multiple values.
   */
  public void setHasMultipleValues(final boolean hasGotMultipleValues) {
<span class="fc" id="L967">    this.hasMultipleValues = hasGotMultipleValues;</span>
<span class="fc" id="L968">  }</span>

  /**
   * @return bool
   */
  public boolean isMultiValued() {
<span class="nc bnc" id="L974" title="All 2 branches missed.">    return possibleValues != null;</span>
  }

  /**
   * Returns the current value, like getValue, but has a workaround for JSF bug
   * with ui:repeat and rendered. See ECA-5342
   *
   * @return value
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public T getJsfBooleanValue() {
<span class="nc bnc" id="L985" title="All 4 branches missed.">    if (hasMultipleValues || type != Boolean.class) {</span>
      // In this case, JSF made a spurious call and will throw away the return
      // value, but it must be of expected type (boolean)
<span class="nc" id="L988">      return (T) Boolean.FALSE;</span>
    } else {
<span class="nc" id="L990">      return getValue();</span>
    }
  }

  /**
   * Sets the value, by calling setValue. Needed for the getJsfBooleanValue
   * workaround.
   *
   * @param newValue the new value of type &amp;lt;T&amp;gt;.
   * @throws PropertyValidationException if the value failed validation.
   */
  public void setJsfBooleanValue(final T newValue)
      throws PropertyValidationException {
<span class="nc" id="L1003">    setValue(newValue);</span>
<span class="nc" id="L1004">  }</span>

  /**
   * Sets the validator instance.
   *
   * @param aValidator the validator.
   */
  public void setValidator(final DynamicUiPropertyValidator&lt;T&gt; aValidator) {
<span class="nc" id="L1012">    this.validator = aValidator;</span>
<span class="nc" id="L1013">  }</span>

  /**
   * Gets the validator type.
   *
   * @return the validator type or &quot;dummyValidator&quot; if the validator is null.
   */
  public String getValidatorType() {
<span class="nc bnc" id="L1021" title="All 2 branches missed.">    if (validator != null) {</span>
<span class="nc" id="L1022">      return validator.getValidatorType();</span>
    } else {
<span class="nc" id="L1024">      return &quot;dummyValidator&quot;;</span>
    }
  }

  /**
   * Gets the map of I18N key / value pairs.
   *
   * @return the list.
   */
  public Map&lt;?, String&gt; getLabels() {
<span class="nc" id="L1034">    return labels;</span>
  }

  /**
   * Sets the map of I18N key / value pairs.
   *
   * @param theLabels the map.
   */
  public void setLabels(final Map&lt;?, String&gt; theLabels) {
<span class="nc" id="L1043">    labeled = MapUtils.isNotEmpty(theLabels);</span>
<span class="nc" id="L1044">    this.labels = theLabels;</span>
<span class="nc" id="L1045">  }</span>

  /**
   * Returns true if the property type is java.lang.Boolean (this method is used
   * because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.lang.Boolean.
   */
  public boolean isBooleanType() {
<span class="nc" id="L1054">    return Boolean.class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if the property type is java.lang.Integer (this method is used
   * because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.lang.Integer.
   */
  public boolean isIntegerType() {
<span class="nc" id="L1064">    return Integer.class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if the property type is java.lang.BigInteger (this method is
   * used because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.lang.BigInteger.
   */
  public boolean isBigIntegerType() {
<span class="nc" id="L1074">    return BigInteger.class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if the property type is java.lang.Long (this method is used
   * because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.lang.Long.
   */
  public boolean isLongType() {
<span class="nc" id="L1084">    return Long.class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if the property type is java.lang.FLoat (this method is used
   * because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.lang.Float.
   */
  public boolean isFloatType() {
<span class="nc" id="L1094">    return Float.class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if the property type is java.lang.String(this method is used
   * because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.lang.String.
   */
  public boolean isStringType() {
<span class="nc" id="L1104">    return String.class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if the property type is java.util.HashMap (this method is used
   * because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.util.HashMap.
   */
  public boolean isMapType() {
<span class="nc" id="L1114">    return TreeMap.class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if the property type is java.io.File (this method is used
   * because of the lack of 'instanceof' operator in JSF EL).
   *
   * @return true if the property type is java.io.File.
   */
  public boolean isFileType() {
<span class="nc" id="L1124">    return File.class.getName().equals(getType().getName());</span>
  }

  /**
   * @return bool
   */
  public boolean isByteArrayType() {
<span class="nc" id="L1131">    return byte[].class.getName().equals(getType().getName());</span>
  }

  /**
   * Returns true if a check box should be rendered.
   *
   * @return true or false.
   */
  public boolean isRenderCheckBox() {
<span class="nc" id="L1140">    return isBooleanType();</span>
  }

  /**
   * Temp. method to store java.util.List as LIST_SEPARATOR separated List of
   * Strings (use for PublicKeyBlacklistKeyValidator only at the time).
   *
   * @return true if the list of Strings has to be stored as string.
   */
  public boolean isSaveListAsString() {
<span class="nc" id="L1150">    return saveListAsString;</span>
  }

  /**
   * Temp. method to store java.util.List as LIST_SEPARATOR separated List of
   * Strings (use for PublicKeyBlacklistKeyValidator only at the time).
   *
   * @param doSaveListAsString true if the list of Strings has to be stored as
   *     string.
   */
  public void setSaveListAsString(final boolean doSaveListAsString) {
<span class="nc" id="L1161">    this.saveListAsString = doSaveListAsString;</span>
<span class="nc" id="L1162">  }</span>

  /**
   * Sets the rendering hint ((see {@link #RENDER_NONE}, {@link #RENDER_LABEL},
   * {@link #RENDER_CHECKBOX}, {@link #RENDER_TEXTFIELD}, {@link
   * #RENDER_SELECT_ONE} or {@link #RENDER_SELECT_MANY})).
   *
   * @param aRenderingHint the rendering hint.
   */
  public void setRenderingHint(final String aRenderingHint) {
<span class="nc" id="L1172">    this.renderingHint = aRenderingHint;</span>
<span class="nc" id="L1173">  }</span>

  /**
   * Gets the rendering hint ((see {@link #RENDER_NONE}, {@link #RENDER_LABEL},
   * {@link #RENDER_CHECKBOX}, {@link #RENDER_TEXTFIELD}, {@link
   * #RENDER_SELECT_ONE} or {@link #RENDER_SELECT_MANY})).
   *
   * @return the rendering hint.
   */
  public String getRenderingHint() {
    // User explicit set rendering hint.
<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">    if (renderingHint != null) {</span>
<span class="nc" id="L1185">      return renderingHint;</span>
    }
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">    if (isLabelOnly()) {</span>
<span class="nc" id="L1188">      return RENDER_NONE;</span>
    }
<span class="fc" id="L1190">    String result = RENDER_TEXTFIELD;</span>
    // Multiple values always use drop-down boxes.
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">    if (getHasMultipleValues()) {</span>
<span class="nc" id="L1193">      result = RENDER_SELECT_MANY;</span>
    } else {
<span class="fc bfc" id="L1195" title="All 2 branches covered.">      if (!Boolean.class.equals(getType())) {</span>
        // NOOP
      } else {
<span class="fc" id="L1198">        result = RENDER_CHECKBOX;</span>
      }
    }
<span class="fc" id="L1201">    return result;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L1206">    return &quot;DynamicUiProperty [name=&quot;</span>
        + name
        + &quot;, required=&quot;
        + required
        + &quot;, defaultValue=&quot;
        + defaultValue
        + &quot;, values=&quot;
        + values
        + &quot;, possibleValues=&quot;
        + possibleValues
        + &quot;, renderingHint=&quot;
        + renderingHint
        + &quot;, labeled=&quot;
        + labeled
        + &quot;, labels=&quot;
        + labels
        + &quot;, labelOnly=&quot;
        + labelOnly
        + &quot;, type=&quot;
        + type
        + &quot;, hasMultipleValues=&quot;
        + hasMultipleValues
        + &quot;]&quot;;
  }

  /**
   * Delegation method for {@link DynamicUiModel#addDynamicUiComponent}.
   *
   * @param component component
   */
  public void addDynamicUiComponent(final DynamicUiComponent component) {
<span class="nc" id="L1237">    getDynamicUiModel().addDynamicUiComponent(name, component);</span>
<span class="nc" id="L1238">  }</span>

  /** Update the view components attributes here! */
  public void updateViewComponents() {
    for (DynamicUiComponent component
<span class="nc bnc" id="L1243" title="All 2 branches missed.">        : getDynamicUiModel().getViewComponents(name)) {</span>
<span class="nc bnc" id="L1244" title="All 4 branches missed.">      component.setDisabled(getDynamicUiModel().isDisabled() || isDisabled());</span>
<span class="nc" id="L1245">    }</span>
<span class="nc" id="L1246">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>