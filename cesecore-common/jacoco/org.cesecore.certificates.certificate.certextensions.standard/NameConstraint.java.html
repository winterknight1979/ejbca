<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NameConstraint.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.certificate.certextensions.standard</a> &gt; <span class="el_source">NameConstraint.java</span></div><h1>NameConstraint.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.certificate.certextensions.standard;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.List;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.DEROctetString;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.GeneralName;
import org.bouncycastle.asn1.x509.GeneralSubtree;
import org.bouncycastle.asn1.x509.NameConstraints;
import org.cesecore.certificates.ca.CA;
import org.cesecore.certificates.ca.X509CA;
import org.cesecore.certificates.ca.internal.CertificateValidity;
import org.cesecore.certificates.certificate.certextensions.CertificateExtensionException;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.cesecore.util.CeSecoreNameStyle;

/**
 * Extension for Name Constraints. &lt;a
 * href=&quot;https://tools.ietf.org/html/rfc5280#section-4.2.1.10&quot;&gt;RFC 5280&lt;/a&gt;
 *
 * &lt;p&gt;For storing Name Constraints, an internal encoded form is used. The format
 * is &quot;type-id:data&quot; where data is either a regular string or hex-encoded data,
 * depending on the type. Use parseNameConstraintList to convert human-readable
 * strings into encoded strings.
 *
 * @version $Id: NameConstraint.java 29904 2018-09-26 13:14:30Z samuellb $
 */
<span class="nc" id="L49">public class NameConstraint extends StandardCertificateExtension {</span>

  private static final long serialVersionUID = 1L;

  @Override
  public void init(final CertificateProfile certProf) {
<span class="nc" id="L55">    super.setOID(Extension.nameConstraints.getId());</span>
<span class="nc" id="L56">    super.setCriticalFlag(certProf.getNameConstraintsCritical());</span>
<span class="nc" id="L57">  }</span>

  @Override
  public ASN1Encodable getValue(
      final EndEntityInformation userData,
      final CA ca,
      final CertificateProfile certProfile,
      final PublicKey userPublicKey,
      final PublicKey caPublicKey,
      final CertificateValidity val)
      throws CertificateExtensionException {
<span class="nc" id="L68">    NameConstraints nc = null;</span>

<span class="nc bnc" id="L70" title="All 2 branches missed.">    if (!(ca instanceof X509CA)) {</span>
<span class="nc" id="L71">      throw new CertificateExtensionException(</span>
          &quot;Can't issue non-X509 certificate with Name Constraint&quot;);
    }

<span class="nc" id="L75">    final ExtendedInformation ei = userData.getExtendedInformation();</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (ei != null) {</span>
<span class="nc" id="L77">      final List&lt;String&gt; permittedNames = ei.getNameConstraintsPermitted();</span>
<span class="nc" id="L78">      final List&lt;String&gt; excludedNames = ei.getNameConstraintsExcluded();</span>

      // Do not include an empty name constraints extension
<span class="nc bnc" id="L81" title="All 4 branches missed.">      if (permittedNames != null || excludedNames != null) {</span>
<span class="nc" id="L82">        final GeneralSubtree[] permitted = toGeneralSubtrees(permittedNames);</span>
<span class="nc" id="L83">        final GeneralSubtree[] excluded = toGeneralSubtrees(excludedNames);</span>

<span class="nc" id="L85">        nc = new NameConstraints(permitted, excluded);</span>
      }
    }

<span class="nc" id="L89">    return nc;</span>
  }

  /**
   * Converts a list of encoded strings of Name Constraints into ASN1
   * GeneralSubtree objects. This is needed when creating an BouncyCastle ASN1
   * NameConstraint object for inclusion in a certificate.
   *
   * @param list encoded strings
   * @return ASN1 subtree
   */
  public static GeneralSubtree[] toGeneralSubtrees(final List&lt;String&gt; list) {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">    if (list == null) {</span>
<span class="nc" id="L102">      return null;</span>
    }

<span class="fc" id="L105">    GeneralSubtree[] ret = new GeneralSubtree[list.size()];</span>
<span class="fc" id="L106">    int i = 0;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">    for (String entry : list) {</span>
<span class="fc" id="L108">      int type = getNameConstraintType(entry);</span>
<span class="fc" id="L109">      Object data = getNameConstraintData(entry);</span>
      GeneralName genname;
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">      switch (type) {</span>
        case GeneralName.dNSName:
        case GeneralName.rfc822Name:
<span class="fc" id="L114">          genname = new GeneralName(type, (String) data);</span>
<span class="fc" id="L115">          break;</span>
        case GeneralName.directoryName:
<span class="fc" id="L117">          genname =</span>
              new GeneralName(
                  new X500Name(CeSecoreNameStyle.INSTANCE, (String) data));
<span class="fc" id="L120">          break;</span>
        case GeneralName.iPAddress:
<span class="fc" id="L122">          genname = new GeneralName(type, new DEROctetString((byte[]) data));</span>
<span class="fc" id="L123">          break;</span>
        default:
<span class="nc" id="L125">          throw new UnsupportedOperationException(</span>
              &quot;Encoding of name constraint type &quot;
                  + type
                  + &quot; is not implemented.&quot;);
      }
<span class="fc" id="L130">      ret[i++] = new GeneralSubtree(genname);</span>
<span class="fc" id="L131">    }</span>
<span class="fc" id="L132">    return ret;</span>
  }

  /**
   * @param encoded name constraint
   * @return the GeneralName type code for an encoded Name Constraint.
   */
  private static int getNameConstraintType(final String encoded) {
<span class="fc" id="L140">    String typeString = encoded.split(&quot;:&quot;, 2)[0];</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (&quot;iPAddress&quot;.equals(typeString)) {</span>
<span class="fc" id="L142">      return GeneralName.iPAddress;</span>
    }
<span class="fc bfc" id="L144" title="All 2 branches covered.">    if (&quot;dNSName&quot;.equals(typeString)) {</span>
<span class="fc" id="L145">      return GeneralName.dNSName;</span>
    }
<span class="fc bfc" id="L147" title="All 2 branches covered.">    if (&quot;directoryName&quot;.equals(typeString)) {</span>
<span class="fc" id="L148">      return GeneralName.directoryName;</span>
    }
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    if (&quot;rfc822Name&quot;.equals(typeString)) {</span>
<span class="fc" id="L151">      return GeneralName.rfc822Name;</span>
    }
<span class="nc" id="L153">    throw new UnsupportedOperationException(</span>
        &quot;Unsupported name constraint type &quot; + typeString);
  }

  /**
   * Returns the GeneralName data (as a byte array or String) from an encoded
   * string.
   *
   * @param encoded string
   * @return GeneralName
   */
  private static Object getNameConstraintData(final String encoded) {
<span class="fc" id="L165">    int type = getNameConstraintType(encoded);</span>
<span class="fc" id="L166">    String data = encoded.split(&quot;:&quot;, 2)[1];</span>

<span class="pc bpc" id="L168" title="1 of 3 branches missed.">    switch (type) {</span>
      case GeneralName.dNSName:
      case GeneralName.directoryName:
      case GeneralName.rfc822Name:
<span class="fc" id="L172">        return data;</span>
      case GeneralName.iPAddress:
        try {
<span class="fc" id="L175">          return Hex.decodeHex(data.toCharArray());</span>
<span class="nc" id="L176">        } catch (DecoderException e) {</span>
<span class="nc" id="L177">          throw new IllegalStateException(</span>
              &quot;internal name constraint data could not be decoded as hex&quot;, e);
        }
      default:
<span class="nc" id="L181">        throw new UnsupportedOperationException(</span>
            &quot;Unsupported name constraint type &quot; + type);
    }
  }

  /**
   * Parses a single name constraint entry in human-readable form into an
   * encoded string for database storage etc. The intention is to make it
   * possible to change the human readable form at a later point.
   *
   * &lt;p&gt;This format is essentially a hex string representation of a RFC 5280
   * GeneralName, but only DNS Names and IP Addresses are supported so far.
   *
   * @param str constraint
   * @return encoded string
   * @throws CertificateExtensionException if the string can not be parsed.
   */
  public static String parseNameConstraintEntry(final String str)
      throws CertificateExtensionException {
<span class="fc bfc" id="L200" title="All 2 branches covered.">    if (str.matches(&quot;^([0-9]+\\.){3,3}([0-9]+)/[0-9]+$&quot;)</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        || str.matches(</span>
            &quot;^[0-9a-fA-F]{0,4}:[0-9a-fA-F]{0,4}:[0-9a-fA-F:]*/[0-9]+$&quot;)) {
      // IPv4 or IPv6 address
      try {
<span class="fc" id="L205">        String[] pieces = str.split(&quot;/&quot;, 2);</span>
<span class="fc" id="L206">        byte[] addr = InetAddress.getByName(pieces[0]).getAddress();</span>
<span class="fc" id="L207">        byte[] encoded =</span>
            new byte[2 * addr.length]; // will hold address and netmask
<span class="fc" id="L209">        System.arraycopy(addr, 0, encoded, 0, addr.length);</span>

        // The second half in the encoded form is the netmask
<span class="fc" id="L212">        int netmask = Integer.parseInt(pieces[1]);</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (netmask &gt; 8 * addr.length) {</span>
<span class="nc" id="L214">          throw new CertificateExtensionException(</span>
              &quot;Netmask is too large: &quot; + str);
        }
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (int i = 0; i &lt; netmask; i++) {</span>
<span class="fc" id="L218">          encoded[addr.length + i / 8] |= 1 &lt;&lt; (7 - i % 8);</span>
        }
        // Clear host part from IP address
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (int i = netmask; i &lt; 8 * addr.length; i++) {</span>
<span class="fc" id="L222">          encoded[i / 8] &amp;= ~(1 &lt;&lt; (7 - i % 8));</span>
        }
<span class="fc" id="L224">        return &quot;iPAddress:&quot; + Hex.encodeHexString(encoded);</span>
<span class="nc" id="L225">      } catch (UnknownHostException e) {</span>
<span class="nc" id="L226">        throw new CertificateExtensionException(</span>
            &quot;Failed to parse IP address in name constraint: &quot; + str, e);
      }
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">    } else if (str.matches(&quot;^([0-9]+\\.){3,3}([0-9]+)$&quot;)) {</span>
      // IP address without netmask. This is not a valid DNS name, so catch it
      // here.
<span class="nc" id="L232">      throw new CertificateExtensionException(</span>
          &quot;Name constraint entry with IP address is missing a netmask: &quot;
              + str
              + &quot;. Use /32 to match only this address.&quot;);
<span class="fc bfc" id="L236" title="All 2 branches covered.">    } else if (str.matches(&quot;^\\.?([a-zA-Z0-9_-]+\\.)*[a-zA-Z0-9_-]+$&quot;)) {</span>
      // DNS name (it can start with a &quot;.&quot;, this means &quot;all subdomains&quot;)
<span class="fc" id="L238">      return &quot;dNSName:&quot; + str;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">    } else if (str.matches(&quot;^[^=,]*@[a-zA-Z0-9_.\\[\\]:-]+$&quot;)) {</span>
<span class="fc" id="L240">      String email = str;</span>
      // RFC 822 Name (i.e. e-mail)
<span class="fc bfc" id="L242" title="All 2 branches covered.">      if (str.startsWith(&quot;@&quot;)) {</span>
        // In EJBCA, rfc822Names without a user part start with @ to distinguish
        // them from domain names.
        // This is not the case in the encoded form.
<span class="fc" id="L246">        email = email.substring(1);</span>
      }
<span class="fc" id="L248">      return &quot;rfc822Name:&quot; + email;</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    } else if (str.contains(&quot;=&quot;)) {</span>
      // Directory name
<span class="fc" id="L251">      return &quot;directoryName:&quot;</span>
<span class="fc" id="L252">          + new X500Name(CeSecoreNameStyle.INSTANCE, str).toString();</span>
    } else {
<span class="nc" id="L254">      throw new CertificateExtensionException(</span>
          &quot;Cannot parse name constraint entry (only DNS Name, RFC 822 Name,&quot;
              + &quot; Directory Name, IPv4/Netmask and IPv6/Netmask are&quot;
              + &quot; supported): &quot;
              + str);
    }
  }

  /**
   * Parses human readable name constraints, one entry per line, into a list of
   * encoded name constraints.
   *
   * @param input Constraints
   * @return encoded constraints
   * @throws CertificateExtensionException if the string cannot be parsed
   * @see #parseNameConstraintEntry
   */
  public static List&lt;String&gt; parseNameConstraintsList(final String input)
      throws CertificateExtensionException {
<span class="fc" id="L273">    List&lt;String&gt; encodedNames = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">    if (input != null) {</span>
<span class="fc" id="L275">      String[] pieces = input.split(&quot;\n&quot;);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">      for (String piece : pieces) {</span>
<span class="fc" id="L277">        piece = piece.trim();</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (!piece.isEmpty()) {</span>
<span class="fc" id="L279">          encodedNames.add(NameConstraint.parseNameConstraintEntry(piece));</span>
        }
      }
    }
<span class="fc" id="L283">    return encodedNames;</span>
  }

  /**
   * Formats an encoded name constraint from parseNameConstraintEntry into
   * human-readable form.
   *
   * @param encoded encoded string
   * @return human-readable
   */
  public static String formatNameConstraintEntry(final String encoded) {
<span class="nc bnc" id="L294" title="All 2 branches missed.">    if (encoded == null) {</span>
<span class="nc" id="L295">      return &quot;&quot;;</span>
    }

<span class="nc" id="L298">    int type = getNameConstraintType(encoded);</span>
<span class="nc" id="L299">    Object data = getNameConstraintData(encoded);</span>

<span class="nc bnc" id="L301" title="All 4 branches missed.">    switch (type) {</span>
      case GeneralName.dNSName:
      case GeneralName.directoryName:
<span class="nc" id="L304">        return (String) data; // not changed during encoding</span>
      case GeneralName.iPAddress:
<span class="nc" id="L306">        byte[] bytes = (byte[]) data;</span>
<span class="nc" id="L307">        byte[] ip = new byte[bytes.length / 2];</span>
<span class="nc" id="L308">        byte[] netmaskBytes = new byte[bytes.length / 2];</span>
<span class="nc" id="L309">        System.arraycopy(bytes, 0, ip, 0, ip.length);</span>
<span class="nc" id="L310">        System.arraycopy(</span>
            bytes, ip.length, netmaskBytes, 0, netmaskBytes.length);

<span class="nc" id="L313">        int netmask = 0;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        for (int i = 0; i &lt; 8 * netmaskBytes.length; i++) {</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">          final boolean one = (netmaskBytes[i / 8] &gt;&gt; (7 - i % 8) &amp; 1) == 1;</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">          if (one &amp;&amp; netmask == i) {</span>
<span class="nc" id="L317">            netmask++; // leading ones</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">          } else if (one) {</span>
            // trailings ones = error!
<span class="nc" id="L320">            throw new IllegalArgumentException(</span>
                &quot;Unsupported netmask with mixed ones/zeros&quot;);
          }
        }

        try {
<span class="nc" id="L326">          return InetAddress.getByAddress(ip).getHostAddress() + &quot;/&quot; + netmask;</span>
<span class="nc" id="L327">        } catch (UnknownHostException e) {</span>
<span class="nc" id="L328">          throw new IllegalArgumentException(e);</span>
        }
      case GeneralName.rfc822Name:
        // Prepend @ is it's only the domain part to distinguish from DNS names
<span class="nc" id="L332">        String str = (String) data;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        return (str.contains(&quot;@&quot;) ? str : &quot;@&quot; + str);</span>
      default:
<span class="nc" id="L335">        throw new UnsupportedOperationException(</span>
            &quot;Unsupported name constraint type &quot; + type);
    }
  }

  /**
   * Formats an encoded list of name constraints into a human-readable list,
   * with one entry per line.
   *
   * @param encodedList List of constraints
   * @return a newline-separated string of encoded name constraints
   */
  public static String formatNameConstraintsList(
      final List&lt;String&gt; encodedList) {
<span class="nc" id="L349">    final StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">    if (encodedList != null) {</span>
<span class="nc" id="L351">      boolean first = true;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">      for (String encodedName : encodedList) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (!first) {</span>
<span class="nc" id="L354">          sb.append('\n');</span>
        }
<span class="nc" id="L356">        first = false;</span>
<span class="nc" id="L357">        sb.append(</span>
<span class="nc" id="L358">            formatNameConstraintEntry(</span>
                encodedName)); // notice the call to formatNameConstraintEntry,
                               // so this is different from StringUtils.join
<span class="nc" id="L361">      }</span>
    }
<span class="nc" id="L363">    return sb.toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>