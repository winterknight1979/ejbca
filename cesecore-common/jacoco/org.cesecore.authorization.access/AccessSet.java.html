<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccessSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.authorization.access</a> &gt; <span class="el_source">AccessSet.java</span></div><h1>AccessSet.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.authorization.access;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.log4j.Logger;
import org.cesecore.roles.AccessRulesHelper;

/**
 * Represents all access rules that a given AuthenticationToken is allowed to
 * access.
 *
 * @version $Id: AccessSet.java 25591 2017-03-23 13:13:02Z jeklund $
 * @deprecated since EJBCA 6.8.0
 */
@Deprecated
public final class AccessSet implements Serializable {
  /** Logger. */
<span class="fc" id="L39">  private static final Logger LOG = Logger.getLogger(AccessSet.class);</span>

  private static final long serialVersionUID = -6522714939328731306L;

  /**
   * Wildcard meaning: Access is granted to some items. Used only in calls to
   * isAuthorized to query whether we have access to any of the items (and in
   * AccessSet objects for faster access control checks).
   *
   * &lt;p&gt;Example: &quot;/cryptotoken/use/*SOME&quot;, which would check if we have ccess to
   * use any cryptotoken.
   */
  public static final String WILDCARD_SOME = &quot;*SOME&quot;;

  /**
   * Wildcard meaning: Access is granted recursively to all subresources (but
   * not the resource itself, for performance reasons). Used internally only,
   * never in calls to isAuthorized (AccessSets don't have anything like the
   * requireRecursive parameter).
   *
   * &lt;p&gt;Example: &quot;/*RECURSIVE&quot; together with &quot;/&quot;, which would grant access to
   * everything
   *
   * @deprecated Since 6.8.0
   */
  @Deprecated static final String WILDCARD_RECURSIVE = &quot;*RECURSIVE&quot;;

  /** Pattern. */
<span class="fc" id="L67">  private static final Pattern ID_IN_RULENAME =</span>
<span class="fc" id="L68">      Pattern.compile(&quot;^/(.+)/(-?[0-9]+)(/|$)&quot;);</span>

  /**
   * Legacy storage of access rules in the AccessSet, used in EJBCA 6.6.0 and
   * 6.7.0.
   */
  @Deprecated private Collection&lt;String&gt; set;

  /** No-args constructor for deserialization only. */
<span class="nc" id="L77">  public AccessSet() { }</span>

  /**
   * Creates an AccessSet with a legacy 6.6.0 access rule set, which can't
   * contain deny rules and works using the old access rule system.
   *
   * @param legacySet Rule set
   * @deprecated Since 6.8.0
   */
  @Deprecated
<span class="fc" id="L87">  public AccessSet(final Collection&lt;String&gt; legacySet) {</span>
<span class="fc" id="L88">    this.set = new HashSet&lt;&gt;(legacySet);</span>
<span class="fc" id="L89">  }</span>

  /**
   * Creates an access set merged from two access sets.
   *
   * @param a Set a
   * @param b Set b
   */
<span class="nc" id="L97">  public AccessSet(final AccessSet a, final AccessSet b) {</span>
<span class="nc" id="L98">    set = new HashSet&lt;&gt;(a.set.size() + b.set.size());</span>
<span class="nc" id="L99">    set.addAll(a.set);</span>
<span class="nc" id="L100">    set.addAll(b.set);</span>
<span class="nc" id="L101">  }</span>

  /** Max search depth. */
  private static final int MAX_DEPTH = 100;

  /**
   * Is access to the resource authorised?
   *
   * @param resources Resource
   * @return boolean
   */
  public boolean isAuthorized(final String... resources) {
    // Note that &quot;*SOME&quot; rules are added when the rules for the
    // AccessSet are built, and don't need to be handled here
    NEXT_RESOURCE:
<span class="nc bnc" id="L116" title="All 2 branches missed.">    for (final String resource : resources) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">      if (resource.charAt(0) != '/') {</span>
<span class="nc" id="L118">        throw new IllegalArgumentException(&quot;Resource must start with /&quot;);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">      } else if (resource.length() != 1</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">          &amp;&amp; resource.charAt(resource.length() - 1) == '/') {</span>
<span class="nc" id="L121">        throw new IllegalArgumentException(&quot;Resource should not end with /&quot;);</span>
      }

      // Check for exact rule
<span class="nc bnc" id="L125" title="All 2 branches missed.">      if (set.contains(resource)) {</span>
<span class="nc" id="L126">        continue NEXT_RESOURCE; // OK. Check next resource</span>
      }

      // Check for recursive rules
<span class="nc" id="L130">      int depth = 0;</span>
<span class="nc" id="L131">      String parentResource = resource;</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">      while (++depth &lt; MAX_DEPTH) { // never split more than 100 times</span>
<span class="nc" id="L133">        int slash = parentResource.lastIndexOf('/');</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (slash == -1) {</span>
<span class="nc" id="L135">          break;</span>
        }
<span class="nc" id="L137">        parentResource = parentResource.substring(0, slash);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L139">          LOG.trace(</span>
              &quot;Checking for '&quot;
                  + parentResource
                  + &quot;/&quot;
                  + WILDCARD_RECURSIVE
                  + &quot;'&quot;);
        }
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (set.contains(parentResource + &quot;/&quot; + WILDCARD_RECURSIVE)) {</span>
<span class="nc" id="L147">          continue NEXT_RESOURCE; // OK. Check next resource</span>
        }
<span class="nc" id="L149">      }</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">      if (depth == MAX_DEPTH &amp;&amp; LOG.isDebugEnabled()) {</span>
        // Recursive rules are always accept rules, so it's safe to
        // ignore some of them and continue
<span class="nc" id="L153">        LOG.debug(</span>
            &quot;Resource had more than 100 components, only the &quot;
                + &quot;first 100 were checked for recursive accept access: &quot;
                + resource);
      }

<span class="nc bnc" id="L159" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L160">        LOG.trace(</span>
            &quot;No access rule for &quot;
                + resource
                + &quot;. Denying access.&quot;
                + &quot; Number of allowed resources=&quot;
<span class="nc" id="L165">                + set.size());</span>
      }
<span class="nc" id="L167">      return false;</span>
    }
<span class="nc" id="L169">    return true; // all resources match</span>
  }

  /** Use in tests only. */
  public void dumpRules() {
<span class="nc" id="L174">    final List&lt;String&gt; resources = new ArrayList&lt;&gt;(set);</span>
<span class="nc" id="L175">    Collections.sort(resources);</span>
<span class="nc" id="L176">    LOG.debug(&quot;Legacy set&quot;);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">    for (final String resource : resources) {</span>
<span class="nc" id="L178">      LOG.debug(&quot;Resource: &quot; + resource);</span>
<span class="nc" id="L179">    }</span>
<span class="nc" id="L180">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L184">    return Arrays.toString(set.toArray());</span>
  }

  @Override
  public boolean equals(final Object obj) {
<span class="nc bnc" id="L189" title="All 2 branches missed.">    if (this == obj) {</span>
<span class="nc" id="L190">      return true;</span>
    }
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L193">      return false;</span>
    }
<span class="nc bnc" id="L195" title="All 2 branches missed.">    if (!(obj instanceof AccessSet)) {</span>
<span class="nc" id="L196">      return false;</span>
    }
<span class="nc" id="L198">    AccessSet other = (AccessSet) obj;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    if (set == null) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      if (other.set != null) {</span>
<span class="nc" id="L201">        return false;</span>
      }
<span class="nc bnc" id="L203" title="All 2 branches missed.">    } else if (!set.equals(other.set)) {</span>
<span class="nc" id="L204">      return false;</span>
    }
<span class="nc" id="L206">    return true;</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L211">    final int prime = 31;</span>
<span class="nc" id="L212">    int result = 1;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">    result = prime * result + ((set == null) ? 0 : set.hashCode());</span>
<span class="nc" id="L214">    return result;</span>
  }

  /**
   * Converts from EJBCA 6.8.0+ access rules to the old version of AccessSet
   * introduced in EJBCA 6.6.0, for compatibility with old RA clients. The
   * result of the conversion is written to &quot;set&quot;, which is a HashSet of every
   * single accepted resource enriched with &quot;*SOME&quot; but no &quot;*RECURSIVE&quot;.
   *
   * &lt;p&gt;Before calling this method, the &quot;accessMap&quot; variable is expected to
   * contain the 6.8.0+ access rule structure.
   *
   * &lt;p&gt;Note: - The legacy set created via this method will not grant access to
   * a - configured rules that don't exist on the system. - ...and this means
   * that access to non-existing resources will not - be granted to old RA
   * clients.
   *
   * @param accessRules the EJBCA 6.8.0+ style access rules
   * @param allResources whole universe of resources that exists
   * @return an AccessSet of every single accepted resource enriched with
   *     &quot;*SOME&quot;, but no &quot;*RECURSIVE&quot;
   */
  public static AccessSet fromAccessRules(
      final HashMap&lt;String, Boolean&gt; accessRules,
      final Set&lt;String&gt; allResources) {
<span class="nc" id="L239">    final Set&lt;String&gt; set = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">    for (final String current : allResources) {</span>
      // De-normalize if needed
      final String resource =
<span class="nc bnc" id="L243" title="All 4 branches missed.">          (current.length() &gt; 1 &amp;&amp; current.charAt(current.length() - 1) == '/')</span>
<span class="nc" id="L244">              ? current.substring(0, current.length() - 1)</span>
<span class="nc" id="L245">              : current;</span>
<span class="nc" id="L246">      final boolean authorizedToResource =</span>
<span class="nc" id="L247">          AccessRulesHelper.hasAccessToResource(accessRules, resource);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if (authorizedToResource) {</span>
<span class="nc" id="L249">        set.add(resource);</span>
        // Check if we have an (integer) ID in the resource
<span class="nc" id="L251">        final Matcher matcher = ID_IN_RULENAME.matcher(resource);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (matcher.find()) {</span>
          // Add &quot;*SOME&quot; resource
<span class="nc" id="L254">          final String someResource =</span>
<span class="nc" id="L255">              matcher.replaceFirst(&quot;/$1/&quot; + WILDCARD_SOME + &quot;$3&quot;);</span>
<span class="nc" id="L256">          set.add(someResource);</span>
        }
      }
<span class="nc" id="L259">    }</span>
    // Since expect the whole universe of rules to be provided,
    // there should be no need to add the WILDCARD_RECURSIVE rule
<span class="nc" id="L262">    return new AccessSet(set);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>