<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CaCertificateCache.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca.internal</a> &gt; <span class="el_source">CaCertificateCache.java</span></div><h1>CaCertificateCache.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/

package org.cesecore.certificates.ca.internal;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.X509Certificate;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import org.apache.log4j.Logger;
import org.cesecore.certificates.certificate.HashID;
import org.cesecore.config.OcspConfiguration;
import org.cesecore.util.Base64;
import org.cesecore.util.CertTools;

/**
 * A cache for storing CA certificates.
 *
 * @version $Id: CaCertificateCache.java 27419 2017-12-05 13:18:18Z anatom $
 */
<span class="fc" id="L38">public enum CaCertificateCache {</span>
  /** Singleton instance. */
<span class="fc" id="L40">  INSTANCE;</span>

    /** Logger. */
<span class="fc" id="L43">  private final Logger log = Logger.getLogger(CaCertificateCache.class);</span>

  /** Mapping from subjectDN to key in the certs HashMap. */
<span class="fc" id="L46">  private Map&lt;Integer, X509Certificate&gt; certsFromSubjectDN =</span>
      new HashMap&lt;Integer, X509Certificate&gt;();
  /** Mapping from issuerDN to key in the certs HashMap. */
<span class="fc" id="L49">  private Map&lt;Integer, Set&lt;X509Certificate&gt;&gt; certsFromIssuerDN =</span>
      new HashMap&lt;Integer, Set&lt;X509Certificate&gt;&gt;();
  /** Mapping from subject key identifier to key in the certs HashMap. */
<span class="fc" id="L52">  private Map&lt;Integer, X509Certificate&gt; certsFromSubjectKeyIdentifier =</span>
      new HashMap&lt;Integer, X509Certificate&gt;();
  /** All root certificates. */
<span class="fc" id="L55">  private Set&lt;X509Certificate&gt; rootCertificates =</span>
      new HashSet&lt;X509Certificate&gt;();

  /** Cache time counter, set and used by loadCertificates. */
<span class="fc" id="L59">  private long certValidTo = 0;</span>
  /**
   *
   * @param id ID
   * @return Cert
   */
  public X509Certificate findLatestBySubjectDN(final HashID id) {
<span class="fc" id="L66">    final X509Certificate ret = certsFromSubjectDN.get(id.getKey());</span>
<span class="pc bpc" id="L67" title="1 of 4 branches missed.">    if (ret == null &amp;&amp; log.isDebugEnabled()) {</span>
<span class="nc" id="L68">      log.debug(</span>
          &quot;Certificate not found from SubjectDN HashId in certsFromSubjectDN&quot;
              + &quot; map. HashID=&quot;
<span class="nc" id="L71">              + id.getB64());</span>
    }
<span class="fc" id="L73">    return ret;</span>
  }

  /** @param id ID
 * @return cert */
  public X509Certificate[] findLatestByIssuerDN(final HashID id) {
<span class="nc" id="L79">    final Set&lt;X509Certificate&gt; sCert = certsFromIssuerDN.get(id.getKey());</span>
<span class="nc bnc" id="L80" title="All 4 branches missed.">    if (sCert == null || sCert.isEmpty()) {</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      if (log.isDebugEnabled()) {</span>
<span class="nc" id="L82">        log.debug(</span>
            &quot;Certificate not found from IssuerDN HashId in certsFromIssuerDN&quot;
                + &quot; map. HashID=&quot;
<span class="nc" id="L85">                + id.getB64());</span>
      }
<span class="nc" id="L87">      return null;</span>
    }
<span class="nc" id="L89">    return sCert.toArray(new X509Certificate[sCert.size()]);</span>
  }

  /** @return root certs */
  public X509Certificate[] getRootCertificates() {
<span class="nc" id="L94">    return rootCertificates.toArray(new X509Certificate[0]);</span>
  }

  /**
   *  @param id ID
 * @return cert */
  public X509Certificate findBySubjectKeyIdentifier(final HashID id) {
<span class="nc" id="L101">    final X509Certificate ret = certsFromSubjectKeyIdentifier.get(id.getKey());</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">    if (ret == null &amp;&amp; log.isDebugEnabled()) {</span>
<span class="nc" id="L103">      log.debug(</span>
          &quot;Certificate not found from SubjectKeyIdentifier HashId in&quot;
              + &quot; certsFromSubjectKeyIdentifier map. HashID=&quot;
<span class="nc" id="L106">              + id.getB64());</span>
    }
<span class="nc" id="L108">    return ret;</span>
  }

  /** @return true if cache has expired */
  public boolean isCacheExpired() {
<span class="nc bnc" id="L113" title="All 2 branches missed.">    return certValidTo &lt; System.currentTimeMillis();</span>
  }

  /**
   * Loads CA certificates but holds a cache so it's reloaded only every five
   * minutes (configurable).
   *
   * &lt;p&gt;We keep this method as synchronized, it should not take more than a few
   * microseconds to complete if the cache does not have to be reloaded. If the
   * cache must be reloaded, we must wait for it anyway to not have
   * ConcurrentModificationException. We also only want one single thread to do
   * the rebuilding.
   *
   * @param certs Certificates
   */
  public synchronized void loadCertificates(
      final Collection&lt;Certificate&gt; certs) {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L131">      log.debug(</span>
          &quot;Loaded &quot;
<span class="nc bnc" id="L133" title="All 2 branches missed.">              + (certs == null ? &quot;0&quot; : Integer.toString(certs.size()))</span>
              + &quot; ca certificates&quot;);
    }

<span class="fc" id="L137">    Map&lt;Integer, X509Certificate&gt; newCertsFromSubjectDN =</span>
        new HashMap&lt;Integer, X509Certificate&gt;();
<span class="fc" id="L139">    Map&lt;Integer, Set&lt;X509Certificate&gt;&gt; newCertsFromIssuerDN =</span>
        new HashMap&lt;Integer, Set&lt;X509Certificate&gt;&gt;();
<span class="fc" id="L141">    Map&lt;Integer, X509Certificate&gt; newCertsFromSubjectKeyIdentifier =</span>
        new HashMap&lt;Integer, X509Certificate&gt;();
<span class="fc" id="L143">    Set&lt;X509Certificate&gt; newRootCertificates = new HashSet&lt;X509Certificate&gt;();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">    for (final Certificate tmp : certs) {</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">      if (!(tmp instanceof X509Certificate)) {</span>
<span class="fc" id="L146">        log.debug(&quot;Not adding CA certificate of type: &quot; + tmp.getType());</span>
<span class="fc" id="L147">        continue;</span>
      }
<span class="fc" id="L149">      final X509Certificate cert = (X509Certificate) tmp;</span>
      try { // test if certificate is OK. we have experienced that BC could
            // decode a certificate that later on could not be used.
<span class="fc" id="L152">        final Integer key = HashID.getFromKeyID(cert).getKey();</span>
<span class="fc" id="L153">        final X509Certificate pastCert =</span>
<span class="fc" id="L154">            newCertsFromSubjectKeyIdentifier.get(key);</span>
        // Add the entry if it's the first, or if it is more recent than the one
        // existing (in that case replace it)
<span class="pc bpc" id="L157" title="3 of 4 branches missed.">        if (pastCert == null</span>
            || (pastCert != null
<span class="nc" id="L159">                &amp;&amp; CertTools.getNotBefore(cert)</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                    .after(CertTools.getNotBefore(pastCert)))) {</span>
<span class="fc" id="L161">          newCertsFromSubjectKeyIdentifier.put(key, cert);</span>
        }
<span class="nc" id="L163">      } catch (</span>
          Throwable t) { // NOPMD: catch all to not break with an error here.
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L166">          final StringWriter sw = new StringWriter();</span>
<span class="nc" id="L167">          final PrintWriter pw = new PrintWriter(sw);</span>
<span class="nc" id="L168">          pw.println(&quot;Erroneous certificate fetched from database.&quot;);</span>
<span class="nc" id="L169">          pw.println(</span>
              &quot;The public key can not be extracted from the certificate.&quot;);
<span class="nc" id="L171">          pw.println(&quot;Here follows a base64 encoding of the certificate:&quot;);</span>
          try {
<span class="nc" id="L173">            final String b64encoded =</span>
<span class="nc" id="L174">                new String(Base64.encode(cert.getEncoded()));</span>
<span class="nc" id="L175">            pw.println(CertTools.BEGIN_CERTIFICATE);</span>
<span class="nc" id="L176">            pw.println(b64encoded);</span>
<span class="nc" id="L177">            pw.println(CertTools.END_CERTIFICATE);</span>
<span class="nc" id="L178">          } catch (CertificateEncodingException e) {</span>
<span class="nc" id="L179">            pw.println(&quot;Not possible to encode certificate.&quot;);</span>
<span class="nc" id="L180">          }</span>
<span class="nc" id="L181">          pw.flush();</span>
<span class="nc" id="L182">          log.debug(sw.toString());</span>
        }
<span class="nc" id="L184">        continue;</span>
<span class="fc" id="L185">      }</span>
<span class="fc" id="L186">      final Integer subjectDNKey = HashID.getFromSubjectDN(cert).getKey();</span>
      // Check if we already have a certificate from this issuer in the HashMap.
      // We only want to store the latest cert from each issuer in this map
<span class="fc" id="L189">      final X509Certificate pastCert = newCertsFromSubjectDN.get(subjectDNKey);</span>
      final boolean isLatest;
<span class="fc bfc" id="L191" title="All 2 branches covered.">      if (pastCert != null) {</span>
<span class="fc" id="L192">        if (CertTools.getNotBefore(cert)</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            .after(CertTools.getNotBefore(pastCert))) {</span>
<span class="fc" id="L194">          isLatest = true;</span>
        } else {
<span class="nc" id="L196">          isLatest = false;</span>
        }
      } else {
<span class="fc" id="L199">        isLatest = true;</span>
      }
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">      if (isLatest) {</span>
<span class="fc" id="L202">        newCertsFromSubjectDN.put(subjectDNKey, cert);</span>
<span class="fc" id="L203">        final Integer issuerDNKey = HashID.getFromIssuerDN(cert).getKey();</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (!issuerDNKey.equals(</span>
            subjectDNKey)) { // don't add roots to themselves
<span class="fc" id="L206">          Set&lt;X509Certificate&gt; sIssuer = newCertsFromIssuerDN.get(issuerDNKey);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">          if (sIssuer == null) {</span>
<span class="fc" id="L208">            sIssuer = new HashSet&lt;X509Certificate&gt;();</span>
<span class="fc" id="L209">            newCertsFromIssuerDN.put(issuerDNKey, sIssuer);</span>
          }
<span class="fc" id="L211">          sIssuer.add(cert);</span>
<span class="fc" id="L212">          sIssuer.remove(pastCert);</span>
<span class="fc" id="L213">        } else {</span>
<span class="fc" id="L214">          newRootCertificates.add(cert);</span>
<span class="fc" id="L215">          newRootCertificates.remove(pastCert);</span>
        }
      }
<span class="fc" id="L218">    }</span>
    // Log what we have stored in the cache
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L221">      final StringWriter sw = new StringWriter();</span>
<span class="nc" id="L222">      final PrintWriter pw = new PrintWriter(sw, true);</span>
<span class="nc" id="L223">      pw.println(&quot;Found the following CA certificates :&quot;);</span>
      for (Entry&lt;Integer, X509Certificate&gt; key
<span class="nc bnc" id="L225" title="All 2 branches missed.">          : newCertsFromSubjectKeyIdentifier.entrySet()) {</span>
<span class="nc" id="L226">        final Certificate cert = key.getValue();</span>
<span class="nc" id="L227">        pw.print(CertTools.getSubjectDN(cert));</span>
<span class="nc" id="L228">        pw.print(',');</span>
<span class="nc" id="L229">        pw.println(CertTools.getSerialNumberAsString(cert));</span>
<span class="nc" id="L230">      }</span>
<span class="nc" id="L231">      log.debug(sw);</span>
    }
    // Replace the old caches
<span class="fc" id="L234">    certsFromSubjectKeyIdentifier = newCertsFromSubjectKeyIdentifier;</span>
<span class="fc" id="L235">    certsFromIssuerDN = newCertsFromIssuerDN;</span>
<span class="fc" id="L236">    certsFromSubjectDN = newCertsFromSubjectDN;</span>
<span class="fc" id="L237">    rootCertificates = newRootCertificates;</span>
<span class="fc" id="L238">    certValidTo =</span>
<span class="fc" id="L239">        System.currentTimeMillis()</span>
<span class="fc" id="L240">            + OcspConfiguration.getSigningCertsValidTimeInMilliseconds();</span>
<span class="fc" id="L241">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>