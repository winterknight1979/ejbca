<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CertificateValidity.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca.internal</a> &gt; <span class="el_source">CertificateValidity.java</span></div><h1>CertificateValidity.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca.internal;

import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.text.ParseException;
import java.util.Arrays;
import java.util.Date;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1GeneralizedTime;
import org.bouncycastle.asn1.x509.PrivateKeyUsagePeriod;
import org.cesecore.certificates.ca.CAOfflineException;
import org.cesecore.certificates.ca.IllegalValidityException;
import org.cesecore.certificates.certificateprofile.CertificateProfile;
import org.cesecore.certificates.endentity.EndEntityInformation;
import org.cesecore.certificates.endentity.ExtendedInformation;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.util.CertTools;
import org.cesecore.util.SimpleTime;
import org.cesecore.util.ValidityDate;

/**
 * Class used to construct validity times based on a range of different input
 * parameters and configuration.
 *
 * @version $Id: CertificateValidity.java 28114 2018-01-26 14:51:20Z samuellb $
 */
public class CertificateValidity {

  /** 24. */
  private static final int HOURS_PER_DAY = 24;
  /** 60. */
  private static final int MINS_PER_HOUR = 60;
  /** 60. */
  private static final int SECS_PER_MIN = 60;
  /** 1000. */
  private static final int MS_PER_SEC = 1000;

  /** Class logger. */
<span class="fc" id="L53">  private static final Logger LOG = Logger.getLogger(CertificateValidity.class);</span>

  /** Internal localization of logs and errors. */
  private static final InternalResources INTRES =
<span class="fc" id="L57">      InternalResources.getInstance();</span>

  /**
   * Issuing certificates with 'notAfter' greater than this value throws an
   * exception.
   */
  private static Date tooLateExpireDate;

  static {
<span class="fc" id="L66">    final String value = CesecoreConfiguration.getCaTooLateExpireDate();</span>
    try {
<span class="fc" id="L68">      tooLateExpireDate = ValidityDate.parseCaLatestValidDateTime(value);</span>
<span class="nc" id="L69">    } catch (Exception e) {</span>
<span class="nc" id="L70">      final String newValue =</span>
<span class="nc" id="L71">          ValidityDate.formatAsISO8601(</span>
              new Date(Long.MAX_VALUE), ValidityDate.TIMEZONE_SERVER);
<span class="nc" id="L73">      tooLateExpireDate = ValidityDate.parseCaLatestValidDateTime(newValue);</span>
<span class="nc" id="L74">      LOG.warn(</span>
          &quot;cesecore.properties ca.toolateexpiredate '&quot;
              + value
              + &quot;' could not be parsed Using default value '&quot;
              + newValue
              + &quot;'.&quot;,
          e);
<span class="fc" id="L81">    }</span>
  }

  /**
   * Validity offset in milliseconds (offset for the 'notBefore' value) The
   * default start date is set 10 minutes back to avoid some problems with
   * unsynchronized clocks.
   */
  private static long defaultValidityOffset;

  static {
<span class="fc" id="L92">    final String value = CesecoreConfiguration.getCertificateValidityOffset();</span>
    try {
      defaultValidityOffset =
<span class="fc" id="L95">          SimpleTime.getSecondsFormat().parseMillis(value);</span>
<span class="nc" id="L96">    } catch (Exception e) {</span>
      // Use old value for compatibility reasons!
<span class="nc" id="L98">      defaultValidityOffset = -10L * SECS_PER_MIN * MS_PER_SEC;</span>
<span class="nc" id="L99">      LOG.warn(</span>
          &quot;cesecore.properties certificate.validityoffset '&quot;
              + value
              + &quot;' could not be parsed as relative time string. Using default&quot;
              + &quot; value '-10m' = -60000ms&quot;,
          e);
<span class="fc" id="L105">    }</span>
<span class="fc" id="L106">  }</span>

  /**
   * Gets the default validity offset.
   *
   * @return the offset as relative time.
   * @see org.cesecore.util.SimpleTime SimpleTime
   */
  public static final long getValidityOffset() {
<span class="fc" id="L115">    return defaultValidityOffset;</span>
  }

  /**
   * Gets the maximum possible value for the certificates 'notAfter' value.
   *
   * @return ISO8601 date
   */
  public static Date getToolLateExpireDate() {
<span class="fc" id="L124">    return tooLateExpireDate;</span>
  }

  /**
   * Sets the maximum possible value for the certificates 'notAfter' value. This
   * method MUST NOT BE CALLED, except for unit testing.
   *
   * @param date the date to set.
   */
  public static void setTooLateExpireDate(final Date date) {
<span class="fc" id="L134">    tooLateExpireDate = date;</span>
<span class="fc" id="L135">  }</span>

  /** The certificates 'notAfter' value. */
  private Date lastDate;

  /** The certificates 'notBefore' value. */
  private Date firstDate;

  /** Constructor.
   *
   * @param subject Subject
   * @param certProfile DN
   * @param notBefore Date
   * @param notAfter Date
   * @param cacert CA cert
   * @param isRootCA Bool
   * @param isLinkCertificate Bool
   * @throws IllegalValidityException Fail
   */
  public CertificateValidity(
      final EndEntityInformation subject,
      final CertificateProfile certProfile,
      final Date notBefore,
      final Date notAfter,
      final Certificate cacert,
      final boolean isRootCA,
      final boolean isLinkCertificate)
      throws IllegalValidityException {
<span class="fc" id="L163">    this(</span>
        new Date(),
        subject,
        certProfile,
        notBefore,
        notAfter,
        cacert,
        isRootCA,
        isLinkCertificate);
<span class="fc" id="L172">  }</span>

  /**
   * Constructor that injects the reference point (now). This constructor mainly
   * is used for unit testing.
   *
   * @param now Now
   * @param subject Subject
   * @param certProfile Profila
   * @param notBefore Start date
   * @param notAfter End date
   * @param cacert CA Certificate
   * @param isRootCA bool
   * @param isLinkCertificate bool
   * @throws IllegalValidityException on fail
   */
  public CertificateValidity(
      final Date now,
      final EndEntityInformation subject,
      final CertificateProfile certProfile,
      final Date notBefore,
      final Date notAfter,
      final Certificate cacert,
      final boolean isRootCA,
      final boolean isLinkCertificate)
<span class="fc" id="L197">      throws IllegalValidityException {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L199">      LOG.debug(&quot;Requested notBefore: &quot; + notBefore);</span>
<span class="nc" id="L200">      LOG.debug(&quot;Requested notAfter: &quot; + notAfter);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">      if (null != subject.getExtendedInformation()) {</span>
<span class="nc" id="L202">        LOG.debug(</span>
            &quot;End entity extended information 'notBefore': &quot;
                + subject
<span class="nc" id="L205">                    .getExtendedInformation()</span>
<span class="nc" id="L206">                    .getCustomData(ExtendedInformation.CUSTOM_STARTTIME));</span>
      }
<span class="nc bnc" id="L208" title="All 2 branches missed.">      if (null != subject.getExtendedInformation()) {</span>
<span class="nc" id="L209">        LOG.debug(</span>
            &quot;End entity extended information 'notAfter': &quot;
                + subject
<span class="nc" id="L212">                    .getExtendedInformation()</span>
<span class="nc" id="L213">                    .getCustomData(ExtendedInformation.CUSTOM_ENDTIME));</span>
      }
<span class="nc" id="L215">      LOG.debug(&quot;Default validty offset: &quot; + defaultValidityOffset);</span>
<span class="nc" id="L216">      LOG.debug(</span>
<span class="nc" id="L217">          &quot;Certificate profile validty: &quot; + certProfile.getEncodedValidity());</span>
<span class="nc" id="L218">      LOG.debug(</span>
          &quot;Certificate profile use validty offset: &quot;
<span class="nc" id="L220">              + certProfile.getUseCertificateValidityOffset());</span>
<span class="nc" id="L221">      LOG.debug(</span>
          &quot;Certificate profile validty offset: &quot;
<span class="nc" id="L223">              + certProfile.getCertificateValidityOffset());</span>
<span class="nc" id="L224">      LOG.debug(</span>
          &quot;Certificate profile use expiration restrictions for weekdays: &quot;
<span class="nc" id="L226">              + certProfile.getUseExpirationRestrictionForWeekdays());</span>
<span class="nc" id="L227">      LOG.debug(</span>
          &quot;Certificate profile expiration restrictions weekdays: &quot;
<span class="nc" id="L229">              + Arrays.toString(</span>
<span class="nc" id="L230">                  certProfile.getExpirationRestrictionWeekdays()));</span>
<span class="nc" id="L231">      LOG.debug(</span>
          &quot;Certificate profile expiration restrictions for weekdays before: &quot;
<span class="nc" id="L233">              + certProfile.getExpirationRestrictionForWeekdaysExpireBefore());</span>
    }
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">    if (tooLateExpireDate == null) {</span>
<span class="nc" id="L236">      throw new IllegalStateException(</span>
          &quot;ca.toolateexpiredate in cesecore.properties is not a valid date.&quot;);
    }

    // ECA-3554 add the offset

<span class="fc" id="L242">    Date newNow = getNowWithOffset(now, certProfile);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L244">      LOG.debug(&quot;Using new start time including offset: &quot; + newNow);</span>
    }

    // Find out what start and end time to actually use..
<span class="fc bfc" id="L248" title="All 2 branches covered.">    if (certProfile.getAllowValidityOverride()) {</span>
      // First Priority has information supplied in Extended information object.
      // This allows RA-users to set the time-span.
      // Second Priority has the information supplied in the method arguments
<span class="fc" id="L252">      firstDate = getExtendedInformationStartTime(newNow, subject);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">      if (firstDate == null) {</span>
<span class="fc" id="L254">        firstDate = notBefore;</span>
      }
<span class="fc" id="L256">      lastDate = getExtendedInformationEndTime(newNow, subject);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">      if (lastDate == null) {</span>
<span class="fc" id="L258">        lastDate = notAfter;</span>
      }
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L261">        LOG.debug(&quot;Allow validity override, notBefore: &quot; + firstDate);</span>
<span class="nc" id="L262">        LOG.debug(&quot;Allow validity override, notAfter: &quot; + lastDate);</span>
      }
    }
    // Third priority: If nothing could be set by external information have the
    // default  3 is default values
<span class="fc bfc" id="L267" title="All 2 branches covered.">    if (firstDate == null) {</span>
<span class="fc" id="L268">      firstDate = newNow;</span>
    }
<span class="fc" id="L270">    Date certProfileLastDate =</span>
<span class="fc" id="L271">        new Date(getCertificateProfileValidtyEndDate(certProfile, firstDate));</span>
    // Limit validity: ECA-5330 Apply expiration restriction for weekdays
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (certProfile.getUseExpirationRestrictionForWeekdays()</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        &amp;&amp; isRelativeTime(certProfile.getEncodedValidity())) {</span>
<span class="fc" id="L275">      LOG.info(</span>
          &quot;Applying expiration restrictions for weekdays: &quot;
<span class="fc" id="L277">              + Arrays.asList(certProfile.getExpirationRestrictionWeekdays()));</span>
      try {
<span class="fc" id="L279">        final Date newDate =</span>
<span class="fc" id="L280">            ValidityDate.applyExpirationRestrictionForWeekdays(</span>
                certProfileLastDate,
<span class="fc" id="L282">                certProfile.getExpirationRestrictionWeekdays(),</span>
<span class="fc" id="L283">                certProfile.getExpirationRestrictionForWeekdaysExpireBefore());</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if (!firstDate.before(newDate)) {</span>
<span class="nc" id="L285">          LOG.warn(</span>
              &quot;Expiration restriction of certificate profile could not be&quot;
                  + &quot; applied because it's before start date!&quot;);
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        } else if (!tooLateExpireDate.after(newDate)) {</span>
<span class="nc" id="L289">          LOG.warn(</span>
              &quot;Expiration restriction of certificate profile could not be&quot;
                  + &quot; applied because it's after latest possible end date!&quot;);
        } else {
<span class="fc" id="L293">          certProfileLastDate = newDate;</span>
        }
<span class="nc" id="L295">      } catch (Exception e) {</span>
<span class="nc" id="L296">        LOG.warn(</span>
            &quot;Expiration restriction of certificate profile could not be&quot;
                + &quot; applied!&quot;);
<span class="fc" id="L299">      }</span>
    }
    // If it is a link certificate that we create, we use the old ca's expire
    // date, as requested, as link certificate expire date
<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (isLinkCertificate) {</span>
<span class="fc" id="L304">      lastDate = notAfter;</span>
    }
<span class="fc bfc" id="L306" title="All 2 branches covered.">    if (lastDate == null) {</span>
<span class="fc" id="L307">      lastDate = certProfileLastDate;</span>
    }
    // Limit validity: Do not allow last date to be before first date
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">    if (lastDate.before(firstDate)) {</span>
<span class="nc" id="L311">      LOG.info(</span>
<span class="nc" id="L312">          INTRES.getLocalizedMessage(</span>
              &quot;createcert.errorinvalidcausality&quot;, firstDate, lastDate));
<span class="nc" id="L314">      Date tmp = lastDate;</span>
<span class="nc" id="L315">      lastDate = firstDate;</span>
<span class="nc" id="L316">      firstDate = tmp;</span>
    }
    // Limit validity: We do not allow a certificate to be valid before the
    // current date, i.e. not back dated start dates
    // Unless allowValidityOverride is set, then we allow everything
    // So this check is probably completely unneeded and can never be true
<span class="pc bpc" id="L322" title="1 of 4 branches missed.">    if (firstDate.before(newNow) &amp;&amp; !certProfile.getAllowValidityOverride()) {</span>
<span class="nc" id="L323">      LOG.error(</span>
<span class="nc" id="L324">          INTRES.getLocalizedMessage(</span>
              &quot;createcert.errorbeforecurrentdate&quot;,
              firstDate,
<span class="nc" id="L327">              subject.getUsername()));</span>
<span class="nc" id="L328">      firstDate = newNow;</span>
      // Update valid length from the profile since the starting point has
      // changed
<span class="nc" id="L331">      certProfileLastDate =</span>
<span class="nc" id="L332">          new Date(getCertificateProfileValidtyEndDate(certProfile, firstDate));</span>
      // Update lastDate if we use maximum validity
    }
    // Limit validity: We do not allow a certificate to be valid after the the
    // validity of the certificate profile
<span class="fc bfc" id="L337" title="All 2 branches covered.">    if (lastDate.after(certProfileLastDate)) {</span>
<span class="fc" id="L338">      LOG.info(</span>
<span class="fc" id="L339">          INTRES.getLocalizedMessage(</span>
              &quot;createcert.errorbeyondmaxvalidity&quot;,
              lastDate,
<span class="fc" id="L342">              subject.getUsername(),</span>
              certProfileLastDate));
<span class="fc" id="L344">      lastDate = certProfileLastDate;</span>
    }
    // Limit validity: We do not allow a certificate to be valid after the the
    // validity of the CA (unless it's RootCA during renewal)
<span class="fc bfc" id="L348" title="All 4 branches covered.">    if (cacert != null &amp;&amp; !isRootCA) {</span>
<span class="fc" id="L349">      final Date caNotAfter = CertTools.getNotAfter(cacert);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">      if (lastDate.after(caNotAfter)) {</span>
<span class="fc" id="L351">        LOG.info(</span>
<span class="fc" id="L352">            INTRES.getLocalizedMessage(</span>
                &quot;createcert.limitingvalidity&quot;,
<span class="fc" id="L354">                lastDate.toString(),</span>
                caNotAfter));
<span class="fc" id="L356">        lastDate = caNotAfter;</span>
      }
    }
    // Limit validity: We do not allow a certificate to be valid before the the
    // CA becomes valid (unless it's RootCA during renewal)
<span class="fc bfc" id="L361" title="All 4 branches covered.">    if (cacert != null &amp;&amp; !isRootCA) {</span>
<span class="fc" id="L362">      final Date caNotBefore = CertTools.getNotBefore(cacert);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">      if (firstDate.before(caNotBefore)) {</span>
<span class="fc" id="L364">        LOG.info(</span>
<span class="fc" id="L365">            INTRES.getLocalizedMessage(</span>
                &quot;createcert.limitingvaliditystart&quot;,
<span class="fc" id="L367">                firstDate.toString(),</span>
                caNotBefore));
<span class="fc" id="L369">        firstDate = caNotBefore;</span>
      }
    }
<span class="fc bfc" id="L372" title="All 2 branches covered.">    if (!lastDate.before(CertificateValidity.tooLateExpireDate)) {</span>
<span class="fc" id="L373">      String msg =</span>
<span class="fc" id="L374">          INTRES.getLocalizedMessage(</span>
              &quot;createcert.errorbeyondtoolateexpiredate&quot;,
<span class="fc" id="L376">              lastDate.toString(),</span>
<span class="fc" id="L377">              CertificateValidity.tooLateExpireDate.toString());</span>
<span class="fc" id="L378">      LOG.info(msg);</span>
<span class="fc" id="L379">      throw new IllegalValidityException(msg);</span>
    }
<span class="fc" id="L381">  }</span>

  /**
   * Gets the certificates 'notAter' value.
   *
   * @return the 'notAfter' date.
   */
  public Date getNotAfter() {
<span class="fc" id="L389">    return lastDate;</span>
  }

  /**
   * Gets the certificates 'notBefore' value.
   *
   * @return the 'notBefore' date.
   */
  public Date getNotBefore() {
<span class="fc" id="L398">    return firstDate;</span>
  }

  /**
   * Gets the validity end date for the certificate using the certificate
   * profiles encoded validity.
   *
   * @param profile the certificate profile
   * @param aFirstDate the start time.
   * @return the encoded validity.
   */
  @SuppressWarnings(&quot;deprecation&quot;)
  private long getCertificateProfileValidtyEndDate(
      final CertificateProfile profile, final  Date aFirstDate) {
<span class="fc" id="L412">    final String encodedValidity = profile.getEncodedValidity();</span>
<span class="fc" id="L413">    Date date = null;</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">    if (StringUtils.isNotBlank(encodedValidity)) {</span>
<span class="fc" id="L415">      date = ValidityDate.getDate(encodedValidity, aFirstDate);</span>
    } else {
<span class="nc" id="L417">      date =</span>
<span class="nc" id="L418">          ValidityDate.getDateBeforeVersion661(</span>
<span class="nc" id="L419">              profile.getValidity(), aFirstDate);</span>
    }
<span class="fc" id="L421">    return date.getTime();</span>
  }

  /**
   * Offsets the certificates 'notBefore' (reference point) with the global
   * offset or the offset of the certificate profile.
   *
   * @param now the reference point
   * @param profile the certificate profile
   * @return the offset reference point
   */
  private Date getNowWithOffset(
      final Date now, final CertificateProfile profile) {
<span class="fc" id="L434">    Date result = null;</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (profile.getUseCertificateValidityOffset()) {</span>
<span class="fc" id="L436">      final String offset = profile.getCertificateValidityOffset();</span>
      try {
<span class="fc" id="L438">        result = new Date(now.getTime() + SimpleTime.parseMillies(offset));</span>
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L440">          LOG.debug(&quot;Using validity offset by certificate profile: &quot; + offset);</span>
        }
<span class="nc" id="L442">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L443">        LOG.warn(</span>
            &quot;Could not parse certificate validity offset &quot;
                + offset
                + &quot;; using default &quot;
                + defaultValidityOffset);
<span class="fc" id="L448">      }</span>
<span class="fc" id="L449">    } else {</span>
<span class="fc" id="L450">      result = new Date(now.getTime() + defaultValidityOffset);</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L452">        LOG.debug(</span>
            &quot;Using validity offset by cesecore.properties: &quot;
<span class="nc" id="L454">                + SimpleTime.toString(</span>
                    defaultValidityOffset, SimpleTime.TYPE_DAYS));
      }
    }
<span class="fc" id="L458">    return result;</span>
  }

  /**
   * Gets the start time by the extended entity information.
   *
   * @param now the reference point.
   * @param subject the end entity information.
   * @return Start time
   */
  private Date getExtendedInformationStartTime(
      final Date now, final EndEntityInformation subject) {
<span class="fc" id="L470">    Date result = null;</span>
<span class="fc" id="L471">    final ExtendedInformation extendedInformation =</span>
<span class="fc" id="L472">        subject.getExtendedInformation();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">    if (extendedInformation != null) {</span>
<span class="fc" id="L474">      result =</span>
<span class="fc" id="L475">          parseExtendedInformationEncodedValidity(</span>
              now,
<span class="fc" id="L477">              extendedInformation.getCustomData(</span>
                  ExtendedInformation.CUSTOM_STARTTIME));
    }
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L481">      LOG.debug(&quot;Using ExtendedInformationStartTime: &quot; + result);</span>
    }
<span class="fc" id="L483">    return result;</span>
  }

  /**
   * Gets the end time by the extended entity information.
   *
   * @param now the reference point.
   * @param subject the end entity information.
   * @return End time
   */
  private Date getExtendedInformationEndTime(
      final Date now, final EndEntityInformation subject) {
<span class="fc" id="L495">    Date result = null;</span>
<span class="fc" id="L496">    final ExtendedInformation extendedInformation =</span>
<span class="fc" id="L497">        subject.getExtendedInformation();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">    if (extendedInformation != null) {</span>
<span class="fc" id="L499">      result =</span>
<span class="fc" id="L500">          parseExtendedInformationEncodedValidity(</span>
              now,
<span class="fc" id="L502">              extendedInformation.getCustomData(</span>
                  ExtendedInformation.CUSTOM_ENDTIME));
    }
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L506">      LOG.debug(&quot;Using ExtendedInformationEndTime: &quot; + result);</span>
    }
<span class="fc" id="L508">    return result;</span>
  }

  /**
   * Checks that the PrivateKeyUsagePeriod of the certificate is valid at this
   * time.
   *
   * @param cert Certificate
   * @throws CAOfflineException if PrivateKeyUsagePeriod either is not valid yet
   *     or has expired, exception message gives details
   */
  public static void checkPrivateKeyUsagePeriod(final X509Certificate cert)
      throws CAOfflineException {
<span class="fc" id="L521">    checkPrivateKeyUsagePeriod(cert, new Date());</span>
<span class="fc" id="L522">  }</span>

  /**
   *
   * @param cert Certificate
   * @param checkDate Date
   * @throws CAOfflineException Fail
   */
  public static void checkPrivateKeyUsagePeriod(
      final X509Certificate cert, final Date checkDate)
      throws CAOfflineException {
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">    if (cert != null) {</span>
<span class="fc" id="L534">      final PrivateKeyUsagePeriod pku =</span>
<span class="fc" id="L535">          CertTools.getPrivateKeyUsagePeriod(cert);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">      if (pku != null) {</span>
<span class="fc" id="L537">        final ASN1GeneralizedTime notBefore = pku.getNotBefore();</span>
        final Date pkuNotBefore;
        final Date pkuNotAfter;
        try {
<span class="fc bfc" id="L541" title="All 2 branches covered.">          if (notBefore == null) {</span>
<span class="fc" id="L542">            pkuNotBefore = null;</span>
          } else {
<span class="fc" id="L544">            pkuNotBefore = notBefore.getDate();</span>
          }
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L547">            LOG.debug(&quot;PrivateKeyUsagePeriod.notBefore is &quot; + pkuNotBefore);</span>
          }
<span class="fc bfc" id="L549" title="All 4 branches covered.">          if (pkuNotBefore != null &amp;&amp; checkDate.before(pkuNotBefore)) {</span>
<span class="fc" id="L550">            final String msg =</span>
<span class="fc" id="L551">                INTRES.getLocalizedMessage(</span>
                    &quot;createcert.privatekeyusagenotvalid&quot;,
<span class="fc" id="L553">                    pkuNotBefore.toString(),</span>
<span class="fc" id="L554">                    cert.getSubjectDN().toString());</span>
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L556">              LOG.debug(msg);</span>
            }
<span class="fc" id="L558">            throw new CAOfflineException(msg);</span>
          }
<span class="fc" id="L560">          final ASN1GeneralizedTime notAfter = pku.getNotAfter();</span>

<span class="fc bfc" id="L562" title="All 2 branches covered.">          if (notAfter == null) {</span>
<span class="fc" id="L563">            pkuNotAfter = null;</span>
          } else {
<span class="fc" id="L565">            pkuNotAfter = notAfter.getDate();</span>
          }
<span class="nc" id="L567">        } catch (ParseException e) {</span>
<span class="nc" id="L568">          throw new IllegalStateException(&quot;Could not parse dates.&quot;, e);</span>
<span class="fc" id="L569">        }</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L571">          LOG.debug(&quot;PrivateKeyUsagePeriod.notAfter is &quot; + pkuNotAfter);</span>
        }
<span class="fc bfc" id="L573" title="All 4 branches covered.">        if (pkuNotAfter != null &amp;&amp; checkDate.after(pkuNotAfter)) {</span>
<span class="fc" id="L574">          final String msg =</span>
<span class="fc" id="L575">              INTRES.getLocalizedMessage(</span>
                  &quot;createcert.privatekeyusageexpired&quot;,
<span class="fc" id="L577">                  pkuNotAfter.toString(),</span>
<span class="fc" id="L578">                  cert.getSubjectDN().toString());</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L580">            LOG.debug(msg);</span>
          }
<span class="fc" id="L582">          throw new CAOfflineException(msg);</span>
        }
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">      } else if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L585">        LOG.debug(&quot;No PrivateKeyUsagePeriod available in certificate.&quot;);</span>
      }
<span class="pc bnc" id="L587" title="All 2 branches missed.">    } else if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L588">      LOG.debug(</span>
          &quot;No CA certificate available, not checking PrivateKeyUsagePeriod.&quot;);
    }
<span class="fc" id="L591">  }</span>

  /**
   * Checks if the encoded validity is an ISO8601 date or a relative time.
   *
   * @param encodedValidity the validity
   * @return Boolean.TRUE if it is a relative time, Boolean.FALSE if it is an
   *     ISO8601 date, otherwise NULL. @See {@link
   *     org.cesecore.util.ValidityDate ValidityDate} @See {@link
   *     org.cesecore.util.SimpleTime SimpleTime}
   */
  private static Boolean isRelativeTime(final String encodedValidity) {
    try {
      // Try the most likely setting first, for fail-fast
<span class="fc" id="L605">      SimpleTime.parseMillies(encodedValidity);</span>
<span class="fc" id="L606">      return Boolean.TRUE;</span>
<span class="fc" id="L607">    } catch (NumberFormatException nfe) {</span>
      // NOOP
    }
    try {
<span class="fc" id="L611">      ValidityDate.parseAsIso8601(encodedValidity);</span>
<span class="fc" id="L612">      return Boolean.FALSE;</span>
<span class="nc" id="L613">    } catch (ParseException e) {</span>
<span class="nc" id="L614">      return null;</span>
    }
  }

  /**
   * Parses the entity extended information start and end time format and
   * offsets it with the reference point.
   *
   * @param now the reference point
   * @param timeString the value in form of 'days:hours:minutes'
   * @return the parse value offset with now (reference point).
   */
  private static Date parseExtendedInformationEncodedValidity(
      final Date now, final String timeString) {
<span class="fc" id="L628">    Date result = null;</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">    if (timeString != null) {</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">      if (timeString.matches(&quot;^\\d+:\\d?\\d:\\d?\\d$&quot;)) {</span>
<span class="fc" id="L631">        final String[] endTimeArray = timeString.split(&quot;:&quot;);</span>
<span class="fc" id="L632">        long relative =</span>
<span class="fc" id="L633">            (Long.parseLong(endTimeArray[0]) * HOURS_PER_DAY * MINS_PER_HOUR</span>
<span class="fc" id="L634">                    + Long.parseLong(endTimeArray[1]) * MINS_PER_HOUR</span>
<span class="fc" id="L635">                    + Long.parseLong(endTimeArray[2]))</span>
                * SECS_PER_MIN
                * MS_PER_SEC;
<span class="fc" id="L638">        result = new Date(now.getTime() + relative);</span>
<span class="fc" id="L639">      } else {</span>
        try {
          // Try parsing data as &quot;yyyy-MM-dd HH:mm&quot; assuming UTC
<span class="fc" id="L642">          result = ValidityDate.parseAsUTC(timeString);</span>
<span class="nc" id="L643">        } catch (ParseException e) {</span>
<span class="nc" id="L644">          LOG.error(</span>
<span class="nc" id="L645">              INTRES.getLocalizedMessage(</span>
                  &quot;createcert.errorinvalidstarttime&quot;, timeString));
<span class="fc" id="L647">        }</span>
      }
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">      if ((LOG.isDebugEnabled())) {</span>
<span class="nc" id="L650">        LOG.debug(&quot;Time string by end entity extended Information: &quot; + result);</span>
      }
    }
<span class="fc" id="L653">    return result;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>