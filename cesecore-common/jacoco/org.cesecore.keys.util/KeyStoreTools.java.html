<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyStoreTools.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.util</a> &gt; <span class="el_source">KeyStoreTools.java</span></div><h1>KeyStoreTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.util;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.Security;
import java.security.UnrecoverableEntryException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.ECGenParameterSpec;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;

import javax.crypto.KeyGenerator;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.DERSet;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
import org.bouncycastle.crypto.ec.CustomNamedCurves;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;
import org.bouncycastle.jce.ECKeyUtil;
import org.bouncycastle.operator.BufferingContentSigner;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.pkcs.PKCS10CertificationRequest;
import org.bouncycastle.pkcs.PKCSException;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.keys.KeyCreationException;
import org.cesecore.keys.token.CachingKeyStoreWrapper;
import org.cesecore.keys.token.p11.PKCS11Utils;
import org.cesecore.util.CertTools;

/**
 * @version $Id: KeyStoreTools.java 29332 2018-06-25 13:39:58Z andresjakobs $
 */
public class KeyStoreTools {
<span class="fc" id="L80">    private static final Logger log = Logger.getLogger(KeyStoreTools.class);</span>
    /** Internal localization of logs and errors */
<span class="fc" id="L82">    private static final InternalResources intres = InternalResources.getInstance();</span>

    protected final CachingKeyStoreWrapper keyStore;
    private final String providerName;

<span class="fc" id="L87">    public KeyStoreTools(CachingKeyStoreWrapper _keyStore, String _providerName){</span>
<span class="fc" id="L88">        this.keyStore = _keyStore;</span>
<span class="fc" id="L89">        this.providerName = _providerName;</span>
<span class="fc" id="L90">    }</span>

    /**
     * @return the name of the Provider used by this container
     */
    public String getProviderName() {
<span class="nc" id="L96">        return this.providerName;</span>
    }

    /**
     * @return a reference to the KeyStore for this container
     */
    public CachingKeyStoreWrapper getKeyStore() {
<span class="fc" id="L103">        return this.keyStore;</span>
    }

    public void setKeyEntry(String alias, Key key, Certificate chain[]) throws KeyStoreException {
        // Removal of old key is only needed for sun-p11 with none ASCII chars in the alias.
        // But it makes no harm to always do it and it should be fast.
        // If not done the entry will not be stored correctly in the p11 KeyStore.
<span class="fc" id="L110">        getKeyStore().deleteEntry(alias);</span>
<span class="fc" id="L111">        getKeyStore().setKeyEntry(alias, key, null, chain);</span>
<span class="fc" id="L112">    }</span>

    private void deleteAlias(String alias) throws KeyStoreException {
<span class="fc" id="L115">        getKeyStore().deleteEntry(alias);</span>
<span class="fc" id="L116">    }</span>
    /** Deletes an entry in the keystore
     * 
     * @param alias is a reference to the entry in the KeyStore that should be deleted, if alias is null, all entries are deleted.
     * 
     * 
     * @throws KeyStoreException on error
     */
    public void deleteEntry(final String alias) throws KeyStoreException {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if ( alias!=null ) {</span>
<span class="fc" id="L126">            deleteAlias(alias);</span>
<span class="fc" id="L127">            return;</span>
        }
<span class="nc" id="L129">        final Enumeration&lt;String&gt; e = getKeyStore().aliases();</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        while( e.hasMoreElements() ) {</span>
<span class="nc" id="L131">            final String str = e.nextElement();</span>
<span class="nc" id="L132">            deleteAlias( str );</span>
<span class="nc" id="L133">        }</span>
<span class="nc" id="L134">    }</span>
    /**
     * Rename the alias of an entry.
     * This has just been tested on pkcs#11 keystores. On other keystore it might
     * be that you will get two aliases for the same key (copy). But on p11
     * we know that the oldAlias is not existing after the method is called.
     *  
     * @param oldAlias is the current name
     * @param newAlias is the new name
     */
    public void renameEntry( String oldAlias, String newAlias ) {
        // only one key with same public part (certificate) is existing on a p11 token. this has been tested.
        try {
<span class="nc" id="L147">            getKeyStore().setEntry(newAlias, getKeyStore().getEntry(oldAlias, null), null);</span>
<span class="nc" id="L148">        } catch (KeyStoreException | NoSuchAlgorithmException | UnrecoverableEntryException e) {</span>
<span class="nc" id="L149">            throw new KeyUtilRuntimeException(&quot;Renaming entry failed.&quot;, e);</span>
<span class="nc" id="L150">        }</span>
<span class="nc" id="L151">    }</span>

    private class CertificateSignOperation implements ISignOperation {

        final private PrivateKey privateKey;
        final private X509v3CertificateBuilder certificateBuilder;
        private X509CertificateHolder result;

        public CertificateSignOperation(
                final PrivateKey pk,
<span class="fc" id="L161">                final X509v3CertificateBuilder cb) {</span>
<span class="fc" id="L162">            this.privateKey = pk;</span>
<span class="fc" id="L163">            this.certificateBuilder = cb;</span>
<span class="fc" id="L164">        }</span>
        @SuppressWarnings(&quot;synthetic-access&quot;)
        @Override
        public void taskWithSigning(String sigAlg, Provider provider) throws TaskWithSigningException {
<span class="fc" id="L168">            log.debug(&quot;Keystore signing algorithm &quot; + sigAlg);</span>
            final ContentSigner signer;
            try {
<span class="fc" id="L171">                signer = new BufferingContentSigner(new JcaContentSignerBuilder(sigAlg).setProvider(provider.getName()).build(this.privateKey), 20480);</span>
<span class="nc" id="L172">            } catch (OperatorCreationException e) {</span>
<span class="nc" id="L173">                throw new TaskWithSigningException(String.format(&quot;Signing certificate failed: %s&quot;, e.getMessage()), e);</span>
<span class="fc" id="L174">            }</span>
<span class="fc" id="L175">            this.result = this.certificateBuilder.build(signer);</span>
<span class="fc" id="L176">        }</span>
        public X509CertificateHolder getResult() {
<span class="fc" id="L178">            return this.result;</span>
        }
    }
    private X509Certificate getSelfCertificate(String myname, long validity, List&lt;String&gt; sigAlgs, KeyPair keyPair) throws InvalidKeyException,
            CertificateException {
<span class="fc" id="L183">        final long currentTime = new Date().getTime();</span>
<span class="fc" id="L184">        final Date firstDate = new Date(currentTime - 24 * 60 * 60 * 1000);</span>
<span class="fc" id="L185">        final Date lastDate = new Date(currentTime + validity * 1000);</span>
<span class="fc" id="L186">        final X500Name issuer = new X500Name(myname);</span>
<span class="fc" id="L187">        final BigInteger serno = BigInteger.valueOf(firstDate.getTime());</span>
<span class="fc" id="L188">        final PublicKey publicKey = keyPair.getPublic();</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (publicKey == null) {</span>
<span class="nc" id="L190">            throw new InvalidKeyException(&quot;Public key is null&quot;);</span>
        }

        try {
<span class="fc" id="L194">            final X509v3CertificateBuilder cb = new JcaX509v3CertificateBuilder(issuer, serno, firstDate, lastDate, issuer, publicKey);</span>
<span class="fc" id="L195">            final CertificateSignOperation cso = new CertificateSignOperation(keyPair.getPrivate(), cb);</span>
<span class="fc" id="L196">            SignWithWorkingAlgorithm.doSignTask(sigAlgs, this.providerName, cso);</span>
<span class="fc" id="L197">            final X509CertificateHolder cert = cso.getResult();</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if ( cert==null ) {</span>
<span class="nc" id="L199">                throw new CertificateException(&quot;Self signing of certificate failed.&quot;);</span>
            }
<span class="fc" id="L201">            return CertTools.getCertfromByteArray(cert.getEncoded(), X509Certificate.class);</span>
<span class="nc" id="L202">        } catch (TaskWithSigningException e) {</span>
<span class="nc" id="L203">            log.error(&quot;Error creating content signer: &quot;, e);</span>
<span class="nc" id="L204">            throw new CertificateException(e);</span>
<span class="nc" id="L205">        } catch (IOException e) {</span>
<span class="nc" id="L206">            throw new CertificateException(&quot;Could not read certificate&quot;, e);</span>
<span class="nc" id="L207">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L208">            throw new CertificateException(String.format(&quot;Provider '%s' does not exist.&quot;, this.providerName), e);</span>
        }
    }

    private void generateEC(final String ecNamedCurveBc, final String keyAlias) throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L214">            log.trace(&quot;&gt;generate EC: curve name &quot;+ecNamedCurveBc+&quot;, keyEntryName &quot;+keyAlias);</span>
        }
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (StringUtils.contains(Security.getProvider(this.providerName).getClass().getName(), &quot;iaik&quot;)) {</span>
<span class="nc" id="L217">            throw new InvalidAlgorithmParameterException(&quot;IAIK ECC key generation not implemented.&quot;);</span>
        }
        final AlgorithmParameterSpec keyParams;
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (StringUtils.equals(ecNamedCurveBc,&quot;implicitlyCA&quot;)) {</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L222">                log.debug(&quot;Generating implicitlyCA encoded ECDSA key pair&quot;);</span>
            }
            // If the keySpec is null, we have &quot;implicitlyCA&quot; defined EC parameters
            // The parameters were already installed when we installed the provider
            // We just make sure that ecSpec == null here
<span class="fc" id="L227">            keyParams = null;</span>
        } else {
            // Convert it to the OID if possible since the human friendly name might differ in the provider
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (ECUtil.getNamedCurveOid(ecNamedCurveBc) != null) {</span>
<span class="fc" id="L231">                final String oidOrName = AlgorithmTools.getEcKeySpecOidFromBcName(ecNamedCurveBc);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L233">                    log.debug(&quot;keySpecification '&quot;+ecNamedCurveBc+&quot;' transformed into OID &quot; + oidOrName);</span>
                }
<span class="fc" id="L235">                keyParams = new ECGenParameterSpec(oidOrName);</span>
<span class="fc" id="L236">            } else {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L238">                    log.debug(&quot;Curve did not have an OID in BC, trying to pick up Parameter spec: &quot; + ecNamedCurveBc);</span>
                }
                // This may be a new curve without OID, like curve25519 and we have to do something a bit different
<span class="nc" id="L241">                X9ECParameters ecP = CustomNamedCurves.getByName(ecNamedCurveBc);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if (ecP == null) {</span>
<span class="nc" id="L243">                    throw new InvalidAlgorithmParameterException(&quot;Can not generate EC curve, no OID and no ECParameters found: &quot;+ecNamedCurveBc);</span>
                }
<span class="nc" id="L245">                keyParams = new org.bouncycastle.jce.spec.ECParameterSpec(</span>
<span class="nc" id="L246">                        ecP.getCurve(), ecP.getG(), ecP.getN(), ecP.getH(), ecP.getSeed()); </span>
            }
        }
        try {
<span class="fc" id="L250">            generateKeyPair(</span>
                    keyParams, keyAlias,
                    AlgorithmConstants.KEYALGORITHM_EC,
                    AlgorithmTools.SIG_ALGS_ECDSA);
<span class="nc" id="L254">        } catch( InvalidAlgorithmParameterException e ) {</span>
<span class="nc" id="L255">            log.debug(&quot;EC name &quot;+ecNamedCurveBc+&quot; not supported.&quot;);</span>
<span class="nc" id="L256">            throw e;</span>
<span class="fc" id="L257">        }</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L259">            log.trace(&quot;&lt;generate: curve name &quot;+ecNamedCurveBc+&quot;, keyEntryName &quot;+keyAlias);</span>
        }
<span class="fc" id="L261">    }</span>

    private void generateExtraEC(
            final String name, final String keyAlias, final String keyAlgorithm,
            final List&lt;String&gt; sigAlgNames) throws InvalidAlgorithmParameterException {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L267">            log.trace(&quot;&gt;generate &quot;+keyAlgorithm+&quot;: curve name &quot;+name+&quot;, keyEntryName &quot;+keyAlias);</span>
        }
        // Generate the EC Keypair
<span class="nc" id="L270">        final ECGenParameterSpec keyParams = new ECGenParameterSpec(name);</span>
        try {
<span class="nc" id="L272">            generateKeyPair(keyParams, keyAlias, keyAlgorithm, sigAlgNames);</span>
<span class="nc" id="L273">        } catch( InvalidAlgorithmParameterException e ) {</span>
<span class="nc" id="L274">            log.debug(&quot;EC &quot;+keyAlgorithm+&quot; name &quot;+name+&quot; not supported.&quot;);</span>
<span class="nc" id="L275">            throw e;</span>
<span class="nc" id="L276">        }</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L278">            log.trace(&quot;&lt;generate: curve name &quot;+name+&quot;, keyEntryName &quot;+keyAlias);</span>
        }
<span class="nc" id="L280">    }</span>

    private void generateGOST3410(final String name, final String keyEntryName) throws
            InvalidAlgorithmParameterException {
<span class="nc" id="L284">        generateExtraEC(</span>
                name, keyEntryName, AlgorithmConstants.KEYALGORITHM_ECGOST3410,
                AlgorithmTools.SIG_ALGS_ECGOST3410);
<span class="nc" id="L287">    }</span>
    
    private void generateDSTU4145(final String name, final String keyEntryName) throws
            InvalidAlgorithmParameterException {
<span class="nc" id="L291">        generateExtraEC(</span>
                name, keyEntryName, AlgorithmConstants.KEYALGORITHM_DSTU4145,
                AlgorithmTools.SIG_ALGS_DSTU4145);
<span class="nc" id="L294">    }</span>

    private void generateRSA(final int keySize, final String keyEntryName) throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L298">            log.trace(&quot;&gt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyEntryName);</span>
        }
<span class="fc" id="L300">        generateKeyPair(</span>
                new SizeAlgorithmParameterSpec(keySize), keyEntryName,
                AlgorithmConstants.KEYALGORITHM_RSA,
                AlgorithmTools.SIG_ALGS_RSA);
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L305">            log.trace(&quot;&lt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyEntryName);</span>
        }
<span class="fc" id="L307">    }</span>

    private void generateDSA(final int keySize, final String keyAlias) throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L311">            log.trace(&quot;&gt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyAlias);</span>
        }
        // Generate the RSA Keypair
        final KeyPairGenerator kpg;
        try {
<span class="fc" id="L316">            kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;, this.providerName);</span>
<span class="nc" id="L317">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L318">           throw new IllegalStateException(&quot;Algorithm &quot; + &quot;DSA&quot; + &quot; was not recognized.&quot;, e);</span>
<span class="nc" id="L319">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L320">            throw new IllegalStateException(&quot;BouncyCastle was not found as a provider.&quot;, e);</span>
<span class="fc" id="L321">        }</span>
<span class="fc" id="L322">        kpg.initialize(keySize);</span>
<span class="fc" id="L323">        generateKeyPair(</span>
                new SizeAlgorithmParameterSpec(keySize), keyAlias,
                AlgorithmConstants.KEYALGORITHM_DSA, AlgorithmTools.SIG_ALGS_DSA);
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L327">            log.trace(&quot;&lt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyAlias);</span>
        }
<span class="fc" id="L329">    }</span>

    /** Generates asymmteric keys in the Keystore token.
     * 
     * @param keySpec all decimal digits RSA key length, otherwise name of ECC curve or DSA key using syntax DSAnnnn
     * @param keyEntryName entry name
     * @throws InvalidAlgorithmParameterException if invalid params apssed
     */
    public void generateKeyPair(final String keySpec, final String keyEntryName) throws
            InvalidAlgorithmParameterException {

<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (keySpec.toUpperCase().startsWith(&quot;DSA&quot;)) {</span>
<span class="fc" id="L341">            generateDSA(Integer.parseInt(keySpec.substring(3).trim()), keyEntryName);</span>
<span class="pc bpc" id="L342" title="3 of 4 branches missed.">        } else if (AlgorithmTools.isGost3410Enabled() &amp;&amp; keySpec.startsWith(AlgorithmConstants.KEYSPECPREFIX_ECGOST3410)) {</span>
<span class="nc" id="L343">            generateGOST3410(keySpec, keyEntryName);</span>
<span class="pc bpc" id="L344" title="3 of 4 branches missed.">        } else if (AlgorithmTools.isDstu4145Enabled() &amp;&amp; keySpec.startsWith(CesecoreConfiguration.getOidDstu4145() + &quot;.&quot;)) {</span>
<span class="nc" id="L345">            generateDSTU4145(keySpec, keyEntryName);</span>
        } else {

            try {
<span class="fc" id="L349">                generateRSA(Integer.parseInt(keySpec.trim()), keyEntryName);</span>
<span class="fc" id="L350">            } catch (NumberFormatException e) {</span>
<span class="fc" id="L351">                generateEC(keySpec, keyEntryName);</span>
<span class="fc" id="L352">            }</span>
        }
<span class="fc" id="L354">    }</span>
    
    /** Generates symmetric keys in the Keystore token.
     * 
     * @param algorithm symmetric algorithm specified in http://download.oracle.com/javase/1.5.0/docs/api/index.html, suggest AES, DESede or DES
     * @param keysize keysize of symmetric key, suggest 128 or 256 for AES, 64 for 168 for DESede and 64 for DES
     * @param keyEntryName the alias the key will get in the keystore
     * @throws NoSuchProviderException  if provider not found
     * @throws NoSuchAlgorithmException  of algo not found
     * @throws KeyStoreException  if store fails
     */
    public void generateKey(final String algorithm, final int keysize,
                            final String keyEntryName) throws NoSuchAlgorithmException, NoSuchProviderException, KeyStoreException {
<span class="nc" id="L367">        final KeyGenerator generator = KeyGenerator.getInstance(algorithm, this.providerName);</span>
<span class="nc" id="L368">        generator.init(keysize);</span>
<span class="nc" id="L369">        final Key key = generator.generateKey();</span>
<span class="nc" id="L370">        setKeyEntry(keyEntryName, key, null);</span>
<span class="nc" id="L371">    }</span>

    /** Generates keys in the Keystore token.
     * @param keyParams AlgorithmParameterSpec for the KeyPairGenerator. Can be anything like RSAKeyGenParameterSpec, DSAParameterSpec, ECParameterSpec or ECGenParameterSpec. 
     * @param keyAlias Alias
     * @throws InvalidAlgorithmParameterException if params are invalid
     */
    public void generateKeyPair(final AlgorithmParameterSpec keyParams, final String keyAlias) throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L380">            log.trace(&quot;&gt;generate from AlgorithmParameterSpec: &quot;+keyParams.getClass().getName());</span>
        }
        // Generate the Keypair
        final String keyAlgorithm;
        final List&lt;String&gt; certSignAlgorithms;
<span class="fc" id="L385">        final String specName = keyParams.getClass().getName();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (specName.contains(AlgorithmConstants.KEYALGORITHM_DSA)) {</span>
<span class="fc" id="L387">            keyAlgorithm = AlgorithmConstants.KEYALGORITHM_DSA;</span>
<span class="fc" id="L388">            certSignAlgorithms = AlgorithmTools.SIG_ALGS_DSA;</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">        } else if (specName.contains(AlgorithmConstants.KEYALGORITHM_RSA)) {</span>
<span class="fc" id="L390">            keyAlgorithm = AlgorithmConstants.KEYALGORITHM_RSA;</span>
<span class="fc" id="L391">            certSignAlgorithms = AlgorithmTools.SIG_ALGS_RSA;</span>
        } else {
<span class="fc" id="L393">            keyAlgorithm = AlgorithmConstants.KEYALGORITHM_EC;</span>
<span class="fc" id="L394">            certSignAlgorithms = AlgorithmTools.SIG_ALGS_ECDSA;</span>
        }
<span class="fc" id="L396">        generateKeyPair(keyParams, keyAlias, keyAlgorithm, certSignAlgorithms);</span>
<span class="fc" id="L397">    }</span>
    private class SizeAlgorithmParameterSpec implements AlgorithmParameterSpec {
        final int keySize;
<span class="fc" id="L400">        public SizeAlgorithmParameterSpec(final int _keySize) {</span>
<span class="fc" id="L401">            this.keySize = _keySize;</span>
<span class="fc" id="L402">        }</span>
    }
    private void generateKeyPair(
            final AlgorithmParameterSpec keyParams, final String keyAlias,
            final String keyAlgorithm,
            final List&lt;String&gt; certSignAlgorithms) throws InvalidAlgorithmParameterException {
        final KeyPairGenerator kpg;
        try {
<span class="fc" id="L410">            kpg = KeyPairGenerator.getInstance(keyAlgorithm, this.providerName);</span>
<span class="nc" id="L411">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L412">            throw new IllegalStateException(&quot;Algorithm &quot; + keyAlgorithm + &quot; was not recognized.&quot;, e);</span>
<span class="nc" id="L413">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L414">            throw new IllegalStateException(this.providerName+ &quot; was not found as a provider.&quot;, e);</span>
<span class="fc" id="L415">        }</span>
        try {
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if ( keyParams instanceof SizeAlgorithmParameterSpec ) {</span>
<span class="fc" id="L418">                kpg.initialize(((SizeAlgorithmParameterSpec)keyParams).keySize);</span>
            } else {
<span class="fc" id="L420">                kpg.initialize(keyParams);</span>
            }
<span class="nc" id="L422">        } catch( InvalidAlgorithmParameterException e ) {</span>
<span class="nc" id="L423">            log.debug(&quot;Algorithm parameters not supported: &quot;+e.getMessage());</span>
<span class="nc" id="L424">            throw e;</span>
<span class="fc" id="L425">        }</span>
        // We will make a loop to retry key generation here. Using the IAIK provider it seems to give
        // CKR_OBJECT_HANDLE_INVALID about every second time we try to store keys
        // But if we try again it succeeds
<span class="fc" id="L429">        int bar = 0;</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">        while (bar &lt; 3) {</span>
            try {
<span class="fc" id="L432">                log.debug(&quot;generating...&quot;);</span>
<span class="fc" id="L433">                final KeyPair keyPair = kpg.generateKeyPair();</span>
<span class="fc" id="L434">                final X509Certificate selfSignedCert = getSelfCertificate(&quot;CN=Dummy certificate created by a CESeCore application&quot;, (long) 30 * 24 * 60 * 60 * 365, certSignAlgorithms, keyPair);</span>
<span class="fc" id="L435">                final X509Certificate chain[] = new X509Certificate[]{selfSignedCert};</span>
<span class="fc" id="L436">                log.debug(&quot;Creating certificate with entry &quot; + keyAlias + '.');</span>
<span class="fc" id="L437">                setKeyEntry(keyAlias, keyPair.getPrivate(), chain);</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                if ( CesecoreConfiguration.makeKeyUnmodifiableAfterGeneration() ) {</span>
<span class="nc" id="L439">                    PKCS11Utils.getInstance().makeKeyUnmodifiable(keyPair.getPrivate(), this.providerName);</span>
                }
<span class="fc" id="L441">                break; // success no need to try more</span>
<span class="nc" id="L442">            } catch (KeyStoreException e) {</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if ( bar&lt;3 ) {</span>
<span class="nc" id="L444">                    log.info(&quot;Failed to generate or store new key, will try 3 times. This was try: &quot; + bar, e);</span>
                } else {
<span class="nc" id="L446">                    throw new KeyCreationException(&quot;Signing failed.&quot;, e);</span>
                }
<span class="nc" id="L448">            } catch(CertificateException e) {</span>
<span class="nc" id="L449">                throw new KeyCreationException(&quot;Can't create keystore because dummy certificate chain creation failed.&quot;,e);</span>
<span class="nc" id="L450">            } catch (InvalidKeyException e) {</span>
<span class="nc" id="L451">               throw new KeyCreationException(&quot;Dummy certificate chain was created with an invalid key&quot; , e);</span>
<span class="nc" id="L452">            }</span>
<span class="nc" id="L453">            bar++;</span>
        }
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            log.trace(&quot;&lt;generate from AlgorithmParameterSpec: &quot;+(keyParams!=null ? keyParams.getClass().getName() : &quot;null&quot;));</span>
        }
<span class="fc" id="L458">    }</span>

    private class SignCsrOperation implements ISignOperation {
        final private String alias;
        final private String sDN;
        final private boolean explicitEccParameters;
        final private PublicKey publicKeyTmp;
        private PKCS10CertificationRequest certReq;

<span class="nc" id="L467">        public SignCsrOperation(final String _alias, final String _sDN, final boolean _explicitEccParameters, final PublicKey publicKey) {</span>
<span class="nc" id="L468">            this.alias = _alias;</span>
<span class="nc" id="L469">            this.sDN = _sDN;</span>
<span class="nc" id="L470">            this.explicitEccParameters = _explicitEccParameters;</span>
<span class="nc" id="L471">            this.certReq = null;</span>
<span class="nc" id="L472">            this.publicKeyTmp = publicKey;</span>
<span class="nc" id="L473">        }</span>
        @SuppressWarnings(&quot;synthetic-access&quot;)
        private void signCSR(final String signAlgorithm, final Provider provider) throws NoSuchAlgorithmException, NoSuchProviderException, UnrecoverableKeyException, KeyStoreException, OperatorCreationException, TaskWithSigningException {
            final PublicKey publicKey;
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L478">                log.debug(String.format(</span>
                        &quot;alias: %s SHA1 of public key: %s&quot;,
                        this.alias,
<span class="nc" id="L481">                        CertTools.getFingerprintAsString(this.publicKeyTmp.getEncoded())</span>
                        ));
            }
<span class="nc bnc" id="L484" title="All 4 branches missed.">            if (signAlgorithm.contains(&quot;ECDSA&quot;) &amp;&amp; this.explicitEccParameters) {</span>
<span class="nc" id="L485">                log.info(&quot;Using explicit parameter encoding for ECC key.&quot;);</span>
<span class="nc" id="L486">                publicKey = ECKeyUtil.publicToExplicitParameters(this.publicKeyTmp, &quot;BC&quot;);</span>
            } else {
<span class="nc" id="L488">                log.info(&quot;Using named curve parameter encoding for ECC key.&quot;);</span>
<span class="nc" id="L489">                publicKey = this.publicKeyTmp;</span>
            }
<span class="nc" id="L491">            final PrivateKey privateKey = getPrivateKey(this.alias);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            final X500Name sDNName = this.sDN!=null ? new X500Name(this.sDN) : new X500Name(&quot;CN=&quot;+this.alias);</span>
<span class="nc" id="L493">            this.certReq = CertTools.genPKCS10CertificationRequest(</span>
                    signAlgorithm,
                    sDNName,
                    publicKey, new DERSet(),
                    privateKey,
<span class="nc" id="L498">                    provider.getName() );</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if ( this.certReq==null) {</span>
<span class="nc" id="L500">                throw new TaskWithSigningException(&quot;Not possible to sign CSR.&quot;);</span>
            }
<span class="nc" id="L502">        }</span>
        @Override
        public void taskWithSigning(final String signAlgorithm, final Provider provider) throws TaskWithSigningException {
            try {
<span class="nc" id="L506">                signCSR(signAlgorithm, provider);</span>
<span class="nc" id="L507">            } catch (TaskWithSigningException e) {</span>
<span class="nc" id="L508">                throw e;</span>
<span class="nc" id="L509">            } catch (OperatorCreationException | UnrecoverableKeyException | NoSuchAlgorithmException | NoSuchProviderException | KeyStoreException e) {</span>
<span class="nc" id="L510">                throw new TaskWithSigningException(String.format(&quot;Not possible to sign CSR: %s&quot;, e.getMessage()), e);</span>
<span class="nc" id="L511">            }</span>
<span class="nc" id="L512">        }</span>
        public PKCS10CertificationRequest getResult() {
<span class="nc" id="L514">            return this.certReq;</span>
        }
    }
    /** Generates a certificate request (CSR) in PKCS#10 format and writes to file
     * @param alias for the key to be used
     * @param sDN the DN to be used. If null the 'CN=alias' will be used
     * @param explicitEccParameters false should be default and will use NamedCurve encoding of ECC public keys (IETF recommendation), use true to include all parameters explicitly (ICAO ePassport requirement).
     */
    public void generateCertReq(String alias, String sDN, boolean explicitEccParameters) {
        try {
<span class="nc" id="L524">            final PublicKey publicKey = getCertificate(alias).getPublicKey();</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L526">                log.debug(&quot;alias: &quot; + alias + &quot; SHA1 of public key: &quot; + CertTools.getFingerprintAsString(publicKey.getEncoded()));</span>
            }
            // Candidate algorithms. The first working one will be selected by SignWithWorkingAlgorithm
<span class="nc" id="L529">            final List&lt;String&gt; sigAlg = AlgorithmTools.getSignatureAlgorithms(publicKey);</span>
<span class="nc" id="L530">            final SignCsrOperation operation = new SignCsrOperation(alias, sDN, explicitEccParameters, publicKey);</span>
<span class="nc" id="L531">            SignWithWorkingAlgorithm.doSignTask(sigAlg, this.providerName, operation);</span>
<span class="nc" id="L532">            final PKCS10CertificationRequest certReq = operation.getResult();</span>
<span class="nc" id="L533">            final ContentVerifierProvider verifier = CertTools.genContentVerifierProvider(publicKey);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if ( !certReq.isSignatureValid(verifier) ) {</span>
<span class="nc" id="L535">                final String msg = intres.getLocalizedMessage(&quot;token.errorcertreqverify&quot;, alias);</span>
<span class="nc" id="L536">                throw new KeyUtilRuntimeException(msg);</span>
            }
<span class="nc" id="L538">            final String filename = alias+&quot;.pem&quot;;</span>

<span class="nc" id="L540">            try( final OutputStream os = new FileOutputStream(filename) ) {</span>
<span class="nc" id="L541">                os.write( CertTools.getPEMFromCertificateRequest(certReq.getEncoded()) );</span>
            }
<span class="nc" id="L543">            log.info(&quot;Wrote csr to file: &quot;+filename);</span>
<span class="nc" id="L544">        } catch (KeyStoreException | NoSuchProviderException | TaskWithSigningException | OperatorCreationException | PKCSException | IOException  e) {</span>
<span class="nc" id="L545">            throw new KeyUtilRuntimeException(&quot;Failed to generate a certificate request.&quot;, e);</span>
<span class="nc" id="L546">        }</span>
<span class="nc" id="L547">    }</span>

    /**
     * Install certificate chain to key in keystore.
     * @param fileName name of the file with chain. Starting with the certificate of the key. Ending with the root certificate.
     */
    public void installCertificate(final String fileName) {
<span class="nc" id="L554">        try( final InputStream is = new FileInputStream(fileName) ) {</span>
            final X509Certificate chain[];
<span class="nc" id="L556">            chain = CertTools.getCertsFromPEM(is, X509Certificate.class).toArray(new X509Certificate[0]);</span>
<span class="nc" id="L557">            final PublicKey importPublicKey = chain[0].getPublicKey();</span>
<span class="nc" id="L558">            final String importKeyHash = CertTools.getFingerprintAsString(importPublicKey.getEncoded());</span>
<span class="nc" id="L559">            final Enumeration&lt;String&gt; eAlias = getKeyStore().aliases();</span>
<span class="nc" id="L560">            boolean notFound = true;</span>
<span class="nc bnc" id="L561" title="All 4 branches missed.">            while ( eAlias.hasMoreElements() &amp;&amp; notFound ) {</span>
<span class="nc" id="L562">                final String alias = eAlias.nextElement();</span>
<span class="nc" id="L563">                final PublicKey hsmPublicKey = getCertificate(alias).getPublicKey();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L565">                    log.debug(&quot;alias: &quot; + alias + &quot; SHA1 of public hsm key: &quot; + CertTools.getFingerprintAsString(hsmPublicKey.getEncoded())</span>
                    + &quot; SHA1 of first public key in chain: &quot; + importKeyHash
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    +  (chain.length==1?&quot;&quot;:(&quot;SHA1 of last public key in chain: &quot; + CertTools.getFingerprintAsString(chain[chain.length-1].getPublicKey().getEncoded()))));</span>
                }
<span class="nc bnc" id="L569" title="All 2 branches missed.">                if ( hsmPublicKey.equals(importPublicKey) ) {</span>
<span class="nc" id="L570">                    log.info(&quot;Found a matching public key for alias \&quot;&quot; + alias + &quot;\&quot;.&quot;);</span>
<span class="nc" id="L571">                    getKeyStore().setKeyEntry(alias, getPrivateKey(alias), null, chain);</span>
<span class="nc" id="L572">                    notFound = false;</span>
                }
<span class="nc" id="L574">            }</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if ( notFound ) {</span>
<span class="nc" id="L576">                final String msg = intres.getLocalizedMessage(&quot;token.errorkeynottoken&quot;, importKeyHash);</span>
<span class="nc" id="L577">                throw new KeyUtilRuntimeException(msg);</span>
            }
<span class="nc" id="L579">        } catch (IOException | CertificateParsingException | KeyStoreException | UnrecoverableKeyException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L580">            throw new KeyUtilRuntimeException(&quot;Failed to install cert chain into keystore.&quot;, e);</span>
<span class="nc" id="L581">        }</span>
<span class="nc" id="L582">    }</span>
    
    /**
     * Install trusted root in trust store
     * @param fileName name of the trusted root.
     */
    public void installTrustedRoot(String fileName) {
<span class="nc" id="L589">        try( final InputStream is = new FileInputStream(fileName) ) {</span>
<span class="nc" id="L590">            final List&lt;Certificate&gt; chain = CertTools.getCertsFromPEM(is, Certificate.class);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">            if ( chain.size()&lt;1 ) {</span>
<span class="nc" id="L592">                throw new KeyUtilRuntimeException(&quot;No certificate in file&quot;);</span>
            }
            // assume last cert in chain is root if more than 1
<span class="nc" id="L595">            getKeyStore().setCertificateEntry(&quot;trusted&quot;, chain.get(chain.size()-1));</span>
<span class="nc" id="L596">        } catch (IOException | CertificateParsingException | KeyStoreException e) {</span>
<span class="nc" id="L597">            throw new KeyUtilRuntimeException(&quot;Failing to install trusted certificate.&quot;, e);</span>
<span class="nc" id="L598">        }</span>
<span class="nc" id="L599">    }</span>
    private PrivateKey getPrivateKey(String alias) throws UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException {
<span class="nc" id="L601">        final PrivateKey key = (PrivateKey)getKey(alias);</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if ( key==null ) {</span>
<span class="nc" id="L603">            String msg = intres.getLocalizedMessage(&quot;token.errornokeyalias&quot;, alias);</span>
<span class="nc" id="L604">            log.info(msg);</span>
        }
<span class="nc" id="L606">        return key;</span>
    }
    private Key getKey(String alias) throws UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException {
<span class="nc" id="L609">        return getKeyStore().getKey(alias, null);</span>
    }
    private X509Certificate getCertificate( String alias ) throws KeyStoreException {
<span class="nc" id="L612">        final X509Certificate cert = (X509Certificate)this.keyStore.getCertificate(alias);</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if ( cert==null ) {</span>
<span class="nc" id="L614">            String msg = intres.getLocalizedMessage(&quot;token.errornocertalias&quot;, alias);</span>
<span class="nc" id="L615">            log.info(msg);</span>
        }
<span class="nc" id="L617">        return cert;</span>
    }

    /**
     * Encodes a Keystore to a byte array.
     * @param keyStore the keystore.
     * @param password the password.
     * @return the keystore encoded as byte array.
     */
    public static byte[] getAsByteArray(final KeyStore keyStore, final String password) {
<span class="nc" id="L627">        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="nc" id="L628">            keyStore.store(outputStream, password.toCharArray());</span>
<span class="nc" id="L629">            return outputStream.toByteArray();</span>
<span class="nc" id="L630">        } catch (IOException | KeyStoreException | NoSuchAlgorithmException | CertificateException e) {</span>
<span class="nc" id="L631">            log.error(e); //should never happen if keyStore is valid object</span>
        }
<span class="nc" id="L633">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>