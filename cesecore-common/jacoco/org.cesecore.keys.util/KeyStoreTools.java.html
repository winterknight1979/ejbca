<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyStoreTools.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.util</a> &gt; <span class="el_source">KeyStoreTools.java</span></div><h1>KeyStoreTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.util;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.Security;
import java.security.UnrecoverableEntryException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.ECGenParameterSpec;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;
import javax.crypto.KeyGenerator;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.DERSet;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
import org.bouncycastle.crypto.ec.CustomNamedCurves;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;
import org.bouncycastle.jce.ECKeyUtil;
import org.bouncycastle.operator.BufferingContentSigner;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.pkcs.PKCS10CertificationRequest;
import org.bouncycastle.pkcs.PKCSException;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.keys.KeyCreationException;
import org.cesecore.keys.token.CachingKeyStoreWrapper;
import org.cesecore.keys.token.p11.PKCS11Utils;
import org.cesecore.util.CertTools;

/**
 * @version $Id: KeyStoreTools.java 29332 2018-06-25 13:39:58Z andresjakobs $
 */
public class KeyStoreTools {
    /** Logger. */
<span class="fc" id="L79">  private static final Logger LOG = Logger.getLogger(KeyStoreTools.class);</span>
  /** Internal localization of logs and errors. */
<span class="fc" id="L81">  private static final InternalResources INTRES =</span>
<span class="fc" id="L82">      InternalResources.getInstance();</span>
  /** Store. */
  protected final CachingKeyStoreWrapper keyStore;
  /** Provider. */
  private final String providerName;
  /**
   * @param aKeyStore Store
   * @param aProviderName Name
   */
  public KeyStoreTools(
<span class="fc" id="L92">          final CachingKeyStoreWrapper aKeyStore, final String aProviderName) {</span>
<span class="fc" id="L93">    this.keyStore = aKeyStore;</span>
<span class="fc" id="L94">    this.providerName = aProviderName;</span>
<span class="fc" id="L95">  }</span>

  /** @return the name of the Provider used by this container */
  public String getProviderName() {
<span class="nc" id="L99">    return this.providerName;</span>
  }

  /** @return a reference to the KeyStore for this container */
  public CachingKeyStoreWrapper getKeyStore() {
<span class="fc" id="L104">    return this.keyStore;</span>
  }

  /**
   * @param alias Alias
   * @param key Key
   * @param chain Chain
   * @throws KeyStoreException On fail
   */
  public void setKeyEntry(
          final String alias,
          final Key key,
          final Certificate[] chain)
      throws KeyStoreException {
    // Removal of old key is only needed for sun-p11 with none ASCII chars in
    // the alias.
    // But it makes no harm to always do it and it should be fast.
    // If not done the entry will not be stored correctly in the p11 KeyStore.
<span class="fc" id="L122">    getKeyStore().deleteEntry(alias);</span>
<span class="fc" id="L123">    getKeyStore().setKeyEntry(alias, key, null, chain);</span>
<span class="fc" id="L124">  }</span>

  private void deleteAlias(final String alias) throws KeyStoreException {
<span class="fc" id="L127">    getKeyStore().deleteEntry(alias);</span>
<span class="fc" id="L128">  }</span>
  /**
   * Deletes an entry in the keystore.
   *
   * @param alias is a reference to the entry in the KeyStore that should be
   *     deleted, if alias is null, all entries are deleted.
   * @throws KeyStoreException on error
   */
  public void deleteEntry(final String alias) throws KeyStoreException {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">    if (alias != null) {</span>
<span class="fc" id="L138">      deleteAlias(alias);</span>
<span class="fc" id="L139">      return;</span>
    }
<span class="nc" id="L141">    final Enumeration&lt;String&gt; e = getKeyStore().aliases();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    while (e.hasMoreElements()) {</span>
<span class="nc" id="L143">      final String str = e.nextElement();</span>
<span class="nc" id="L144">      deleteAlias(str);</span>
<span class="nc" id="L145">    }</span>
<span class="nc" id="L146">  }</span>
  /**
   * Rename the alias of an entry. This has just been tested on pkcs#11
   * keystores. On other keystore it might be that you will get two aliases for
   * the same key (copy). But on p11 we know that the oldAlias is not existing
   * after the method is called.
   *
   * @param oldAlias is the current name
   * @param newAlias is the new name
   */
  public void renameEntry(final String oldAlias, final String newAlias) {
    // only one key with same public part (certificate) is existing on a p11
    // token. this has been tested.
    try {
<span class="nc" id="L160">      getKeyStore()</span>
<span class="nc" id="L161">          .setEntry(newAlias, getKeyStore().getEntry(oldAlias, null), null);</span>
<span class="nc" id="L162">    } catch (KeyStoreException</span>
        | NoSuchAlgorithmException
        | UnrecoverableEntryException e) {
<span class="nc" id="L165">      throw new KeyUtilRuntimeException(&quot;Renaming entry failed.&quot;, e);</span>
<span class="nc" id="L166">    }</span>
<span class="nc" id="L167">  }</span>

  private class CertificateSignOperation implements ISignOperation {
    /** Key. */
    private final PrivateKey privateKey;
    /** Builder.*/
    private final X509v3CertificateBuilder certificateBuilder;
    /** Result. */
    private X509CertificateHolder result;

    CertificateSignOperation(
<span class="fc" id="L178">        final PrivateKey pk, final X509v3CertificateBuilder cb) {</span>
<span class="fc" id="L179">      this.privateKey = pk;</span>
<span class="fc" id="L180">      this.certificateBuilder = cb;</span>
<span class="fc" id="L181">    }</span>

    @SuppressWarnings(&quot;synthetic-access&quot;)
    @Override
    public void taskWithSigning(final String sigAlg, final Provider provider)
        throws TaskWithSigningException {
<span class="fc" id="L187">      LOG.debug(&quot;Keystore signing algorithm &quot; + sigAlg);</span>
      final ContentSigner signer;
<span class="fc" id="L189">      final int bufferSize = 20480;</span>
      try {
<span class="fc" id="L191">        signer =</span>
            new BufferingContentSigner(
                new JcaContentSignerBuilder(sigAlg)
<span class="fc" id="L194">                    .setProvider(provider.getName())</span>
<span class="fc" id="L195">                    .build(this.privateKey),</span>
                bufferSize);
<span class="nc" id="L197">      } catch (OperatorCreationException e) {</span>
<span class="nc" id="L198">        throw new TaskWithSigningException(</span>
<span class="nc" id="L199">            String.format(&quot;Signing certificate failed: %s&quot;, e.getMessage()), e);</span>
<span class="fc" id="L200">      }</span>
<span class="fc" id="L201">      this.result = this.certificateBuilder.build(signer);</span>
<span class="fc" id="L202">    }</span>

    public X509CertificateHolder getResult() {
<span class="fc" id="L205">      return this.result;</span>
    }
  }

  private X509Certificate getSelfCertificate(
      final String myname,
      final long validity,
      final List&lt;String&gt; sigAlgs,
      final KeyPair keyPair)
      throws InvalidKeyException, CertificateException {
<span class="fc" id="L215">    final long currentTime = new Date().getTime();</span>
<span class="fc" id="L216">    final Date firstDate = new Date(currentTime - 24 * 60 * 60 * 1000);</span>
<span class="fc" id="L217">    final Date lastDate = new Date(currentTime + validity * 1000);</span>
<span class="fc" id="L218">    final X500Name issuer = new X500Name(myname);</span>
<span class="fc" id="L219">    final BigInteger serno = BigInteger.valueOf(firstDate.getTime());</span>
<span class="fc" id="L220">    final PublicKey publicKey = keyPair.getPublic();</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">    if (publicKey == null) {</span>
<span class="nc" id="L222">      throw new InvalidKeyException(&quot;Public key is null&quot;);</span>
    }

    try {
<span class="fc" id="L226">      final X509v3CertificateBuilder cb =</span>
          new JcaX509v3CertificateBuilder(
              issuer, serno, firstDate, lastDate, issuer, publicKey);
<span class="fc" id="L229">      final CertificateSignOperation cso =</span>
<span class="fc" id="L230">          new CertificateSignOperation(keyPair.getPrivate(), cb);</span>
<span class="fc" id="L231">      SignWithWorkingAlgorithm.doSignTask(sigAlgs, this.providerName, cso);</span>
<span class="fc" id="L232">      final X509CertificateHolder cert = cso.getResult();</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">      if (cert == null) {</span>
<span class="nc" id="L234">        throw new CertificateException(&quot;Self signing of certificate failed.&quot;);</span>
      }
<span class="fc" id="L236">      return CertTools.getCertfromByteArray(</span>
<span class="fc" id="L237">          cert.getEncoded(), X509Certificate.class);</span>
<span class="nc" id="L238">    } catch (TaskWithSigningException e) {</span>
<span class="nc" id="L239">      LOG.error(&quot;Error creating content signer: &quot;, e);</span>
<span class="nc" id="L240">      throw new CertificateException(e);</span>
<span class="nc" id="L241">    } catch (IOException e) {</span>
<span class="nc" id="L242">      throw new CertificateException(&quot;Could not read certificate&quot;, e);</span>
<span class="nc" id="L243">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L244">      throw new CertificateException(</span>
<span class="nc" id="L245">          String.format(&quot;Provider '%s' does not exist.&quot;, this.providerName), e);</span>
    }
  }

  private void generateEC(final String ecNamedCurveBc, final String keyAlias)
      throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L252">      LOG.trace(</span>
          &quot;&gt;generate EC: curve name &quot;
              + ecNamedCurveBc
              + &quot;, keyEntryName &quot;
              + keyAlias);
    }
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">    if (StringUtils.contains(</span>
<span class="fc" id="L259">        Security.getProvider(this.providerName).getClass().getName(), &quot;iaik&quot;)) {</span>
<span class="nc" id="L260">      throw new InvalidAlgorithmParameterException(</span>
          &quot;IAIK ECC key generation not implemented.&quot;);
    }
    final AlgorithmParameterSpec keyParams;
<span class="fc bfc" id="L264" title="All 2 branches covered.">    if (StringUtils.equals(ecNamedCurveBc, &quot;implicitlyCA&quot;)) {</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L266">        LOG.debug(&quot;Generating implicitlyCA encoded ECDSA key pair&quot;);</span>
      }
      // If the keySpec is null, we have &quot;implicitlyCA&quot; defined EC parameters
      // The parameters were already installed when we installed the provider
      // We just make sure that ecSpec == null here
<span class="fc" id="L271">      keyParams = null;</span>
    } else {
      // Convert it to the OID if possible since the human friendly name might
      // differ in the provider
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">      if (ECUtil.getNamedCurveOid(ecNamedCurveBc) != null) {</span>
<span class="fc" id="L276">        final String oidOrName =</span>
<span class="fc" id="L277">            AlgorithmTools.getEcKeySpecOidFromBcName(ecNamedCurveBc);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L279">          LOG.debug(</span>
              &quot;keySpecification '&quot;
                  + ecNamedCurveBc
                  + &quot;' transformed into OID &quot;
                  + oidOrName);
        }
<span class="fc" id="L285">        keyParams = new ECGenParameterSpec(oidOrName);</span>
<span class="fc" id="L286">      } else {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L288">          LOG.debug(</span>
              &quot;Curve did not have an OID in BC, trying to pick up Parameter&quot;
                  + &quot; spec: &quot;
                  + ecNamedCurveBc);
        }
        // This may be a new curve without OID, like curve25519 and we have to
        // do something a bit different
<span class="nc" id="L295">        X9ECParameters ecP = CustomNamedCurves.getByName(ecNamedCurveBc);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (ecP == null) {</span>
<span class="nc" id="L297">          throw new InvalidAlgorithmParameterException(</span>
              &quot;Can not generate EC curve, no OID and no ECParameters found: &quot;
                  + ecNamedCurveBc);
        }
<span class="nc" id="L301">        keyParams =</span>
            new org.bouncycastle.jce.spec.ECParameterSpec(
<span class="nc" id="L303">                ecP.getCurve(),</span>
<span class="nc" id="L304">                ecP.getG(),</span>
<span class="nc" id="L305">                ecP.getN(),</span>
<span class="nc" id="L306">                ecP.getH(),</span>
<span class="nc" id="L307">                ecP.getSeed());</span>
      }
    }
    try {
<span class="fc" id="L311">      generateKeyPair(</span>
          keyParams,
          keyAlias,
          AlgorithmConstants.KEYALGORITHM_EC,
          AlgorithmTools.SIG_ALGS_ECDSA);
<span class="nc" id="L316">    } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L317">      LOG.debug(&quot;EC name &quot; + ecNamedCurveBc + &quot; not supported.&quot;);</span>
<span class="nc" id="L318">      throw e;</span>
<span class="fc" id="L319">    }</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L321">      LOG.trace(</span>
          &quot;&lt;generate: curve name &quot;
              + ecNamedCurveBc
              + &quot;, keyEntryName &quot;
              + keyAlias);
    }
<span class="fc" id="L327">  }</span>

  private void generateExtraEC(
      final String name,
      final String keyAlias,
      final String keyAlgorithm,
      final List&lt;String&gt; sigAlgNames)
      throws InvalidAlgorithmParameterException {
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L336">      LOG.trace(</span>
          &quot;&gt;generate &quot;
              + keyAlgorithm
              + &quot;: curve name &quot;
              + name
              + &quot;, keyEntryName &quot;
              + keyAlias);
    }
    // Generate the EC Keypair
<span class="nc" id="L345">    final ECGenParameterSpec keyParams = new ECGenParameterSpec(name);</span>
    try {
<span class="nc" id="L347">      generateKeyPair(keyParams, keyAlias, keyAlgorithm, sigAlgNames);</span>
<span class="nc" id="L348">    } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L349">      LOG.debug(&quot;EC &quot; + keyAlgorithm + &quot; name &quot; + name + &quot; not supported.&quot;);</span>
<span class="nc" id="L350">      throw e;</span>
<span class="nc" id="L351">    }</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L353">      LOG.trace(&quot;&lt;generate: curve name &quot; + name + &quot;, keyEntryName &quot; + keyAlias);</span>
    }
<span class="nc" id="L355">  }</span>

  private void generateGOST3410(final String name, final String keyEntryName)
      throws InvalidAlgorithmParameterException {
<span class="nc" id="L359">    generateExtraEC(</span>
        name,
        keyEntryName,
        AlgorithmConstants.KEYALGORITHM_ECGOST3410,
        AlgorithmTools.SIG_ALGS_ECGOST3410);
<span class="nc" id="L364">  }</span>

  private void generateDSTU4145(final String name, final String keyEntryName)
      throws InvalidAlgorithmParameterException {
<span class="nc" id="L368">    generateExtraEC(</span>
        name,
        keyEntryName,
        AlgorithmConstants.KEYALGORITHM_DSTU4145,
        AlgorithmTools.SIG_ALGS_DSTU4145);
<span class="nc" id="L373">  }</span>

  private void generateRSA(final int keySize, final String keyEntryName)
      throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L378">      LOG.trace(</span>
          &quot;&gt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyEntryName);
    }
<span class="fc" id="L381">    generateKeyPair(</span>
        new SizeAlgorithmParameterSpec(keySize),
        keyEntryName,
        AlgorithmConstants.KEYALGORITHM_RSA,
        AlgorithmTools.SIG_ALGS_RSA);
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L387">      LOG.trace(</span>
          &quot;&lt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyEntryName);
    }
<span class="fc" id="L390">  }</span>

  private void generateDSA(final int keySize, final String keyAlias)
      throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L395">      LOG.trace(&quot;&gt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyAlias);</span>
    }
    // Generate the RSA Keypair
    final KeyPairGenerator kpg;
    try {
<span class="fc" id="L400">      kpg = KeyPairGenerator.getInstance(&quot;DSA&quot;, this.providerName);</span>
<span class="nc" id="L401">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L402">      throw new IllegalStateException(</span>
          &quot;Algorithm &quot; + &quot;DSA&quot; + &quot; was not recognized.&quot;, e);
<span class="nc" id="L404">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L405">      throw new IllegalStateException(</span>
          &quot;BouncyCastle was not found as a provider.&quot;, e);
<span class="fc" id="L407">    }</span>
<span class="fc" id="L408">    kpg.initialize(keySize);</span>
<span class="fc" id="L409">    generateKeyPair(</span>
        new SizeAlgorithmParameterSpec(keySize),
        keyAlias,
        AlgorithmConstants.KEYALGORITHM_DSA,
        AlgorithmTools.SIG_ALGS_DSA);
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L415">      LOG.trace(&quot;&lt;generate: keySize &quot; + keySize + &quot;, keyEntryName &quot; + keyAlias);</span>
    }
<span class="fc" id="L417">  }</span>

  /**
   * Generates asymmteric keys in the Keystore token.
   *
   * @param keySpec all decimal digits RSA key length, otherwise name of ECC
   *     curve or DSA key using syntax DSAnnnn
   * @param keyEntryName entry name
   * @throws InvalidAlgorithmParameterException if invalid params apssed
   */
  public void generateKeyPair(final String keySpec, final String keyEntryName)
      throws InvalidAlgorithmParameterException {
<span class="fc" id="L429">    final int startPos = 3;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">    if (keySpec.toUpperCase().startsWith(&quot;DSA&quot;)) {</span>
<span class="fc" id="L431">      generateDSA(Integer.parseInt(keySpec.substring(startPos)</span>
<span class="fc" id="L432">              .trim()), keyEntryName);</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">    } else if (AlgorithmTools.isGost3410Enabled()</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        &amp;&amp; keySpec.startsWith(AlgorithmConstants.KEYSPECPREFIX_ECGOST3410)) {</span>
<span class="nc" id="L435">      generateGOST3410(keySpec, keyEntryName);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">    } else if (AlgorithmTools.isDstu4145Enabled()</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        &amp;&amp; keySpec.startsWith(CesecoreConfiguration.getOidDstu4145() + &quot;.&quot;)) {</span>
<span class="nc" id="L438">      generateDSTU4145(keySpec, keyEntryName);</span>
    } else {

      try {
<span class="fc" id="L442">        generateRSA(Integer.parseInt(keySpec.trim()), keyEntryName);</span>
<span class="fc" id="L443">      } catch (NumberFormatException e) {</span>
<span class="fc" id="L444">        generateEC(keySpec, keyEntryName);</span>
<span class="fc" id="L445">      }</span>
    }
<span class="fc" id="L447">  }</span>

  /**
   * Generates symmetric keys in the Keystore token.
   *
   * @param algorithm symmetric algorithm specified in
   *     http://download.oracle.com/javase/1.5.0/docs/api/index.html, suggest
   *     AES, DESede or DES
   * @param keysize keysize of symmetric key, suggest 128 or 256 for AES, 64 for
   *     168 for DESede and 64 for DES
   * @param keyEntryName the alias the key will get in the keystore
   * @throws NoSuchProviderException if provider not found
   * @throws NoSuchAlgorithmException of algo not found
   * @throws KeyStoreException if store fails
   */
  public void generateKey(
      final String algorithm, final int keysize, final String keyEntryName)
      throws NoSuchAlgorithmException, NoSuchProviderException,
          KeyStoreException {
<span class="nc" id="L466">    final KeyGenerator generator =</span>
<span class="nc" id="L467">        KeyGenerator.getInstance(algorithm, this.providerName);</span>
<span class="nc" id="L468">    generator.init(keysize);</span>
<span class="nc" id="L469">    final Key key = generator.generateKey();</span>
<span class="nc" id="L470">    setKeyEntry(keyEntryName, key, null);</span>
<span class="nc" id="L471">  }</span>

  /**
   * Generates keys in the Keystore token.
   *
   * @param keyParams AlgorithmParameterSpec for the KeyPairGenerator. Can be
   *     anything like RSAKeyGenParameterSpec, DSAParameterSpec, ECParameterSpec
   *     or ECGenParameterSpec.
   * @param keyAlias Alias
   * @throws InvalidAlgorithmParameterException if params are invalid
   */
  public void generateKeyPair(
      final AlgorithmParameterSpec keyParams, final String keyAlias)
      throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L486">      LOG.trace(</span>
          &quot;&gt;generate from AlgorithmParameterSpec: &quot;
<span class="nc" id="L488">              + keyParams.getClass().getName());</span>
    }
    // Generate the Keypair
    final String keyAlgorithm;
    final List&lt;String&gt; certSignAlgorithms;
<span class="fc" id="L493">    final String specName = keyParams.getClass().getName();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">    if (specName.contains(AlgorithmConstants.KEYALGORITHM_DSA)) {</span>
<span class="fc" id="L495">      keyAlgorithm = AlgorithmConstants.KEYALGORITHM_DSA;</span>
<span class="fc" id="L496">      certSignAlgorithms = AlgorithmTools.SIG_ALGS_DSA;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">    } else if (specName.contains(AlgorithmConstants.KEYALGORITHM_RSA)) {</span>
<span class="fc" id="L498">      keyAlgorithm = AlgorithmConstants.KEYALGORITHM_RSA;</span>
<span class="fc" id="L499">      certSignAlgorithms = AlgorithmTools.SIG_ALGS_RSA;</span>
    } else {
<span class="fc" id="L501">      keyAlgorithm = AlgorithmConstants.KEYALGORITHM_EC;</span>
<span class="fc" id="L502">      certSignAlgorithms = AlgorithmTools.SIG_ALGS_ECDSA;</span>
    }
<span class="fc" id="L504">    generateKeyPair(keyParams, keyAlias, keyAlgorithm, certSignAlgorithms);</span>
<span class="fc" id="L505">  }</span>

  private class SizeAlgorithmParameterSpec implements AlgorithmParameterSpec {
      /** size. */
    private final int keySize;

<span class="fc" id="L511">    SizeAlgorithmParameterSpec(final int aKeySize) {</span>
<span class="fc" id="L512">      this.keySize = aKeySize;</span>
<span class="fc" id="L513">    }</span>
  }

  private void generateKeyPair(
      final AlgorithmParameterSpec keyParams,
      final String keyAlias,
      final String keyAlgorithm,
      final List&lt;String&gt; certSignAlgorithms)
      throws InvalidAlgorithmParameterException {
<span class="fc" id="L522">    final int maxRetries = 3;</span>
    final KeyPairGenerator kpg;
    try {
<span class="fc" id="L525">      kpg = KeyPairGenerator.getInstance(keyAlgorithm, this.providerName);</span>
<span class="nc" id="L526">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L527">      throw new IllegalStateException(</span>
          &quot;Algorithm &quot; + keyAlgorithm + &quot; was not recognized.&quot;, e);
<span class="nc" id="L529">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L530">      throw new IllegalStateException(</span>
          this.providerName + &quot; was not found as a provider.&quot;, e);
<span class="fc" id="L532">    }</span>
    try {
<span class="fc bfc" id="L534" title="All 2 branches covered.">      if (keyParams instanceof SizeAlgorithmParameterSpec) {</span>
<span class="fc" id="L535">        kpg.initialize(((SizeAlgorithmParameterSpec) keyParams).keySize);</span>
      } else {
<span class="fc" id="L537">        kpg.initialize(keyParams);</span>
      }
<span class="nc" id="L539">    } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L540">      LOG.debug(&quot;Algorithm parameters not supported: &quot; + e.getMessage());</span>
<span class="nc" id="L541">      throw e;</span>
<span class="fc" id="L542">    }</span>
    // We will make a loop to retry key generation here. Using the IAIK provider
    // it seems to give
    // CKR_OBJECT_HANDLE_INVALID about every second time we try to store keys
    // But if we try again it succeeds
<span class="fc" id="L547">    int bar = 0;</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">    while (bar &lt; maxRetries) {</span>
      try {
<span class="fc" id="L550">        LOG.debug(&quot;generating...&quot;);</span>
<span class="fc" id="L551">        final KeyPair keyPair = kpg.generateKeyPair();</span>
<span class="fc" id="L552">        final X509Certificate selfSignedCert =</span>
<span class="fc" id="L553">            getSelfCertificate(</span>
                &quot;CN=Dummy certificate created by a CESeCore application&quot;,
                (long) 30 * 24 * 60 * 60 * 365,
                certSignAlgorithms,
                keyPair);
<span class="fc" id="L558">        final X509Certificate[] chain = new X509Certificate[] {selfSignedCert};</span>
<span class="fc" id="L559">        LOG.debug(&quot;Creating certificate with entry &quot; + keyAlias + '.');</span>
<span class="fc" id="L560">        setKeyEntry(keyAlias, keyPair.getPrivate(), chain);</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">        if (CesecoreConfiguration.makeKeyUnmodifiableAfterGeneration()) {</span>
<span class="nc" id="L562">          PKCS11Utils.getInstance()</span>
<span class="nc" id="L563">              .makeKeyUnmodifiable(keyPair.getPrivate(), this.providerName);</span>
        }
<span class="fc" id="L565">        break; // success no need to try more</span>
<span class="nc" id="L566">      } catch (KeyStoreException e) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (bar &lt; maxRetries) {</span>
<span class="nc" id="L568">          LOG.info(</span>
              &quot;Failed to generate or store new key, will try 3 times. This was&quot;
                  + &quot; try: &quot;
                  + bar,
              e);
        } else {
<span class="nc" id="L574">          throw new KeyCreationException(&quot;Signing failed.&quot;, e);</span>
        }
<span class="nc" id="L576">      } catch (CertificateException e) {</span>
<span class="nc" id="L577">        throw new KeyCreationException(</span>
            &quot;Can't create keystore because dummy certificate chain creation&quot;
                + &quot; failed.&quot;,
            e);
<span class="nc" id="L581">      } catch (InvalidKeyException e) {</span>
<span class="nc" id="L582">        throw new KeyCreationException(</span>
            &quot;Dummy certificate chain was created with an invalid key&quot;, e);
<span class="nc" id="L584">      }</span>
<span class="nc" id="L585">      bar++;</span>
    }
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L588">      LOG.trace(</span>
          &quot;&lt;generate from AlgorithmParameterSpec: &quot;
<span class="nc bnc" id="L590" title="All 2 branches missed.">              + (keyParams != null ? keyParams.getClass().getName() : &quot;null&quot;));</span>
    }
<span class="fc" id="L592">  }</span>

  private class SignCsrOperation implements ISignOperation {
     /** Alias. */
      private final String alias;
    /** DN. */
    private final String sDN;
    /** Params. */
    private final boolean explicitEccParameters;
    /** Key. */
    private final PublicKey publicKeyTmp;
    /** Request. */
    private PKCS10CertificationRequest certReq;

   SignCsrOperation(
        final String anAlias,
        final String aSDN,
        final boolean aExplicitEccParameters,
<span class="nc" id="L610">        final PublicKey publicKey) {</span>
<span class="nc" id="L611">      this.alias = anAlias;</span>
<span class="nc" id="L612">      this.sDN = aSDN;</span>
<span class="nc" id="L613">      this.explicitEccParameters = aExplicitEccParameters;</span>
<span class="nc" id="L614">      this.certReq = null;</span>
<span class="nc" id="L615">      this.publicKeyTmp = publicKey;</span>
<span class="nc" id="L616">    }</span>

    @SuppressWarnings(&quot;synthetic-access&quot;)
    private void signCSR(final String signAlgorithm, final Provider provider)
        throws NoSuchAlgorithmException, NoSuchProviderException,
            UnrecoverableKeyException, KeyStoreException,
            OperatorCreationException, TaskWithSigningException {
      final PublicKey publicKey;
<span class="nc bnc" id="L624" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L625">        LOG.debug(</span>
<span class="nc" id="L626">            String.format(</span>
                &quot;alias: %s SHA1 of public key: %s&quot;,
                this.alias,
<span class="nc" id="L629">                CertTools.getFingerprintAsString(</span>
<span class="nc" id="L630">                    this.publicKeyTmp.getEncoded())));</span>
      }
<span class="nc bnc" id="L632" title="All 4 branches missed.">      if (signAlgorithm.contains(&quot;ECDSA&quot;) &amp;&amp; this.explicitEccParameters) {</span>
<span class="nc" id="L633">        LOG.info(&quot;Using explicit parameter encoding for ECC key.&quot;);</span>
<span class="nc" id="L634">        publicKey =</span>
<span class="nc" id="L635">            ECKeyUtil.publicToExplicitParameters(this.publicKeyTmp, &quot;BC&quot;);</span>
      } else {
<span class="nc" id="L637">        LOG.info(&quot;Using named curve parameter encoding for ECC key.&quot;);</span>
<span class="nc" id="L638">        publicKey = this.publicKeyTmp;</span>
      }
<span class="nc" id="L640">      final PrivateKey privateKey = getPrivateKey(this.alias);</span>
      final X500Name sDNName =
<span class="nc bnc" id="L642" title="All 2 branches missed.">          this.sDN != null</span>
<span class="nc" id="L643">              ? new X500Name(this.sDN)</span>
<span class="nc" id="L644">              : new X500Name(&quot;CN=&quot; + this.alias);</span>
<span class="nc" id="L645">      this.certReq =</span>
<span class="nc" id="L646">          CertTools.genPKCS10CertificationRequest(</span>
              signAlgorithm,
              sDNName,
              publicKey,
              new DERSet(),
              privateKey,
<span class="nc" id="L652">              provider.getName());</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">      if (this.certReq == null) {</span>
<span class="nc" id="L654">        throw new TaskWithSigningException(&quot;Not possible to sign CSR.&quot;);</span>
      }
<span class="nc" id="L656">    }</span>

    @Override
    public void taskWithSigning(
        final String signAlgorithm, final Provider provider)
        throws TaskWithSigningException {
      try {
<span class="nc" id="L663">        signCSR(signAlgorithm, provider);</span>
<span class="nc" id="L664">      } catch (TaskWithSigningException e) {</span>
<span class="nc" id="L665">        throw e;</span>
<span class="nc" id="L666">      } catch (OperatorCreationException</span>
          | UnrecoverableKeyException
          | NoSuchAlgorithmException
          | NoSuchProviderException
          | KeyStoreException e) {
<span class="nc" id="L671">        throw new TaskWithSigningException(</span>
<span class="nc" id="L672">            String.format(&quot;Not possible to sign CSR: %s&quot;, e.getMessage()), e);</span>
<span class="nc" id="L673">      }</span>
<span class="nc" id="L674">    }</span>

    public PKCS10CertificationRequest getResult() {
<span class="nc" id="L677">      return this.certReq;</span>
    }
  }
  /**
   * Generates a certificate request (CSR) in PKCS#10 format and writes to file.
   *
   * @param alias for the key to be used
   * @param sDN the DN to be used. If null the 'CN=alias' will be used
   * @param explicitEccParameters false should be default and will use
   *     NamedCurve encoding of ECC public keys (IETF recommendation), use true
   *     to include all parameters explicitly (ICAO ePassport requirement).
   */
  public void generateCertReq(
      final String alias,
      final String sDN,
      final boolean explicitEccParameters) {
    try {
<span class="nc" id="L694">      final PublicKey publicKey = getCertificate(alias).getPublicKey();</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L696">        LOG.debug(</span>
            &quot;alias: &quot;
                + alias
                + &quot; SHA1 of public key: &quot;
<span class="nc" id="L700">                + CertTools.getFingerprintAsString(publicKey.getEncoded()));</span>
      }
      // Candidate algorithms. The first working one will be selected by
      // SignWithWorkingAlgorithm
<span class="nc" id="L704">      final List&lt;String&gt; sigAlg =</span>
<span class="nc" id="L705">          AlgorithmTools.getSignatureAlgorithms(publicKey);</span>
<span class="nc" id="L706">      final SignCsrOperation operation =</span>
          new SignCsrOperation(alias, sDN, explicitEccParameters, publicKey);
<span class="nc" id="L708">      SignWithWorkingAlgorithm.doSignTask(sigAlg, this.providerName, operation);</span>
<span class="nc" id="L709">      final PKCS10CertificationRequest certReq = operation.getResult();</span>
<span class="nc" id="L710">      final ContentVerifierProvider verifier =</span>
<span class="nc" id="L711">          CertTools.genContentVerifierProvider(publicKey);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">      if (!certReq.isSignatureValid(verifier)) {</span>
<span class="nc" id="L713">        final String msg =</span>
<span class="nc" id="L714">            INTRES.getLocalizedMessage(&quot;token.errorcertreqverify&quot;, alias);</span>
<span class="nc" id="L715">        throw new KeyUtilRuntimeException(msg);</span>
      }
<span class="nc" id="L717">      final String filename = alias + &quot;.pem&quot;;</span>

<span class="nc" id="L719">      try (OutputStream os = new FileOutputStream(filename)) {</span>
<span class="nc" id="L720">        os.write(CertTools.getPEMFromCertificateRequest(certReq.getEncoded()));</span>
      }
<span class="nc" id="L722">      LOG.info(&quot;Wrote csr to file: &quot; + filename);</span>
<span class="nc" id="L723">    } catch (KeyStoreException</span>
        | NoSuchProviderException
        | TaskWithSigningException
        | OperatorCreationException
        | PKCSException
        | IOException e) {
<span class="nc" id="L729">      throw new KeyUtilRuntimeException(</span>
          &quot;Failed to generate a certificate request.&quot;, e);
<span class="nc" id="L731">    }</span>
<span class="nc" id="L732">  }</span>

  /**
   * Install certificate chain to key in keystore.
   *
   * @param fileName name of the file with chain. Starting with the certificate
   *     of the key. Ending with the root certificate.
   */
  public void installCertificate(final String fileName) {
<span class="nc" id="L741">    try (InputStream is = new FileInputStream(fileName)) {</span>
      final X509Certificate[] chain;
<span class="nc" id="L743">      chain =</span>
<span class="nc" id="L744">          CertTools.getCertsFromPEM(is, X509Certificate.class)</span>
<span class="nc" id="L745">              .toArray(new X509Certificate[0]);</span>
<span class="nc" id="L746">      final PublicKey importPublicKey = chain[0].getPublicKey();</span>
<span class="nc" id="L747">      final String importKeyHash =</span>
<span class="nc" id="L748">          CertTools.getFingerprintAsString(importPublicKey.getEncoded());</span>
<span class="nc" id="L749">      final Enumeration&lt;String&gt; eAlias = getKeyStore().aliases();</span>
<span class="nc" id="L750">      boolean notFound = true;</span>
<span class="nc bnc" id="L751" title="All 4 branches missed.">      while (eAlias.hasMoreElements() &amp;&amp; notFound) {</span>
<span class="nc" id="L752">        final String alias = eAlias.nextElement();</span>
<span class="nc" id="L753">        final PublicKey hsmPublicKey = getCertificate(alias).getPublicKey();</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L755">          LOG.debug(</span>
              &quot;alias: &quot;
                  + alias
                  + &quot; SHA1 of public hsm key: &quot;
<span class="nc" id="L759">                  + CertTools.getFingerprintAsString(hsmPublicKey.getEncoded())</span>
                  + &quot; SHA1 of first public key in chain: &quot;
                  + importKeyHash
<span class="nc bnc" id="L762" title="All 2 branches missed.">                  + (chain.length == 1</span>
<span class="nc" id="L763">                      ? &quot;&quot;</span>
<span class="nc" id="L764">                      : (&quot;SHA1 of last public key in chain: &quot;</span>
<span class="nc" id="L765">                          + CertTools.getFingerprintAsString(</span>
                              chain[chain.length - 1]
<span class="nc" id="L767">                                  .getPublicKey()</span>
<span class="nc" id="L768">                                  .getEncoded()))));</span>
        }
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (hsmPublicKey.equals(importPublicKey)) {</span>
<span class="nc" id="L771">          LOG.info(&quot;Found a matching public key for alias \&quot;&quot; + alias + &quot;\&quot;.&quot;);</span>
<span class="nc" id="L772">          getKeyStore().setKeyEntry(alias, getPrivateKey(alias), null, chain);</span>
<span class="nc" id="L773">          notFound = false;</span>
        }
<span class="nc" id="L775">      }</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">      if (notFound) {</span>
<span class="nc" id="L777">        final String msg =</span>
<span class="nc" id="L778">            INTRES.getLocalizedMessage(&quot;token.errorkeynottoken&quot;, importKeyHash);</span>
<span class="nc" id="L779">        throw new KeyUtilRuntimeException(msg);</span>
      }
<span class="nc" id="L781">    } catch (IOException</span>
        | CertificateParsingException
        | KeyStoreException
        | UnrecoverableKeyException
        | NoSuchAlgorithmException e) {
<span class="nc" id="L786">      throw new KeyUtilRuntimeException(</span>
          &quot;Failed to install cert chain into keystore.&quot;, e);
<span class="nc" id="L788">    }</span>
<span class="nc" id="L789">  }</span>

  /**
   * Install trusted root in trust store.
   *
   * @param fileName name of the trusted root.
   */
  public void installTrustedRoot(final String fileName) {
<span class="nc" id="L797">    try (InputStream is = new FileInputStream(fileName)) {</span>
<span class="nc" id="L798">      final List&lt;Certificate&gt; chain =</span>
<span class="nc" id="L799">          CertTools.getCertsFromPEM(is, Certificate.class);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">      if (chain.size() &lt; 1) {</span>
<span class="nc" id="L801">        throw new KeyUtilRuntimeException(&quot;No certificate in file&quot;);</span>
      }
      // assume last cert in chain is root if more than 1
<span class="nc" id="L804">      getKeyStore().setCertificateEntry(&quot;trusted&quot;, chain.get(chain.size() - 1));</span>
<span class="nc" id="L805">    } catch (IOException | CertificateParsingException | KeyStoreException e) {</span>
<span class="nc" id="L806">      throw new KeyUtilRuntimeException(</span>
          &quot;Failing to install trusted certificate.&quot;, e);
<span class="nc" id="L808">    }</span>
<span class="nc" id="L809">  }</span>

  private PrivateKey getPrivateKey(final String alias)
      throws UnrecoverableKeyException, KeyStoreException,
          NoSuchAlgorithmException {
<span class="nc" id="L814">    final PrivateKey key = (PrivateKey) getKey(alias);</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">    if (key == null) {</span>
<span class="nc" id="L816">      String msg = INTRES.getLocalizedMessage(&quot;token.errornokeyalias&quot;, alias);</span>
<span class="nc" id="L817">      LOG.info(msg);</span>
    }
<span class="nc" id="L819">    return key;</span>
  }

  private Key getKey(final String alias)
      throws UnrecoverableKeyException, KeyStoreException,
          NoSuchAlgorithmException {
<span class="nc" id="L825">    return getKeyStore().getKey(alias, null);</span>
  }

  private X509Certificate getCertificate(final String alias)
      throws KeyStoreException {
<span class="nc" id="L830">    final X509Certificate cert =</span>
<span class="nc" id="L831">        (X509Certificate) this.keyStore.getCertificate(alias);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L833">      String msg = INTRES.getLocalizedMessage(&quot;token.errornocertalias&quot;, alias);</span>
<span class="nc" id="L834">      LOG.info(msg);</span>
    }
<span class="nc" id="L836">    return cert;</span>
  }

  /**
   * Encodes a Keystore to a byte array.
   *
   * @param keyStore the keystore.
   * @param password the password.
   * @return the keystore encoded as byte array.
   */
  public static byte[] getAsByteArray(
      final KeyStore keyStore, final String password) {
<span class="nc" id="L848">    try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
<span class="nc" id="L849">      keyStore.store(outputStream, password.toCharArray());</span>
<span class="nc" id="L850">      return outputStream.toByteArray();</span>
<span class="nc" id="L851">    } catch (IOException</span>
        | KeyStoreException
        | NoSuchAlgorithmException
        | CertificateException e) {
<span class="nc" id="L855">      LOG.error(e); // should never happen if keyStore is valid object</span>
    }
<span class="nc" id="L857">    return null;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>