<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyTools.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.util</a> &gt; <span class="el_source">KeyTools.java</span></div><h1>KeyTools.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.util;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.Signature;
import java.security.SignatureException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.security.interfaces.DSAParams;
import java.security.interfaces.DSAPrivateKey;
import java.security.interfaces.DSAPublicKey;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.DSAParameterSpec;
import java.security.spec.ECFieldFp;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.ECParameterSpec;
import java.security.spec.ECPoint;
import java.security.spec.EllipticCurve;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAKeyGenParameterSpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.List;
import javax.crypto.interfaces.DHPrivateKey;
import javax.crypto.interfaces.DHPublicKey;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERBMPString;
import org.bouncycastle.asn1.DERBitString;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.SubjectKeyIdentifier;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.x9.X9ECParameters;
import org.bouncycastle.cert.X509ExtensionUtils;
import org.bouncycastle.cert.bc.BcX509ExtensionUtils;
import org.bouncycastle.crypto.ec.CustomNamedCurves;
import org.bouncycastle.crypto.util.PublicKeyFactory;
import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;
import org.bouncycastle.jcajce.provider.asymmetric.util.EC5Util;
import org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;
import org.bouncycastle.jce.ECGOST3410NamedCurveTable;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.provider.JCEECPublicKey;
import org.bouncycastle.jce.spec.ECNamedCurveSpec;
import org.bouncycastle.jce.spec.ECPublicKeySpec;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.openssl.jcajce.JcaPEMWriter;
import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequest;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;
import org.cesecore.util.Base64;
import org.cesecore.util.CertTools;
import org.cesecore.util.CryptoProviderTools;
import org.ejbca.cvc.PublicKeyEC;

/**
 * Tools to handle common key and keystore operations.
 *
 * @version $Id: KeyTools.java 29338 2018-06-26 05:55:57Z samuellb $
 */
public final class KeyTools {
    /** Logger. */
<span class="fc" id="L117">  private static final Logger LOG = Logger.getLogger(KeyTools.class);</span>
  /** Resource. */
  private static final InternalResources INTRES =
<span class="fc" id="L120">      InternalResources.getInstance();</span>
  /** Attrs. */
<span class="fc" id="L122">  private static final byte[] BAG_ATTRIBUTES = &quot;Bag Attributes\n&quot;.getBytes();</span>
  /** Name. */
<span class="fc" id="L124">  private static final byte[] FRIENDLY_NAME = &quot;    friendlyName: &quot;.getBytes();</span>
  /** Subject. */
<span class="fc" id="L126">  private static final byte[] SUBJECT_ATTRIBUTE = &quot;subject=/&quot;.getBytes();</span>
  /** Issuer. */
<span class="fc" id="L128">  private static final byte[] ISSUER_ATTRIBUTE = &quot;issuer=/&quot;.getBytes();</span>
  /** Cert start. */
<span class="fc" id="L130">  private static final byte[] BEGIN_CERTIFICATE =</span>
<span class="fc" id="L131">      &quot;-----BEGIN CERTIFICATE-----&quot;.getBytes();</span>
  /** Cert end. */
<span class="fc" id="L133">  private static final byte[] END_CERTIFICATE =</span>
<span class="fc" id="L134">      &quot;-----END CERTIFICATE-----&quot;.getBytes();</span>
  /** Key start. */
<span class="fc" id="L136">  private static final byte[] BEGIN_PRIVATE_KEY =</span>
<span class="fc" id="L137">      &quot;-----BEGIN PRIVATE KEY-----&quot;.getBytes();</span>
  /** Key end. */
<span class="fc" id="L139">  private static final byte[] END_PRIVATE_KEY =</span>
<span class="fc" id="L140">      &quot;-----END PRIVATE KEY-----&quot;.getBytes();</span>
  /** Newline. */
<span class="fc" id="L142">  private static final byte[] NL = &quot;\n&quot;.getBytes();</span>

  /** Prevent from creating new KeyTools object. */
  private KeyTools() {
    // should never be called
  }

  /**
   * Generates a keypair.
   *
   * @param keySpec string specification of keys to generate, typical value is
   *     2048 for RSA keys, 1024 for DSA keys, secp256r1 for ECDSA keys, or null
   *     if algspec is to be used.
   * @param algSpec AlgorithmParameterSpec of keys to generate, typically an
   *     EXParameterSpec for EC keys, or null if keySpec is to be used.
   * @param keyAlg algorithm of keys to generate, typical value is RSA, DSA or
   *     ECDSA, see AlgorithmConstants.KEYALGORITHM_XX
   * @see org.cesecore.certificates.util.AlgorithmConstants
   * @see org.bouncycastle.asn1.x9.X962NamedCurves
   * @see org.bouncycastle.asn1.nist.NISTNamedCurves
   * @see org.bouncycastle.asn1.sec.SECNamedCurves
   * @return KeyPair the generated keypair
   * @throws InvalidAlgorithmParameterException if the given parameters are
   *     inappropriate for this key pair generator.
   * @see org.cesecore.certificates.util.AlgorithmConstants#KEYALGORITHM_RSA
   */
  public static KeyPair genKeys(
      final String keySpec,
      final AlgorithmParameterSpec algSpec,
      final String keyAlg)
      throws InvalidAlgorithmParameterException {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L174">      LOG.trace(&quot;&gt;genKeys(&quot; + keySpec + &quot;, &quot; + keyAlg + &quot;)&quot;);</span>
    }

    final KeyPairGenerator keygen;
    try {
<span class="fc" id="L179">      keygen =</span>
<span class="fc" id="L180">          KeyPairGenerator.getInstance(</span>
              keyAlg, BouncyCastleProvider.PROVIDER_NAME);
<span class="nc" id="L182">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L183">      throw new IllegalStateException(</span>
          &quot;Algorithm &quot; + keyAlg + &quot; was not recognized.&quot;, e);
<span class="nc" id="L185">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L186">      throw new IllegalStateException(</span>
          &quot;BouncyCastle was not found as a provider.&quot;, e);
<span class="fc" id="L188">    }</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">    if (StringUtils.equals(keyAlg, AlgorithmConstants.KEYALGORITHM_ECDSA)</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        || StringUtils.equals(keyAlg, AlgorithmConstants.KEYALGORITHM_EC)) {</span>
<span class="fc bfc" id="L191" title="All 4 branches covered.">      if ((keySpec != null) &amp;&amp; !StringUtils.equals(keySpec, &quot;implicitlyCA&quot;)) {</span>
<span class="fc" id="L192">        LOG.debug(&quot;Generating named curve ECDSA key pair: &quot; + keySpec);</span>
        // Check if we have an OID for this named curve
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (ECUtil.getNamedCurveOid(keySpec) != null) {</span>
<span class="fc" id="L195">          ECGenParameterSpec bcSpec = new ECGenParameterSpec(keySpec);</span>
<span class="fc" id="L196">          keygen.initialize(bcSpec, new SecureRandom());</span>
<span class="fc" id="L197">        } else {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L199">            LOG.debug(</span>
                &quot;Curve did not have an OID in BC, trying to pick up Parameter&quot;
                    + &quot; spec: &quot;
                    + keySpec);
          }
          // This may be a new curve without OID, like curve25519 and we have to
          // do something a bit different
<span class="fc" id="L206">          X9ECParameters ecP = CustomNamedCurves.getByName(keySpec);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">          if (ecP == null) {</span>
<span class="fc" id="L208">            throw new InvalidAlgorithmParameterException(</span>
                &quot;Can not generate EC curve, no OID and no ECParameters found: &quot;
                    + keySpec);
          }
<span class="nc" id="L212">          org.bouncycastle.jce.spec.ECParameterSpec ecSpec =</span>
              new org.bouncycastle.jce.spec.ECParameterSpec(
<span class="nc" id="L214">                  ecP.getCurve(),</span>
<span class="nc" id="L215">                  ecP.getG(),</span>
<span class="nc" id="L216">                  ecP.getN(),</span>
<span class="nc" id="L217">                  ecP.getH(),</span>
<span class="nc" id="L218">                  ecP.getSeed());</span>
<span class="nc" id="L219">          keygen.initialize(ecSpec, new SecureRandom());</span>
<span class="nc" id="L220">        }</span>
        // The old code should work in BC v1.50b6 and later, but in versions
        // prior to that the below produces a key with explicit parameter
        // encoding instead of named curves.
        // There is a test for this in KeyToolsTest.testGenKeysECDSAx9
        //                ecSpec = ECNamedCurveTable.getParameterSpec(keySpec);
        //                if (ecSpec == null) {
        //                    throw new
        // InvalidAlgorithmParameterException(&quot;keySpec &quot; + keySpec + &quot; is
        // invalid for ECDSA.&quot;);
        //                }
        //                keygen.initialize(ecSpec, new SecureRandom());
<span class="fc bfc" id="L232" title="All 2 branches covered.">      } else if (algSpec != null) {</span>
<span class="fc" id="L233">        LOG.debug(</span>
            &quot;Generating ECDSA key pair from AlgorithmParameterSpec: &quot;
                + algSpec);
<span class="fc" id="L236">        keygen.initialize(algSpec, new SecureRandom());</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">      } else if (StringUtils.equals(keySpec, &quot;implicitlyCA&quot;)) {</span>
<span class="fc" id="L238">        LOG.debug(&quot;Generating implicitlyCA encoded ECDSA key pair&quot;);</span>
        // If the keySpec is null, we have &quot;implicitlyCA&quot; defined EC parameters
        // The parameters were already installed when we installed the provider
        // We just make sure that ecSpec == null here
<span class="fc" id="L242">        keygen.initialize(null, new SecureRandom());</span>
      } else {
<span class="fc" id="L244">        throw new InvalidAlgorithmParameterException(</span>
            &quot;No keySpec no algSpec and no implicitlyCA specified&quot;);
      }
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">    } else if (keyAlg.equals(AlgorithmConstants.KEYALGORITHM_ECGOST3410)) {</span>
      final AlgorithmParameterSpec ecSpec;
<span class="nc bnc" id="L249" title="All 2 branches missed.">      if (keySpec != null) {</span>
<span class="nc" id="L250">        LOG.debug(&quot;Generating keys from given key specifications : &quot; + keySpec);</span>
<span class="nc" id="L251">        ecSpec = ECGOST3410NamedCurveTable.getParameterSpec(keySpec);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (ecSpec == null) {</span>
<span class="nc" id="L253">          throw new InvalidAlgorithmParameterException(</span>
              &quot;Key specification &quot; + keySpec + &quot; is invalid for ECGOST3410&quot;);
          }
<span class="nc bnc" id="L256" title="All 2 branches missed.">      } else if (algSpec != null) {</span>
<span class="nc" id="L257">        LOG.debug(</span>
            &quot;Generating keys from given algorithm parameters : &quot; + algSpec);
<span class="nc" id="L259">        ecSpec = algSpec;</span>
      } else {
<span class="nc" id="L261">        throw new InvalidAlgorithmParameterException(</span>
            &quot;No key or algorithm specifications&quot;);
      }
<span class="nc" id="L264">      keygen.initialize(ecSpec, new SecureRandom());</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">    } else if (keyAlg.equals(AlgorithmConstants.KEYALGORITHM_DSTU4145)) {</span>
      final AlgorithmParameterSpec ecSpec;
<span class="nc bnc" id="L267" title="All 2 branches missed.">      if (keySpec != null) {</span>
<span class="nc" id="L268">        LOG.debug(&quot;Generating keys from given key specifications : &quot; + keySpec);</span>
<span class="nc" id="L269">        ecSpec = dstuOidToAlgoParams(keySpec);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (ecSpec == null) {</span>
<span class="nc" id="L271">          throw new InvalidAlgorithmParameterException(</span>
              &quot;Key specification &quot; + keySpec + &quot; is invalid for DSTU4145&quot;);
          }
<span class="nc bnc" id="L274" title="All 2 branches missed.">      } else if (algSpec != null) {</span>
<span class="nc" id="L275">        LOG.debug(</span>
            &quot;Generating keys from given algorithm parameters : &quot; + algSpec);
<span class="nc" id="L277">        ecSpec = algSpec;</span>
      } else {
<span class="nc" id="L279">        throw new InvalidAlgorithmParameterException(</span>
            &quot;No key or algorithm specifications&quot;);
      }
<span class="nc" id="L282">      keygen.initialize(ecSpec, new SecureRandom());</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">    } else if (keySpec.startsWith(&quot;DSA&quot;)) {</span>
      // DSA key with &quot;DSA&quot; in keyspec
<span class="nc" id="L285">      final int keysize = Integer.parseInt(keySpec.substring(3));</span>
<span class="nc" id="L286">      keygen.initialize(keysize);</span>
<span class="nc" id="L287">    } else {</span>
      // RSA or DSA key where keyspec is simply the key length
<span class="fc" id="L289">      final int keysize = Integer.parseInt(keySpec);</span>
<span class="fc" id="L290">      keygen.initialize(keysize);</span>
    }

<span class="fc" id="L293">    final KeyPair keys = keygen.generateKeyPair();</span>

<span class="pc bpc" id="L295" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L296">      final PublicKey pk = keys.getPublic();</span>
<span class="nc" id="L297">      final int len = getKeyLength(pk);</span>
<span class="nc" id="L298">      LOG.debug(</span>
          &quot;Generated &quot;
<span class="nc" id="L300">              + keys.getPublic().getAlgorithm()</span>
              + &quot; keys with length &quot;
              + len);
    }
<span class="fc" id="L304">    LOG.trace(&quot;&lt;genKeys()&quot;);</span>
<span class="fc" id="L305">    return keys;</span>
  } // genKeys

  /**
   * @param keySpec Spec
   * @param keyAlg Algorithm
   * @return Key pair
   * @see KeyTools#genKeys(String,AlgorithmParameterSpec,String)
   * @throws InvalidAlgorithmParameterException if the given parameters are
   *     inappropriate for this key pair generator.
   */
  public static KeyPair genKeys(final String keySpec, final String keyAlg)
      throws InvalidAlgorithmParameterException {
<span class="fc" id="L318">    return genKeys(keySpec, null, keyAlg);</span>
  }

  /**
   * An ECDSA key can be stripped of the curve parameters so it only contains
   * the public point, and this is not enough to use the key for verification.
   * However, if we know the curve name we can fill in the curve parameters and
   * get a usable EC public key
   *
   * @param pk PublicKey, org.ejbca.cvc.PublicKeyEC, that might miss parameters,
   *     if parameters are there we do not touch the public key just return it
   *     unchanged
   * @param keySpec name of curve for example brainpoolp224r1
   * @return PublicKey with parameters from the named curve
   * @throws NoSuchProviderException if provider not found
   * @throws NoSuchAlgorithmException if algorithm not found
   * @throws InvalidKeySpecException if spec is invalid
   */
  public static PublicKey getECPublicKeyWithParams(
      final PublicKey pk, final String keySpec)
      throws NoSuchAlgorithmException, NoSuchProviderException,
          InvalidKeySpecException {
<span class="fc" id="L340">    PublicKey ret = pk;</span>
<span class="pc bpc" id="L341" title="1 of 4 branches missed.">    if ((pk instanceof PublicKeyEC) &amp;&amp; (keySpec != null)) {</span>
<span class="fc" id="L342">      final PublicKeyEC pkec = (PublicKeyEC) pk;</span>
      // The public key of IS and DV certificate do not have any parameters so
      // we have to do some magic to get a complete EC public key
<span class="fc" id="L345">      final ECParameterSpec spec = pkec.getParams();</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">      if (spec == null) {</span>
        // we did not have the parameter specs, lets create them because we know
        // which curve we are using
<span class="fc" id="L349">        final org.bouncycastle.jce.spec.ECParameterSpec bcspec =</span>
<span class="fc" id="L350">            ECNamedCurveTable.getParameterSpec(keySpec);</span>
<span class="fc" id="L351">        final java.security.spec.ECPoint p = pkec.getW();</span>
<span class="fc" id="L352">        final org.bouncycastle.math.ec.ECPoint ecp =</span>
<span class="fc" id="L353">            EC5Util.convertPoint(bcspec.getCurve(), p, false);</span>
<span class="fc" id="L354">        final ECPublicKeySpec pubKey = new ECPublicKeySpec(ecp, bcspec);</span>
<span class="fc" id="L355">        final KeyFactory keyfact = KeyFactory.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);</span>
<span class="fc" id="L356">        ret = keyfact.generatePublic(pubKey);</span>
      }
    }
<span class="fc" id="L359">    return ret;</span>
  }
  /**
   * An ECDSA key can be stripped of the curve parameters so it only contains
   * the public point, and this is not enough to use the key for verification.
   * However, if we know the curve name we can fill in the curve parameters and
   * get a usable EC public key
   *
   * @param pk PublicKey, org.ejbca.cvc.PublicKeyEC, that might miss parameters,
   *     if parameters are there we do not touch the public key just return it
   *     unchanged
   * @param pkwithparams PublicKey, org.ejbca.cvc.PublicKeyEC, that contains all
   *     parameters.
   * @return PublicKey with parameters from the named curve
   * @throws InvalidKeySpecException if the key specification in pkwithparams
   *     was invalid
   */
  public static PublicKey getECPublicKeyWithParams(
      final PublicKey pk, final PublicKey pkwithparams)
      throws InvalidKeySpecException {
<span class="pc bpc" id="L379" title="1 of 4 branches missed.">    if (!(pk instanceof PublicKeyEC)</span>
        || !(pkwithparams instanceof PublicKeyEC)) {
<span class="fc" id="L381">      LOG.info(</span>
          &quot;Either pk or pkwithparams is not a PublicKeyEC: &quot;
<span class="fc" id="L383">              + pk.toString()</span>
              + &quot;, &quot;
<span class="fc" id="L385">              + pkwithparams.toString());</span>
<span class="fc" id="L386">      return pk;</span>
    }
<span class="fc" id="L388">    final PublicKeyEC pkec = (PublicKeyEC) pk;</span>
<span class="fc" id="L389">    final ECParameterSpec spec = pkec.getParams();</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">    if (spec != null) {</span>
<span class="nc" id="L391">      return pk; // the key allready has its parameters.</span>
    }
    // The public key of IS and DV certificate do not have any parameters so we
    // have to do some magic to get a complete EC public key
<span class="fc" id="L395">    final PublicKeyEC pkecp = (PublicKeyEC) pkwithparams;</span>
<span class="fc" id="L396">    final ECParameterSpec pkspec = pkecp.getParams();</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">    if (pkspec == null) {</span>
<span class="fc" id="L398">      LOG.info(&quot;pkwithparams does not have any params.&quot;);</span>
<span class="fc" id="L399">      return pk;</span>
    }
<span class="fc" id="L401">    final org.bouncycastle.jce.spec.ECParameterSpec bcspec =</span>
<span class="fc" id="L402">        EC5Util.convertSpec(pkspec, false);</span>
<span class="fc" id="L403">    final java.security.spec.ECPoint p = pkec.getW();</span>
<span class="fc" id="L404">    final org.bouncycastle.math.ec.ECPoint ecp =</span>
<span class="fc" id="L405">        EC5Util.convertPoint(pkspec, p, false);</span>
<span class="fc" id="L406">    final ECPublicKeySpec pubKey = new ECPublicKeySpec(ecp, bcspec);</span>
    final KeyFactory keyfact;
    try {
<span class="fc" id="L409">      keyfact =</span>
<span class="fc" id="L410">          KeyFactory.getInstance(&quot;ECDSA&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="nc" id="L411">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L412">      throw new IllegalStateException(&quot;ECDSA was an unknown algorithm&quot;, e);</span>
<span class="nc" id="L413">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L414">      throw new IllegalStateException(</span>
          &quot;BouncyCastle was not found as a provider.&quot;, e);
<span class="fc" id="L416">    }</span>
<span class="fc" id="L417">    return keyfact.generatePublic(pubKey);</span>
  }

  /**
   * Gets the key length of supported keys.
   *
   * @param pk PublicKey used to derive the keysize
   * @return -1 if key is unsupported, otherwise a number &amp;gt;= 0. 0 usually
   *     means the length can not be calculated, for example if the key is an EC
   *     key and the &quot;implicitlyCA&quot; encoding is used.
   */
  public static int getKeyLength(final PublicKey pk) {
<span class="fc bfc" id="L429" title="All 2 branches covered.">    if (pk instanceof RSAPublicKey) {</span>
<span class="fc" id="L430">      final RSAPublicKey rsapub = (RSAPublicKey) pk;</span>
<span class="fc" id="L431">      return rsapub.getModulus().bitLength();</span>
    }
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">    if (pk instanceof JCEECPublicKey) {</span>
<span class="nc" id="L434">      final JCEECPublicKey ecpriv = (JCEECPublicKey) pk;</span>
<span class="nc" id="L435">      final org.bouncycastle.jce.spec.ECParameterSpec spec =</span>
<span class="nc" id="L436">          ecpriv.getParameters();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">      if (spec != null) {</span>
<span class="nc" id="L438">        return spec.getN().bitLength();</span>
      }
      // We support the key, but we don't know the key length
<span class="nc" id="L441">      return 0;</span>
    }
<span class="fc bfc" id="L443" title="All 2 branches covered.">    if (pk instanceof BCECPublicKey) {</span>
<span class="fc" id="L444">      final BCECPublicKey ecpriv = (BCECPublicKey) pk;</span>
<span class="fc" id="L445">      final org.bouncycastle.jce.spec.ECParameterSpec spec =</span>
<span class="fc" id="L446">          ecpriv.getParameters();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">      if (spec != null) {</span>
<span class="fc" id="L448">        return spec.getN().bitLength();</span>
      }
      // We support the key, but we don't know the key length
<span class="fc" id="L451">      return 0;</span>
    }
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">    if (pk instanceof ECPublicKey) {</span>
<span class="nc" id="L454">      final ECPublicKey ecpriv = (ECPublicKey) pk;</span>
<span class="nc" id="L455">      final java.security.spec.ECParameterSpec spec = ecpriv.getParams();</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">      if (spec != null) {</span>
<span class="nc" id="L457">        return spec.getOrder()</span>
<span class="nc" id="L458">            .bitLength(); // does this really return something we expect?</span>
      }
      // We support the key, but we don't know the key length
<span class="nc" id="L461">      return 0;</span>
    }
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">    if (pk instanceof DSAPublicKey) {</span>
<span class="fc" id="L464">      final DSAPublicKey dsapub = (DSAPublicKey) pk;</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">      if (dsapub.getParams() != null) {</span>
<span class="fc" id="L466">        return dsapub.getParams().getP().bitLength();</span>
      }
<span class="nc" id="L468">      return dsapub.getY().bitLength();</span>
    }
    // Unknown key type
<span class="nc" id="L471">    return -1;</span>
  }

  /**
   * Gets the key AlgorithmParameterSpec of supported keys. Can be used to
   * initialize a KeyPairGenerator to generate a key of equal type and size.
   *
   * @param pk PublicKey used to derive the AlgorithmParameterSpec
   * @return null if key is unsupported or pk is null, otherwise a
   *     AlgorithmParameterSpec.
   */
  public static AlgorithmParameterSpec getKeyGenSpec(final PublicKey pk) {
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (pk == null) {</span>
<span class="nc" id="L484">      return null;</span>
    }
<span class="fc bfc" id="L486" title="All 2 branches covered.">    if (pk instanceof RSAPublicKey) {</span>
<span class="fc" id="L487">      LOG.debug(&quot;getKeyGenSpec: RSA&quot;);</span>
<span class="fc" id="L488">      final RSAPublicKey rpk = (RSAPublicKey) pk;</span>
<span class="fc" id="L489">      return new RSAKeyGenParameterSpec(</span>
<span class="fc" id="L490">          getKeyLength(pk), rpk.getPublicExponent());</span>
    }
<span class="fc bfc" id="L492" title="All 2 branches covered.">    if (pk instanceof DSAPublicKey) {</span>
<span class="fc" id="L493">      LOG.debug(&quot;getKeyGenSpec: DSA&quot;);</span>
<span class="fc" id="L494">      final DSAPublicKey dpk = (DSAPublicKey) pk;</span>
<span class="fc" id="L495">      final DSAParams params = dpk.getParams();</span>
<span class="fc" id="L496">      return new DSAParameterSpec(params.getP(), params.getQ(), params.getG());</span>
    }
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">    if (pk instanceof ECPublicKey) {</span>
<span class="fc" id="L499">      LOG.debug(&quot;getKeyGenSpec: ECPublicKey&quot;);</span>
<span class="fc" id="L500">      final ECPublicKey ecpub = (ECPublicKey) pk;</span>
<span class="fc" id="L501">      final java.security.spec.ECParameterSpec sunsp = ecpub.getParams();</span>
<span class="fc" id="L502">      final EllipticCurve ecurve =</span>
          new EllipticCurve(
<span class="fc" id="L504">              sunsp.getCurve().getField(),</span>
<span class="fc" id="L505">              sunsp.getCurve().getA(),</span>
<span class="fc" id="L506">              sunsp.getCurve().getB());</span>
      // ECParameterSpec par = new ECNamedCurveSpec(null, sunsp.getCurve(),
      // sunsp.getGenerator(), sunsp.getOrder(),
      // BigInteger.valueOf(sunsp.getCofactor()));
<span class="fc" id="L510">      final ECParameterSpec params =</span>
          new ECParameterSpec(
              ecurve,
<span class="fc" id="L513">              sunsp.getGenerator(),</span>
<span class="fc" id="L514">              sunsp.getOrder(),</span>
<span class="fc" id="L515">              sunsp.getCofactor());</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L517">        LOG.debug(&quot;Fieldsize: &quot; + params.getCurve().getField().getFieldSize());</span>
<span class="nc" id="L518">        final EllipticCurve curve = params.getCurve();</span>
<span class="nc" id="L519">        LOG.debug(&quot;CurveA: &quot; + curve.getA().toString(16));</span>
<span class="nc" id="L520">        LOG.debug(&quot;CurveB: &quot; + curve.getB().toString(16));</span>
<span class="nc" id="L521">        LOG.debug(&quot;CurveSeed: &quot; + curve.getSeed());</span>
<span class="nc" id="L522">        final ECFieldFp field = (ECFieldFp) curve.getField();</span>
<span class="nc" id="L523">        LOG.debug(&quot;CurveSfield: &quot; + field.getP().toString(16));</span>
<span class="nc" id="L524">        final ECPoint p = params.getGenerator();</span>
<span class="nc" id="L525">        LOG.debug(</span>
            &quot;Generator: &quot;
<span class="nc" id="L527">                + p.getAffineX().toString(16)</span>
                + &quot;, &quot;
<span class="nc" id="L529">                + p.getAffineY().toString(16));</span>
<span class="nc" id="L530">        LOG.debug(&quot;Order: &quot; + params.getOrder().toString(16));</span>
<span class="nc" id="L531">        LOG.debug(&quot;CoFactor: &quot; + params.getCofactor());</span>
      }
<span class="fc" id="L533">      return params;</span>
    }
<span class="nc bnc" id="L535" title="All 2 branches missed.">    if (pk instanceof JCEECPublicKey) {</span>
<span class="nc" id="L536">      LOG.debug(&quot;getKeyGenSpec: JCEECPublicKey&quot;);</span>
<span class="nc" id="L537">      final JCEECPublicKey ecpub = (JCEECPublicKey) pk;</span>
<span class="nc" id="L538">      final org.bouncycastle.jce.spec.ECParameterSpec bcsp =</span>
<span class="nc" id="L539">          ecpub.getParameters();</span>
<span class="nc" id="L540">      final ECCurve curve = bcsp.getCurve();</span>
      // TODO: this probably does not work for key generation with the Sun
      // PKCS#11 provider. Maybe seed needs to be set to null as above? Or
      // something else, the BC curve is it the same?
<span class="nc" id="L544">      final ECParameterSpec params =</span>
          new ECNamedCurveSpec(
<span class="nc" id="L546">              null, curve, bcsp.getG(), bcsp.getN(), bcsp.getH());</span>
<span class="nc" id="L547">      return params;</span>
      // EllipticCurve ecc = new EllipticCurve(curve.)
      // ECParameterSpec sp = new ECParameterSpec(, bcsp.getG(), bcsp.getN(),
      // bcsp.getH().intValue());
    }
<span class="nc" id="L552">    return null;</span>
  }

  /**
   * Creates PKCS12-file that can be imported in IE or Firefox. The alias for
   * the private key is set to 'privateKey' and the private key password is
   * null.
   *
   * @param alias the alias used for the key entry
   * @param privKey RSA private key
   * @param cert user certificate
   * @param cacert CA-certificate or null if only one cert in chain, in that
   *     case use 'cert'.
   * @return KeyStore containing PKCS12-keystore
   * @throws CertificateException if the certificate couldn't be parsed
   * @throws CertificateEncodingException if the encoded bytestream of the
   *     certificate couldn't be retrieved
   * @throws NoSuchAlgorithmException if the algorithm defined in privKey
   *     couldn't be found
   * @throws InvalidKeySpecException if the key specification defined in privKey
   *     couldn't be found
   */
  public static KeyStore createP12(
      final String alias,
      final PrivateKey privKey,
      final Certificate cert,
      final Certificate cacert)
      throws CertificateException, NoSuchAlgorithmException,
          InvalidKeySpecException {
    final Certificate[] chain;

<span class="pc bpc" id="L583" title="1 of 2 branches missed.">    if (cacert == null) {</span>
<span class="fc" id="L584">      chain = null;</span>
    } else {
<span class="nc" id="L586">      chain = new Certificate[1];</span>
<span class="nc" id="L587">      chain[0] = cacert;</span>
    }

<span class="fc" id="L590">    return createP12(alias, privKey, cert, chain);</span>
  } // createP12

  /**
   * Creates PKCS12-file that can be imported in IE or Firefox. The alias for
   * the private key is set to 'privateKey' and the private key password is
   * null.
   *
   * @param alias the alias used for the key entry
   * @param privKey RSA private key
   * @param cert user certificate
   * @param cacerts Collection of X509Certificate, or null if only one cert in
   *     chain, in that case use 'cert'.
   * @return KeyStore containing PKCS12-keystore
   * @throws CertificateException if the certificate couldn't be parsed
   * @throws CertificateEncodingException if the encoded bytestream of the
   *     certificate couldn't be retrieved
   * @throws NoSuchAlgorithmException if the algorithm defined in privKey
   *     couldn't be found
   * @throws InvalidKeySpecException if the key specification defined in privKey
   *     couldn't be found
   */
  public static KeyStore createP12(
      final String alias,
      final PrivateKey privKey,
      final Certificate cert,
      final Collection&lt;Certificate&gt; cacerts)
      throws CertificateException, NoSuchAlgorithmException,
          InvalidKeySpecException {
    final Certificate[] chain;
<span class="nc bnc" id="L620" title="All 2 branches missed.">    if (cacerts == null) {</span>
<span class="nc" id="L621">      chain = null;</span>
    } else {
<span class="nc" id="L623">      chain = cacerts.toArray(new Certificate[cacerts.size()]);</span>
    }
<span class="nc" id="L625">    return createP12(alias, privKey, cert, chain);</span>
  } // createP12

  /**
   * Creates PKCS12-file that can be imported in IE or Firefox. The alias for
   * the private key is set to 'privateKey' and the private key password is
   * null.
   *
   * @param alias the alias used for the key entry
   * @param privKey RSA private key
   * @param cert user certificate
   * @param cachain CA-certificate chain or null if only one cert in chain, in
   *     that case use 'cert'.
   * @return KeyStore containing PKCS12-keystore
   * @throws CertificateException if the certificate couldn't be parsed
   * @throws CertificateEncodingException if the encoded bytestream of the
   *     certificate couldn't be retrieved
   * @throws NoSuchAlgorithmException if the algorithm defined in privKey
   *     couldn't be found
   * @throws InvalidKeySpecException if the key specification defined in privKey
   *     couldn't be found
   */
  public static KeyStore createP12(
      final String alias,
      final PrivateKey privKey,
      final Certificate cert,
      final Certificate[] cachain)
      throws CertificateEncodingException, CertificateException,
          NoSuchAlgorithmException, InvalidKeySpecException {
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L655">      LOG.trace(</span>
          &quot;&gt;createP12: alias=&quot;
              + alias
              + &quot;, privKey, cert=&quot;
<span class="nc" id="L659">              + CertTools.getSubjectDN(cert)</span>
              + &quot;, cachain.length=&quot;
<span class="nc bnc" id="L661" title="All 2 branches missed.">              + ((cachain == null) ? 0 : cachain.length));</span>
    }
    // Certificate chain
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L665">      throw new IllegalArgumentException(&quot;Parameter cert cannot be null.&quot;);</span>
    }
<span class="fc" id="L667">    int len = 1;</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">    if (cachain != null) {</span>
<span class="nc" id="L669">      len += cachain.length;</span>
    }
<span class="fc" id="L671">    final Certificate[] chain = new Certificate[len];</span>
    // To not get a ClassCastException we need to generate a real new
    // certificate with BC
<span class="fc" id="L674">    final CertificateFactory cf = CertTools.getCertificateFactory();</span>
<span class="fc" id="L675">    chain[0] =</span>
<span class="fc" id="L676">        cf.generateCertificate(new ByteArrayInputStream(cert.getEncoded()));</span>

<span class="pc bpc" id="L678" title="1 of 2 branches missed.">    if (cachain != null) {</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">      for (int i = 0; i &lt; cachain.length; i++) {</span>
<span class="nc" id="L680">        final X509Certificate tmpcert =</span>
            (X509Certificate)
<span class="nc" id="L682">                cf.generateCertificate(</span>
<span class="nc" id="L683">                    new ByteArrayInputStream(cachain[i].getEncoded()));</span>
<span class="nc" id="L684">        chain[i + 1] = tmpcert;</span>
      }
    }
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">    if (chain.length &gt; 1) {</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">      for (int i = 1; i &lt; chain.length; i++) {</span>
<span class="nc" id="L689">        final X509Certificate cacert =</span>
            (X509Certificate)
<span class="nc" id="L691">                cf.generateCertificate(</span>
<span class="nc" id="L692">                    new ByteArrayInputStream(chain[i].getEncoded()));</span>
        // Set attributes on CA-cert
        try {
<span class="nc" id="L695">          final PKCS12BagAttributeCarrier caBagAttr =</span>
              (PKCS12BagAttributeCarrier) chain[i];
          // We construct a friendly name for the CA, and try with some parts
          // from the DN if they exist.
<span class="nc" id="L699">          String cafriendly =</span>
<span class="nc" id="L700">              CertTools.getPartFromDN(CertTools.getSubjectDN(cacert), &quot;CN&quot;);</span>
          // On the ones below we +i to make it unique, O might not be otherwise
<span class="nc bnc" id="L702" title="All 2 branches missed.">          if (cafriendly == null) {</span>
<span class="nc" id="L703">            cafriendly =</span>
<span class="nc" id="L704">                CertTools.getPartFromDN(CertTools.getSubjectDN(cacert), &quot;O&quot;);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            if (cafriendly == null) {</span>
<span class="nc" id="L706">              cafriendly =</span>
<span class="nc" id="L707">                  CertTools.getPartFromDN(CertTools.getSubjectDN(cacert), &quot;OU&quot;);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">              if (cafriendly == null) {</span>
<span class="nc" id="L709">                cafriendly = &quot;CA_unknown&quot; + i;</span>
              } else {
<span class="nc" id="L711">                cafriendly = cafriendly + i;</span>
              }
            } else {
<span class="nc" id="L714">              cafriendly = cafriendly + i;</span>
            }
          }
<span class="nc" id="L717">          caBagAttr.setBagAttribute(</span>
              PKCSObjectIdentifiers.pkcs_9_at_friendlyName,
              new DERBMPString(cafriendly));
<span class="nc" id="L720">        } catch (ClassCastException e) {</span>
<span class="nc" id="L721">          LOG.error(</span>
              &quot;ClassCastException setting BagAttributes, can not set friendly&quot;
                  + &quot; name: &quot;,
              e);
<span class="nc" id="L725">        }</span>
      }
    }

    // Set attributes on user-cert
    try {
<span class="fc" id="L731">      final PKCS12BagAttributeCarrier certBagAttr =</span>
          (PKCS12BagAttributeCarrier) chain[0];
<span class="fc" id="L733">      certBagAttr.setBagAttribute(</span>
          PKCSObjectIdentifiers.pkcs_9_at_friendlyName,
          new DERBMPString(alias));
      // in this case we just set the local key id to that of the public key
<span class="fc" id="L737">      certBagAttr.setBagAttribute(</span>
          PKCSObjectIdentifiers.pkcs_9_at_localKeyId,
<span class="fc" id="L739">          createSubjectKeyId(chain[0].getPublicKey()));</span>
<span class="nc" id="L740">    } catch (ClassCastException e) {</span>
<span class="nc" id="L741">      LOG.error(</span>
          &quot;ClassCastException setting BagAttributes, can not set friendly&quot;
              + &quot; name: &quot;,
          e);
<span class="fc" id="L745">    }</span>
    try {
      // &quot;Clean&quot; private key, i.e. remove any old attributes
<span class="fc" id="L748">      final KeyFactory keyfact =</span>
<span class="fc" id="L749">          KeyFactory.getInstance(</span>
<span class="fc" id="L750">              privKey.getAlgorithm(), BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="fc" id="L751">      final PrivateKey pk =</span>
<span class="fc" id="L752">          keyfact.generatePrivate(</span>
<span class="fc" id="L753">              new PKCS8EncodedKeySpec(privKey.getEncoded()));</span>
      // Set attributes for private key
      try {
<span class="fc" id="L756">        final PKCS12BagAttributeCarrier keyBagAttr =</span>
            (PKCS12BagAttributeCarrier) pk;
        // in this case we just set the local key id to that of the public key
<span class="fc" id="L759">        keyBagAttr.setBagAttribute(</span>
            PKCSObjectIdentifiers.pkcs_9_at_friendlyName,
            new DERBMPString(alias));
<span class="fc" id="L762">        keyBagAttr.setBagAttribute(</span>
            PKCSObjectIdentifiers.pkcs_9_at_localKeyId,
<span class="fc" id="L764">            createSubjectKeyId(chain[0].getPublicKey()));</span>
<span class="nc" id="L765">      } catch (ClassCastException e) {</span>
<span class="nc" id="L766">        LOG.error(</span>
            &quot;ClassCastException setting BagAttributes, can not set friendly&quot;
                + &quot; name: &quot;,
            e);
<span class="fc" id="L770">      }</span>
      // store the key and the certificate chain
      // BC PKCS12 uses 3DES for key protection and 40 bit RC2 for protecting
      // the certificates
<span class="fc" id="L774">      final KeyStore store =</span>
<span class="fc" id="L775">          KeyStore.getInstance(&quot;PKCS12&quot;, BouncyCastleProvider.PROVIDER_NAME);</span>
<span class="fc" id="L776">      store.load(null, null);</span>
<span class="fc" id="L777">      store.setKeyEntry(alias, pk, null, chain);</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L779">        LOG.trace(</span>
            &quot;&lt;createP12: alias=&quot;
                + alias
                + &quot;, privKey, cert=&quot;
<span class="nc" id="L783">                + CertTools.getSubjectDN(cert)</span>
                + &quot;, cachain.length=&quot;
<span class="nc bnc" id="L785" title="All 2 branches missed.">                + ((cachain == null) ? 0 : cachain.length));</span>
      }
<span class="fc" id="L787">      return store;</span>
<span class="nc" id="L788">    } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L789">      throw new IllegalStateException(</span>
          &quot;BouncyCastle provider was not found.&quot;, e);
<span class="nc" id="L791">    } catch (KeyStoreException e) {</span>
<span class="nc" id="L792">      throw new IllegalStateException(</span>
          &quot;PKCS12 keystore type could not be instanced.&quot;, e);
<span class="nc" id="L794">    } catch (IOException e) {</span>
<span class="nc" id="L795">      throw new IllegalStateException(</span>
          &quot;IOException should not be thrown when instancing an empty keystore.&quot;,
          e);
    }
  } // createP12

  /**
   * Creates JKS-file that can be used with JDK. The alias for the private key
   * is set to 'privateKey' and the private key password is null.
   *
   * @param alias the alias used for the key entry
   * @param privKey RSA private key
   * @param password user's password
   * @param cert user certificate
   * @param cachain CA-certificate chain or null if only one cert in chain, in
   *     that case use 'cert'.
   * @return KeyStore containing JKS-keystore
   * @throws KeyStoreException is storing the certificate failed, perhaps
   *     because the alias is already being used?
   */
  public static KeyStore createJKS(
      final String alias,
      final PrivateKey privKey,
      final String password,
      final X509Certificate cert,
      final Certificate[] cachain)
      throws KeyStoreException {
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L823">      LOG.trace(</span>
          &quot;&gt;createJKS: alias=&quot;
              + alias
              + &quot;, privKey, cert=&quot;
<span class="nc" id="L827">              + CertTools.getSubjectDN(cert)</span>
              + &quot;, cachain.length=&quot;
<span class="nc bnc" id="L829" title="All 2 branches missed.">              + ((cachain == null) ? 0 : cachain.length));</span>
    }
<span class="fc" id="L831">    final String caAlias = &quot;cacert&quot;;</span>

    // Certificate chain
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">    if (cert == null) {</span>
<span class="nc" id="L835">      throw new IllegalArgumentException(&quot;Parameter cert cannot be null.&quot;);</span>
    }
<span class="fc" id="L837">    int len = 1;</span>
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">    if (cachain != null) {</span>
<span class="nc" id="L839">      len += cachain.length;</span>
    }
<span class="fc" id="L841">    final Certificate[] chain = new Certificate[len];</span>
<span class="fc" id="L842">    chain[0] = cert;</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">    if (cachain != null) {</span>
<span class="nc" id="L844">      System.arraycopy(cachain, 0, chain, 1, cachain.length);</span>
    }

    // store the key and the certificate chain
    final KeyStore store;
    try {
<span class="fc" id="L850">      store = KeyStore.getInstance(&quot;JKS&quot;);</span>
<span class="nc" id="L851">    } catch (KeyStoreException e) {</span>
<span class="nc" id="L852">      throw new IllegalStateException(</span>
          &quot;No JKS implementation found in provider&quot;, e);
<span class="fc" id="L854">    }</span>
    try {
<span class="fc" id="L856">      store.load(null, null);</span>
<span class="nc" id="L857">    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L858">      throw new IllegalStateException(e);</span>
<span class="nc" id="L859">    } catch (CertificateException e) {</span>
<span class="nc" id="L860">      throw new IllegalStateException(e);</span>
<span class="nc" id="L861">    } catch (IOException e) {</span>
<span class="nc" id="L862">      throw new IllegalStateException(e);</span>
<span class="fc" id="L863">    }</span>

    // First load the key entry
<span class="fc" id="L866">    final X509Certificate[] usercert = new X509Certificate[1];</span>
<span class="fc" id="L867">    usercert[0] = cert;</span>
    try {
<span class="fc" id="L869">      store.setKeyEntry(alias, privKey, password.toCharArray(), usercert);</span>
<span class="nc" id="L870">    } catch (KeyStoreException e) {</span>
<span class="nc" id="L871">      throw new IllegalStateException(</span>
          &quot;Keystore apparently hasn't been loaded?&quot;, e);
<span class="fc" id="L873">    }</span>

    // Add the root cert as trusted
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">    if (cachain != null) {</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">      if (!CertTools.isSelfSigned(cachain[cachain.length - 1])) {</span>
<span class="nc" id="L878">        throw new IllegalArgumentException(&quot;Root cert is not self-signed.&quot;);</span>
      }
<span class="nc" id="L880">      store.setCertificateEntry(caAlias, cachain[cachain.length - 1]);</span>
    }

    // Set the complete chain
<span class="fc" id="L884">    LOG.debug(&quot;Storing cert chain of length &quot; + chain.length);</span>
<span class="fc" id="L885">    store.setKeyEntry(alias, privKey, password.toCharArray(), chain);</span>
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L887">      LOG.trace(</span>
          &quot;&lt;createJKS: alias=&quot;
              + alias
              + &quot;, privKey, cert=&quot;
<span class="nc" id="L891">              + CertTools.getSubjectDN(cert)</span>
              + &quot;, cachain.length=&quot;
<span class="nc bnc" id="L893" title="All 2 branches missed.">              + ((cachain == null) ? 0 : cachain.length));</span>
    }
<span class="fc" id="L895">    return store;</span>
  } // createJKS

  /**
   * Generates KeyStore from key store byte array. Token type (JKS / P12) is
   * determined automatically by the byte array content
   *
   * @param keyStoreBytes byte array containing key store
   * @param password of the key store
   * @return JKS or P12 KeyStore depending of input content
   * @throws KeyStoreException If store fails
   * @throws NoSuchProviderException If provider not found
   * @throws IOException On I/O error
   * @throws NoSuchAlgorithmException If algorithm not found
   * @throws CertificateException on invalid certificate
   */
  public static KeyStore createKeyStore(
          final byte[] keyStoreBytes, final String password)
      throws KeyStoreException, NoSuchProviderException, IOException,
          NoSuchAlgorithmException, CertificateException {
<span class="nc" id="L915">    final byte pkcs12Magic = (byte) 48;</span>
<span class="nc" id="L916">    final byte jksMagic = (byte) (0xfe);</span>

    final KeyStore keyStore;
<span class="nc bnc" id="L919" title="All 2 branches missed.">    if (keyStoreBytes[0] == pkcs12Magic) {</span>
<span class="nc" id="L920">      keyStore = KeyStore.getInstance(&quot;PKCS12&quot;, &quot;BC&quot;);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">    } else if (keyStoreBytes[0] == jksMagic) {</span>
<span class="nc" id="L922">      keyStore = KeyStore.getInstance(&quot;JKS&quot;);</span>
    } else {
<span class="nc" id="L924">      throw new IOException(&quot;Unsupported keystore type. Must be PKCS12 or JKS&quot;);</span>
    }
<span class="nc" id="L926">    keyStore.load(</span>
<span class="nc" id="L927">        new ByteArrayInputStream(keyStoreBytes), password.toCharArray());</span>
<span class="nc" id="L928">    return keyStore;</span>
  }

  /**
   * Convert a KeyStore to PEM format.
   *
   * @param ks Key store
   * @param password password
   * @return PEM
   * @throws KeyStoreException if store fails
   * @throws CertificateEncodingException If cert cannot be parsed
   * @throws IOException on i/o error
   * @throws UnrecoverableKeyException if key cannot be read
   * @throws NoSuchAlgorithmException if algorithm not found
   */
  public static byte[] getSinglePemFromKeyStore(
      final KeyStore ks, final char[] password)
      throws KeyStoreException, CertificateEncodingException, IOException,
          UnrecoverableKeyException, NoSuchAlgorithmException {
<span class="fc" id="L947">    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span>

    // Find the key private key entry in the keystore
<span class="fc" id="L950">    final Enumeration&lt;String&gt; e = ks.aliases();</span>
<span class="fc" id="L951">    Object o = null;</span>
<span class="fc" id="L952">    String alias = &quot;&quot;;</span>
<span class="fc" id="L953">    PrivateKey serverPrivKey = null;</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">    while (e.hasMoreElements()) {</span>
<span class="fc" id="L955">      o = e.nextElement();</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">      if (o instanceof String) {</span>
<span class="fc" id="L957">        serverPrivKey = (PrivateKey) ks.getKey((String) o, password);</span>
<span class="pc bpc" id="L958" title="2 of 4 branches missed.">        if ((ks.isKeyEntry((String) o))</span>
            &amp;&amp; (serverPrivKey != null)) {
<span class="fc" id="L960">          alias = (String) o;</span>
<span class="fc" id="L961">          break;</span>
        }
      }
    }

    final byte[] privKeyEncoded =
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">        serverPrivKey != null ? serverPrivKey.getEncoded() : &quot;&quot;.getBytes();</span>

<span class="fc" id="L969">    final Certificate[] chain = KeyTools.getCertChain(ks, (String) o);</span>
<span class="fc" id="L970">    final X509Certificate userX509Certificate = (X509Certificate) chain[0];</span>

<span class="fc" id="L972">      final byte[] output = userX509Certificate.getEncoded();</span>
<span class="fc" id="L973">      String sn = CertTools.getSubjectDN(userX509Certificate);</span>

<span class="fc" id="L975">      String subjectdnpem = sn.replace(',', '/');</span>
<span class="fc" id="L976">      String issuerdnpem =</span>
<span class="fc" id="L977">          CertTools.getIssuerDN(userX509Certificate).replace(',', '/');</span>

<span class="fc" id="L979">      buffer.write(BAG_ATTRIBUTES);</span>
<span class="fc" id="L980">      buffer.write(FRIENDLY_NAME);</span>
<span class="fc" id="L981">      buffer.write(alias.getBytes());</span>
<span class="fc" id="L982">      buffer.write(NL);</span>
<span class="fc" id="L983">      buffer.write(BEGIN_PRIVATE_KEY);</span>
<span class="fc" id="L984">      buffer.write(NL);</span>

<span class="fc" id="L986">      final byte[] privKey = Base64.encode(privKeyEncoded);</span>
<span class="fc" id="L987">      buffer.write(privKey);</span>
<span class="fc" id="L988">      buffer.write(NL);</span>
<span class="fc" id="L989">      buffer.write(END_PRIVATE_KEY);</span>
<span class="fc" id="L990">      buffer.write(NL);</span>
<span class="fc" id="L991">      buffer.write(BAG_ATTRIBUTES);</span>
<span class="fc" id="L992">      buffer.write(FRIENDLY_NAME);</span>
<span class="fc" id="L993">      buffer.write(alias.getBytes());</span>
<span class="fc" id="L994">      buffer.write(NL);</span>
<span class="fc" id="L995">      buffer.write(SUBJECT_ATTRIBUTE);</span>
<span class="fc" id="L996">      buffer.write(subjectdnpem.getBytes());</span>
<span class="fc" id="L997">      buffer.write(NL);</span>
<span class="fc" id="L998">      buffer.write(ISSUER_ATTRIBUTE);</span>
<span class="fc" id="L999">      buffer.write(issuerdnpem.getBytes());</span>
<span class="fc" id="L1000">      buffer.write(NL);</span>
<span class="fc" id="L1001">      buffer.write(BEGIN_CERTIFICATE);</span>
<span class="fc" id="L1002">      buffer.write(NL);</span>

<span class="fc" id="L1004">      final byte[] userCertB64 = Base64.encode(output);</span>
<span class="fc" id="L1005">      buffer.write(userCertB64);</span>
<span class="fc" id="L1006">      buffer.write(NL);</span>
<span class="fc" id="L1007">      buffer.write(END_CERTIFICATE);</span>
<span class="fc" id="L1008">      buffer.write(NL);</span>

<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">    if (!CertTools.isSelfSigned(userX509Certificate)) {</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">      for (int num = 1; num &lt; chain.length; num++) {</span>
<span class="nc" id="L1012">        final X509Certificate tmpX509Cert = (X509Certificate) chain[num];</span>
<span class="nc" id="L1013">        sn = CertTools.getSubjectDN(tmpX509Cert);</span>

<span class="nc" id="L1015">        final String cnTmp = CertTools.getPartFromDN(sn, &quot;CN&quot;);</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        final String cn = StringUtils.isEmpty(cnTmp) ? cnTmp : &quot;Unknown&quot;;</span>

<span class="nc" id="L1018">        subjectdnpem = sn.replace(',', '/');</span>
<span class="nc" id="L1019">        issuerdnpem =</span>
<span class="nc" id="L1020">            CertTools.getIssuerDN(tmpX509Cert).replace(',', '/');</span>

<span class="nc" id="L1022">        buffer.write(BAG_ATTRIBUTES);</span>
<span class="nc" id="L1023">        buffer.write(FRIENDLY_NAME);</span>
<span class="nc" id="L1024">        buffer.write(cn.getBytes());</span>
<span class="nc" id="L1025">        buffer.write(NL);</span>
<span class="nc" id="L1026">        buffer.write(SUBJECT_ATTRIBUTE);</span>
<span class="nc" id="L1027">        buffer.write(subjectdnpem.getBytes());</span>
<span class="nc" id="L1028">        buffer.write(NL);</span>
<span class="nc" id="L1029">        buffer.write(ISSUER_ATTRIBUTE);</span>
<span class="nc" id="L1030">        buffer.write(issuerdnpem.getBytes());</span>
<span class="nc" id="L1031">        buffer.write(NL);</span>

<span class="nc" id="L1033">        final byte[] tmpOutput = tmpX509Cert.getEncoded();</span>
<span class="nc" id="L1034">        buffer.write(BEGIN_CERTIFICATE);</span>
<span class="nc" id="L1035">        buffer.write(NL);</span>

<span class="nc" id="L1037">        final byte[] tmpCACertB64 = Base64.encode(tmpOutput);</span>
<span class="nc" id="L1038">        buffer.write(tmpCACertB64);</span>
<span class="nc" id="L1039">        buffer.write(NL);</span>
<span class="nc" id="L1040">        buffer.write(END_CERTIFICATE);</span>
<span class="nc" id="L1041">        buffer.write(NL);</span>
      }
    }
<span class="fc" id="L1044">    return buffer.toByteArray();</span>
  }

  /**
   * @param publicKey Key
   * @return a buffer with the public key in PEM format
   * @throws IOException on I/O error
   */
  public static String getAsPem(final PublicKey publicKey) throws IOException {
<span class="nc" id="L1053">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L1054">    try (JcaPEMWriter pemWriter =</span>
        new JcaPEMWriter(new OutputStreamWriter(baos))) {
<span class="nc" id="L1056">      pemWriter.writeObject(publicKey);</span>
    }
<span class="nc" id="L1058">    return new String(baos.toByteArray(), &quot;UTF8&quot;);</span>
  }

  /**
   * Retrieves the certificate chain from a keystore.
   *
   * @param keyStore the keystore, which has been loaded and opened.
   * @param privateKeyAlias the alias of the privatekey for which the certchain
   *     belongs.
   * @return array of Certificate, or null if no certificates are found.
   * @throws KeyStoreException on fail
   */
  public static Certificate[] getCertChain(
      final KeyStore keyStore, final String privateKeyAlias)
      throws KeyStoreException {
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1074">      LOG.trace(&quot;&gt;getCertChain: alias='&quot; + privateKeyAlias + &quot;'&quot;);</span>
    }
<span class="fc" id="L1076">    final Certificate[] certchain =</span>
<span class="fc" id="L1077">        keyStore.getCertificateChain(privateKeyAlias);</span>
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">    if (certchain == null) {</span>
<span class="nc" id="L1079">      return null;</span>
    }
<span class="fc" id="L1081">    LOG.debug(</span>
        &quot;Certchain retrieved from alias '&quot;
            + privateKeyAlias
            + &quot;' has length &quot;
            + certchain.length);

<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">    if (certchain.length &lt; 1) {</span>
<span class="nc" id="L1088">      LOG.error(</span>
          &quot;Cannot load certificate chain with alias '&quot;
              + privateKeyAlias
              + &quot;' from keystore.&quot;);
<span class="nc bnc" id="L1092" title="All 2 branches missed.">      if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1093">        LOG.trace(</span>
            &quot;&lt;getCertChain: alias='&quot;
                + privateKeyAlias
                + &quot;', retlength=&quot;
                + certchain.length);
      }
<span class="nc" id="L1099">      return certchain;</span>
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">    } else if (certchain.length &gt; 0) {</span>
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">      if (CertTools.isSelfSigned(certchain[certchain.length - 1])) {</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1103">          LOG.debug(</span>
              &quot;Issuer='&quot;
<span class="nc" id="L1105">                  + CertTools.getIssuerDN(certchain[certchain.length - 1])</span>
                  + &quot;'.&quot;);
<span class="nc" id="L1107">          LOG.debug(</span>
              &quot;Subject='&quot;
<span class="nc" id="L1109">                  + CertTools.getSubjectDN(certchain[certchain.length - 1])</span>
                  + &quot;'.&quot;);
        }
<span class="pc bpc" id="L1112" title="1 of 2 branches missed.">        if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1113">          LOG.trace(</span>
              &quot;&lt;getCertChain: alias='&quot;
                  + privateKeyAlias
                  + &quot;', retlength=&quot;
                  + certchain.length);
        }
<span class="fc" id="L1119">        return certchain;</span>
      }
    }

    // If we came here, we have a cert which is not root cert in 'cert'
<span class="nc" id="L1124">    final ArrayList&lt;Certificate&gt; array = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1126" title="All 2 branches missed.">    for (int i = 0; i &lt; certchain.length; i++) {</span>
<span class="nc" id="L1127">      array.add(certchain[i]);</span>
    }

    while (true) {
<span class="nc" id="L1131">      final X509Certificate cert =</span>
<span class="nc" id="L1132">          (X509Certificate) array.get(array.size() - 1);</span>
<span class="nc" id="L1133">      final String ialias =</span>
<span class="nc" id="L1134">          CertTools.getPartFromDN(CertTools.getIssuerDN(cert), &quot;CN&quot;);</span>
<span class="nc" id="L1135">      final Certificate[] chain1 = keyStore.getCertificateChain(ialias);</span>

<span class="nc bnc" id="L1137" title="All 2 branches missed.">      if (chain1 == null) {</span>
<span class="nc" id="L1138">        break;</span>
      }
<span class="nc bnc" id="L1140" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1141">        LOG.debug(</span>
            &quot;Loaded certificate chain with length &quot;
                + chain1.length
                + &quot; with alias '&quot;
                + ialias
                + &quot;'.&quot;);
      }

<span class="nc bnc" id="L1149" title="All 2 branches missed.">      if (chain1.length == 0) {</span>
<span class="nc" id="L1150">        LOG.error(&quot;No RootCA certificate found!&quot;);</span>
<span class="nc" id="L1151">        break;</span>
      }
<span class="nc" id="L1153">      boolean isSelfSigned = false;</span>
<span class="nc bnc" id="L1154" title="All 4 branches missed.">      for (int j = 0; j &lt; chain1.length &amp;&amp; !isSelfSigned; j++) {</span>
<span class="nc" id="L1155">        array.add(chain1[j]);</span>

        // If one cert is slefsigned, we have found a root certificate, we don't
        // need to go on anymore
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (CertTools.isSelfSigned(chain1[j])) {</span>
<span class="nc" id="L1160">          isSelfSigned = true;</span>
        }
      }
<span class="nc bnc" id="L1163" title="All 2 branches missed.">      if (isSelfSigned) {</span>
<span class="nc" id="L1164">        break;</span>
      }
<span class="nc" id="L1166">    }</span>

<span class="nc" id="L1168">    final Certificate[] ret = new Certificate[array.size()];</span>

<span class="nc bnc" id="L1170" title="All 2 branches missed.">    for (int i = 0; i &lt; ret.length; i++) {</span>
<span class="nc" id="L1171">      ret[i] = array.get(i);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1173">        LOG.debug(&quot;Issuer='&quot; + CertTools.getIssuerDN(ret[i]) + &quot;'.&quot;);</span>
<span class="nc" id="L1174">        LOG.debug(&quot;Subject='&quot; + CertTools.getSubjectDN(ret[i]) + &quot;'.&quot;);</span>
      }
    }
<span class="nc bnc" id="L1177" title="All 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1178">      LOG.trace(</span>
          &quot;&lt;getCertChain: alias='&quot;
              + privateKeyAlias
              + &quot;', retlength=&quot;
              + ret.length);
    }
<span class="nc" id="L1184">    return ret;</span>
  } // getCertChain

  /**
   * create the subject key identifier.
   *
   * @param pubKey the public key
   * @return SubjectKeyIdentifer asn.1 structure
   */
  public static SubjectKeyIdentifier createSubjectKeyId(
      final PublicKey pubKey) {
    try {
      final ASN1Sequence keyASN1Sequence;
<span class="fc" id="L1197">      try (ASN1InputStream pubKeyAsn1InputStream =</span>
          new ASN1InputStream(
<span class="fc" id="L1199">              new ByteArrayInputStream(pubKey.getEncoded())); ) {</span>
<span class="fc" id="L1200">        final Object keyObject = pubKeyAsn1InputStream.readObject();</span>
<span class="pc bpc" id="L1201" title="1 of 2 branches missed.">        if (keyObject instanceof ASN1Sequence) {</span>
<span class="fc" id="L1202">          keyASN1Sequence = (ASN1Sequence) keyObject;</span>
        } else {
          // PublicKey key that doesn't encode to a ASN1Sequence. Fix this by
          // creating a BC object instead.
<span class="nc" id="L1206">          final PublicKey altKey =</span>
              (PublicKey)
<span class="nc" id="L1208">                  KeyFactory.getInstance(</span>
<span class="nc" id="L1209">                          pubKey.getAlgorithm(),</span>
                          BouncyCastleProvider.PROVIDER_NAME)
<span class="nc" id="L1211">                      .translateKey(pubKey);</span>
<span class="nc" id="L1212">          try (ASN1InputStream altKeyAsn1InputStream =</span>
              new ASN1InputStream(
<span class="nc" id="L1214">                  new ByteArrayInputStream(altKey.getEncoded()))) {</span>
<span class="nc" id="L1215">            keyASN1Sequence = (ASN1Sequence) altKeyAsn1InputStream.readObject();</span>
          }
        }
<span class="fc" id="L1218">        X509ExtensionUtils x509ExtensionUtils = new BcX509ExtensionUtils();</span>
<span class="fc" id="L1219">        return x509ExtensionUtils.createSubjectKeyIdentifier(</span>
<span class="fc" id="L1220">            SubjectPublicKeyInfo.getInstance(keyASN1Sequence));</span>
      }
<span class="nc" id="L1222">    } catch (Exception e) {</span>
<span class="nc" id="L1223">      final RuntimeException e2 =</span>
          new RuntimeException(&quot;error creating key&quot;); // NOPMD
<span class="nc" id="L1225">      e2.initCause(e);</span>
<span class="nc" id="L1226">      throw e2;</span>
    }
  }

  /**
   * Detect if &quot;Unlimited Strength&quot; Policy files has bean properly installed.
   *
   * @return true if key strength is limited
   */
  public static boolean isUsingExportableCryptography() {
<span class="nc" id="L1236">    return CryptoProviderTools.isUsingExportableCryptography();</span>
  }

  /**
   * Sign provided data with specified private key and algortihm.
   *
   * @param privateKey the private key
   * @param signatureAlgorithm a valid signature algorithm such as
   *     AlgorithmConstants.SIGALG_SHA256_WITH_RSA
   * @param data the data to sign
   * @return the signature
   * @throws SignatureException If sig is invalid
   * @throws NoSuchAlgorithmException If algorithm not found
   * @throws InvalidKeyException if key is invalid
   * @throws NoSuchProviderException if BouncyCastleProvider is not installed
   */
  public static byte[] signData(
      final PrivateKey privateKey,
      final String signatureAlgorithm,
      final byte[] data)
      throws SignatureException, NoSuchAlgorithmException, InvalidKeyException,
          NoSuchProviderException {
<span class="nc" id="L1258">    final Signature signer =</span>
<span class="nc" id="L1259">        Signature.getInstance(</span>
            signatureAlgorithm, BouncyCastleProvider.PROVIDER_NAME);
<span class="nc" id="L1261">    signer.initSign(privateKey);</span>
<span class="nc" id="L1262">    signer.update(data);</span>
<span class="nc" id="L1263">    return (signer.sign());</span>
  }

  /**
   * Verify signed data with specified public key, algorith and signature.
   *
   * @param publicKey the public key
   * @param signatureAlgorithm a valid signature algorithm
   * @param data the data to verify
   * @param signature the signature
   * @return true if the signature is ok
   * @throws SignatureException if signature is invalid
   * @throws NoSuchAlgorithmException if algo not found
   * @throws InvalidKeyException if key is invalid
   * @throws NoSuchProviderException if BouncyCastleProvider is not installed
   */
  public static boolean verifyData(
      final PublicKey publicKey,
      final String signatureAlgorithm,
      final byte[] data,
      final byte[] signature)
      throws SignatureException, NoSuchAlgorithmException, InvalidKeyException,
          NoSuchProviderException {
<span class="nc" id="L1286">    final Signature signer =</span>
<span class="nc" id="L1287">        Signature.getInstance(</span>
            signatureAlgorithm, BouncyCastleProvider.PROVIDER_NAME);
<span class="nc" id="L1289">    signer.initVerify(publicKey);</span>
<span class="nc" id="L1290">    signer.update(data);</span>
<span class="nc" id="L1291">    return (signer.verify(signature));</span>
  }

  private static class SignDataOperation implements ISignOperation {

    SignDataOperation(
<span class="fc" id="L1297">        final PrivateKey aKey, final byte[] aDataToBeSigned) {</span>
<span class="fc" id="L1298">      this.key = aKey;</span>
<span class="fc" id="L1299">      this.dataToBeSigned = aDataToBeSigned;</span>
<span class="fc" id="L1300">    }</span>

    /** Key. */
    private final PrivateKey key;
    /** Data. */
    private final byte[] dataToBeSigned;
    /** Signature. */
    private byte[] signatureBV;
    /** Algorithm. */
    private String signatureAlgorithm;

    @Override
    public void taskWithSigning(
            final String signAlgorithm, final Provider provider)
        throws TaskWithSigningException {
      final Signature signature;
      try {
<span class="fc" id="L1317">        signature = Signature.getInstance(signAlgorithm, provider);</span>
<span class="fc" id="L1318">        signature.initSign(this.key);</span>
<span class="fc" id="L1319">        signature.update(this.dataToBeSigned);</span>
<span class="fc" id="L1320">        this.signatureBV = signature.sign();</span>
<span class="fc" id="L1321">      } catch (NoSuchAlgorithmException</span>
          | InvalidKeyException
          | SignatureException e) {
<span class="fc" id="L1324">        throw new TaskWithSigningException(</span>
<span class="fc" id="L1325">            String.format(&quot;Signing of data failed: %s&quot;, e.getMessage()), e);</span>
<span class="fc" id="L1326">      }</span>
<span class="fc" id="L1327">      this.signatureAlgorithm = signAlgorithm;</span>
<span class="fc" id="L1328">    }</span>

    public byte[] getSignature() {
<span class="fc" id="L1331">      return this.signatureBV;</span>
    }

    public String getSignatureAlgorithm() {
<span class="fc" id="L1335">      return this.signatureAlgorithm;</span>
    }
  }

  private static Provider getProvider(final String sProvider) {
<span class="fc bfc" id="L1340" title="All 2 branches covered.">    if (sProvider == null) {</span>
<span class="fc" id="L1341">      return Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
    }
<span class="fc" id="L1343">    final Provider provider = Security.getProvider(sProvider);</span>
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">    if (provider != null) {</span>
<span class="fc" id="L1345">      return provider;</span>
    }
<span class="nc" id="L1347">    return Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);</span>
  }
  /**
   * Testing a key pair to verify that it is possible to first sign and then
   * verify with it.
   *
   * @param priv private key to sign a string with
   * @param pub public key to verify the signature with
   * @param sProvider A provider used for signing with the private key, or null
   *     if &quot;BC&quot; should be used.
   * @throws InvalidKeyException if the public key can not be used to verify a
   *     string signed by the private key, because the key is wrong or the
   *     signature operation fails for other reasons such as a
   *     NoSuchAlgorithmException or SignatureException. if the provider is not
   *     installed.
   */
  public static void testKey(
      final PrivateKey priv, final PublicKey pub, final String sProvider)
      throws InvalidKeyException { // NOPMD:this is not a junit test
<span class="fc" id="L1366">    final byte[] input =</span>
<span class="fc" id="L1367">        &quot;Lillan gick pa vagen ut, motte dar en katt...&quot;.getBytes();</span>
    final byte[] signBV;
    final String testSigAlg;
    try {
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1372">        final StringWriter sw = new StringWriter();</span>
<span class="nc" id="L1373">        try (PrintWriter pw = new PrintWriter(sw)) {</span>
<span class="nc" id="L1374">          pw.println(&quot;Testing a key:&quot;);</span>
<span class="nc" id="L1375">          pw.println(</span>
<span class="nc" id="L1376">              String.format(</span>
<span class="nc" id="L1377">                  &quot;\tTesting keys with algorithm: %s&quot;, pub.getAlgorithm()));</span>
<span class="nc" id="L1378">          pw.println(String.format(&quot;\tprovider: %s&quot;, sProvider));</span>
<span class="nc" id="L1379">          pw.println(String.format(&quot;\tprivateKey: %s&quot;, priv));</span>
<span class="nc" id="L1380">          pw.println(</span>
<span class="nc" id="L1381">              String.format(</span>
<span class="nc" id="L1382">                  &quot;\tprivateKey class: %s&quot;, priv.getClass().getName()));</span>
<span class="nc" id="L1383">          pw.println(String.format(&quot;\tpublicKey: %s&quot;, pub));</span>
<span class="nc" id="L1384">          pw.println(</span>
<span class="nc" id="L1385">              String.format(&quot;\tpublicKey class: %s&quot;, pub.getClass().getName()));</span>
<span class="nc" id="L1386">          pw.flush();</span>
        }
<span class="nc" id="L1388">        LOG.debug(sw.toString());</span>
      }

<span class="fc" id="L1391">        final SignDataOperation operation = new SignDataOperation(priv, input);</span>
        // Candidate algorithms. The first working one will be selected by
        // SignWithWorkingAlgorithm
<span class="fc" id="L1394">        final List&lt;String&gt; availableSignAlgorithms =</span>
<span class="fc" id="L1395">            AlgorithmTools.getSignatureAlgorithms(pub);</span>
<span class="fc" id="L1396">        SignWithWorkingAlgorithm.doSignTask(</span>
<span class="fc" id="L1397">            availableSignAlgorithms, getProvider(sProvider), operation);</span>
<span class="fc" id="L1398">        signBV = operation.getSignature();</span>
<span class="fc" id="L1399">        testSigAlg = operation.getSignatureAlgorithm();</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        if (signBV == null) {</span>
<span class="fc" id="L1401">          throw new InvalidKeyException(&quot;Result from signing is null.&quot;);</span>
        }
<span class="pc bpc" id="L1403" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1404">          LOG.trace(&quot;Created signature of size: &quot; + signBV.length);</span>
<span class="nc" id="L1405">          LOG.trace(&quot;Created signature: &quot; + new String(Hex.encode(signBV)));</span>
        }


        final Signature signature;
        try {
<span class="fc" id="L1411">          signature = Signature.getInstance(testSigAlg, &quot;BC&quot;);</span>
<span class="nc" id="L1412">        } catch (NoSuchProviderException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1413">          throw new IllegalStateException(</span>
              &quot;BouncyCastle was not found as a provider.&quot;, e);
<span class="fc" id="L1415">        }</span>
<span class="fc" id="L1416">        signature.initVerify(pub);</span>
<span class="fc" id="L1417">        signature.update(input);</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">        if (!signature.verify(signBV)) {</span>
<span class="fc" id="L1419">          throw new InvalidKeyException(</span>
              &quot;Signature was not correctly verified.&quot;);
        }

<span class="fc" id="L1423">    } catch (InvalidKeyException e) {</span>
<span class="fc" id="L1424">      throw e;</span>
<span class="fc" id="L1425">    } catch (TaskWithSigningException | SignatureException e) {</span>
<span class="fc" id="L1426">      throw new InvalidKeyException(</span>
<span class="fc" id="L1427">          String.format(&quot;Exception testing key: %s&quot;, e.getMessage()), e);</span>
<span class="fc" id="L1428">    }</span>
<span class="fc" id="L1429">  }</span>

  /**
   * Print parameters of public part of a key.
   *
   * @param publK the key
   * @param ps stream to print to.
   */
  public static void printPublicKeyInfo(
      final PublicKey publK, final PrintStream ps) {
<span class="fc bfc" id="L1439" title="All 2 branches covered.">    if (publK instanceof RSAPublicKey) {</span>
<span class="fc" id="L1440">      ps.println(&quot;RSA key:&quot;);</span>
<span class="fc" id="L1441">      final RSAPublicKey rsa = (RSAPublicKey) publK;</span>
<span class="fc" id="L1442">      ps.println(&quot;  modulus: &quot; + rsa.getModulus().toString(16));</span>
<span class="fc" id="L1443">      ps.println(&quot;  public exponent: &quot; + rsa.getPublicExponent().toString(16));</span>
<span class="fc" id="L1444">      return;</span>
    }
<span class="fc bfc" id="L1446" title="All 2 branches covered.">    if (publK instanceof ECPublicKey) {</span>
<span class="fc" id="L1447">      ps.println(&quot;Elliptic curve key:&quot;);</span>
<span class="fc" id="L1448">      final ECPublicKey ec = (ECPublicKey) publK;</span>
<span class="fc" id="L1449">      ps.println(&quot;  Named curve: &quot; + AlgorithmTools.getKeySpecification(ec));</span>
<span class="fc" id="L1450">      ps.println(</span>
<span class="fc" id="L1451">          &quot;  the affine x-coordinate: &quot; + ec.getW().getAffineX().toString(16));</span>
<span class="fc" id="L1452">      ps.println(</span>
<span class="fc" id="L1453">          &quot;  the affine y-coordinate: &quot; + ec.getW().getAffineY().toString(16));</span>
<span class="fc" id="L1454">      return;</span>
    }
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">    if (publK instanceof DHPublicKey) {</span>
<span class="nc" id="L1457">      ps.println(&quot;DH key:&quot;);</span>
<span class="nc" id="L1458">      final DHPublicKey dh = (DHPublicKey) publK;</span>
<span class="nc" id="L1459">      ps.println(&quot;  the public value y: &quot; + dh.getY().toString(16));</span>
<span class="nc" id="L1460">      return;</span>
    }
<span class="pc bpc" id="L1462" title="1 of 2 branches missed.">    if (publK instanceof DSAPublicKey) {</span>
<span class="fc" id="L1463">      ps.println(&quot;DSA key:&quot;);</span>
<span class="fc" id="L1464">      final DSAPublicKey dsa = (DSAPublicKey) publK;</span>
<span class="fc" id="L1465">      ps.println(&quot;  the public value y: &quot; + dsa.getY().toString(16));</span>
<span class="fc" id="L1466">      return;</span>
    }
<span class="nc" id="L1468">  }</span>

  /**
   * Test if a private key is extractable (could be stored).
   *
   * @param privK key to test.
   * @return true if the key is extractable.
   */
  public static boolean isPrivateKeyExtractable(final PrivateKey privK) {
<span class="fc bfc" id="L1477" title="All 2 branches covered.">    if (privK instanceof RSAPrivateKey) {</span>
<span class="fc" id="L1478">      final RSAPrivateKey rsa = (RSAPrivateKey) privK;</span>
<span class="fc" id="L1479">      final BigInteger result = rsa.getPrivateExponent();</span>
<span class="pc bpc" id="L1480" title="2 of 4 branches missed.">      return result != null &amp;&amp; result.bitLength() &gt; 0;</span>
    }
<span class="fc bfc" id="L1482" title="All 2 branches covered.">    if (privK instanceof ECPrivateKey) {</span>
<span class="fc" id="L1483">      final ECPrivateKey ec = (ECPrivateKey) privK;</span>
<span class="fc" id="L1484">      final BigInteger result = ec.getS();</span>
<span class="pc bpc" id="L1485" title="2 of 4 branches missed.">      return result != null &amp;&amp; result.bitLength() &gt; 0;</span>
    }
<span class="pc bpc" id="L1487" title="1 of 2 branches missed.">    if (privK instanceof DHPrivateKey) {</span>
<span class="nc" id="L1488">      final DHPrivateKey dh = (DHPrivateKey) privK;</span>
<span class="nc" id="L1489">      final BigInteger result = dh.getX();</span>
<span class="nc bnc" id="L1490" title="All 4 branches missed.">      return result != null &amp;&amp; result.bitLength() &gt; 0;</span>
    }
<span class="pc bpc" id="L1492" title="1 of 2 branches missed.">    if (privK instanceof DSAPrivateKey) {</span>
<span class="fc" id="L1493">      final DSAPrivateKey dsa = (DSAPrivateKey) privK;</span>
<span class="fc" id="L1494">      final BigInteger result = dsa.getX();</span>
<span class="pc bpc" id="L1495" title="2 of 4 branches missed.">      return result != null &amp;&amp; result.bitLength() &gt; 0;</span>
    }
<span class="nc" id="L1497">    return false;</span>
  }

  /**
   * @param keyspec Spec
   * @throws InvalidKeyException Fail
   * @throws InvalidAlgorithmParameterException Fail
   */
  public static void checkValidKeyLength(final String keyspec)
      throws InvalidKeyException, InvalidAlgorithmParameterException {
<span class="nc" id="L1507">    final String keyAlg = keyspecToKeyalg(keyspec);</span>
    final int len;
<span class="nc" id="L1509">    final int startPos = 3;</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">    if (keyAlg.equals(AlgorithmConstants.KEYALGORITHM_RSA)) {</span>
<span class="nc" id="L1511">      len = Integer.parseInt(keyspec);</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">    } else if (keyAlg.equals(AlgorithmConstants.KEYALGORITHM_DSA)) {</span>
<span class="nc" id="L1513">      len = Integer.parseInt(keyspec.substring(startPos));</span>
    } else {
      // Assume it's elliptic curve
<span class="nc" id="L1516">      final KeyPair kp = KeyTools.genKeys(keyspec, keyAlg);</span>
<span class="nc" id="L1517">      len = KeyTools.getKeyLength(kp.getPublic());</span>
    }
<span class="nc" id="L1519">    checkValidKeyLength(keyAlg, len);</span>
<span class="nc" id="L1520">  }</span>

  /**
   * @param pk Key
   * @throws InvalidKeyException fail
   */
  public static void checkValidKeyLength(final PublicKey pk)
      throws InvalidKeyException {
<span class="nc" id="L1528">    final String keyAlg = AlgorithmTools.getKeyAlgorithm(pk);</span>
<span class="nc" id="L1529">    final int len = KeyTools.getKeyLength(pk);</span>
<span class="nc" id="L1530">    checkValidKeyLength(keyAlg, len);</span>
<span class="nc" id="L1531">  }</span>

  /**
   * @param keyAlg Algorithm
   * @param len Key length
   * @throws InvalidKeyException fail
   */
  public static void checkValidKeyLength(final String keyAlg, final int len)
      throws InvalidKeyException {
<span class="nc" id="L1540">    final int ecMinSize = 224;</span>
<span class="nc" id="L1541">    final int dsaMinSize = 1024;</span>
<span class="nc" id="L1542">    final boolean isEcdsa =</span>
<span class="nc" id="L1543">        AlgorithmConstants.KEYALGORITHM_ECDSA.equals(keyAlg);</span>
    final boolean isGost3410 =
<span class="nc bnc" id="L1545" title="All 2 branches missed.">        AlgorithmTools.isGost3410Enabled()</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">            &amp;&amp; AlgorithmConstants.KEYALGORITHM_ECGOST3410.equals(keyAlg);</span>
    final boolean isDstu4145 =
<span class="nc bnc" id="L1548" title="All 2 branches missed.">        AlgorithmTools.isDstu4145Enabled()</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">            &amp;&amp; keyAlg.startsWith(CesecoreConfiguration.getOidDstu4145() + &quot;.&quot;);</span>
<span class="nc bnc" id="L1550" title="All 6 branches missed.">    if (isEcdsa || isGost3410 || isDstu4145) {</span>
      // We allow key lengths of 0, because that means that implicitlyCA is
      // used.
      // for ImplicitlyCA we have no idea what the key length is, on the other
      // hand only real professionals
      // will ever use that to we will allow it.
<span class="nc bnc" id="L1556" title="All 4 branches missed.">      if ((len &gt; 0) &amp;&amp; (len &lt; ecMinSize)) {</span>
<span class="nc" id="L1557">        final String msg =</span>
<span class="nc" id="L1558">            INTRES.getLocalizedMessage(</span>
                &quot;catoken.invalidkeylength&quot;,
                &quot;ECDSA&quot;,
<span class="nc" id="L1561">                Integer.valueOf(ecMinSize).toString(),</span>
<span class="nc" id="L1562">                Integer.valueOf(len));</span>
<span class="nc" id="L1563">        throw new InvalidKeyException(msg);</span>
      }
<span class="nc bnc" id="L1565" title="All 2 branches missed.">    } else if (AlgorithmConstants.KEYALGORITHM_RSA.equals(keyAlg)</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">        || AlgorithmConstants.KEYALGORITHM_DSA.equals(keyAlg)) {</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">      if (len &lt; dsaMinSize) {</span>
<span class="nc" id="L1568">        final String msg =</span>
<span class="nc" id="L1569">            INTRES.getLocalizedMessage(</span>
                &quot;catoken.invalidkeylength&quot;,
                &quot;RSA/DSA&quot;,
<span class="nc" id="L1572">                Integer.valueOf(dsaMinSize).toString(),</span>
<span class="nc" id="L1573">                Integer.valueOf(len));</span>
<span class="nc" id="L1574">        throw new InvalidKeyException(msg);</span>
      }
    }
<span class="nc" id="L1577">  }</span>

  /**
   * Gets the parameter spec from a given OID of a DSTU curve (they don't have
   * names).
   *
   * @param dstuOid OIS
   * @return spec
   */
  public static AlgorithmParameterSpec dstuOidToAlgoParams(
          final String dstuOid) {
<span class="nc" id="L1588">    return new ECGenParameterSpec(dstuOid);</span>
  }

  /**
   * @param keyspec Spec
   * @return Algorithm
   */
  public static String keyspecToKeyalg(final String keyspec) {
<span class="nc bnc" id="L1596" title="All 2 branches missed.">    if (StringUtils.isNumeric(keyspec)) {</span>
<span class="nc" id="L1597">      return AlgorithmConstants.KEYALGORITHM_RSA;</span>
    }
<span class="nc bnc" id="L1599" title="All 2 branches missed.">    if (keyspec.startsWith(AlgorithmConstants.KEYALGORITHM_RSA)) {</span>
<span class="nc" id="L1600">      return AlgorithmConstants.KEYALGORITHM_RSA;</span>
    }
<span class="nc bnc" id="L1602" title="All 2 branches missed.">    if (keyspec.startsWith(AlgorithmConstants.KEYALGORITHM_DSA)) {</span>
<span class="nc" id="L1603">      return AlgorithmConstants.KEYALGORITHM_DSA;</span>
    }
<span class="nc bnc" id="L1605" title="All 2 branches missed.">    if (AlgorithmTools.isGost3410Enabled()</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">        &amp;&amp; keyspec.startsWith(AlgorithmConstants.KEYSPECPREFIX_ECGOST3410)) {</span>
<span class="nc" id="L1607">      return AlgorithmConstants.KEYALGORITHM_ECGOST3410;</span>
    }
<span class="nc bnc" id="L1609" title="All 2 branches missed.">    if (AlgorithmTools.isDstu4145Enabled()</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">        &amp;&amp; keyspec.startsWith(CesecoreConfiguration.getOidDstu4145() + &quot;.&quot;)) {</span>
<span class="nc" id="L1611">      return AlgorithmConstants.KEYALGORITHM_DSTU4145;</span>
    }
<span class="nc" id="L1613">    return AlgorithmConstants.KEYALGORITHM_ECDSA;</span>
  }

  /**
   * Converts a standalone specspec that starts with the keyalg to a short
   * keyspec which is to be used together with a separate &quot;keyalg&quot; value.
   *
   * @param keyspec spec
   * @return short spec
   */
  public static String shortenKeySpec(final String keyspec) {
<span class="nc" id="L1624">    final int startPos = 3;</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">    if (keyspec.startsWith(AlgorithmConstants.KEYALGORITHM_DSA)</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">        || keyspec.startsWith(AlgorithmConstants.KEYALGORITHM_RSA)) {</span>
<span class="nc" id="L1627">      return keyspec.substring(startPos);</span>
    }
<span class="nc" id="L1629">    return keyspec;</span>
  }

  /**
   * Converts a keyalg/keyspec pair into a standalone specspec.
   *
   * @param keyalg algorithm
   * @param keyspec spec
   * @return specspec
   */
  public static String keyalgspecToKeyspec(
          final String keyalg, final String keyspec) {
<span class="nc bnc" id="L1641" title="All 2 branches missed.">    if (&quot;DSA&quot;.equals(keyalg)) {</span>
<span class="nc" id="L1642">      return &quot;DSA&quot; + keyspec;</span>
    }
<span class="nc" id="L1644">    return keyspec;</span>
  }

  /**
   * Get the ASN.1 encoded PublicKey as a Java PublicKey Object.
   *
   * @param asn1EncodedPublicKey the ASN.1 encoded PublicKey
   * @return the ASN.1 encoded PublicKey as a Java Object
   */
  public static PublicKey getPublicKeyFromBytes(
          final byte[] asn1EncodedPublicKey) {
    try {
      final SubjectPublicKeyInfo keyInfo;
<span class="nc" id="L1657">      keyInfo = SubjectPublicKeyInfo.getInstance(asn1EncodedPublicKey);</span>
<span class="nc" id="L1658">      final AlgorithmIdentifier keyAlg = keyInfo.getAlgorithm();</span>
<span class="nc" id="L1659">      final X509EncodedKeySpec xKeySpec =</span>
<span class="nc" id="L1660">          new X509EncodedKeySpec(new DERBitString(keyInfo).getBytes());</span>
<span class="nc" id="L1661">      final KeyFactory keyFact =</span>
<span class="nc" id="L1662">          KeyFactory.getInstance(</span>
<span class="nc" id="L1663">              keyAlg.getAlgorithm().getId(),</span>
              BouncyCastleProvider.PROVIDER_NAME);
<span class="nc" id="L1665">      return keyFact.generatePublic(xKeySpec);</span>
<span class="nc" id="L1666">    } catch (IOException</span>
        | NoSuchAlgorithmException
        | NoSuchProviderException
        | InvalidKeySpecException e) {
<span class="nc" id="L1670">      LOG.debug(&quot;Unable to decode PublicKey.&quot;, e);</span>
    }
<span class="nc" id="L1672">    return null;</span>
  }

  /**
   * Extracts the binary data from a PEM of a specified kind, e.g. public key.
   *
   * @param pem PEM data to extract from. May contain other types of data as
   *     well.
   * @param beginMarker E.g. CertTools.BEGIN_PUBLIC_KEY
   * @param endMarker E.g. CertTools.END_PUBLIC_KEY
   * @return The first entry of the matching type, or null if it couldn't be
   *     parsed.
   */
  public static byte[] getBytesFromPEM(
      final String pem, final String beginMarker, final String endMarker) {
<span class="fc" id="L1687">    final int start = pem.indexOf(beginMarker);</span>
<span class="fc" id="L1688">    final int end = pem.indexOf(endMarker, start);</span>
<span class="fc bfc" id="L1689" title="All 4 branches covered.">    if (start == -1 || end == -1) {</span>
<span class="fc" id="L1690">      LOG.debug(</span>
          &quot;Could not find &quot;
              + beginMarker
              + &quot; and &quot;
              + endMarker
              + &quot; lines in PEM&quot;);
<span class="fc" id="L1696">      return null;</span>
    }

<span class="fc" id="L1699">    final String base64 = pem.substring(start + beginMarker.length(), end);</span>
    try {
<span class="fc" id="L1701">      return Base64.decode(base64.getBytes(&quot;ASCII&quot;));</span>
<span class="nc" id="L1702">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L1703">      LOG.debug(String.format(&quot;Invalid byte in PEM data: %s&quot;, e.getMessage()));</span>
<span class="nc" id="L1704">      return null;</span>
    }
  }

  /**
   * Extracts the binary DER data from a public key file. The file may be either
   * in PEM format or in DER format. In the latter case, the file contents is
   * returned as-is.
   *
   * @param file Data of a PEM or DER file.
   * @return DER encoded public key.
   * @throws CertificateParsingException If the data isn't a public key in
   *     either PEM or DER format.
   */
  public static byte[] getBytesFromPublicKeyFile(final byte[] file)
      throws CertificateParsingException {
<span class="fc" id="L1720">    final String fileText =</span>
<span class="fc" id="L1721">        Charset.forName(&quot;ASCII&quot;)</span>
<span class="fc" id="L1722">            .decode(java.nio.ByteBuffer.wrap(file))</span>
<span class="fc" id="L1723">            .toString();</span>
    final byte[] asn1bytes;

<span class="fc" id="L1726">      final byte[] tmpBytes =</span>
<span class="fc" id="L1727">          getBytesFromPEM(</span>
              fileText, CertTools.BEGIN_PUBLIC_KEY, CertTools.END_PUBLIC_KEY);
      asn1bytes =
<span class="fc bfc" id="L1730" title="All 2 branches covered.">          tmpBytes != null</span>
<span class="fc" id="L1731">              ? tmpBytes</span>
<span class="fc" id="L1732">              : file; // Assume it's in ASN1 format already if null</span>

    try {
<span class="fc" id="L1735">      PublicKeyFactory.createKey(</span>
          asn1bytes); // Check that it's a valid public key
<span class="fc" id="L1737">      return asn1bytes;</span>
<span class="fc" id="L1738">    } catch (IOException e) {</span>
<span class="fc" id="L1739">      throw new CertificateParsingException(e);</span>
    }
  }

  /**
   * Returns the modulus of the public key.
   *
   * @param publicKey public key
   * @return modulus of the public key
   */
  public static String getKeyModulus(final PublicKey publicKey) {
<span class="nc" id="L1750">    String modulus = null;</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">    if (publicKey instanceof RSAPublicKey) {</span>
<span class="nc" id="L1752">      byte[] modulusBytes =</span>
<span class="nc" id="L1753">          ((RSAPublicKey) publicKey).getModulus().toByteArray();</span>
<span class="nc" id="L1754">      modulus = new String(Hex.encode(modulusBytes));</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">    } else if (publicKey instanceof DSAPublicKey) {</span>
<span class="nc" id="L1756">      byte[] modulusBytes = ((DSAPublicKey) publicKey).getY().toByteArray();</span>
<span class="nc" id="L1757">      modulus = new String(Hex.encode(modulusBytes));</span>
<span class="nc bnc" id="L1758" title="All 2 branches missed.">    } else if (publicKey instanceof ECPublicKey) {</span>
<span class="nc" id="L1759">      byte[] modulusBytesX =</span>
<span class="nc" id="L1760">          ((ECPublicKey) publicKey).getW().getAffineX().toByteArray();</span>
<span class="nc" id="L1761">      byte[] modulusBytesY =</span>
<span class="nc" id="L1762">          ((ECPublicKey) publicKey).getW().getAffineY().toByteArray();</span>
<span class="nc" id="L1763">      modulus =</span>
<span class="nc" id="L1764">          new String(Hex.encode(modulusBytesX))</span>
<span class="nc" id="L1765">              .concat(new String(Hex.encode(modulusBytesY)));</span>
    }
<span class="nc" id="L1767">    return modulus;</span>
  }

  /**
   * Returns the exponent of the public key.
   *
   * @param publicKey public key
   * @return modulus of the public key
   */
  public static String getKeyPublicExponent(final PublicKey publicKey) {
<span class="nc" id="L1777">    String exponent = null;</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">    if (publicKey instanceof RSAPublicKey) {</span>
<span class="nc" id="L1779">      exponent = ((RSAPublicKey) publicKey).getPublicExponent().toString();</span>
    }
<span class="nc" id="L1781">    return exponent;</span>
  }

  /**
   * Generates the SHA256 fingerprint of the given text string.
   *
   * @param text input on what to generate the fingerprint
   * @return SHA256 fingerprint of given input string
   */
  public static String getSha256Fingerprint(final String text) {
<span class="nc" id="L1791">    byte[] sha256Fingerprint =</span>
<span class="nc" id="L1792">        CertTools.generateSHA256Fingerprint(text.getBytes());</span>
<span class="nc" id="L1793">    return new String(Hex.encode(sha256Fingerprint));</span>
  }

  /**
   * Returns the signature of the given JcaPKCS10CertificationRequest.
   *
   * @param certificationRequest BouncyCastle JcaPKCS10CertificationRequest
   *     certification request
   * @return signature of given certification request
   */
  public static String getCertificateRequestSignature(
      final JcaPKCS10CertificationRequest certificationRequest) {
<span class="nc" id="L1805">    return new String(Hex.encode(certificationRequest.getSignature()));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>