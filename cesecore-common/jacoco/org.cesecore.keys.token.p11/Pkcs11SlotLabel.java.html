<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Pkcs11SlotLabel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.token.p11</a> &gt; <span class="el_source">Pkcs11SlotLabel.java</span></div><h1>Pkcs11SlotLabel.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.token.p11;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.Provider;
import java.security.Security;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.keys.token.p11.exception.NoSuchSlotException;
import org.cesecore.keys.token.p11.exception.P11RuntimeException;

/**
 * @version $Id: Pkcs11SlotLabel.java 29747 2018-08-25 23:54:33Z anatom $
 *
 * Object for handling a PKCS#11 Slot Label.
 *
 */
public class Pkcs11SlotLabel {

    /** The name of Suns pkcs11 implementation */
    public static final String SUN_PKCS11_CLASS = &quot;sun.security.pkcs11.SunPKCS11&quot;;
    public static final String IAIK_PKCS11_CLASS = &quot;iaik.pkcs.pkcs11.provider.IAIKPkcs11&quot;;
    public static final String IAIK_JCEPROVIDER_CLASS = &quot;iaik.security.provider.IAIK&quot;;

<span class="nc" id="L52">    private static final Logger log = Logger.getLogger(Pkcs11SlotLabel.class);</span>

    private final static String DELIMETER = &quot;:&quot;;
    private final Pkcs11SlotLabelType type;
    private final String value;

    /**
     * Use explicit values.
     * @param type type
     * @param value value
     */
<span class="nc" id="L63">    public Pkcs11SlotLabel(final Pkcs11SlotLabelType type, final String value) {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if(type == null) {</span>
<span class="nc" id="L65">            throw new IllegalArgumentException(&quot;Type can not be null&quot;);</span>
        }
<span class="nc" id="L67">        this.type = type;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        this.value = value == null ? null : value.trim();</span>
<span class="nc" id="L69">    }</span>

    /**
     * Get a string that later could be used to create a new object.
     * Use it when you want to store a reference to the slot.
     * @return the string.
     */
    public String getTaggedString() {
<span class="nc" id="L77">        return this.type.name() + DELIMETER + this.value;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L82">        return &quot;Slot type: '&quot; + this.type + &quot;'. Slot value: '&quot; + this.value + &quot;'.&quot;;</span>
    }

    /**
     * Get provider for the slot.
     * @param fileName path name to the P11 module so file or sun config file (only in the case of {@link #type}=={@link Pkcs11SlotLabelType#SUN_FILE})
     * @param attributesFile Path to file with P11 attributes to be used when generating keys with the provider. If null a good default will be used.
     * @param privateKeyLabel Label that will be set to all private keys generated by the provider. If null no label will be set.
     * @return the provider, or null if none is available.
     * @throws NoSuchSlotException if no slot as defined by this slot label was found
     * 
     */
    public Provider getProvider(final String fileName, final String attributesFile, final String privateKeyLabel) throws NoSuchSlotException {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (StringUtils.isEmpty(fileName)) {</span>
<span class="nc" id="L96">            throw new IllegalArgumentException(&quot;A file name must be supplied.&quot;);</span>
        }
<span class="nc" id="L98">        final File libFile = new File(fileName);</span>
<span class="nc bnc" id="L99" title="All 4 branches missed.">        if (!libFile.isFile() || !libFile.canRead()) {</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;The file &quot; + fileName + &quot; can't be read.&quot;);</span>
        }
        // We will construct the PKCS11 provider (sun.security..., or iaik...) using reflection, because
        // the sun class does not exist on all platforms in jdk5, and we want to be able to compile everything.
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L105">            log.debug(&quot;slot spec: &quot; + toString());</span>
        }
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if ( this.type==Pkcs11SlotLabelType.SUN_FILE ) {// if sun cfg file then we do not know the name of the p11 module and we must quit.</span>
            try {
<span class="nc" id="L109">                List&lt;String&gt; fileContent = new ArrayList&lt;&gt;(Files.readAllLines(Paths.get(fileName), StandardCharsets.UTF_8));</span>
<span class="nc" id="L110">                replaceCkaLabel(fileContent, privateKeyLabel);</span>
<span class="nc" id="L111">                final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L112">                try( final PrintWriter pw = new PrintWriter(baos) ) {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">                    for (String string : fileContent) {</span>
<span class="nc" id="L114">                        pw.println(string);</span>
<span class="nc" id="L115">                    }</span>
                }
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L118">                    log.debug(baos.toString());</span>
                }
<span class="nc" id="L120">                try ( final ByteArrayInputStream inputStream = new ByteArrayInputStream(baos.toByteArray()) ) {</span>
<span class="nc" id="L121">                    return getSunP11Provider(inputStream);</span>
                }
<span class="nc" id="L123">            } catch (FileNotFoundException e) {</span>
<span class="nc" id="L124">                throw new IllegalArgumentException(&quot;File &quot; + libFile + &quot; was not found.&quot;);</span>
<span class="nc" id="L125">            } catch ( IOException e ) {</span>
<span class="nc" id="L126">                throw new P11RuntimeException(String.format(&quot;The file %s can not be closed after use.&quot;, libFile), e);</span>
            }
        }
        final long slot;
<span class="nc" id="L130">        final Pkcs11Wrapper p11 = Pkcs11Wrapper.getInstance(libFile); // must be called before any provider is created for libFile</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">        switch (this.type) {</span>
        case SLOT_LABEL:
<span class="nc" id="L133">            slot = getSlotID(this.value, p11);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (slot &lt; 0) {</span>
<span class="nc" id="L135">                throw new IllegalStateException(&quot;Token label '&quot; + this.value + &quot;' not found.&quot;);</span>
            }
            break;
        case SLOT_NUMBER:
<span class="nc" id="L139">            slot = Long.parseLong(this.value);</span>
<span class="nc" id="L140">            break;</span>
        case SLOT_INDEX:
            //Be generous and allow numbers to act as indexes as well
<span class="nc bnc" id="L143" title="All 2 branches missed.">            slot = Long.parseLong((this.value.charAt(0) == 'i' ? this.value.substring(1) : this.value));</span>
<span class="nc" id="L144">            break;</span>
            //$CASES-OMITTED$
        default:
<span class="nc" id="L147">            throw new IllegalStateException(&quot;This should not ever happen if all type of slots are tested.&quot;);</span>
        }
        {// We will first try to construct the more competent IAIK provider, if it exists in the classpath
<span class="nc" id="L150">            final Provider prov = getIAIKP11Provider(slot, libFile, this.type);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (prov != null) {</span>
<span class="nc" id="L152">                return prov;</span>
            }
        }
        {// if that does not exist, we will revert back to use the SUN provider
<span class="nc" id="L156">            final Provider prov = getSunP11Provider( getSunP11ProviderInputStream(slot, libFile, this.type, attributesFile, privateKeyLabel) );</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (prov != null) {</span>
<span class="nc" id="L158">                return prov;</span>
            }
        }
<span class="nc" id="L161">        log.error(&quot;No provider available.&quot;);</span>
<span class="nc" id="L162">        return null;</span>
    }

    /** @param libFile library file
     * @return a List of &quot;slotId;tokenLabel&quot; in the (indexed) order we get the from the P11 */
    public static List&lt;String&gt; getExtendedTokenLabels(final File libFile) {
<span class="nc" id="L168">        final List&lt;String&gt; tokenLabels = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L169">        final Pkcs11Wrapper p11 = Pkcs11Wrapper.getInstance(libFile);</span>
<span class="nc" id="L170">        final long slots[] = p11.getSlotList();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L172">            log.debug(&quot;Found numer of slots:\t&quot; + slots.length);</span>
        }
<span class="nc bnc" id="L174" title="All 2 branches missed.">        for (int i=0; i&lt;slots.length; i++) {</span>
<span class="nc" id="L175">            final long slotID = slots[i];</span>
<span class="nc" id="L176">            final char label[] = p11.getTokenLabel(slotID);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (label == null) {</span>
<span class="nc" id="L178">                continue;</span>
            }
<span class="nc" id="L180">            final String tokenLabel = new String(label);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L182">                log.debug(i+&quot;: Found token label:\t&quot; + tokenLabel + &quot;\tid=&quot;+slotID);</span>
            }
<span class="nc" id="L184">            tokenLabels.add(slotID+&quot;;&quot;+tokenLabel.trim());</span>
        }
<span class="nc" id="L186">        return tokenLabels;</span>
    }
    
    /**
     * Get slot ID for a token label.
     * @param tokenLabel the label.
     * @param p11 object to get slot list and labels for all slots with tokens
     * @return the slot ID.
     * @throws NoSuchSlotException if no slot as defined by tokenLabel was found

     */
    private static long getSlotID(final String tokenLabel, final Pkcs11Wrapper p11) throws NoSuchSlotException {
<span class="nc" id="L198">        final long slots[] = p11.getSlotList();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L200">            log.debug(&quot;Searching for token label:\t&quot; + tokenLabel);</span>
        }

<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (final long slotID : slots) {</span>
<span class="nc" id="L204">            final char label[] = p11.getTokenLabel(slotID);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (label == null) {</span>
<span class="nc" id="L206">                continue;</span>
            }
<span class="nc" id="L208">            final String candidateTokenLabel = new String(label);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L210">                log.debug(&quot;Candidate token label:\t&quot; + candidateTokenLabel);</span>
            }
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (!tokenLabel.equals(candidateTokenLabel.trim())) {</span>
<span class="nc" id="L213">                continue;</span>
            }
<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L216">                log.debug(&quot;Label '&quot; + tokenLabel + &quot;' found. The slot ID is:\t&quot; + slotID);</span>
            }
<span class="nc" id="L218">            return slotID;</span>
        }
<span class="nc" id="L220">        throw new NoSuchSlotException(&quot;Token label '&quot; + tokenLabel + &quot;' not found.&quot;);</span>
    }

    /**
     * Get the IAIK provider.
     * @param slot Slot list index or slot ID.
     * @param libFile P11 module so file.
     * @param type type
     * @return the provider
     */
    private static Provider getIAIKP11Provider(final long slot, final File libFile, final Pkcs11SlotLabelType type) {
        // Properties for the IAIK PKCS#11 provider
<span class="nc" id="L232">        final Properties prop = new Properties();</span>
        try {
<span class="nc" id="L234">            prop.setProperty(&quot;PKCS11_NATIVE_MODULE&quot;, libFile.getCanonicalPath());</span>
<span class="nc" id="L235">        } catch (IOException e) {</span>
<span class="nc" id="L236">            throw new RuntimeException(&quot;Could for unknown reason not construct canonical filename.&quot;, e);</span>
<span class="nc" id="L237">        }</span>
        // If using Slot Index it is denoted by brackets in iaik
<span class="nc bnc" id="L239" title="All 2 branches missed.">        prop.setProperty(&quot;SLOT_ID&quot;, type.equals(Pkcs11SlotLabelType.SLOT_INDEX) ? (&quot;[&quot; + slot + &quot;]&quot;) : Long.toString(slot));</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L241">            log.debug(prop.toString());</span>
        }
        final Provider ret;
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L246">            final Class&lt;? extends Provider&gt; implClass = (Class&lt;? extends Provider&gt;) Class.forName(IAIK_PKCS11_CLASS);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L248">                log.debug(&quot;Using IAIK PKCS11 provider: &quot; + IAIK_PKCS11_CLASS);</span>
            }
            // iaik PKCS11 has Properties as constructor argument
<span class="nc" id="L251">            ret = implClass.getConstructor(Properties.class).newInstance(new Object[] { prop });</span>
<span class="nc" id="L252">        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException |</span>
                NoSuchMethodException | SecurityException | ClassNotFoundException e) {
<span class="nc" id="L254">            return null;</span>
<span class="nc" id="L255">        }</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if ( ret==null ) {</span>
<span class="nc" id="L257">            return null;</span>
        }
        try {
            // It's not enough just to add the p11 provider. Depending on algorithms we may have to install the IAIK JCE provider as well in order
            // to support algorithm delegation
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L263">            final Class&lt;? extends Provider&gt; jceImplClass = (Class&lt;? extends Provider&gt;) Class.forName(IAIK_JCEPROVIDER_CLASS);</span>
<span class="nc" id="L264">            final Provider iaikProvider = jceImplClass.getConstructor().newInstance();</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            if (Security.getProvider(iaikProvider.getName()) == null) {</span>
<span class="nc" id="L266">                log.info(&quot;Adding IAIK JCE provider for Delegation: &quot; + IAIK_JCEPROVIDER_CLASS);</span>
<span class="nc" id="L267">                Security.addProvider(iaikProvider);</span>
            }
<span class="nc" id="L269">        } catch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException |</span>
                NoSuchMethodException | SecurityException | ClassNotFoundException e) {
            // NOPMD: Ignore, reflection related errors are handled elsewhere
<span class="nc" id="L272">        }</span>
<span class="nc" id="L273">        return ret;</span>
    }

    /**
     * Get an InputStream to be used to create the Sun provider.
     * @param slot Slot list index or slot ID.
     * @param libFile P11 module so file.
     * @param type a Pkcs11SlotLabelType if the slot is not an ID byt a label for example.
     * @param attributesFile Path to file with P11 attributes to be used when generating keys with the provider. If null a good default will be used.
     * @param privateKeyLabel Label that will be set to all private keys generated by the provider. If null no label will be set.
     * @return the stream
     */
    private static InputStream getSunP11ProviderInputStream(final long slot, final File libFile, final Pkcs11SlotLabelType type, final String attributesFile,
            String privateKeyLabel) {

        // Properties for the SUN PKCS#11 provider
<span class="nc" id="L289">        final String sSlot = Long.toString(slot);</span>
        final String libFilePath;
        try {
<span class="nc" id="L292">            libFilePath = libFile.getCanonicalPath();</span>
<span class="nc" id="L293">        } catch (IOException e) {</span>
<span class="nc" id="L294">            throw new RuntimeException(&quot;Could for unknown reason not construct canonical filename.&quot;, e);</span>
<span class="nc" id="L295">        }</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L297">            log.debug(&quot;&gt;getSunP11ProviderInputStream: &quot;+sSlot+&quot;, &quot;+libFilePath+&quot;, &quot;+type.toString()+&quot;, &quot;+attributesFile+&quot;, &quot;+privateKeyLabel);</span>
        }
<span class="nc" id="L299">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L300">        try( final PrintWriter pw = new PrintWriter(baos) ) {</span>
<span class="nc" id="L301">            pw.println(&quot;name = &quot; + libFile.getName() + &quot;-slot&quot; + sSlot);</span>
<span class="nc" id="L302">            pw.println(&quot;library = &quot; + libFilePath);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (sSlot != null) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                pw.println(&quot;slot&quot; + (type.isEqual(Pkcs11SlotLabelType.SLOT_INDEX) ? &quot;ListIndex&quot; : &quot;&quot;) + &quot; = &quot; + sSlot);</span>
            }
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (attributesFile != null) {</span>
                try {
<span class="nc" id="L308">                    List&lt;String&gt; fileContent = new ArrayList&lt;&gt;(Files.readAllLines(Paths.get(attributesFile), StandardCharsets.UTF_8));</span>
<span class="nc" id="L309">                    replaceCkaLabel(fileContent, privateKeyLabel);</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                    for (String string : fileContent) {</span>
<span class="nc" id="L311">                        pw.println(string);</span>
<span class="nc" id="L312">                    }</span>
<span class="nc" id="L313">                } catch (IOException e) {</span>
<span class="nc" id="L314">                    throw new IllegalArgumentException(&quot;File &quot; + attributesFile + &quot; was not found, or could not be read.&quot;, e);</span>
<span class="nc" id="L315">                }</span>
                //pw.println(new String(attrs));
            } else {
                // setting the attributes like this should work for most HSMs.
<span class="nc" id="L319">                pw.println(&quot;attributes(*, CKO_PUBLIC_KEY, *) = {&quot;);</span>
<span class="nc" id="L320">                pw.println(&quot;  CKA_TOKEN = false&quot;); // Do not save public keys permanent in order to save space.</span>
<span class="nc" id="L321">                pw.println(&quot;  CKA_ENCRYPT = true&quot;);</span>
<span class="nc" id="L322">                pw.println(&quot;  CKA_VERIFY = true&quot;);</span>
<span class="nc" id="L323">                pw.println(&quot;  CKA_WRAP = true&quot;);// no harm allowing wrapping of keys. created private keys can not be wrapped anyway since CKA_EXTRACTABLE</span>
                // is false.
<span class="nc" id="L325">                pw.println(&quot;}&quot;);</span>
<span class="nc" id="L326">                pw.println(&quot;attributes(*, CKO_PRIVATE_KEY, *) = {&quot;);</span>
<span class="nc" id="L327">                pw.println(&quot;  CKA_DERIVE = false&quot;); //Amazon CloudHSM will not accept that CKA_DERIVE is present in private key template and will give CKR_TEMPLATE_INCONSISTENT.</span>
<span class="nc" id="L328">                pw.println(&quot;  CKA_TOKEN = true&quot;); // all created private keys should be permanent. They should not only exist during the session.</span>
<span class="nc" id="L329">                pw.println(&quot;  CKA_PRIVATE = true&quot;); // always require logon with password to use the key</span>
<span class="nc" id="L330">                pw.println(&quot;  CKA_SENSITIVE = true&quot;); // not possible to read the key</span>
<span class="nc" id="L331">                pw.println(&quot;  CKA_EXTRACTABLE = false&quot;); // not possible to wrap the key with another key</span>
<span class="nc" id="L332">                pw.println(&quot;  CKA_DECRYPT = true&quot;);</span>
<span class="nc" id="L333">                pw.println(&quot;  CKA_SIGN = true&quot;);</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">                if (privateKeyLabel != null &amp;&amp; privateKeyLabel.length() &gt; 0) {</span>
<span class="nc" id="L335">                    final String labelStr = &quot;  CKA_LABEL = 0h&quot; + new String(Hex.encode(privateKeyLabel.getBytes()));</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L337">                        log.debug(&quot;Setting CKA_LABEL to '&quot;+labelStr+&quot;'&quot;);</span>
                    }
<span class="nc" id="L339">                    pw.println(labelStr);</span>
                }
<span class="nc" id="L341">                pw.println(&quot;  CKA_UNWRAP = true&quot;);// for unwrapping of session keys,</span>
<span class="nc" id="L342">                pw.println(&quot;}&quot;);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if ( CesecoreConfiguration.p11disableHashingSignMechanisms() ) {</span>
<span class="nc" id="L344">                    pw.println(&quot;disabledMechanisms = {&quot;);</span>
                    // by disabling these mechanisms the hashing will be done in the application instead of the HSM.
<span class="nc" id="L346">                    pw.println(&quot;  CKM_SHA1_RSA_PKCS&quot;);</span>
<span class="nc" id="L347">                    pw.println(&quot;  CKM_SHA256_RSA_PKCS&quot;);</span>
<span class="nc" id="L348">                    pw.println(&quot;  CKM_SHA384_RSA_PKCS&quot;);</span>
<span class="nc" id="L349">                    pw.println(&quot;  CKM_SHA512_RSA_PKCS&quot;);</span>
<span class="nc" id="L350">                    pw.println(&quot;  CKM_MD2_RSA_PKCS&quot;);</span>
<span class="nc" id="L351">                    pw.println(&quot;  CKM_MD5_RSA_PKCS&quot;);</span>
<span class="nc" id="L352">                    pw.println(&quot;  CKM_DSA_SHA1&quot;);</span>
<span class="nc" id="L353">                    pw.println(&quot;  CKM_ECDSA_SHA1&quot;);</span>
<span class="nc" id="L354">                    pw.println(&quot;}&quot;);</span>
                }
<span class="nc" id="L356">                pw.println(&quot;attributes(*, CKO_SECRET_KEY, *) = {&quot;);</span>
<span class="nc" id="L357">                pw.println(&quot;  CKA_SENSITIVE = true&quot;); // not possible to read the key</span>
<span class="nc" id="L358">                pw.println(&quot;  CKA_EXTRACTABLE = false&quot;); // not possible to wrap the key with another key</span>
<span class="nc" id="L359">                pw.println(&quot;  CKA_ENCRYPT = true&quot;);</span>
<span class="nc" id="L360">                pw.println(&quot;  CKA_DECRYPT = true&quot;);</span>
<span class="nc" id="L361">                pw.println(&quot;  CKA_SIGN = true&quot;);</span>
<span class="nc" id="L362">                pw.println(&quot;  CKA_VERIFY = true&quot;);</span>
<span class="nc" id="L363">                pw.println(&quot;  CKA_WRAP = true&quot;);// for unwrapping of session keys,</span>
<span class="nc" id="L364">                pw.println(&quot;  CKA_UNWRAP = true&quot;);// for unwrapping of session keys,</span>
<span class="nc" id="L365">                pw.println(&quot;}&quot;);</span>
            }
        }
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L369">            log.debug(baos.toString());</span>
        }
<span class="nc" id="L371">        return new ByteArrayInputStream(baos.toByteArray());</span>
    }

    private static void replaceCkaLabel(List&lt;String&gt; fileContent, String privateKeyLabel) {
        // If the attributes file contain a CKA_LABEL without a label, set it to our desired label
<span class="nc bnc" id="L376" title="All 2 branches missed.">        for (int i = 0; i &lt; fileContent.size(); i++) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (fileContent.get(i).equals(&quot;  CKA_LABEL&quot;)) { // just the CKA_LABEL with two spaces before and nothing, not even a space after</span>
<span class="nc bnc" id="L378" title="All 4 branches missed.">                if (privateKeyLabel != null &amp;&amp; privateKeyLabel.length() &gt; 0) {</span>
<span class="nc" id="L379">                    final String labelStr = &quot;  CKA_LABEL = 0h&quot; + new String(Hex.encode(privateKeyLabel.getBytes()));</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L381">                        log.debug(&quot;Setting CKA_LABEL to '&quot;+labelStr+&quot;'&quot;);</span>
                    }
<span class="nc" id="L383">                    fileContent.set(i, labelStr);</span>
<span class="nc" id="L384">                } else {</span>
                    // If there is no privateKeyLabel, we have to remove the bogus empty CKA_LABEL
<span class="nc" id="L386">                    log.debug(&quot;Removing placeholder CKA_LABEL&quot;);</span>
<span class="nc" id="L387">                    fileContent.remove(i); // .remove() is ok since we break out of the loop here, if we didn't this would be bad practice</span>
                }
<span class="nc" id="L389">                break;</span>
            }
        }
<span class="nc" id="L392">    }</span>

    /**
     * Get the provider without taking care of exceptions.
     * @param is InputStream for sun configuration file.
     * @return The Sun provider
     * @throws ClassNotFoundException If Sun provider not found
     * @throws IllegalArgumentException If illegal args passed
     * @throws SecurityException If security violation
     * @throws InstantiationException If instantiation fails
     * @throws IllegalAccessException if access is illegal
     * @throws InvocationTargetException if invication fails
     * @throws NoSuchMethodException if method not found
     */
    private static Provider getSunP11ProviderNoExceptionHandling(final InputStream is) throws ClassNotFoundException, IllegalArgumentException, SecurityException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
        // Sun PKCS11 has InputStream as constructor argument
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L409">        final Class&lt;? extends Provider&gt; implClass = (Class&lt;? extends Provider&gt;) Class.forName(SUN_PKCS11_CLASS);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L411">            log.debug(&quot;Using SUN PKCS11 provider: &quot; + SUN_PKCS11_CLASS);</span>
        }
<span class="nc" id="L413">        return implClass.getConstructor(InputStream.class).newInstance(new Object[] { is });</span>
    }

    /**
     * @param is InputStream for sun configuration file.
     * @return The Sun provider
     */
    private static Provider getSunP11Provider(final InputStream is) {
        try {
<span class="nc" id="L422">            return getSunP11ProviderNoExceptionHandling(is);</span>
<span class="nc" id="L423">        } catch (Exception e) {</span>
<span class="nc" id="L424">            final String msg = &quot;Error constructing pkcs11 provider: &quot; + e.getMessage();</span>
<span class="nc" id="L425">            log.error(msg);</span>
<span class="nc" id="L426">            throw new IllegalStateException(msg, e);</span>
        }
    }

    /**
     * Creating dummy provider just to have C_Initialize executed with multiple
     * thread argument. {@link Pkcs11Wrapper#getInstance(File)} should call it
     * before making any PKCS#11 calls. If not then C_Initialize will be called
     * with null argument causing multi threading to be disabled for the token.
     * 
     * There is a boolean in the sun code ensuring that C_Initialize is only
     * called once.
     * To check this implementation the p11 spy utils could be used. Check that
     * it is only one C_Initialize call and that null is not passed.
     * @param libFile a file with the path of the p11 module on which C_Finalize should
     * be called.
     */
    static void doC_Initialize(final File libFile) {
        try {
<span class="nc" id="L445">            getSunP11ProviderNoExceptionHandling( getSunP11ProviderInputStream(-1, libFile, Pkcs11SlotLabelType.SLOT_NUMBER, null, null) );</span>
<span class="nc" id="L446">        } catch (InvocationTargetException e) {</span>
            // the p11 module don't like the bogus arguments and throws an exception but we don't bother about this since
            // C_Initialize has already been called with multithread arguments.
<span class="nc" id="L449">            log.debug(&quot;Get dummy sun provider throws an exception for &quot;+libFile.getPath()+&quot;. This is OK.&quot;, e);</span>
<span class="nc" id="L450">        } catch (Exception e) {</span>
<span class="nc" id="L451">            final String msg = &quot;Error constructing pkcs11 provider: &quot; + e.getMessage();</span>
<span class="nc" id="L452">            log.error(msg);</span>
<span class="nc" id="L453">            throw new IllegalStateException(msg, e);</span>
<span class="nc" id="L454">        }</span>
<span class="nc" id="L455">    }</span>

    /**
     * Creates a SUN or IAIK PKCS#11 provider using the passed in pkcs11 library. First we try to see if the IAIK provider is available, because it
     * supports more algorithms. If the IAIK provider is not available in the classpath, we try the SUN provider.
     * 
     * @param sSlot
     *            The value of the slot, which may be a number ([0...9]*), an index i[0...9] or a label, but may also be labels matching the former.
     *            To solve this ambiguity, slots will be presumed to be numbers or indexes if the names match, and if no slot is found by that number
     *            or index will then be presumed to be labels (for legacy reasons). 
     * @param slotLabelType label type
     * @param fileName
     *            the manufacturers provided pkcs11 library (.dll or .so) or config file name if slot is null

     * @param attributesFile
     *            a file specifying PKCS#11 attributes (used mainly for key generation) in the format specified in the
     *            &quot;JavaTM PKCS#11 Reference Guide&quot;, http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html
     * 
     *            Example contents of attributes file:
     * 
     *            attributes(generate,CKO_PRIVATE_KEY,*) = { CKA_PRIVATE = true CKA_SIGN = true CKA_DECRYPT = true CKA_TOKEN = true }
     * 
     *            See also html documentation for PKCS#11 HSMs in EJBCA.
     * 
     * @return AuthProvider of type &quot;sun.security.pkcs11.SunPKCS11&quot;, or null if none is available
     * @throws NoSuchSlotException is no slot as defined by sSlot and slotLabelType was found
     */
    public static Provider getP11Provider(final String sSlot, Pkcs11SlotLabelType slotLabelType, final String fileName, final String attributesFile) throws NoSuchSlotException {
<span class="nc" id="L483">        return getP11Provider(sSlot, slotLabelType, fileName, attributesFile, null);</span>
    }

    /**
     * Creates a SUN or IAIK PKCS#11 provider using the passed in pkcs11 library. First we try to see if the IAIK provider is available, because it
     * supports more algorithms. If the IAIK provider is not available in the classpath, we try the SUN provider.
     * 
     * @param sSlot
     *            The value of the slot, which may be a number ([0...9]*), an index i[0...9] or a label, but may also be labels matching the former.
     *            To solve this ambiguity, slots will be presumed to be numbers or indexes if the names match, and if no slot is found by that number
     *            or index will then be presumed to be labels (for legacy reasons). Can be null if slotLabelType is SUN_FILE, then the slot must be specified in the attributesFile.
     * @param slotLabelType label type
     * @param fileName
     *            the manufacturers provided pkcs11 library (.dll or .so) or config file name if slot is null

     * @param attributesFile
     *            a file specifying PKCS#11 attributes (used mainly for key generation) in the format specified in the
     *            &quot;JavaTM PKCS#11 Reference Guide&quot;, http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html
     * 
     *            Example contents of attributes file:
     * 
     *            attributes(generate,CKO_PRIVATE_KEY,*) = { CKA_PRIVATE = true CKA_SIGN = true CKA_DECRYPT = true CKA_TOKEN = true }
     * 
     *            See also html documentation for PKCS#11 HSMs in EJBCA.
     * @param privateKeyLabel
     *            The private key label to be set to generated keys. null means no label.
     * 
     * @return AuthProvider of type &quot;sun.security.pkcs11.SunPKCS11&quot;, or null if none is available
     * @throws NoSuchSlotException if no slot as defined by this label was found
     */
    public static Provider getP11Provider(final String sSlot, final Pkcs11SlotLabelType slotLabelType, final String fileName,
            final String attributesFile, final String privateKeyLabel) throws NoSuchSlotException {
<span class="nc bnc" id="L515" title="All 6 branches missed.">        if ((sSlot == null || sSlot.length() &lt; 1) &amp;&amp; slotLabelType!=Pkcs11SlotLabelType.SUN_FILE) {</span>
<span class="nc" id="L516">            return null;</span>
        }
<span class="nc" id="L518">        final Pkcs11SlotLabel slotSpec = new Pkcs11SlotLabel(slotLabelType, sSlot);</span>
<span class="nc" id="L519">        return slotSpec.getProvider(fileName, attributesFile, privateKeyLabel);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>