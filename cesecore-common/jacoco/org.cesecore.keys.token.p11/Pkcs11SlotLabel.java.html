<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Pkcs11SlotLabel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.token.p11</a> &gt; <span class="el_source">Pkcs11SlotLabel.java</span></div><h1>Pkcs11SlotLabel.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  EJBCA Community: The OpenSource Certificate Authority                *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.token.p11;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.Provider;
import java.security.Security;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.util.encoders.Hex;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.keys.token.p11.exception.NoSuchSlotException;
import org.cesecore.keys.token.p11.exception.P11RuntimeException;

/**
 * @version $Id: Pkcs11SlotLabel.java 29747 2018-08-25 23:54:33Z anatom $
 *     &lt;p&gt;Object for handling a PKCS#11 Slot Label.
 */
public class Pkcs11SlotLabel {

  /** The name of Suns pkcs11 implementation. */
  public static final String SUN_PKCS11_CLASS = &quot;sun.security.pkcs11.SunPKCS11&quot;;
 /** PKCS11. */
  public static final String IAIK_PKCS11_CLASS =
      &quot;iaik.pkcs.pkcs11.provider.IAIKPkcs11&quot;;
  /** JCE.*/
  public static final String IAIK_JCEPROVIDER_CLASS =
      &quot;iaik.security.provider.IAIK&quot;;

  /** Logger. */
<span class="nc" id="L54">  private static final Logger LOG = Logger.getLogger(Pkcs11SlotLabel.class);</span>

  /** Delimeter.*/
  private static final String DELIMETER = &quot;:&quot;;
  /** Type. */
  private final Pkcs11SlotLabelType type;
  /** Value. */
  private final String value;

  /**
   * Use explicit values.
   *
   * @param aType type
   * @param aValue value
   */
<span class="nc" id="L69">  public Pkcs11SlotLabel(final Pkcs11SlotLabelType aType, final String aValue) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">    if (aType == null) {</span>
<span class="nc" id="L71">      throw new IllegalArgumentException(&quot;Type can not be null&quot;);</span>
    }
<span class="nc" id="L73">    this.type = aType;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">    this.value = aValue == null ? null : aValue.trim();</span>
<span class="nc" id="L75">  }</span>

  /**
   * Get a string that later could be used to create a new object. Use it when
   * you want to store a reference to the slot.
   *
   * @return the string.
   */
  public String getTaggedString() {
<span class="nc" id="L84">    return this.type.name() + DELIMETER + this.value;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L89">    return &quot;Slot type: '&quot; + this.type + &quot;'. Slot value: '&quot; + this.value + &quot;'.&quot;;</span>
  }

  /**
   * Get provider for the slot.
   *
   * @param fileName path name to the P11 module so file or sun config file
   *     (only in the case of {@link #type}=={@link
   *     Pkcs11SlotLabelType#SUN_FILE})
   * @param attributesFile Path to file with P11 attributes to be used when
   *     generating keys with the provider. If null a good default will be used.
   * @param privateKeyLabel Label that will be set to all private keys generated
   *     by the provider. If null no label will be set.
   * @return the provider, or null if none is available.
   * @throws NoSuchSlotException if no slot as defined by this slot label was
   *     found
   */
  public Provider getProvider(
      final String fileName,
      final String attributesFile,
      final String privateKeyLabel)
      throws NoSuchSlotException {
<span class="nc bnc" id="L111" title="All 2 branches missed.">    if (StringUtils.isEmpty(fileName)) {</span>
<span class="nc" id="L112">      throw new IllegalArgumentException(&quot;A file name must be supplied.&quot;);</span>
    }
<span class="nc" id="L114">    final File libFile = new File(fileName);</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">    if (!libFile.isFile() || !libFile.canRead()) {</span>
<span class="nc" id="L116">      throw new IllegalArgumentException(</span>
          &quot;The file &quot; + fileName + &quot; can't be read.&quot;);
    }
    // We will construct the PKCS11 provider (sun.security..., or iaik...) using
    // reflection, because
    // the sun class does not exist on all platforms in jdk5, and we want to be
    // able to compile everything.
<span class="nc bnc" id="L123" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L124">      LOG.debug(&quot;slot spec: &quot; + toString());</span>
    }
<span class="nc bnc" id="L126" title="All 2 branches missed.">    if (this.type</span>
        == Pkcs11SlotLabelType
            .SUN_FILE) { // if sun cfg file then we do not know the name of the
                         // p11 module and we must quit.
      try {
<span class="nc" id="L131">        List&lt;String&gt; fileContent =</span>
            new ArrayList&lt;&gt;(
<span class="nc" id="L133">                Files.readAllLines(</span>
<span class="nc" id="L134">                    Paths.get(fileName), StandardCharsets.UTF_8));</span>
<span class="nc" id="L135">        replaceCkaLabel(fileContent, privateKeyLabel);</span>
<span class="nc" id="L136">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L137">        try (PrintWriter pw = new PrintWriter(baos)) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">          for (String string : fileContent) {</span>
<span class="nc" id="L139">            pw.println(string);</span>
<span class="nc" id="L140">          }</span>
        }
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L143">          LOG.debug(baos.toString());</span>
        }
<span class="nc" id="L145">        try (ByteArrayInputStream inputStream =</span>
<span class="nc" id="L146">            new ByteArrayInputStream(baos.toByteArray())) {</span>
<span class="nc" id="L147">          return getSunP11Provider(inputStream);</span>
        }
<span class="nc" id="L149">      } catch (FileNotFoundException e) {</span>
<span class="nc" id="L150">        throw new IllegalArgumentException(</span>
            &quot;File &quot; + libFile + &quot; was not found.&quot;);
<span class="nc" id="L152">      } catch (IOException e) {</span>
<span class="nc" id="L153">        throw new P11RuntimeException(</span>
<span class="nc" id="L154">            String.format(&quot;The file %s can not be closed after use.&quot;, libFile),</span>
            e);
      }
    }
    final long slot;
<span class="nc" id="L159">    final Pkcs11Wrapper p11 =</span>
<span class="nc" id="L160">        Pkcs11Wrapper.getInstance(</span>
            libFile); // must be called before any provider is created for
                      // libFile
<span class="nc bnc" id="L163" title="All 4 branches missed.">    switch (this.type) {</span>
      case SLOT_LABEL:
<span class="nc" id="L165">        slot = getSlotID(this.value, p11);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (slot &lt; 0) {</span>
<span class="nc" id="L167">          throw new IllegalStateException(</span>
              &quot;Token label '&quot; + this.value + &quot;' not found.&quot;);
        }
        break;
      case SLOT_NUMBER:
<span class="nc" id="L172">        slot = Long.parseLong(this.value);</span>
<span class="nc" id="L173">        break;</span>
      case SLOT_INDEX:
        // Be generous and allow numbers to act as indexes as well
        slot =
<span class="nc" id="L177">            Long.parseLong(</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                (this.value.charAt(0) == 'i'</span>
<span class="nc" id="L179">                    ? this.value.substring(1)</span>
<span class="nc" id="L180">                    : this.value));</span>
<span class="nc" id="L181">        break;</span>
        // $CASES-OMITTED$
      default:
<span class="nc" id="L184">        throw new IllegalStateException(</span>
            &quot;This should not ever happen if all type of slots are tested.&quot;);
    }
     // We will first try to construct the more competent IAIK provider, if it
      // exists in the classpath
<span class="nc" id="L189">      Provider prov = getIAIKP11Provider(slot, libFile, this.type);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">      if (prov != null) {</span>
<span class="nc" id="L191">        return prov;</span>
      }

      // if that does not exist, we will revert back to use the SUN provider
<span class="nc" id="L195">      prov =</span>
<span class="nc" id="L196">          getSunP11Provider(</span>
<span class="nc" id="L197">              getSunP11ProviderInputStream(</span>
                  slot, libFile, this.type, attributesFile, privateKeyLabel));
<span class="nc bnc" id="L199" title="All 2 branches missed.">      if (prov != null) {</span>
<span class="nc" id="L200">        return prov;</span>
      }

<span class="nc" id="L203">    LOG.error(&quot;No provider available.&quot;);</span>
<span class="nc" id="L204">    return null;</span>
  }

  /**
   * @param libFile library file
   * @return a List of &quot;slotId;tokenLabel&quot; in the (indexed) order we get the
   *     from the P11
   */
  public static List&lt;String&gt; getExtendedTokenLabels(final File libFile) {
<span class="nc" id="L213">    final List&lt;String&gt; tokenLabels = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L214">    final Pkcs11Wrapper p11 = Pkcs11Wrapper.getInstance(libFile);</span>
<span class="nc" id="L215">    final long[] slots = p11.getSlotList();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L217">      LOG.debug(&quot;Found numer of slots:\t&quot; + slots.length);</span>
    }
<span class="nc bnc" id="L219" title="All 2 branches missed.">    for (int i = 0; i &lt; slots.length; i++) {</span>
<span class="nc" id="L220">      final long slotID = slots[i];</span>
<span class="nc" id="L221">      final char[] label = p11.getTokenLabel(slotID);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">      if (label == null) {</span>
<span class="nc" id="L223">        continue;</span>
      }
<span class="nc" id="L225">      final String tokenLabel = new String(label);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L227">        LOG.debug(i + &quot;: Found token label:\t&quot; + tokenLabel + &quot;\tid=&quot; + slotID);</span>
      }
<span class="nc" id="L229">      tokenLabels.add(slotID + &quot;;&quot; + tokenLabel.trim());</span>
    }
<span class="nc" id="L231">    return tokenLabels;</span>
  }

  /**
   * Get slot ID for a token label.
   *
   * @param tokenLabel the label.
   * @param p11 object to get slot list and labels for all slots with tokens
   * @return the slot ID.
   * @throws NoSuchSlotException if no slot as defined by tokenLabel was found
   */
  private static long getSlotID(
      final String tokenLabel, final Pkcs11Wrapper p11)
      throws NoSuchSlotException {
<span class="nc" id="L245">    final long[] slots = p11.getSlotList();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L247">      LOG.debug(&quot;Searching for token label:\t&quot; + tokenLabel);</span>
    }

<span class="nc bnc" id="L250" title="All 2 branches missed.">    for (final long slotID : slots) {</span>
<span class="nc" id="L251">      final char[] label = p11.getTokenLabel(slotID);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">      if (label == null) {</span>
<span class="nc" id="L253">        continue;</span>
      }
<span class="nc" id="L255">      final String candidateTokenLabel = new String(label);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L257">        LOG.debug(&quot;Candidate token label:\t&quot; + candidateTokenLabel);</span>
      }
<span class="nc bnc" id="L259" title="All 2 branches missed.">      if (!tokenLabel.equals(candidateTokenLabel.trim())) {</span>
<span class="nc" id="L260">        continue;</span>
      }
<span class="nc bnc" id="L262" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L263">        LOG.debug(</span>
            &quot;Label '&quot; + tokenLabel + &quot;' found. The slot ID is:\t&quot; + slotID);
      }
<span class="nc" id="L266">      return slotID;</span>
    }
<span class="nc" id="L268">    throw new NoSuchSlotException(</span>
        &quot;Token label '&quot; + tokenLabel + &quot;' not found.&quot;);
  }

  /**
   * Get the IAIK provider.
   *
   * @param slot Slot list index or slot ID.
   * @param libFile P11 module so file.
   * @param type type
   * @return the provider
   */
  private static Provider getIAIKP11Provider(
      final long slot, final File libFile, final Pkcs11SlotLabelType type) {
    // Properties for the IAIK PKCS#11 provider
<span class="nc" id="L283">    final Properties prop = new Properties();</span>
    try {
<span class="nc" id="L285">      prop.setProperty(&quot;PKCS11_NATIVE_MODULE&quot;, libFile.getCanonicalPath());</span>
<span class="nc" id="L286">    } catch (IOException e) {</span>
<span class="nc" id="L287">      throw new RuntimeException(</span>
          &quot;Could for unknown reason not construct canonical filename.&quot;, e);
<span class="nc" id="L289">    }</span>
    // If using Slot Index it is denoted by brackets in iaik
<span class="nc" id="L291">    prop.setProperty(</span>
        &quot;SLOT_ID&quot;,
<span class="nc bnc" id="L293" title="All 2 branches missed.">        type.equals(Pkcs11SlotLabelType.SLOT_INDEX)</span>
<span class="nc" id="L294">            ? (&quot;[&quot; + slot + &quot;]&quot;)</span>
<span class="nc" id="L295">            : Long.toString(slot));</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L297">      LOG.debug(prop.toString());</span>
    }
    final Provider ret;
    try {
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L302">      final Class&lt;? extends Provider&gt; implClass =</span>
<span class="nc" id="L303">          (Class&lt;? extends Provider&gt;) Class.forName(IAIK_PKCS11_CLASS);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L305">        LOG.debug(&quot;Using IAIK PKCS11 provider: &quot; + IAIK_PKCS11_CLASS);</span>
      }
      // iaik PKCS11 has Properties as constructor argument
<span class="nc" id="L308">      ret =</span>
          implClass
<span class="nc" id="L310">              .getConstructor(Properties.class)</span>
<span class="nc" id="L311">              .newInstance(new Object[] {prop});</span>
<span class="nc" id="L312">    } catch (InvocationTargetException</span>
        | InstantiationException
        | IllegalAccessException
        | IllegalArgumentException
        | NoSuchMethodException
        | SecurityException
        | ClassNotFoundException e) {
<span class="nc" id="L319">      return null;</span>
<span class="nc" id="L320">    }</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">    if (ret == null) {</span>
<span class="nc" id="L322">      return null;</span>
    }
    try {
      // It's not enough just to add the p11 provider. Depending on algorithms
      // we may have to install the IAIK JCE provider as well in order
      // to support algorithm delegation
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L329">      final Class&lt;? extends Provider&gt; jceImplClass =</span>
<span class="nc" id="L330">          (Class&lt;? extends Provider&gt;) Class.forName(IAIK_JCEPROVIDER_CLASS);</span>
<span class="nc" id="L331">      final Provider iaikProvider = jceImplClass.getConstructor().newInstance();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">      if (Security.getProvider(iaikProvider.getName()) == null) {</span>
<span class="nc" id="L333">        LOG.info(</span>
            &quot;Adding IAIK JCE provider for Delegation: &quot;
                + IAIK_JCEPROVIDER_CLASS);
<span class="nc" id="L336">        Security.addProvider(iaikProvider);</span>
      }
<span class="nc" id="L338">    } catch (InvocationTargetException</span>
        | InstantiationException
        | IllegalAccessException
        | IllegalArgumentException
        | NoSuchMethodException
        | SecurityException
        | ClassNotFoundException e) {
      // NOPMD: Ignore, reflection related errors are handled elsewhere
<span class="nc" id="L346">    }</span>
<span class="nc" id="L347">    return ret;</span>
  }

  /**
   * Get an InputStream to be used to create the Sun provider.
   *
   * @param slot Slot list index or slot ID.
   * @param libFile P11 module so file.
   * @param type a Pkcs11SlotLabelType if the slot is not an ID byt a label for
   *     example.
   * @param attributesFile Path to file with P11 attributes to be used when
   *     generating keys with the provider. If null a good default will be used.
   * @param privateKeyLabel Label that will be set to all private keys generated
   *     by the provider. If null no label will be set.
   * @return the stream
   */
  private static InputStream getSunP11ProviderInputStream(
      final long slot,
      final File libFile,
      final Pkcs11SlotLabelType type,
      final String attributesFile,
      final String privateKeyLabel) {

    // Properties for the SUN PKCS#11 provider
<span class="nc" id="L371">    final String sSlot = Long.toString(slot);</span>
    final String libFilePath;
    try {
<span class="nc" id="L374">      libFilePath = libFile.getCanonicalPath();</span>
<span class="nc" id="L375">    } catch (IOException e) {</span>
<span class="nc" id="L376">      throw new RuntimeException(</span>
          &quot;Could for unknown reason not construct canonical filename.&quot;, e);
<span class="nc" id="L378">    }</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L380">      LOG.debug(</span>
          &quot;&gt;getSunP11ProviderInputStream: &quot;
              + sSlot
              + &quot;, &quot;
              + libFilePath
              + &quot;, &quot;
<span class="nc" id="L386">              + type.toString()</span>
              + &quot;, &quot;
              + attributesFile
              + &quot;, &quot;
              + privateKeyLabel);
    }
<span class="nc" id="L392">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L393">    try (PrintWriter pw = new PrintWriter(baos)) {</span>
<span class="nc" id="L394">      pw.println(&quot;name = &quot; + libFile.getName() + &quot;-slot&quot; + sSlot);</span>
<span class="nc" id="L395">      pw.println(&quot;library = &quot; + libFilePath);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">      if (sSlot != null) {</span>
<span class="nc" id="L397">        pw.println(</span>
            &quot;slot&quot;
<span class="nc bnc" id="L399" title="All 2 branches missed.">                + (type.isEqual(Pkcs11SlotLabelType.SLOT_INDEX)</span>
<span class="nc" id="L400">                    ? &quot;ListIndex&quot;</span>
<span class="nc" id="L401">                    : &quot;&quot;)</span>
                + &quot; = &quot;
                + sSlot);
      }
<span class="nc bnc" id="L405" title="All 2 branches missed.">      if (attributesFile != null) {</span>
        try {
<span class="nc" id="L407">          List&lt;String&gt; fileContent =</span>
              new ArrayList&lt;&gt;(
<span class="nc" id="L409">                  Files.readAllLines(</span>
<span class="nc" id="L410">                      Paths.get(attributesFile), StandardCharsets.UTF_8));</span>
<span class="nc" id="L411">          replaceCkaLabel(fileContent, privateKeyLabel);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">          for (String string : fileContent) {</span>
<span class="nc" id="L413">            pw.println(string);</span>
<span class="nc" id="L414">          }</span>
<span class="nc" id="L415">        } catch (IOException e) {</span>
<span class="nc" id="L416">          throw new IllegalArgumentException(</span>
              &quot;File &quot;
                  + attributesFile
                  + &quot; was not found, or could not be read.&quot;,
              e);
<span class="nc" id="L421">        }</span>
        // pw.println(new String(attrs));
      } else {
        // setting the attributes like this should work for most HSMs.
<span class="nc" id="L425">        pw.println(&quot;attributes(*, CKO_PUBLIC_KEY, *) = {&quot;);</span>
<span class="nc" id="L426">        pw.println(</span>
            &quot;  CKA_TOKEN = false&quot;); // Do not save public keys permanent in
                                    // order to save space.
<span class="nc" id="L429">        pw.println(&quot;  CKA_ENCRYPT = true&quot;);</span>
<span class="nc" id="L430">        pw.println(&quot;  CKA_VERIFY = true&quot;);</span>
<span class="nc" id="L431">        pw.println(</span>
            &quot;  CKA_WRAP = true&quot;); // no harm allowing wrapping of keys. created
                                  // private keys can not be wrapped anyway
                                  // since CKA_EXTRACTABLE
        // is false.
<span class="nc" id="L436">        pw.println(&quot;}&quot;);</span>
<span class="nc" id="L437">        pw.println(&quot;attributes(*, CKO_PRIVATE_KEY, *) = {&quot;);</span>
<span class="nc" id="L438">        pw.println(</span>
            &quot;  CKA_DERIVE = false&quot;); // Amazon CloudHSM will not accept that
                                     // CKA_DERIVE is present in private key
                                     // template and will give
                                     // CKR_TEMPLATE_INCONSISTENT.
<span class="nc" id="L443">        pw.println(</span>
            &quot;  CKA_TOKEN = true&quot;); // all created private keys should be
                                   // permanent. They should not only exist
                                   // during the session.
<span class="nc" id="L447">        pw.println(</span>
            &quot;  CKA_PRIVATE = true&quot;); // always require logon with password to
                                     // use the key
<span class="nc" id="L450">        pw.println(&quot;  CKA_SENSITIVE = true&quot;); // not possible to read the key</span>
<span class="nc" id="L451">        pw.println(</span>
            &quot;  CKA_EXTRACTABLE = false&quot;); // not possible to wrap the key with
                                          // another key
<span class="nc" id="L454">        pw.println(&quot;  CKA_DECRYPT = true&quot;);</span>
<span class="nc" id="L455">        pw.println(&quot;  CKA_SIGN = true&quot;);</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">        if (privateKeyLabel != null &amp;&amp; privateKeyLabel.length() &gt; 0) {</span>
<span class="nc" id="L457">          final String labelStr =</span>
              &quot;  CKA_LABEL = 0h&quot;
<span class="nc" id="L459">                  + new String(Hex.encode(privateKeyLabel.getBytes()));</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L461">            LOG.debug(&quot;Setting CKA_LABEL to '&quot; + labelStr + &quot;'&quot;);</span>
          }
<span class="nc" id="L463">          pw.println(labelStr);</span>
        }
<span class="nc" id="L465">        pw.println(&quot;  CKA_UNWRAP = true&quot;); // for unwrapping of session keys,</span>
<span class="nc" id="L466">        pw.println(&quot;}&quot;);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (CesecoreConfiguration.p11disableHashingSignMechanisms()) {</span>
<span class="nc" id="L468">          pw.println(&quot;disabledMechanisms = {&quot;);</span>
          // by disabling these mechanisms the hashing will be done in the
          // application instead of the HSM.
<span class="nc" id="L471">          pw.println(&quot;  CKM_SHA1_RSA_PKCS&quot;);</span>
<span class="nc" id="L472">          pw.println(&quot;  CKM_SHA256_RSA_PKCS&quot;);</span>
<span class="nc" id="L473">          pw.println(&quot;  CKM_SHA384_RSA_PKCS&quot;);</span>
<span class="nc" id="L474">          pw.println(&quot;  CKM_SHA512_RSA_PKCS&quot;);</span>
<span class="nc" id="L475">          pw.println(&quot;  CKM_MD2_RSA_PKCS&quot;);</span>
<span class="nc" id="L476">          pw.println(&quot;  CKM_MD5_RSA_PKCS&quot;);</span>
<span class="nc" id="L477">          pw.println(&quot;  CKM_DSA_SHA1&quot;);</span>
<span class="nc" id="L478">          pw.println(&quot;  CKM_ECDSA_SHA1&quot;);</span>
<span class="nc" id="L479">          pw.println(&quot;}&quot;);</span>
        }
<span class="nc" id="L481">        pw.println(&quot;attributes(*, CKO_SECRET_KEY, *) = {&quot;);</span>
<span class="nc" id="L482">        pw.println(&quot;  CKA_SENSITIVE = true&quot;); // not possible to read the key</span>
<span class="nc" id="L483">        pw.println(</span>
            &quot;  CKA_EXTRACTABLE = false&quot;); // not possible to wrap the key with
                                          // another key
<span class="nc" id="L486">        pw.println(&quot;  CKA_ENCRYPT = true&quot;);</span>
<span class="nc" id="L487">        pw.println(&quot;  CKA_DECRYPT = true&quot;);</span>
<span class="nc" id="L488">        pw.println(&quot;  CKA_SIGN = true&quot;);</span>
<span class="nc" id="L489">        pw.println(&quot;  CKA_VERIFY = true&quot;);</span>
<span class="nc" id="L490">        pw.println(&quot;  CKA_WRAP = true&quot;); // for unwrapping of session keys,</span>
<span class="nc" id="L491">        pw.println(&quot;  CKA_UNWRAP = true&quot;); // for unwrapping of session keys,</span>
<span class="nc" id="L492">        pw.println(&quot;}&quot;);</span>
      }
    }
<span class="nc bnc" id="L495" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L496">      LOG.debug(baos.toString());</span>
    }
<span class="nc" id="L498">    return new ByteArrayInputStream(baos.toByteArray());</span>
  }

  private static void replaceCkaLabel(
     final  List&lt;String&gt; fileContent, final String privateKeyLabel) {
    // If the attributes file contain a CKA_LABEL without a label, set it to our
    // desired label
<span class="nc bnc" id="L505" title="All 2 branches missed.">    for (int i = 0; i &lt; fileContent.size(); i++) {</span>
<span class="nc" id="L506">      if (fileContent</span>
<span class="nc" id="L507">          .get(i)</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">          .equals(</span>
              &quot;  CKA_LABEL&quot;)) { // just the CKA_LABEL with two spaces before and
                                // nothing, not even a space after
<span class="nc bnc" id="L511" title="All 4 branches missed.">        if (privateKeyLabel != null &amp;&amp; privateKeyLabel.length() &gt; 0) {</span>
<span class="nc" id="L512">          final String labelStr =</span>
              &quot;  CKA_LABEL = 0h&quot;
<span class="nc" id="L514">                  + new String(Hex.encode(privateKeyLabel.getBytes()));</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L516">            LOG.debug(&quot;Setting CKA_LABEL to '&quot; + labelStr + &quot;'&quot;);</span>
          }
<span class="nc" id="L518">          fileContent.set(i, labelStr);</span>
<span class="nc" id="L519">        } else {</span>
          // If there is no privateKeyLabel, we have to remove the bogus empty
          // CKA_LABEL
<span class="nc" id="L522">          LOG.debug(&quot;Removing placeholder CKA_LABEL&quot;);</span>
<span class="nc" id="L523">          fileContent.remove(</span>
              i); // .remove() is ok since we break out of the loop here, if we
                  // didn't this would be bad practice
        }
<span class="nc" id="L527">        break;</span>
      }
    }
<span class="nc" id="L530">  }</span>

  /**
   * Get the provider without taking care of exceptions.
   *
   * @param is InputStream for sun configuration file.
   * @return The Sun provider
   * @throws ClassNotFoundException If Sun provider not found
   * @throws IllegalArgumentException If illegal args passed
   * @throws SecurityException If security violation
   * @throws InstantiationException If instantiation fails
   * @throws IllegalAccessException if access is illegal
   * @throws InvocationTargetException if invication fails
   * @throws NoSuchMethodException if method not found
   */
  private static Provider getSunP11ProviderNoExceptionHandling(
      final InputStream is)
      throws ClassNotFoundException, IllegalArgumentException,
          SecurityException, InstantiationException, IllegalAccessException,
          InvocationTargetException, NoSuchMethodException {
    // Sun PKCS11 has InputStream as constructor argument
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L552">    final Class&lt;? extends Provider&gt; implClass =</span>
<span class="nc" id="L553">        (Class&lt;? extends Provider&gt;) Class.forName(SUN_PKCS11_CLASS);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L555">      LOG.debug(&quot;Using SUN PKCS11 provider: &quot; + SUN_PKCS11_CLASS);</span>
    }
<span class="nc" id="L557">    return implClass</span>
<span class="nc" id="L558">        .getConstructor(InputStream.class)</span>
<span class="nc" id="L559">        .newInstance(new Object[] {is});</span>
  }

  /**
   * @param is InputStream for sun configuration file.
   * @return The Sun provider
   */
  private static Provider getSunP11Provider(final InputStream is) {
    try {
<span class="nc" id="L568">      return getSunP11ProviderNoExceptionHandling(is);</span>
<span class="nc" id="L569">    } catch (Exception e) {</span>
<span class="nc" id="L570">      final String msg =</span>
<span class="nc" id="L571">          &quot;Error constructing pkcs11 provider: &quot; + e.getMessage();</span>
<span class="nc" id="L572">      LOG.error(msg);</span>
<span class="nc" id="L573">      throw new IllegalStateException(msg, e);</span>
    }
  }

  /**
   * Creating dummy provider just to have C_Initialize executed with multiple
   * thread argument. {@link Pkcs11Wrapper#getInstance(File)} should call it
   * before making any PKCS#11 calls. If not then C_Initialize will be called
   * with null argument causing multi threading to be disabled for the token.
   *
   * &lt;p&gt;There is a boolean in the sun code ensuring that C_Initialize is only
   * called once. To check this implementation the p11 spy utils could be used.
   * Check that it is only one C_Initialize call and that null is not passed.
   *
   * @param libFile a file with the path of the p11 module on which C_Finalize
   *     should be called.
   */
  static void doCInitialize(final File libFile) {
    try {
<span class="nc" id="L592">      getSunP11ProviderNoExceptionHandling(</span>
<span class="nc" id="L593">          getSunP11ProviderInputStream(</span>
              -1, libFile, Pkcs11SlotLabelType.SLOT_NUMBER, null, null));
<span class="nc" id="L595">    } catch (InvocationTargetException e) {</span>
      // the p11 module don't like the bogus arguments and throws an exception
      // but we don't bother about this since
      // C_Initialize has already been called with multithread arguments.
<span class="nc" id="L599">      LOG.debug(</span>
          &quot;Get dummy sun provider throws an exception for &quot;
<span class="nc" id="L601">              + libFile.getPath()</span>
              + &quot;. This is OK.&quot;,
          e);
<span class="nc" id="L604">    } catch (Exception e) {</span>
<span class="nc" id="L605">      final String msg =</span>
<span class="nc" id="L606">          &quot;Error constructing pkcs11 provider: &quot; + e.getMessage();</span>
<span class="nc" id="L607">      LOG.error(msg);</span>
<span class="nc" id="L608">      throw new IllegalStateException(msg, e);</span>
<span class="nc" id="L609">    }</span>
<span class="nc" id="L610">  }</span>

  /**
   * Creates a SUN or IAIK PKCS#11 provider using the passed in pkcs11 library.
   * First we try to see if the IAIK provider is available, because it supports
   * more algorithms. If the IAIK provider is not available in the classpath, we
   * try the SUN provider.
   *
   * @param sSlot The value of the slot, which may be a number ([0...9]*), an
   *     index i[0...9] or a label, but may also be labels matching the former.
   *     To solve this ambiguity, slots will be presumed to be numbers or
   *     indexes if the names match, and if no slot is found by that number or
   *     index will then be presumed to be labels (for legacy reasons).
   * @param slotLabelType label type
   * @param fileName the manufacturers provided pkcs11 library (.dll or .so) or
   *     config file name if slot is null
   * @param attributesFile a file specifying PKCS#11 attributes (used mainly for
   *     key generation) in the format specified in the &quot;JavaTM PKCS#11
   *     Reference Guide&quot;,
   *     http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html
   *     &lt;p&gt;Example contents of attributes file:
   *     &lt;p&gt;attributes(generate,CKO_PRIVATE_KEY,*) = { CKA_PRIVATE = true
   *     CKA_SIGN = true CKA_DECRYPT = true CKA_TOKEN = true }
   *     &lt;p&gt;See also html documentation for PKCS#11 HSMs in EJBCA.
   * @return AuthProvider of type &quot;sun.security.pkcs11.SunPKCS11&quot;, or null if
   *     none is available
   * @throws NoSuchSlotException is no slot as defined by sSlot and
   *     slotLabelType was found
   */
  public static Provider getP11Provider(
      final String sSlot,
      final Pkcs11SlotLabelType slotLabelType,
      final String fileName,
      final String attributesFile)
      throws NoSuchSlotException {
<span class="nc" id="L645">    return getP11Provider(sSlot, slotLabelType, fileName, attributesFile, null);</span>
  }

  /**
   * Creates a SUN or IAIK PKCS#11 provider using the passed in pkcs11 library.
   * First we try to see if the IAIK provider is available, because it supports
   * more algorithms. If the IAIK provider is not available in the classpath, we
   * try the SUN provider.
   *
   * @param sSlot The value of the slot, which may be a number ([0...9]*), an
   *     index i[0...9] or a label, but may also be labels matching the former.
   *     To solve this ambiguity, slots will be presumed to be numbers or
   *     indexes if the names match, and if no slot is found by that number or
   *     index will then be presumed to be labels (for legacy reasons). Can be
   *     null if slotLabelType is SUN_FILE, then the slot must be specified in
   *     the attributesFile.
   * @param slotLabelType label type
   * @param fileName the manufacturers provided pkcs11 library (.dll or .so) or
   *     config file name if slot is null
   * @param attributesFile a file specifying PKCS#11 attributes (used mainly for
   *     key generation) in the format specified in the &quot;JavaTM PKCS#11
   *     Reference Guide&quot;,
   *     http://java.sun.com/javase/6/docs/technotes/guides/security/p11guide.html
   *     &lt;p&gt;Example contents of attributes file:
   *     &lt;p&gt;attributes(generate,CKO_PRIVATE_KEY,*) = { CKA_PRIVATE = true
   *     CKA_SIGN = true CKA_DECRYPT = true CKA_TOKEN = true }
   *     &lt;p&gt;See also html documentation for PKCS#11 HSMs in EJBCA.
   * @param privateKeyLabel The private key label to be set to generated keys.
   *     null means no label.
   * @return AuthProvider of type &quot;sun.security.pkcs11.SunPKCS11&quot;, or null if
   *     none is available
   * @throws NoSuchSlotException if no slot as defined by this label was found
   */
  public static Provider getP11Provider(
      final String sSlot,
      final Pkcs11SlotLabelType slotLabelType,
      final String fileName,
      final String attributesFile,
      final String privateKeyLabel)
      throws NoSuchSlotException {
<span class="nc bnc" id="L685" title="All 6 branches missed.">    if ((sSlot == null || sSlot.length() &lt; 1)</span>
        &amp;&amp; slotLabelType != Pkcs11SlotLabelType.SUN_FILE) {
<span class="nc" id="L687">      return null;</span>
    }
<span class="nc" id="L689">    final Pkcs11SlotLabel slotSpec = new Pkcs11SlotLabel(slotLabelType, sSlot);</span>
<span class="nc" id="L690">    return slotSpec.getProvider(fileName, attributesFile, privateKeyLabel);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>