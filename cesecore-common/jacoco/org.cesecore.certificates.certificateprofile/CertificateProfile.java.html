<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CertificateProfile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.certificateprofile</a> &gt; <span class="el_source">CertificateProfile.java</span></div><h1>CertificateProfile.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.certificateprofile;

import java.io.Serializable;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.KeyPurposeId;
import org.cesecore.certificates.ca.ApprovalRequestType;
import org.cesecore.certificates.certificate.CertificateConstants;
import org.cesecore.certificates.certificate.IllegalKeyException;
import org.cesecore.certificates.util.AlgorithmConstants;
import org.cesecore.certificates.util.AlgorithmTools;
import org.cesecore.certificates.util.DNFieldExtractor;
import org.cesecore.certificates.util.DnComponents;
import org.cesecore.internal.InternalResources;
import org.cesecore.internal.UpgradeableDataHashMap;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.util.CertTools;
import org.cesecore.util.ValidityDate;

/**
 * CertificateProfile is a basic class used to customize a certificate
 * configuration or be inherited by fixed certificate profiles.
 *
 * @version $Id: CertificateProfile.java 29578 2018-08-07 12:19:15Z
 *     jekaterina_b_helmes $
 */
public class CertificateProfile extends UpgradeableDataHashMap
    implements Serializable, Cloneable {
    /** Logger. */
<span class="fc" id="L60">  private static final Logger LOG = Logger.getLogger(CertificateProfile.class);</span>
  /** Internal localization of logs and errors. */
  private static final InternalResources INT_RES =
<span class="fc" id="L63">      InternalResources.getInstance();</span>

  // Public Constants
  /** API version. */
  public static final float LATEST_VERSION = (float) 46.0;
  /** Root CA. */
  public static final String ROOTCAPROFILENAME = &quot;ROOTCA&quot;;
  /** Sub CA. */
  public static final String SUBCAPROFILENAME = &quot;SUBCA&quot;;
  /** User. */
  public static final String ENDUSERPROFILENAME = &quot;ENDUSER&quot;;
  /** Signer. */
  public static final String OCSPSIGNERPROFILENAME = &quot;OCSPSIGNER&quot;;
  /** Profile. */
  public static final String SERVERPROFILENAME = &quot;SERVER&quot;;
  /** Auth. */
  public static final String HARDTOKENAUTHPROFILENAME = &quot;HARDTOKEN_AUTH&quot;;
  /** Auth encoding. */
  public static final String HARDTOKENAUTHENCPROFILENAME = &quot;HARDTOKEN_AUTHENC&quot;;
  /** Encoding. */
  public static final String HARDTOKENENCPROFILENAME = &quot;HARDTOKEN_ENC&quot;;
  /** Name. */
  public static final String HARDTOKENSIGNPROFILENAME = &quot;HARDTOKEN_SIGN&quot;;

  /** Names. */
<span class="fc" id="L88">  public static final List&lt;String&gt; FIXED_PROFILENAMES = new ArrayList&lt;&gt;();</span>

  static {
<span class="fc" id="L91">    FIXED_PROFILENAMES.add(ROOTCAPROFILENAME);</span>
<span class="fc" id="L92">    FIXED_PROFILENAMES.add(SUBCAPROFILENAME);</span>
<span class="fc" id="L93">    FIXED_PROFILENAMES.add(ENDUSERPROFILENAME);</span>
<span class="fc" id="L94">    FIXED_PROFILENAMES.add(OCSPSIGNERPROFILENAME);</span>
<span class="fc" id="L95">    FIXED_PROFILENAMES.add(SERVERPROFILENAME);</span>
<span class="fc" id="L96">    FIXED_PROFILENAMES.add(HARDTOKENAUTHPROFILENAME);</span>
<span class="fc" id="L97">    FIXED_PROFILENAMES.add(HARDTOKENAUTHENCPROFILENAME);</span>
<span class="fc" id="L98">    FIXED_PROFILENAMES.add(HARDTOKENENCPROFILENAME);</span>
<span class="fc" id="L99">    FIXED_PROFILENAMES.add(HARDTOKENSIGNPROFILENAME);</span>
  }

  /**
   * Determines if a de-serialized file is compatible with this class.
   *
   * &lt;p&gt;Maintainers must change this value if and only if the new version of
   * this class is not compatible with old versions. See Sun docs for &lt;a
   * href=http://java.sun.com/products/jdk/1.1/docs/guide
   * /serialization/spec/version.doc.html&gt; details. &lt;/a&gt;
   */
  private static final long serialVersionUID = -8069608639716545206L;

  /** Microsoft Template Constants. */
  public static final String MSTEMPL_DOMAINCONTROLLER = &quot;DomainController&quot;;

  /** Templates. */
<span class="fc" id="L116">  public static final String[] AVAILABLE_MSTEMPLATES = {</span>
    MSTEMPL_DOMAINCONTROLLER
  };


  /** Boolean. */
  public static final String TRUE = &quot;true&quot;;
  /** Boolean. */
  public static final String FALSE = &quot;false&quot;;

  /**
   * Determines the access rights in CV Certificates. CV Certificates is used by
   * EU EAC ePassports and is issued by a CVC CA. DG3 is access to fingerprints
   * and DG4 access to iris.
   */
  public static final int CVC_ACCESS_NONE = 0;
  /** Bitmask. */
  public static final int CVC_ACCESS_DG3 = 1;
  /** Bitmask. */
  public static final int CVC_ACCESS_DG4 = 2;
  /** Bitmask. */
  public static final int CVC_ACCESS_DG3DG4 = 3;
  // For signature terminals (defined in version 2.10 of the EAC specification)
  /** Bitmask. */
  public static final int CVC_ACCESS_SIGN = 16;
  /** Bitmask. */
  public static final int CVC_ACCESS_QUALSIGN = 32;
  /** Bitmask. */
  public static final int CVC_ACCESS_SIGN_AND_QUALSIGN = 48;

  /**
   * CVC terminal types. Controls which set of roles and access rights are
   * available.
   */
  public static final int CVC_TERMTYPE_IS = 0;
  /** Authentication terminal. */
  public static final int CVC_TERMTYPE_AT = 1;
  /** Signature terminal. */
  public static final int CVC_TERMTYPE_ST = 2;

  /** Accreditation Body DV for signature terminals. ABs accredits CSPs. */
  public static final int CVC_SIGNTERM_DV_AB = 0;
  /** Certification Service Provider DV for signature terminals. */
  public static final int CVC_SIGNTERM_DV_CSP = 1;

  /** Supported certificate versions. */
  public static final String VERSION_X509V3 = &quot;X509v3&quot;;

  /** Name. */
  public static final String CUSTOMPROFILENAME = &quot;CUSTOM&quot;;

  /**
   * Constant indicating that any CA can be used with this certificate profile.
   */
  public static final int ANYCA = -1;
  /**
   * Constant indicating that any elliptic curve may be used with this profile.
   */
  public static final String ANY_EC_CURVE = &quot;ANY_EC_CURVE&quot;;

  /**
   * Constant holding the default available bit lengths for
   * certificate profiles.
   */
<span class="fc" id="L180">  public static final int[] DEFAULTBITLENGTHS = {</span>
    0, 192, 224, 239, 256, 384, 512, 521, 1024, 1536, 2048, 3072, 4096, 6144,
    8192
  };

  /** Rights. */
<span class="fc" id="L186">  public static final byte[] DEFAULT_CVC_RIGHTS_AT = {0, 0, 0, 0, 0};</span>

  /** Constants for validity and private key usage period. */
  public static final String DEFAULT_CERTIFICATE_VALIDITY = &quot;2y&quot;;
  /**
   * Constant for default validity for fixed profiles is 25 years including 6 or
   * 7 leap days.
   */
  public static final String DEFAULT_CERTIFICATE_VALIDITY_FOR_FIXED_CA =
      &quot;25y7d&quot;;
  /**
   * Constant for default validity offset
   * (for backward compatibility': -10m'!).
   */
  public static final String DEFAULT_CERTIFICATE_VALIDITY_OFFSET = &quot;-10m&quot;;

  /** Offset. */
  public static final long DEFAULT_PRIVATE_KEY_USAGE_PERIOD_OFFSET = 0;
  /** Length. */
  public static final long DEFAULT_PRIVATE_KEY_USAGE_PERIOD_LENGTH =
      730 * 24 * 3600;

  // Profile fields
  /** Version. */
  protected static final String CERTVERSION = &quot;certversion&quot;;
  /** Validity. */
  @Deprecated protected static final String VALIDITY = &quot;validity&quot;;
  /** Validity. */
  protected static final String ENCODED_VALIDITY = &quot;encodedvalidity&quot;;
  /** Validity. */
  protected static final String USE_CERTIFICATE_VALIDITY_OFFSET =
      &quot;usecertificatevalidityoffset&quot;;
  /** Validity. */
  protected static final String CERTIFICATE_VALIDITY_OFFSET =
      &quot;certificatevalidityoffset&quot;;
  /** Expiration. */
  protected static final String USE_EXPIRATION_RESTRICTION_FOR_WEEKDAYS =
      &quot;useexpirationrestrictionforweekdays&quot;;
  /** Expiration. */
  protected static final String EXPIRATION_RESTRICTION_FOR_WEEKDAYS_BEFORE =
      &quot;expirationrestrictionforweekdaysbefore&quot;;
  /** Expiration. */
  protected static final String EXPIRATION_RESTRICTION_WEEKDAYS =
      &quot;expirationrestrictionweekdays&quot;;
  /** Override. */
  protected static final String ALLOWVALIDITYOVERRIDE = &quot;allowvalidityoverride&quot;;
  /** Override. */
  protected static final String ALLOWKEYUSAGEOVERRIDE = &quot;allowkeyusageoverride&quot;;
  /** Revocation. */
  protected static final String ALLOWBACKDATEDREVOCATION =
      &quot;allowbackdatedrevokation&quot;;
  /** Override. */
  protected static final String ALLOWEXTENSIONOVERRIDE =
      &quot;allowextensionoverride&quot;;
  /** Override. */
  protected static final String ALLOWDNOVERRIDE = &quot;allowdnoverride&quot;;
  /** EEI.  */
  protected static final String ALLOWDNOVERRIDEBYEEI = &quot;allowdnoverridebyeei&quot;;
  /** Certs. */
  protected static final String ALLOWCERTSNOVERIDE = &quot;allowcertsnoverride&quot;;
  /** Algos. */
  protected static final String AVAILABLEKEYALGORITHMS =
      &quot;availablekeyalgorithms&quot;;
  /** ECC. */
  protected static final String AVAILABLEECCURVES = &quot;availableeccurves&quot;;
  /** Bit length. */
  protected static final String AVAILABLEBITLENGTHS = &quot;availablebitlengths&quot;;
  /** Bit length. */
  protected static final String MINIMUMAVAILABLEBITLENGTH =
      &quot;minimumavailablebitlength&quot;;
  /** Bit length. */
  protected static final String MAXIMUMAVAILABLEBITLENGTH =
      &quot;maximumavailablebitlength&quot;;
  /** Type. */
  public static final String TYPE = &quot;type&quot;;
  /** CAs. */
  protected static final String AVAILABLECAS = &quot;availablecas&quot;;
  /** Publishers. */
  protected static final String USEDPUBLISHERS = &quot;usedpublishers&quot;;
  /** Postfix. */
  protected static final String USECNPOSTFIX = &quot;usecnpostfix&quot;;
  /** Postix. */
  protected static final String CNPOSTFIX = &quot;cnpostfix&quot;;
  /** DN. */
  protected static final String USESUBJECTDNSUBSET = &quot;usesubjectdnsubset&quot;;
  /** DN. */
  protected static final String SUBJECTDNSUBSET = &quot;subjectdnsubset&quot;;
  /** Alt name. */
  protected static final String USESUBJECTALTNAMESUBSET =
      &quot;usesubjectaltnamesubset&quot;;
  /** Alt name. */
  protected static final String SUBJECTALTNAMESUBSET = &quot;subjectaltnamesubset&quot;;
  /** extensions. */
  protected static final String USEDCERTIFICATEEXTENSIONS =
      &quot;usedcertificateextensions&quot;;
  /**
   * @deprecated since 6.8.0, where approval settings and profiles became
   *     interlinked.
   */
  @Deprecated
  protected static final String APPROVALSETTINGS = &quot;approvalsettings&quot;;
  /**
   * @deprecated since 6.6.0, use the appropriate approval profile instead
   *     Needed for a while in order to be able to import old statedumps from
   *     6.5 and earlier
   */
  @Deprecated
  public static final String NUMOFREQAPPROVALS = &quot;numofreqapprovals&quot;;
  /**
   * @deprecated since 6.8.0, where approval settings and profiles became
   *     interlinked.
   */
  @Deprecated protected static final String APPROVALPROFILE = &quot;approvalProfile&quot;;

  /** Approvals. */
  protected static final String APPROVALS = &quot;approvals&quot;;
  /** Algo. */
  protected static final String SIGNATUREALGORITHM = &quot;signaturealgorithm&quot;;
  /** Storage. */
  protected static final String USECERTIFICATESTORAGE = &quot;usecertificatestorage&quot;;
  /** Data. */
  protected static final String STORECERTIFICATEDATA = &quot;storecertificatedata&quot;;
  /** Name. */
  protected static final String STORESUBJECTALTNAME = &quot;storesubjectaltname&quot;;
  //
  // CRL extensions
  /** CRL. */
  protected static final String USECRLNUMBER = &quot;usecrlnumber&quot;;
  /** CRL. */
  protected static final String CRLNUMBERCRITICAL = &quot;crlnumbercritical&quot;;
  //
  // Certificate extensions
  /** Constraints. */
  protected static final String USEBASICCONSTRAINTS = &quot;usebasicconstrants&quot;;
  /** Constraints. */
  protected static final String BASICCONSTRAINTSCRITICAL =
      &quot;basicconstraintscritical&quot;;
  /** Length. */
  protected static final String USEPATHLENGTHCONSTRAINT =
      &quot;usepathlengthconstraint&quot;;
  /** Length. */
  protected static final String PATHLENGTHCONSTRAINT = &quot;pathlengthconstraint&quot;;
  /** Usage. */
  protected static final String USEKEYUSAGE = &quot;usekeyusage&quot;;
  /** Usage. */
  protected static final String KEYUSAGECRITICAL = &quot;keyusagecritical&quot;;
  /** Usage. */
  protected static final String KEYUSAGE = &quot;keyusage&quot;;
  /** ID. */
  protected static final String USESUBJECTKEYIDENTIFIER =
      &quot;usesubjectkeyidentifier&quot;;
  /** ID. */
  protected static final String SUBJECTKEYIDENTIFIERCRITICAL =
      &quot;subjectkeyidentifiercritical&quot;;
  /** ID. */
  protected static final String USEAUTHORITYKEYIDENTIFIER =
      &quot;useauthoritykeyidentifier&quot;;
  /** ID. */
  protected static final String AUTHORITYKEYIDENTIFIERCRITICAL =
      &quot;authoritykeyidentifiercritical&quot;;
  /** Name. */
  protected static final String USESUBJECTALTERNATIVENAME =
      &quot;usesubjectalternativename&quot;;
  /** Name.. */
  protected static final String SUBJECTALTERNATIVENAMECRITICAL =
      &quot;subjectalternativenamecritical&quot;;
  /** name.. */
  protected static final String USEISSUERALTERNATIVENAME =
      &quot;useissueralternativename&quot;;
  /** Name. */
  protected static final String ISSUERALTERNATIVENAMECRITICAL =
      &quot;issueralternativenamecritical&quot;;
  /** CRL. */
  protected static final String USECRLDISTRIBUTIONPOINT =
      &quot;usecrldistributionpoint&quot;;
  /** CRL. */
  protected static final String USEDEFAULTCRLDISTRIBUTIONPOINT =
      &quot;usedefaultcrldistributionpoint&quot;;
  /** CRL. */
  protected static final String CRLDISTRIBUTIONPOINTCRITICAL =
      &quot;crldistributionpointcritical&quot;;
  /** CRL. */
  protected static final String CRLDISTRIBUTIONPOINTURI =
      &quot;crldistributionpointuri&quot;;
  /** CRL. */
  protected static final String CRLISSUER = &quot;crlissuer&quot;;
  /** CRL. */
  protected static final String USEFRESHESTCRL = &quot;usefreshestcrl&quot;;
  /** CRL. */
  protected static final String USECADEFINEDFRESHESTCRL =
      &quot;usecadefinedfreshestcrl&quot;;
  /** URI. */
  protected static final String FRESHESTCRLURI = &quot;freshestcrluri&quot;;
  /** Policies. */
  protected static final String USECERTIFICATEPOLICIES =
      &quot;usecertificatepolicies&quot;;
  /** Policies. */
  protected static final String CERTIFICATEPOLICIESCRITICAL =
      &quot;certificatepoliciescritical&quot;;
  /** Policy containing oid, User Notice and Cps Url. */
  protected static final String CERTIFICATE_POLICIES = &quot;certificatepolicies&quot;;
 /** Usage. */
  protected static final String USEEXTENDEDKEYUSAGE = &quot;useextendedkeyusage&quot;;
  /** Usage. */
  protected static final String EXTENDEDKEYUSAGE = &quot;extendedkeyusage&quot;;
  /** Usage. */
  protected static final String EXTENDEDKEYUSAGECRITICAL =
      &quot;extendedkeyusagecritical&quot;;
  /** Types. */
  protected static final String USEDOCUMENTTYPELIST = &quot;usedocumenttypelist&quot;;
  /** Types. */
  protected static final String DOCUMENTTYPELISTCRITICAL =
      &quot;documenttypelistcritical&quot;;
  /** Types.. */
  protected static final String DOCUMENTTYPELIST = &quot;documenttypelist&quot;;
  /** Check. */
  protected static final String USEOCSPNOCHECK = &quot;useocspnocheck&quot;;
  /** Access. */
  protected static final String USEAUTHORITYINFORMATIONACCESS =
      &quot;useauthorityinformationaccess&quot;;
  /** Locator. */
  protected static final String USEOCSPSERVICELOCATOR = &quot;useocspservicelocator&quot;;
  /** Issuer. */
  protected static final String USEDEFAULTCAISSUER = &quot;usedefaultcaissuer&quot;;
  /** Locator. */
  protected static final String USEDEFAULTOCSPSERVICELOCATOR =
      &quot;usedefaultocspservicelocator&quot;;
  /** URI. */
  protected static final String OCSPSERVICELOCATORURI = &quot;ocspservicelocatoruri&quot;;
  /** Issuers. */
  protected static final String USECAISSUERS = &quot;usecaissuersuri&quot;;
  /** Issuers. */
  protected static final String CAISSUERS = &quot;caissuers&quot;;
  /** Order. */
  protected static final String USELDAPDNORDER = &quot;useldapdnorder&quot;;
  /** Template. */
  protected static final String USEMICROSOFTTEMPLATE = &quot;usemicrosofttemplate&quot;;
  /** Template. */
  protected static final String MICROSOFTTEMPLATE = &quot;microsofttemplate&quot;;
  /** Number. */
  protected static final String USECARDNUMBER = &quot;usecardnumber&quot;;
  /** Statement. */
  protected static final String USEQCSTATEMENT = &quot;useqcstatement&quot;;
  /** Syntax. */
  protected static final String USEPKIXQCSYNTAXV2 = &quot;usepkixqcsyntaxv2&quot;;
  /** Critical. */
  protected static final String QCSTATEMENTCRITICAL = &quot;useqcstatementcritical&quot;;
  /** Name.*/
  protected static final String QCSTATEMENTRANAME = &quot;useqcstatementraname&quot;;
  /** Semantics. */
  protected static final String QCSSEMANTICSID = &quot;useqcsematicsid&quot;;
  /** Compliance. */
  protected static final String USEQCETSIQCCOMPLIANCE = &quot;useqcetsiqccompliance&quot;;
  /** Limit. */
  protected static final String USEQCETSIVALUELIMIT = &quot;useqcetsivaluelimit&quot;;
  /** Limit. */
  protected static final String QCETSIVALUELIMIT = &quot;qcetsivaluelimit&quot;;
  /** Limit. */
  protected static final String QCETSIVALUELIMITEXP = &quot;qcetsivaluelimitexp&quot;;
  /** Currency. */
  protected static final String QCETSIVALUELIMITCURRENCY =
      &quot;qcetsivaluelimitcurrency&quot;;
  /** Period. */
  protected static final String USEQCETSIRETENTIONPERIOD =
      &quot;useqcetsiretentionperiod&quot;;
  /** Period. */
  protected static final String QCETSIRETENTIONPERIOD = &quot;qcetsiretentionperiod&quot;;
  /** Device. */
  protected static final String USEQCETSISIGNATUREDEVICE =
      &quot;useqcetsisignaturedevice&quot;;
  /** Type. */
  protected static final String USEQCETSITYPE = &quot;useqcetsitype&quot;;
  /** Type. */
  protected static final String QCETSITYPE = &quot;qcetsitype&quot;;
  /** IDs. */
  protected static final String QCETSIPDS = &quot;qcetsipds&quot;;
  /**
   * @deprecated since EJBCA 6.6.1. It was only used in 6.6.0, and is needed to
   *     handle upgrades from that version PDS URLs are now handled in QCETSIPDS
   */
  @Deprecated protected static final String QCETSIPDSURL = &quot;qcetsipdsurl&quot;;
  /**
   * @deprecated since EJBCA 6.6.1. It was only used in 6.6.0, and is needed to
   *     handle upgrades from that version PDS URLs are now handled in QCETSIPDS
   */
  @Deprecated protected static final String QCETSIPDSLANG = &quot;qcetsipdslang&quot;;

  /** Custom. */
  protected static final String USEQCCUSTOMSTRING = &quot;useqccustomstring&quot;;
  /** OID. */
  protected static final String QCCUSTOMSTRINGOID = &quot;qccustomstringoid&quot;;
  /** String. */
  protected static final String QCCUSTOMSTRINGTEXT = &quot;qccustomstringtext&quot;;
  /** Constraints. */
  protected static final String USENAMECONSTRAINTS = &quot;usenameconstraints&quot;;
  /** Constraints. */
  protected static final String NAMECONSTRAINTSCRITICAL =
      &quot;nameconstraintscritical&quot;;
  /** Atributes. */
  protected static final String USESUBJECTDIRATTRIBUTES =
      &quot;usesubjectdirattributes&quot;;
  /** Type. */
  protected static final String CVCTERMINALTYPE = &quot;cvctermtype&quot;;
  /** Rights. */
  protected static final String CVCACCESSRIGHTS = &quot;cvcaccessrights&quot;;
  /** Rights. */
  protected static final String CVCLONGACCESSRIGHTS = &quot;cvclongaccessrights&quot;;
  /** Type. */
  protected static final String CVCSIGNTERMDVTYPE = &quot;cvcsigntermdvtype&quot;;
  /** Period. */
  protected static final String USEPRIVKEYUSAGEPERIOD = &quot;useprivkeyusageperiod&quot;;
  /** Period. */
  protected static final String USEPRIVKEYUSAGEPERIODNOTBEFORE =
      &quot;useprivkeyusageperiodnotbefore&quot;;
  /** Period. */
  protected static final String USEPRIVKEYUSAGEPERIODNOTAFTER =
      &quot;useprivkeyusageperiodnotafter&quot;;
  /** Period. */
  protected static final String PRIVKEYUSAGEPERIODSTARTOFFSET =
      &quot;privkeyusageperiodstartoffset&quot;;
  /** Period. */
  protected static final String PRIVKEYUSAGEPERIODLENGTH =
      &quot;privkeyusageperiodlength&quot;;
  /** Transparency. */
  protected static final String USECERTIFICATETRANSPARENCYINCERTS =
      &quot;usecertificatetransparencyincerts&quot;;
  /** Transparency. */
  protected static final String USECERTIFICATETRANSPARENCYINOCSP =
      &quot;usecertificatetransparencyinocsp&quot;;
  /** Transparency. */
  protected static final String USECERTIFICATETRANSPARENCYINPUBLISHERS =
      &quot;usecertificatetransparencyinpublisher&quot;;

  /* Certificate Transparency */
  /** Existing. */
  protected static final String CTSUBMITEXISTING = &quot;ctsubmitexisting&quot;;
  /** Logs. */
  protected static final String CTLOGS = &quot;ctlogs&quot;;
  /** Labels. */
  protected static final String CTLABELS = &quot;ctlabels&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MIN_TOTAL_SCTS =
      &quot;ctminscts&quot;; // This key is the same as in previous versions

  /** SCTs. */
  @Deprecated
  protected static final String CT_MIN_TOTAL_SCTS_OCSP =
      &quot;ctminsctsocsp&quot;; // This key is also the same as in previous versions

  /** SCTs. */
  @Deprecated
  protected static final String CT_MAX_SCTS =
      &quot;ctmaxscts&quot;; // Only used to fetch old value after upgrade, replaced by
                   // CT_MAX_NON_MANDATORY_SCTS and CT_MAX_MANDATORY_SCTS

  /** SCTs. */
  @Deprecated
  protected static final String CT_MAX_SCTS_OCSP =
      &quot;ctmaxsctsocsp&quot;; // Only used to fetch old value after upgrade, replaced
                       // by CT_MAX_NONMANDATORY_SCTS_OCSP and
                       // CT_MAX_MANDATORY_SCTS

  /* All deprecated below were removed in 6.10.1. Keep for
   * upgrade purposes or move keys to UpgradeSessionBean */
  /** SCTs. */
  @Deprecated
  protected static final String CT_MIN_MANDATORY_SCTS = &quot;ctminmandatoryscts&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MAX_MANDATORY_SCTS = &quot;ctmaxmandatoryscts&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MIN_MANDATORY_SCTS_OCSP =
      &quot;ctminmandatorysctsocsp&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MAX_MANDATORY_SCTS_OCSP =
      &quot;ctmaxmandatorysctsocsp&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MIN_NONMANDATORY_SCTS =
      &quot;ctminnonmandatoryscts&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MAX_NONMANDATORY_SCTS =
      &quot;ctmaxnonmandatoryscts&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MIN_NONMANDATORY_SCTS_OCSP =
      &quot;ctminnonmandatorysctsocsp&quot;;

  /** SCTs. */
  @Deprecated
  protected static final String CT_MAX_NONMANDATORY_SCTS_OCSP =
      &quot;ctmaxnonmandatorysctsocsp&quot;;

  /** SCTs. */
  protected static final String CT_SCTS_MIN = &quot;ctsctsmin&quot;;
  /** SCTs. */
  protected static final String CT_SCTS_MAX = &quot;ctsctsmax&quot;;
  /** SCTs. */
  protected static final String CT_SCTS_MIN_OCSP = &quot;ctsctsminocsp&quot;;
  /** SCTs. */
  protected static final String CT_SCTS_MAX_OCSP = &quot;ctsctsmaxocsp&quot;;
  /** SCTs. */
  protected static final String CT_NUMBER_OF_SCTS_BY_VALIDITY =
      &quot;ctnumberofsctsbyvalidity&quot;;
  /** SCTs. */
  protected static final String CT_NUMBER_OF_SCTS_BY_CUSTOM =
      &quot;ctnumberofsctsbycustom&quot;;
  /** SCTs. */
  protected static final String CT_MAX_NUMBER_OF_SCTS_BY_VALIDITY =
      &quot;ctmaxnumberofsctsbyvalidity&quot;;
  /** SCTs. */
  protected static final String CT_MAX_NUMBER_OF_SCTS_BY_CUSTOM =
      &quot;ctmaxnumberofsctsbycustom&quot;;
  /** Retries. */
  protected static final String CTMAXRETRIES = &quot;ctmaxretries&quot;;

  /** Constraint. */
  protected static final String USERSINGLEACTIVECERTIFICATECONSTRAINT =
      &quot;usesingleactivecertificateconstraint&quot;;
  /** Custom. */
  protected static final String USECUSTOMDNORDER = &quot;usecustomdnorder&quot;;
  /** Custom. */
  protected static final String USECUSTOMDNORDERLDAP = &quot;usecustomdnorderldap&quot;;
  /** Custom. */
  protected static final String CUSTOMDNORDER = &quot;customdnorder&quot;;
  /** Overrideable. */
  protected static final String OVERRIDABLEEXTENSIONOIDS =
      &quot;overridableextensionoids&quot;;
  /** Non-overrideable. */
  protected static final String NONOVERRIDABLEEXTENSIONOIDS =
      &quot;nonoverridableextensionoids&quot;;

  /**
   * OID for creating Smartcard Number Certificate Extension SEIS Cardnumber
   * Extension according to SS 614330/31.
   */
  public static final String OID_CARDNUMBER = &quot;1.2.752.34.2.1&quot;;

  /** Constants holding the use properties for certificate extensions. */
  protected static final HashMap&lt;String, String&gt;
<span class="fc" id="L637">      USE_STD_CERT_EXTENSIONS = new HashMap&lt;&gt;();</span>

  {
<span class="fc" id="L640">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L641">        USEBASICCONSTRAINTS, Extension.basicConstraints.getId());</span>
<span class="fc" id="L642">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L643">        USEKEYUSAGE, Extension.keyUsage.getId());</span>
<span class="fc" id="L644">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L645">        USESUBJECTKEYIDENTIFIER, Extension.subjectKeyIdentifier.getId());</span>
<span class="fc" id="L646">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L647">        USEAUTHORITYKEYIDENTIFIER, Extension.authorityKeyIdentifier.getId());</span>
<span class="fc" id="L648">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L649">        USESUBJECTALTERNATIVENAME, Extension.subjectAlternativeName.getId());</span>
<span class="fc" id="L650">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L651">        USEISSUERALTERNATIVENAME, Extension.issuerAlternativeName.getId());</span>
<span class="fc" id="L652">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L653">        USECRLDISTRIBUTIONPOINT, Extension.cRLDistributionPoints.getId());</span>
<span class="fc" id="L654">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L655">        USEFRESHESTCRL, Extension.freshestCRL.getId());</span>
<span class="fc" id="L656">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L657">        USECERTIFICATEPOLICIES, Extension.certificatePolicies.getId());</span>
<span class="fc" id="L658">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L659">        USEEXTENDEDKEYUSAGE, Extension.extendedKeyUsage.getId());</span>
<span class="fc" id="L660">    USE_STD_CERT_EXTENSIONS.put(</span>
        USEDOCUMENTTYPELIST, &quot;2.23.136.1.1.6.2&quot;);
<span class="fc" id="L662">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L663">        USEQCSTATEMENT, Extension.qCStatements.getId());</span>
<span class="fc" id="L664">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L665">        USENAMECONSTRAINTS, Extension.nameConstraints.getId());</span>
<span class="fc" id="L666">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L667">        USESUBJECTDIRATTRIBUTES, Extension.subjectDirectoryAttributes.getId());</span>
<span class="fc" id="L668">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L669">        USEAUTHORITYINFORMATIONACCESS, Extension.authorityInfoAccess.getId());</span>
<span class="fc" id="L670">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L671">        USEPRIVKEYUSAGEPERIOD, Extension.privateKeyUsagePeriod.getId());</span>
<span class="fc" id="L672">    USE_STD_CERT_EXTENSIONS.put(</span>
<span class="fc" id="L673">        USEOCSPNOCHECK, OCSPObjectIdentifiers.id_pkix_ocsp_nocheck.getId());</span>
<span class="fc" id="L674">    USE_STD_CERT_EXTENSIONS.put(</span>
        USEMICROSOFTTEMPLATE, CertTools.OID_MSTEMPLATE);
<span class="fc" id="L676">    USE_STD_CERT_EXTENSIONS.put(USECARDNUMBER, OID_CARDNUMBER);</span>
  }

  // Old values used to upgrade from v22 to v23
  /** ID. */
  protected static final String CERTIFICATEPOLICYID = &quot;certificatepolicyid&quot;;
  /** Policy Notice Url to CPS field alias in the data structure. */
  protected static final String POLICY_NOTICE_CPS_URL = &quot;policynoticecpsurl&quot;;
  /** Policy Notice User Notice field alias in the data structure. */
  protected static final String POLICY_NOTICE_UNOTICE_TEXT =
      &quot;policynoticeunoticetext&quot;;

  // Public Methods

  /**
   * Creates a new instance of CertificateProfile. The default contructor
   * creates a basic CertificateProfile that is the same as an End User
   * certificateProfile, except that there are _no_ key usages. this means that
   * a certificate issued with a default profile should not be usable for
   * anything. Should be used for testing and where you want to create your own
   * CertificateProfile for specific purposes.
   */
<span class="fc" id="L698">  public CertificateProfile() {</span>
<span class="fc" id="L699">    setCommonDefaults();</span>
<span class="fc" id="L700">  }</span>

  /**
   * Creates a new instance of CertificateProfile
   *
   * &lt;p&gt;These settings are general for all sub-profiles, only differing values
   * are overridden in the sub-profiles. If changing any present value here you
   * must therefore go through all sub-profiles and add an override there. I.e.
   * only add new values here, don't change any present settings.
   *
   * @param type one of CertificateProfileConstants.CERTPROFILE_FIXED_XX, for
   *     example CertificateConstants.CERTPROFILE_NO_PROFILE,
   *     CERTPROFILE_NO_ENDUSER, etc
   */
<span class="fc" id="L714">  public CertificateProfile(final int type) {</span>
<span class="fc" id="L715">    setCommonDefaults();</span>
<span class="fc" id="L716">    setDefaultValues(type);</span>
<span class="fc" id="L717">  }</span>

  private void setCommonDefaults() {
<span class="fc" id="L720">    setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
<span class="fc" id="L721">    setCertificateVersion(VERSION_X509V3);</span>
<span class="fc" id="L722">    setEncodedValidity(DEFAULT_CERTIFICATE_VALIDITY);</span>
<span class="fc" id="L723">    setUseCertificateValidityOffset(false);</span>
<span class="fc" id="L724">    setCertificateValidityOffset(DEFAULT_CERTIFICATE_VALIDITY_OFFSET);</span>
<span class="fc" id="L725">    setUseExpirationRestrictionForWeekdays(false);</span>
<span class="fc" id="L726">    setExpirationRestrictionForWeekdaysExpireBefore(true);</span>
<span class="fc" id="L727">    setDefaultExpirationRestrictionWeekdays();</span>
<span class="fc" id="L728">    setAllowValidityOverride(false);</span>

<span class="fc" id="L730">    setAllowExtensionOverride(false);</span>

<span class="fc" id="L732">    setAllowDNOverride(false);</span>
<span class="fc" id="L733">    setAllowDNOverrideByEndEntityInformation(false);</span>
<span class="fc" id="L734">    setAllowBackdatedRevocation(false);</span>
<span class="fc" id="L735">    setUseCertificateStorage(true);</span>
<span class="fc" id="L736">    setStoreCertificateData(true);</span>
<span class="fc" id="L737">    setStoreSubjectAlternativeName(</span>
        true); // New profiles created after EJBCA 6.6.0 will store SAN by
               // default

<span class="fc" id="L741">    setUseBasicConstraints(true);</span>
<span class="fc" id="L742">    setBasicConstraintsCritical(true);</span>

<span class="fc" id="L744">    setUseSubjectKeyIdentifier(true);</span>
<span class="fc" id="L745">    setSubjectKeyIdentifierCritical(false);</span>

<span class="fc" id="L747">    setUseAuthorityKeyIdentifier(true);</span>
<span class="fc" id="L748">    setAuthorityKeyIdentifierCritical(false);</span>

<span class="fc" id="L750">    setUseSubjectAlternativeName(true);</span>
<span class="fc" id="L751">    setSubjectAlternativeNameCritical(false);</span>

<span class="fc" id="L753">    setUseIssuerAlternativeName(true);</span>
<span class="fc" id="L754">    setIssuerAlternativeNameCritical(false);</span>

<span class="fc" id="L756">    setUseCRLDistributionPoint(false);</span>
<span class="fc" id="L757">    setUseDefaultCRLDistributionPoint(false);</span>
<span class="fc" id="L758">    setCRLDistributionPointCritical(false);</span>
<span class="fc" id="L759">    setCRLDistributionPointURI(&quot;&quot;);</span>
<span class="fc" id="L760">    setUseFreshestCRL(false);</span>
<span class="fc" id="L761">    setUseCADefinedFreshestCRL(false);</span>
<span class="fc" id="L762">    setFreshestCRLURI(&quot;&quot;);</span>
<span class="fc" id="L763">    setCRLIssuer(null);</span>

<span class="fc" id="L765">    setUseCertificatePolicies(false);</span>
<span class="fc" id="L766">    setCertificatePoliciesCritical(false);</span>
<span class="fc" id="L767">    ArrayList&lt;CertificatePolicy&gt; policies = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L768">    setCertificatePolicies(policies);</span>

<span class="fc" id="L770">    setAvailableKeyAlgorithmsAsList(AlgorithmTools.getAvailableKeyAlgorithms());</span>
<span class="fc" id="L771">    setAvailableEcCurvesAsList(Arrays.asList(ANY_EC_CURVE));</span>
<span class="fc" id="L772">    setAvailableBitLengths(DEFAULTBITLENGTHS);</span>
<span class="fc" id="L773">    setSignatureAlgorithm(null);</span>

<span class="fc" id="L775">    setUseKeyUsage(true);</span>
<span class="fc" id="L776">    setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L777">    setAllowKeyUsageOverride(false);</span>
<span class="fc" id="L778">    setKeyUsageCritical(true);</span>

<span class="fc" id="L780">    setUseExtendedKeyUsage(false);</span>
<span class="fc" id="L781">    setExtendedKeyUsage(new ArrayList&lt;String&gt;());</span>
<span class="fc" id="L782">    setExtendedKeyUsageCritical(false);</span>

<span class="fc" id="L784">    setUseDocumentTypeList(false);</span>
<span class="fc" id="L785">    setDocumentTypeListCritical(false);</span>
<span class="fc" id="L786">    setDocumentTypeList(new ArrayList&lt;String&gt;());</span>

<span class="fc" id="L788">    ArrayList&lt;Integer&gt; availablecas = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L789">    availablecas.add(Integer.valueOf(ANYCA));</span>
<span class="fc" id="L790">    setAvailableCAs(availablecas);</span>

<span class="fc" id="L792">    setPublisherList(new ArrayList&lt;Integer&gt;());</span>

<span class="fc" id="L794">    setUseOcspNoCheck(false);</span>

<span class="fc" id="L796">    setUseLdapDnOrder(true);</span>
<span class="fc" id="L797">    setUseCustomDnOrder(false);</span>

<span class="fc" id="L799">    setUseMicrosoftTemplate(false);</span>
<span class="fc" id="L800">    setMicrosoftTemplate(&quot;&quot;);</span>
<span class="fc" id="L801">    setUseCardNumber(false);</span>

<span class="fc" id="L803">    setUseCNPostfix(false);</span>
<span class="fc" id="L804">    setCNPostfix(&quot;&quot;);</span>

<span class="fc" id="L806">    setUseSubjectDNSubSet(false);</span>
<span class="fc" id="L807">    setSubjectDNSubSet(new ArrayList&lt;String&gt;());</span>
<span class="fc" id="L808">    setUseSubjectAltNameSubSet(false);</span>
<span class="fc" id="L809">    setSubjectAltNameSubSet(new ArrayList&lt;Integer&gt;());</span>

<span class="fc" id="L811">    setUsePathLengthConstraint(false);</span>
<span class="fc" id="L812">    setPathLengthConstraint(0);</span>

<span class="fc" id="L814">    setUseQCStatement(false);</span>
<span class="fc" id="L815">    setUsePkixQCSyntaxV2(false);</span>
<span class="fc" id="L816">    setQCStatementCritical(false);</span>
<span class="fc" id="L817">    setQCStatementRAName(null);</span>
<span class="fc" id="L818">    setQCSemanticsId(null);</span>
<span class="fc" id="L819">    setUseQCEtsiQCCompliance(false);</span>
<span class="fc" id="L820">    setUseQCEtsiSignatureDevice(false);</span>
<span class="fc" id="L821">    setUseQCEtsiValueLimit(false);</span>
<span class="fc" id="L822">    setQCEtsiValueLimit(0);</span>
<span class="fc" id="L823">    setQCEtsiValueLimitExp(0);</span>
<span class="fc" id="L824">    setQCEtsiValueLimitCurrency(null);</span>
<span class="fc" id="L825">    setUseQCEtsiRetentionPeriod(false);</span>
<span class="fc" id="L826">    setQCEtsiRetentionPeriod(0);</span>
<span class="fc" id="L827">    setUseQCCustomString(false);</span>
<span class="fc" id="L828">    setQCCustomStringOid(null);</span>
<span class="fc" id="L829">    setQCCustomStringText(null);</span>
<span class="fc" id="L830">    setQCEtsiPds(null);</span>
<span class="fc" id="L831">    setQCEtsiType(null);</span>

<span class="fc" id="L833">    setUseCertificateTransparencyInCerts(false);</span>
<span class="fc" id="L834">    setUseCertificateTransparencyInOCSP(false);</span>
<span class="fc" id="L835">    setUseCertificateTransparencyInPublishers(false);</span>

<span class="fc" id="L837">    setUseSubjectDirAttributes(false);</span>
<span class="fc" id="L838">    setUseNameConstraints(false);</span>
<span class="fc" id="L839">    setUseAuthorityInformationAccess(false);</span>
<span class="fc" id="L840">    setCaIssuers(new ArrayList&lt;String&gt;());</span>
<span class="fc" id="L841">    setUseDefaultCAIssuer(false);</span>
<span class="fc" id="L842">    setUseDefaultOCSPServiceLocator(false);</span>
<span class="fc" id="L843">    setOCSPServiceLocatorURI(&quot;&quot;);</span>

    // Default to have access to fingerprint and iris
<span class="fc" id="L846">    setCVCAccessRights(CertificateProfile.CVC_ACCESS_DG3DG4);</span>

<span class="fc" id="L848">    setUsedCertificateExtensions(new ArrayList&lt;Integer&gt;());</span>
<span class="fc" id="L849">    setApprovals(new LinkedHashMap&lt;ApprovalRequestType, Integer&gt;());</span>

    // PrivateKeyUsagePeriod extension
<span class="fc" id="L852">    setUsePrivateKeyUsagePeriodNotBefore(false);</span>
<span class="fc" id="L853">    setUsePrivateKeyUsagePeriodNotAfter(false);</span>
<span class="fc" id="L854">    setPrivateKeyUsagePeriodStartOffset(</span>
        DEFAULT_PRIVATE_KEY_USAGE_PERIOD_OFFSET);
<span class="fc" id="L856">    setPrivateKeyUsagePeriodLength(DEFAULT_PRIVATE_KEY_USAGE_PERIOD_LENGTH);</span>

<span class="fc" id="L858">    setSingleActiveCertificateConstraint(false);</span>

<span class="fc" id="L860">    setOverridableExtensionOIDs(new LinkedHashSet&lt;String&gt;());</span>
<span class="fc" id="L861">    setNonOverridableExtensionOIDs(new LinkedHashSet&lt;String&gt;());</span>
<span class="fc" id="L862">  }</span>

  /**
   * @param type one of CertificateProfileConstants.CERTPROFILE_FIXED_XX, for
   *     example CertificateConstants.CERTPROFILE_FIXED_ROOTCA
   */
  private void setDefaultValues(final int type) {
<span class="fc bfc" id="L869" title="All 2 branches covered.">    if (type == CertificateProfileConstants.CERTPROFILE_FIXED_ROOTCA) {</span>
<span class="fc" id="L870">      setType(CertificateConstants.CERTTYPE_ROOTCA);</span>
<span class="fc" id="L871">      setAllowValidityOverride(true);</span>
<span class="fc" id="L872">      setUseKeyUsage(true);</span>
<span class="fc" id="L873">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L874">      setKeyUsage(CertificateConstants.DIGITALSIGNATURE, true);</span>
<span class="fc" id="L875">      setKeyUsage(CertificateConstants.KEYCERTSIGN, true);</span>
<span class="fc" id="L876">      setKeyUsage(CertificateConstants.CRLSIGN, true);</span>
<span class="fc" id="L877">      setKeyUsageCritical(true);</span>
<span class="fc" id="L878">      setEncodedValidity(DEFAULT_CERTIFICATE_VALIDITY_FOR_FIXED_CA);</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">    } else if (type == CertificateProfileConstants.CERTPROFILE_FIXED_SUBCA) {</span>
<span class="fc" id="L880">      setType(CertificateConstants.CERTTYPE_SUBCA);</span>
<span class="fc" id="L881">      setAllowValidityOverride(true);</span>
<span class="fc" id="L882">      setUseKeyUsage(true);</span>
<span class="fc" id="L883">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L884">      setKeyUsage(CertificateConstants.DIGITALSIGNATURE, true);</span>
<span class="fc" id="L885">      setKeyUsage(CertificateConstants.KEYCERTSIGN, true);</span>
<span class="fc" id="L886">      setKeyUsage(CertificateConstants.CRLSIGN, true);</span>
<span class="fc" id="L887">      setKeyUsageCritical(true);</span>
<span class="fc" id="L888">      setEncodedValidity(DEFAULT_CERTIFICATE_VALIDITY_FOR_FIXED_CA);</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">    } else if (type == CertificateProfileConstants.CERTPROFILE_FIXED_ENDUSER) {</span>
<span class="fc" id="L890">      setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
      // Standard key usages for end users are: digitalSignature |
      // nonRepudiation, and/or (keyEncipherment or keyAgreement)
      // Default key usage is digitalSignature | nonRepudiation |
      // keyEncipherment
      // Create an array for KeyUsage according to X509Certificate.getKeyUsage()
<span class="fc" id="L896">      setUseKeyUsage(true);</span>
<span class="fc" id="L897">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L898">      setKeyUsage(CertificateConstants.DIGITALSIGNATURE, true);</span>
<span class="fc" id="L899">      setKeyUsage(CertificateConstants.NONREPUDIATION, true);</span>
<span class="fc" id="L900">      setKeyUsage(CertificateConstants.KEYENCIPHERMENT, true);</span>
<span class="fc" id="L901">      setKeyUsageCritical(true);</span>
<span class="fc" id="L902">      setUseExtendedKeyUsage(true);</span>
<span class="fc" id="L903">      ArrayList&lt;String&gt; eku = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L904">      eku.add(KeyPurposeId.id_kp_clientAuth.getId());</span>
<span class="fc" id="L905">      eku.add(KeyPurposeId.id_kp_emailProtection.getId());</span>
<span class="fc" id="L906">      setExtendedKeyUsage(eku);</span>
<span class="fc" id="L907">      setExtendedKeyUsageCritical(false);</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">    } else if (type</span>
        == CertificateProfileConstants.CERTPROFILE_FIXED_OCSPSIGNER) {
<span class="fc" id="L910">      setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
      // Default key usage for an OCSP signer is digitalSignature
      // Create an array for KeyUsage acoording to X509Certificate.getKeyUsage()
<span class="fc" id="L913">      setUseKeyUsage(true);</span>
<span class="fc" id="L914">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L915">      setKeyUsage(CertificateConstants.DIGITALSIGNATURE, true);</span>
<span class="fc" id="L916">      setKeyUsageCritical(true);</span>
<span class="fc" id="L917">      setUseExtendedKeyUsage(true);</span>
<span class="fc" id="L918">      ArrayList&lt;String&gt; eku = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L919">      eku.add(KeyPurposeId.id_kp_OCSPSigning.getId());</span>
<span class="fc" id="L920">      setExtendedKeyUsage(eku);</span>
<span class="fc" id="L921">      setExtendedKeyUsageCritical(false);</span>
<span class="fc" id="L922">      setUseOcspNoCheck(true);</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">    } else if (type == CertificateProfileConstants.CERTPROFILE_FIXED_SERVER) {</span>
<span class="fc" id="L924">      setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
      // Standard key usages for server are: digitalSignature | (keyEncipherment
      // or keyAgreement)
      // Default key usage is digitalSignature | keyEncipherment
      // Create an array for KeyUsage acoording to X509Certificate.getKeyUsage()
<span class="fc" id="L929">      setUseKeyUsage(true);</span>
<span class="fc" id="L930">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L931">      setKeyUsage(CertificateConstants.DIGITALSIGNATURE, true);</span>
<span class="fc" id="L932">      setKeyUsage(CertificateConstants.KEYENCIPHERMENT, true);</span>
<span class="fc" id="L933">      setKeyUsageCritical(true);</span>
<span class="fc" id="L934">      setUseExtendedKeyUsage(true);</span>
<span class="fc" id="L935">      ArrayList&lt;String&gt; eku = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L936">      eku.add(KeyPurposeId.id_kp_serverAuth.getId());</span>
<span class="fc" id="L937">      setExtendedKeyUsage(eku);</span>
<span class="fc" id="L938">      setExtendedKeyUsageCritical(false);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">    } else if (type</span>
        == CertificateProfileConstants.CERTPROFILE_FIXED_HARDTOKENAUTH) {
<span class="fc" id="L941">      setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
<span class="fc" id="L942">      setUseKeyUsage(true);</span>
<span class="fc" id="L943">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L944">      setKeyUsage(CertificateConstants.DIGITALSIGNATURE, true);</span>
<span class="fc" id="L945">      setKeyUsageCritical(true);</span>
<span class="fc" id="L946">      setUseExtendedKeyUsage(true);</span>
<span class="fc" id="L947">      ArrayList&lt;String&gt; eku = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L948">      eku.add(KeyPurposeId.id_kp_clientAuth.getId());</span>
<span class="fc" id="L949">      eku.add(KeyPurposeId.id_kp_smartcardlogon.getId());</span>
<span class="fc" id="L950">      setExtendedKeyUsage(eku);</span>
<span class="fc" id="L951">      setExtendedKeyUsageCritical(false);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">    } else if (type</span>
        == CertificateProfileConstants.CERTPROFILE_FIXED_HARDTOKENAUTHENC) {
<span class="fc" id="L954">      setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
<span class="fc" id="L955">      setUseKeyUsage(true);</span>
<span class="fc" id="L956">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L957">      setKeyUsage(CertificateConstants.KEYENCIPHERMENT, true);</span>
<span class="fc" id="L958">      setKeyUsage(CertificateConstants.DIGITALSIGNATURE, true);</span>
<span class="fc" id="L959">      setKeyUsageCritical(true);</span>
<span class="fc" id="L960">      setUseExtendedKeyUsage(true);</span>
<span class="fc" id="L961">      ArrayList&lt;String&gt; eku = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L962">      eku.add(KeyPurposeId.id_kp_clientAuth.getId());</span>
<span class="fc" id="L963">      eku.add(KeyPurposeId.id_kp_emailProtection.getId());</span>
<span class="fc" id="L964">      eku.add(KeyPurposeId.id_kp_smartcardlogon.getId());</span>
<span class="fc" id="L965">      setExtendedKeyUsage(eku);</span>
<span class="fc" id="L966">      setExtendedKeyUsageCritical(false);</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">    } else if (type</span>
        == CertificateProfileConstants.CERTPROFILE_FIXED_HARDTOKENENC) {
<span class="fc" id="L969">      setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
<span class="fc" id="L970">      setUseKeyUsage(true);</span>
<span class="fc" id="L971">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L972">      setKeyUsage(CertificateConstants.KEYENCIPHERMENT, true);</span>
<span class="fc" id="L973">      setKeyUsageCritical(true);</span>
<span class="fc" id="L974">      setUseExtendedKeyUsage(true);</span>
<span class="fc" id="L975">      ArrayList&lt;String&gt; eku = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L976">      eku.add(KeyPurposeId.id_kp_emailProtection.getId());</span>
<span class="fc" id="L977">      setExtendedKeyUsage(eku);</span>
<span class="fc" id="L978">      setExtendedKeyUsageCritical(false);</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">    } else if (type</span>
        == CertificateProfileConstants.CERTPROFILE_FIXED_HARDTOKENSIGN) {
<span class="fc" id="L981">      setType(CertificateConstants.CERTTYPE_ENDENTITY);</span>
<span class="fc" id="L982">      setUseKeyUsage(true);</span>
<span class="fc" id="L983">      setKeyUsage(new boolean[KEY_USAGE_LENGTH]);</span>
<span class="fc" id="L984">      setKeyUsage(CertificateConstants.NONREPUDIATION, true);</span>
<span class="fc" id="L985">      setKeyUsageCritical(true);</span>
<span class="fc" id="L986">      setUseExtendedKeyUsage(true);</span>
<span class="fc" id="L987">      ArrayList&lt;String&gt; eku = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L988">      eku.add(KeyPurposeId.id_kp_emailProtection.getId());</span>
<span class="fc" id="L989">      setExtendedKeyUsage(eku);</span>
<span class="fc" id="L990">      setExtendedKeyUsageCritical(false);</span>
    }
<span class="fc" id="L992">  }</span>

  /** size of usage array. */
  private static final int KEY_USAGE_LENGTH = 9;

  // Public Methods.
  /**
   * @return the version of the certificate, should be one of the VERSION_
   *     constants defined in CertificateProfile class.
   */
  public String getCertificateVersion() {
<span class="fc" id="L1003">    return (String) data.get(CERTVERSION);</span>
  }

  /**
   * Sets the version of the certificate, should be one of the VERSION_
   * constants defined in CertificateProfile class.
   *
   * @param version version
   */
  public void setCertificateVersion(final String version) {
<span class="fc" id="L1013">    data.put(CERTVERSION, version);</span>
<span class="fc" id="L1014">  }</span>

  /**
   * @see ValidityDate#getDateBeforeVersion661(long, java.util.Date)
   * @return a long that is used to provide the end date of certificates for
   *     this profile, interpreted by ValidityDate#getDate
   * @deprecated since since EJBCA 6.6.1
   */
  @Deprecated
  public long getValidity() {
<span class="nc" id="L1024">    return ((Long) data.get(VALIDITY)).longValue();</span>
  }

  /**
   * Gets the encoded validity.
   *
   * @return the validity as ISO8601 date or relative time.
   * @see org.cesecore.util.ValidityDate ValidityDate
   * @see org.cesecore.util.SimpleTime SimpleTime
   */
  @SuppressWarnings(&quot;deprecation&quot;)
  public String getEncodedValidity() {
<span class="fc" id="L1036">    String result = (String) data.get(ENCODED_VALIDITY);</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">    if (StringUtils.isBlank(result)) {</span>
<span class="nc" id="L1038">      result = ValidityDate.getStringBeforeVersion661(getValidity());</span>
<span class="nc" id="L1039">      setEncodedValidity(result);</span>
    }
<span class="fc" id="L1041">    return result;</span>
  }

  /**
   * Sets the encoded validity .
   *
   * @param encodedValidity the validity as ISO8601 date or relative time.
   * @see org.cesecore.util.ValidityDate ValidityDate
   * @see org.cesecore.util.SimpleTime SimpleTime
   */
  public void setEncodedValidity(final String encodedValidity) {
<span class="fc" id="L1052">    data.put(ENCODED_VALIDITY, encodedValidity);</span>
<span class="fc" id="L1053">  }</span>

  /**
   * Gets the certificate validity offset.
   *
   * @return true if we should overwrite the default certificate validity offset
   *     with the one specified in the certificate profile.
   * @see #setCertificateValidityOffset
   */
  public boolean getUseCertificateValidityOffset() {
    // Extra null check to handle in-development upgrades
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">    if (data.get(USE_CERTIFICATE_VALIDITY_OFFSET) != null) {</span>
<span class="fc" id="L1065">      return Boolean.valueOf(</span>
<span class="fc" id="L1066">          (Boolean) data.get(USE_CERTIFICATE_VALIDITY_OFFSET));</span>
    } else {
<span class="nc" id="L1068">      return false;</span>
    }
  }

  /**
   * Use certificate validity offset.
   *
   * @param enabled boolean
   */
  public void setUseCertificateValidityOffset(final boolean enabled) {
<span class="fc" id="L1078">    data.put(USE_CERTIFICATE_VALIDITY_OFFSET, Boolean.valueOf(enabled));</span>
<span class="fc" id="L1079">  }</span>

  /**
   * Gets the certificate validity offset.
   *
   * @return the offset as simple time string with seconds precision (i.e.
   *     '-10m')
   * @see org.cesecore.util.SimpleTime
   */
  public String getCertificateValidityOffset() {
<span class="fc" id="L1089">    return (String) data.get(CERTIFICATE_VALIDITY_OFFSET);</span>
  }

  /**
   * Sets the certificate not before offset.
   *
   * @param simpleTime the offset as simple time string with seconds precision.
   * @see org.cesecore.util.SimpleTime
   */
  public void setCertificateValidityOffset(final String simpleTime) {
<span class="fc" id="L1099">    data.put(CERTIFICATE_VALIDITY_OFFSET, simpleTime);</span>
<span class="fc" id="L1100">  }</span>

  /**
   * @return true if we should apply restrictions that certificate expiration
   *     can only occur on week days specified by
   *     setExpirationRestrictionWeekday
   * @see #setExpirationRestrictionWeekdays(boolean[])
   */
  public boolean getUseExpirationRestrictionForWeekdays() {
<span class="fc" id="L1109">    return Boolean.valueOf(</span>
<span class="fc" id="L1110">        (Boolean) data.get(USE_EXPIRATION_RESTRICTION_FOR_WEEKDAYS));</span>
  }

  /**
   * Use validity expiration restriction.
   *
   * @param enabled boolean
   */
  public void setUseExpirationRestrictionForWeekdays(final boolean enabled) {
<span class="fc" id="L1119">    data.put(USE_EXPIRATION_RESTRICTION_FOR_WEEKDAYS, Boolean.valueOf(enabled));</span>
<span class="fc" id="L1120">  }</span>

  /**
   * @return true if we should roll back expiration or false of we should roll
   *     forward expiration to match week days specified by
   *     setExpirationRestrictionWeekday
   * @see #setExpirationRestrictionWeekdays(boolean[])
   */
  public boolean getExpirationRestrictionForWeekdaysExpireBefore() {
<span class="fc" id="L1129">    return Boolean.valueOf(</span>
<span class="fc" id="L1130">        (Boolean) data.get(EXPIRATION_RESTRICTION_FOR_WEEKDAYS_BEFORE));</span>
  }

  /**
   * Sets if the certificate validity shall expire earlier as requested if a the
   * expiration restriction was applied?
   *
   * @param enabled true, otherwise false.
   */
  public void setExpirationRestrictionForWeekdaysExpireBefore(
          final boolean enabled) {
<span class="fc" id="L1141">    data.put(</span>
<span class="fc" id="L1142">        EXPIRATION_RESTRICTION_FOR_WEEKDAYS_BEFORE, Boolean.valueOf(enabled));</span>
<span class="fc" id="L1143">  }</span>

  /**
   * @param weekday (see java.util.Calendar.MONDAY - SUNDAY)
   * @return true if the weekday is selected as validity expiration restriction.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public boolean getExpirationRestrictionWeekday(final int weekday) {
<span class="nc" id="L1151">    return ((ArrayList&lt;Boolean&gt;) data.get(EXPIRATION_RESTRICTION_WEEKDAYS))</span>
<span class="nc" id="L1152">        .get(weekday - 1)</span>
<span class="nc" id="L1153">        .booleanValue();</span>
  }

  /**
   * Include a weekday as validity expiration restriction.
   *
   * @param weekday (see java.util.Calendar.MONDAY - SUNDAY)
   * @param enabled boolean
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setExpirationRestrictionWeekday(
          final int weekday, final boolean enabled) {
<span class="fc" id="L1165">    ((ArrayList&lt;Boolean&gt;) data.get(EXPIRATION_RESTRICTION_WEEKDAYS))</span>
<span class="fc" id="L1166">        .set(weekday - 1, Boolean.valueOf(enabled));</span>
<span class="fc" id="L1167">  }</span>

  /**
   * Gets a copy of the List&amp;lt;Boolean&amp;gt; where validity restriction for
   * weekdays are stored.
   *
   * @return boolean array.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public boolean[] getExpirationRestrictionWeekdays() {
<span class="fc" id="L1177">    final ArrayList&lt;Boolean&gt; list =</span>
<span class="fc" id="L1178">        (ArrayList&lt;Boolean&gt;) data.get(EXPIRATION_RESTRICTION_WEEKDAYS);</span>
<span class="fc" id="L1179">    final boolean[] result = new boolean[list.size()];</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">    for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="fc" id="L1181">      result[i] = list.get(i).booleanValue();</span>
    }
<span class="fc" id="L1183">    return result;</span>
  }

  private void setExpirationRestrictionWeekdays(final boolean[] weekdays) {
<span class="fc" id="L1187">    final ArrayList&lt;Boolean&gt; list = new ArrayList&lt;Boolean&gt;(weekdays.length);</span>
<span class="fc bfc" id="L1188" title="All 2 branches covered.">    for (int i = 0; i &lt; weekdays.length; i++) {</span>
<span class="fc" id="L1189">      list.add(Boolean.valueOf(weekdays[i]));</span>
    }
<span class="fc" id="L1191">    data.put(EXPIRATION_RESTRICTION_WEEKDAYS, list);</span>
<span class="fc" id="L1192">  }</span>

  private void setDefaultExpirationRestrictionWeekdays() {
<span class="fc" id="L1195">    setExpirationRestrictionWeekdays(new boolean[DAYS_IN_WEEK]);</span>
<span class="fc" id="L1196">    setExpirationRestrictionWeekday(Calendar.MONDAY, true);</span>
<span class="fc" id="L1197">    setExpirationRestrictionWeekday(Calendar.FRIDAY, true);</span>
<span class="fc" id="L1198">    setExpirationRestrictionWeekday(Calendar.SATURDAY, true);</span>
<span class="fc" id="L1199">    setExpirationRestrictionWeekday(Calendar.SUNDAY, true);</span>
<span class="fc" id="L1200">  }</span>
  /** Days in week. */
  private static final int DAYS_IN_WEEK = 7;

  /**
   * If validity override is allowed, a certificate can have a shorter validity
   * than the one specified in the certificate profile, but never longer. A
   * certificate created with validity override can hava a starting point in the
   * future.
   *
   * @return true if validity override is allowed
   */
  public boolean getAllowValidityOverride() {
<span class="fc" id="L1213">    return ((Boolean) data.get(ALLOWVALIDITYOVERRIDE)).booleanValue();</span>
  }

  /**
   * If validity override is allowed, a certificate can have a shorter validity
   * than the one specified in the certificate profile, but never longer. A
   * certificate created with validity override can hava a starting point in the
   * future.
   *
   * @param allowvalidityoverride boolean
   */
  public void setAllowValidityOverride(final boolean allowvalidityoverride) {
<span class="fc" id="L1225">    data.put(ALLOWVALIDITYOVERRIDE, Boolean.valueOf(allowvalidityoverride));</span>
<span class="fc" id="L1226">  }</span>

  /**
   * If extension override is allowed, the X509 certificate extension created in
   * a certificate can come from the request sent by the user. If the request
   * contains an extension than will be used instead of the one defined in the
   * profile. If the request does not contain an extension, the one defined in
   * the profile will be used.
   *
   * @return boolean
   */
  public boolean getAllowExtensionOverride() {
<span class="fc" id="L1238">    Object d = data.get(ALLOWEXTENSIONOVERRIDE);</span>
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">    if (d == null) {</span>
<span class="nc" id="L1240">      return false;</span>
    }
<span class="fc" id="L1242">    return ((Boolean) d).booleanValue();</span>
  }

  /**
   * @param allowextensionoverride boolean
   * @see #getAllowExtensionOverride()
   */
  public void setAllowExtensionOverride(final boolean allowextensionoverride) {
<span class="fc" id="L1250">    data.put(ALLOWEXTENSIONOVERRIDE, Boolean.valueOf(allowextensionoverride));</span>
<span class="fc" id="L1251">  }</span>

  /**
   * If DN override is allowed, the X509 subject DN extension created in a
   * certificate can come directly from the CSR in the request sent by the user.
   * This is instead of the normal way where the user's registered DN is used.
   *
   * @return boolean
   */
  public boolean getAllowDNOverride() {
<span class="fc" id="L1261">    Object d = data.get(ALLOWDNOVERRIDE);</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">    if (d == null) {</span>
<span class="nc" id="L1263">      return false;</span>
    }
<span class="fc" id="L1265">    return ((Boolean) d).booleanValue();</span>
  }

  /**
   * @param allowdnoverride boolean
   * @see #getAllowDNOverride()
   */
  public void setAllowDNOverride(final boolean allowdnoverride) {
<span class="fc" id="L1273">    data.put(ALLOWDNOVERRIDE, Boolean.valueOf(allowdnoverride));</span>
<span class="fc" id="L1274">  }</span>

  /**
   * If DN override by End Entity Information is allowed, the X509 subject DN
   * extension created in a certificate can come directly from the request meta
   * information sent by the user. This is instead of the normal way where the
   * user's registered DN is used.
   *
   * @return boolean
   */
  public boolean getAllowDNOverrideByEndEntityInformation() {
<span class="nc" id="L1285">    Object d = data.get(ALLOWDNOVERRIDEBYEEI);</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">    if (d == null) {</span>
<span class="nc" id="L1287">      return false;</span>
    }
<span class="nc" id="L1289">    return ((Boolean) d).booleanValue();</span>
  }

  /**
   * @param value boolean
   * @see #getAllowDNOverrideByEndEntityInformation()
   */
  public void setAllowDNOverrideByEndEntityInformation(final boolean value) {
<span class="fc" id="L1297">    data.put(ALLOWDNOVERRIDEBYEEI, Boolean.valueOf(value));</span>
<span class="fc" id="L1298">  }</span>

  /**
   * If override is allowed the serial number could be specified.
   *
   * @return true if allowed
   */
  public boolean getAllowCertSerialNumberOverride() {
<span class="fc" id="L1306">    Object d = data.get(ALLOWCERTSNOVERIDE);</span>
<span class="fc bfc" id="L1307" title="All 2 branches covered.">    if (d == null) {</span>
<span class="fc" id="L1308">      return false;</span>
    }
<span class="fc" id="L1310">    return ((Boolean) d).booleanValue();</span>
  }

  /**
   * @see #getAllowDNOverride()
   * @param allowdnoverride new value
   */
  public void setAllowCertSerialNumberOverride(final boolean allowdnoverride) {
<span class="fc" id="L1318">    data.put(ALLOWCERTSNOVERIDE, Boolean.valueOf(allowdnoverride));</span>
<span class="fc" id="L1319">  }</span>

  /**
   * @return bool
   */
  public boolean getUseBasicConstraints() {
<span class="fc" id="L1325">    return ((Boolean) data.get(USEBASICCONSTRAINTS)).booleanValue();</span>
  }

  /**
   * @param usebasicconstraints bool
   */
  public void setUseBasicConstraints(final boolean usebasicconstraints) {
<span class="fc" id="L1332">    data.put(USEBASICCONSTRAINTS, Boolean.valueOf(usebasicconstraints));</span>
<span class="fc" id="L1333">  }</span>

  /**
   * @return bool
   */
  public boolean getBasicConstraintsCritical() {
<span class="fc" id="L1339">    return ((Boolean) data.get(BASICCONSTRAINTSCRITICAL)).booleanValue();</span>
  }

  /**
   * @param basicconstraintscritical bool
   */
  public void setBasicConstraintsCritical(
          final boolean basicconstraintscritical) {
<span class="fc" id="L1347">    data.put(</span>
<span class="fc" id="L1348">        BASICCONSTRAINTSCRITICAL, Boolean.valueOf(basicconstraintscritical));</span>
<span class="fc" id="L1349">  }</span>

  /**
   * @return bool
   */
  public boolean getUseKeyUsage() {
<span class="fc" id="L1355">    return ((Boolean) data.get(USEKEYUSAGE)).booleanValue();</span>
  }

  /**
   * @param usekeyusage bool
   */
  public void setUseKeyUsage(final boolean usekeyusage) {
<span class="fc" id="L1362">    data.put(USEKEYUSAGE, Boolean.valueOf(usekeyusage));</span>
<span class="fc" id="L1363">  }</span>

  /**
   * @return bool
   */
  public boolean getKeyUsageCritical() {
<span class="fc" id="L1369">    return ((Boolean) data.get(KEYUSAGECRITICAL)).booleanValue();</span>
  }

  /**
   * @param keyusagecritical bool
   */
  public void setKeyUsageCritical(
          final boolean keyusagecritical) {
<span class="fc" id="L1377">    data.put(KEYUSAGECRITICAL, Boolean.valueOf(keyusagecritical));</span>
<span class="fc" id="L1378">  }</span>

  /**
   * @return bool
   */
  public boolean getUseSubjectKeyIdentifier() {
<span class="fc" id="L1384">    return ((Boolean) data.get(USESUBJECTKEYIDENTIFIER)).booleanValue();</span>
  }

  /**
   * @param usesubjectkeyidentifier bool
   */
  public void setUseSubjectKeyIdentifier(
          final boolean usesubjectkeyidentifier) {
<span class="fc" id="L1392">    data.put(USESUBJECTKEYIDENTIFIER, Boolean.valueOf(usesubjectkeyidentifier));</span>
<span class="fc" id="L1393">  }</span>

  /**
   * @return bool
   */
  public boolean getSubjectKeyIdentifierCritical() {
<span class="fc" id="L1399">    return ((Boolean) data.get(SUBJECTKEYIDENTIFIERCRITICAL)).booleanValue();</span>
  }

  /**
   * @param subjectkeyidentifiercritical bool
   */
  public void setSubjectKeyIdentifierCritical(
      final boolean subjectkeyidentifiercritical) {
<span class="fc" id="L1407">    data.put(</span>
        SUBJECTKEYIDENTIFIERCRITICAL,
<span class="fc" id="L1409">        Boolean.valueOf(subjectkeyidentifiercritical));</span>
<span class="fc" id="L1410">  }</span>

  /**
   * @return bool
   */
  public boolean getUseAuthorityKeyIdentifier() {
<span class="fc" id="L1416">    return ((Boolean) data.get(USEAUTHORITYKEYIDENTIFIER)).booleanValue();</span>
  }

  /**
   * @param useauthoritykeyidentifier bool
   */
  public void setUseAuthorityKeyIdentifier(
          final boolean useauthoritykeyidentifier) {
<span class="fc" id="L1424">    data.put(</span>
<span class="fc" id="L1425">        USEAUTHORITYKEYIDENTIFIER, Boolean.valueOf(useauthoritykeyidentifier));</span>
<span class="fc" id="L1426">  }</span>

  /**
   * @return bool
   */
  public boolean getAuthorityKeyIdentifierCritical() {
<span class="fc" id="L1432">    return ((Boolean) data.get(AUTHORITYKEYIDENTIFIERCRITICAL)).booleanValue();</span>
  }

  /**
   * @param authoritykeyidentifiercritical bool
   */
  public void setAuthorityKeyIdentifierCritical(
     final  boolean authoritykeyidentifiercritical) {
<span class="fc" id="L1440">    data.put(</span>
        AUTHORITYKEYIDENTIFIERCRITICAL,
<span class="fc" id="L1442">        Boolean.valueOf(authoritykeyidentifiercritical));</span>
<span class="fc" id="L1443">  }</span>

  /**
   * @return bool
   */
  public boolean getUseSubjectAlternativeName() {
<span class="fc" id="L1449">    return ((Boolean) data.get(USESUBJECTALTERNATIVENAME)).booleanValue();</span>
  }

  /**
   * @param usesubjectalternativename bool
   */
  public void setUseSubjectAlternativeName(
          final boolean usesubjectalternativename) {
<span class="fc" id="L1457">    data.put(</span>
<span class="fc" id="L1458">        USESUBJECTALTERNATIVENAME, Boolean.valueOf(usesubjectalternativename));</span>
<span class="fc" id="L1459">  }</span>

  /**
   * @return bool
   */
  public boolean getStoreCertificateData() {
    // Lazy upgrade for profiles created prior to EJBCA 6.2.10
<span class="nc" id="L1466">    final Boolean value = (Boolean) data.get(STORECERTIFICATEDATA);</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">    if (value == null) {</span>
      // Default for existing profiles is true
<span class="nc" id="L1469">      setStoreCertificateData(true);</span>
<span class="nc" id="L1470">      return true;</span>
    } else {
<span class="nc" id="L1472">      return value.booleanValue();</span>
    }
  }

  /**
   * @param storeCertificateData bool
   */
  public void setStoreCertificateData(final boolean storeCertificateData) {
<span class="fc" id="L1480">    data.put(STORECERTIFICATEDATA, Boolean.valueOf(storeCertificateData));</span>
<span class="fc" id="L1481">  }</span>

  /**
   * @return true if the CertificateData.subjectAltName column should be
   *     populated.
   */
  public boolean getStoreSubjectAlternativeName() {
    // Lazy upgrade for profiles created prior to EJBCA 6.6.0
<span class="nc" id="L1489">    final Boolean value = (Boolean) data.get(STORESUBJECTALTNAME);</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">    if (value == null) {</span>
      // Old profiles created before EJBCA 6.6.0 will not store SAN by default.
<span class="nc" id="L1492">      setStoreSubjectAlternativeName(false);</span>
<span class="nc" id="L1493">      return false;</span>
    } else {
<span class="nc" id="L1495">      return value.booleanValue();</span>
    }
  }

  /**
   * @param storeSubjectAlternativeName bool
   */
  public void setStoreSubjectAlternativeName(
      final boolean storeSubjectAlternativeName) {
<span class="fc" id="L1504">    data.put(STORESUBJECTALTNAME, Boolean.valueOf(storeSubjectAlternativeName));</span>
<span class="fc" id="L1505">  }</span>

  /**
   * @return bool
   */
  public boolean getSubjectAlternativeNameCritical() {
<span class="fc" id="L1511">    return ((Boolean) data.get(SUBJECTALTERNATIVENAMECRITICAL)).booleanValue();</span>
  }

  /**
   * @param subjectalternativenamecritical bool
   */
  public void setSubjectAlternativeNameCritical(
      final boolean subjectalternativenamecritical) {
<span class="fc" id="L1519">    data.put(</span>
        SUBJECTALTERNATIVENAMECRITICAL,
<span class="fc" id="L1521">        Boolean.valueOf(subjectalternativenamecritical));</span>
<span class="fc" id="L1522">  }</span>

  /**
   * @return bool
   */
  public boolean getUseIssuerAlternativeName() {
<span class="fc" id="L1528">    return ((Boolean) data.get(USEISSUERALTERNATIVENAME)).booleanValue();</span>
  }

  /**
   * @param useissueralternativename bool
   */
  public void setUseIssuerAlternativeName(
          final boolean useissueralternativename) {
<span class="fc" id="L1536">    data.put(</span>
<span class="fc" id="L1537">        USEISSUERALTERNATIVENAME, Boolean.valueOf(useissueralternativename));</span>
<span class="fc" id="L1538">  }</span>

  /**
   * @return bool
   */
  public boolean getIssuerAlternativeNameCritical() {
<span class="fc" id="L1544">    return ((Boolean) data.get(ISSUERALTERNATIVENAMECRITICAL)).booleanValue();</span>
  }

  /**
   * @param issueralternativenamecritical bool
   */
  public void setIssuerAlternativeNameCritical(
      final boolean issueralternativenamecritical) {
<span class="fc" id="L1552">    data.put(</span>
        ISSUERALTERNATIVENAMECRITICAL,
<span class="fc" id="L1554">        Boolean.valueOf(issueralternativenamecritical));</span>
<span class="fc" id="L1555">  }</span>

  /**
   * @return bool
   */
  public boolean getUseCRLDistributionPoint() {
<span class="fc" id="L1561">    return ((Boolean) data.get(USECRLDISTRIBUTIONPOINT)).booleanValue();</span>
  }

  /**
   * @param usecrldistributionpoint bool
   */
  public void setUseCRLDistributionPoint(
          final boolean usecrldistributionpoint) {
<span class="fc" id="L1569">    data.put(USECRLDISTRIBUTIONPOINT, Boolean.valueOf(usecrldistributionpoint));</span>
<span class="fc" id="L1570">  }</span>

  /**
   * @return bool
   */
  public boolean getUseDefaultCRLDistributionPoint() {
<span class="fc" id="L1576">    return ((Boolean) data.get(USEDEFAULTCRLDISTRIBUTIONPOINT)).booleanValue();</span>
  }

  /**
   * @param usedefaultcrldistributionpoint bool
   */
  public void setUseDefaultCRLDistributionPoint(
      final boolean usedefaultcrldistributionpoint) {
<span class="fc" id="L1584">    data.put(</span>
        USEDEFAULTCRLDISTRIBUTIONPOINT,
<span class="fc" id="L1586">        Boolean.valueOf(usedefaultcrldistributionpoint));</span>
<span class="fc" id="L1587">  }</span>

  /**
   * @return bool
   */
  public boolean getCRLDistributionPointCritical() {
<span class="fc" id="L1593">    return ((Boolean) data.get(CRLDISTRIBUTIONPOINTCRITICAL)).booleanValue();</span>
  }

  /**
   * @param crldistributionpointcritical bool
   */
  public void setCRLDistributionPointCritical(
      final boolean crldistributionpointcritical) {
<span class="fc" id="L1601">    data.put(</span>
        CRLDISTRIBUTIONPOINTCRITICAL,
<span class="fc" id="L1603">        Boolean.valueOf(crldistributionpointcritical));</span>
<span class="fc" id="L1604">  }</span>

  /**
   * @return URI
   */
  public String getCRLDistributionPointURI() {
<span class="fc" id="L1610">    return (String) data.get(CRLDISTRIBUTIONPOINTURI);</span>
  }

  /**
   * @param crldistributionpointuri URI
   */
  public void setCRLDistributionPointURI(final String crldistributionpointuri) {
<span class="fc bfc" id="L1617" title="All 2 branches covered.">    if (crldistributionpointuri == null) {</span>
<span class="fc" id="L1618">      data.put(CRLDISTRIBUTIONPOINTURI, &quot;&quot;);</span>
    } else {
<span class="fc" id="L1620">      data.put(CRLDISTRIBUTIONPOINTURI, crldistributionpointuri);</span>
    }
<span class="fc" id="L1622">  }</span>

  /**
   * @return bool
   */
  public String getCRLIssuer() {
<span class="fc" id="L1628">    return (String) data.get(CRLISSUER);</span>
  }

  /**
   * @param crlissuer issuer
   */
  public void setCRLIssuer(final String crlissuer) {
<span class="fc bfc" id="L1635" title="All 2 branches covered.">    if (crlissuer == null) {</span>
<span class="fc" id="L1636">      data.put(CRLISSUER, &quot;&quot;);</span>
    } else {
<span class="fc" id="L1638">      data.put(CRLISSUER, crlissuer);</span>
    }
<span class="fc" id="L1640">  }</span>

  /**
   * @return bool
   */
  public boolean getUseFreshestCRL() {
<span class="fc" id="L1646">    Object obj = data.get(USEFRESHESTCRL);</span>
<span class="pc bpc" id="L1647" title="1 of 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L1648">      return false;</span>
    } else {
<span class="fc" id="L1650">      return ((Boolean) obj).booleanValue();</span>
    }
  }

  /**
   * @param usefreshestcrl bool
   */
  public void setUseFreshestCRL(final boolean usefreshestcrl) {
<span class="fc" id="L1658">    data.put(USEFRESHESTCRL, Boolean.valueOf(usefreshestcrl));</span>
<span class="fc" id="L1659">  }</span>

  /**
   * @return bool
   */
  public boolean getUseCADefinedFreshestCRL() {
<span class="fc" id="L1665">    Object obj = data.get(USECADEFINEDFRESHESTCRL);</span>
<span class="pc bpc" id="L1666" title="1 of 2 branches missed.">    if (obj == null) {</span>
<span class="nc" id="L1667">      return false;</span>
    } else {
<span class="fc" id="L1669">      return ((Boolean) obj).booleanValue();</span>
    }
  }

  /**
   * @param usecadefinedfreshestcrl bool
   */
  public void setUseCADefinedFreshestCRL(
          final boolean usecadefinedfreshestcrl) {
<span class="fc" id="L1678">    data.put(USECADEFINEDFRESHESTCRL, Boolean.valueOf(usecadefinedfreshestcrl));</span>
<span class="fc" id="L1679">  }</span>

  /**
   * @return URI
   */
  public String getFreshestCRLURI() {
<span class="fc" id="L1685">    return ((String) data.get(FRESHESTCRLURI));</span>
  }

  /**
   * @param freshestcrluri URI
   */
  public void setFreshestCRLURI(final String freshestcrluri) {
<span class="fc bfc" id="L1692" title="All 2 branches covered.">    if (freshestcrluri == null) {</span>
<span class="fc" id="L1693">      data.put(FRESHESTCRLURI, &quot;&quot;);</span>
    } else {
<span class="fc" id="L1695">      data.put(FRESHESTCRLURI, freshestcrluri);</span>
    }
<span class="fc" id="L1697">  }</span>

  /**
   * @return bool
   */
  public boolean getUseCertificatePolicies() {
<span class="fc" id="L1703">    return ((Boolean) data.get(USECERTIFICATEPOLICIES)).booleanValue();</span>
  }

  /**
   * @param usecertificatepolicies bool
   */
  public void setUseCertificatePolicies(final boolean usecertificatepolicies) {
<span class="fc" id="L1710">    data.put(USECERTIFICATEPOLICIES, Boolean.valueOf(usecertificatepolicies));</span>
<span class="fc" id="L1711">  }</span>

  /**
   * @return bool
   */
  public boolean getUseCertificateStorage() {
    // Lazy upgrade for profiles created prior to EJBCA 6.2.10
<span class="nc" id="L1718">    Boolean value = (Boolean) data.get(USECERTIFICATESTORAGE);</span>
<span class="nc bnc" id="L1719" title="All 2 branches missed.">    if (value == null) {</span>
      // Default is true
<span class="nc" id="L1721">      setUseCertificateStorage(true);</span>
<span class="nc" id="L1722">      return true;</span>
    } else {
<span class="nc" id="L1724">      return value.booleanValue();</span>
    }
  }

  /**
   * @param useCertificateStorage bool
   */
  public void setUseCertificateStorage(final boolean useCertificateStorage) {
<span class="fc" id="L1732">    data.put(USECERTIFICATESTORAGE, Boolean.valueOf(useCertificateStorage));</span>
<span class="fc" id="L1733">  }</span>

  /**
   * @return bool
   */
  public boolean getCertificatePoliciesCritical() {
<span class="fc" id="L1739">    return ((Boolean) data.get(CERTIFICATEPOLICIESCRITICAL)).booleanValue();</span>
  }

  /**
   * @param certificatepoliciescritical bool
   */
  public void setCertificatePoliciesCritical(
      final boolean certificatepoliciescritical) {
<span class="fc" id="L1747">    data.put(</span>
        CERTIFICATEPOLICIESCRITICAL,
<span class="fc" id="L1749">        Boolean.valueOf(certificatepoliciescritical));</span>
<span class="fc" id="L1750">  }</span>

  /**
   * @return policies
   */
  public List&lt;CertificatePolicy&gt; getCertificatePolicies() {
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1757">    List&lt;CertificatePolicy&gt; l =</span>
<span class="fc" id="L1758">        (List&lt;CertificatePolicy&gt;) data.get(CERTIFICATE_POLICIES);</span>
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">    if (l == null) {</span>
<span class="nc" id="L1760">      l = new ArrayList&lt;CertificatePolicy&gt;();</span>
    } else {
      // Check class name, because we changed this in EJBCA 5 and need to
      // support older versions in the database for 100% upgrade
<span class="fc bfc" id="L1764" title="All 2 branches covered.">      if (l.size() &gt; 0) {</span>
        try {
          // Don't remove the unused test object
<span class="fc" id="L1767">          CertificatePolicy test =</span>
<span class="fc" id="L1768">              l.get(</span>
                  0); // NOPMD: we need to actually get the text object,
                      // otherwise the cast will not be tried
<span class="fc" id="L1771">          test.getPolicyID();</span>
<span class="fc" id="L1772">        } catch (ClassCastException e) {</span>
<span class="pc bpc" id="L1773" title="1 of 2 branches missed.">          if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1774">            LOG.debug(</span>
                &quot;CertificatePolicy in profile is old class name (&lt; EJBCA 5),&quot;
                    + &quot; post-upgrade has not been run. Converting in code to&quot;
                    + &quot; return new class type.&quot;);
          }
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1780">          List&lt;Object&gt; oldl = (List&lt;Object&gt;) data.get(CERTIFICATE_POLICIES);</span>
          // In worst case they can have mixed old and new classes, therefore we
          // use a &quot;normal&quot; iterator so we can verify the cast
<span class="fc" id="L1783">          l = new ArrayList&lt;CertificatePolicy&gt;();</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">          for (int i = 0; i &lt; oldl.size(); i++) {</span>
            try {
              org.ejbca.core.model.ca.certificateprofiles.CertificatePolicy
<span class="fc" id="L1787">                  oldPol =</span>
                      (org.ejbca.core.model.ca.certificateprofiles
                              .CertificatePolicy)
<span class="fc" id="L1790">                          oldl.get(i);</span>
<span class="fc" id="L1791">              CertificatePolicy newPol =</span>
                  new CertificatePolicy(
<span class="fc" id="L1793">                      oldPol.getPolicyID(),</span>
<span class="fc" id="L1794">                      oldPol.getQualifierId(),</span>
<span class="fc" id="L1795">                      oldPol.getQualifier());</span>
<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">              if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1797">                LOG.trace(&quot;Adding converted policy&quot;);</span>
              }
<span class="fc" id="L1799">              l.add(newPol);</span>
<span class="fc" id="L1800">            } catch (ClassCastException e2) {</span>
              // This was already a new class, there are mixed policies here...
<span class="fc" id="L1802">              CertificatePolicy newPol = (CertificatePolicy) oldl.get(i);</span>
<span class="pc bpc" id="L1803" title="1 of 2 branches missed.">              if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L1804">                LOG.trace(&quot;Adding non-converted policy&quot;);</span>
              }
<span class="fc" id="L1806">              l.add(newPol);</span>
<span class="fc" id="L1807">            }</span>
          }
<span class="fc" id="L1809">        }</span>
      }
    }
<span class="fc" id="L1812">    return l;</span>
  }

  /**
   * @param policy policy
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void addCertificatePolicy(final CertificatePolicy policy) {
<span class="pc bpc" id="L1820" title="1 of 2 branches missed.">    if (data.get(CERTIFICATE_POLICIES) == null) {</span>
<span class="nc" id="L1821">      setCertificatePolicies(new ArrayList&lt;CertificatePolicy&gt;());</span>
    }
<span class="fc" id="L1823">    ((List&lt;CertificatePolicy&gt;) data.get(CERTIFICATE_POLICIES)).add(policy);</span>
<span class="fc" id="L1824">  }</span>

  /**
   * @param policies Policies
   */
  public void setCertificatePolicies(final List&lt;CertificatePolicy&gt; policies) {
<span class="pc bpc" id="L1830" title="1 of 2 branches missed.">    if (policies == null) {</span>
<span class="nc" id="L1831">      data.put(CERTIFICATE_POLICIES, new ArrayList&lt;CertificatePolicy&gt;(0));</span>
    } else {
<span class="fc" id="L1833">      data.put(CERTIFICATE_POLICIES, policies);</span>
    }
<span class="fc" id="L1835">  }</span>

  /**
   * @param policy Policy
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void removeCertificatePolicy(final CertificatePolicy policy) {
<span class="pc bpc" id="L1842" title="1 of 2 branches missed.">    if (data.get(CERTIFICATE_POLICIES) != null) {</span>
<span class="fc" id="L1843">      ((List&lt;CertificatePolicy&gt;) data.get(CERTIFICATE_POLICIES)).remove(policy);</span>
    }
<span class="fc" id="L1845">  }</span>

  /**
   * Type is used when setting BasicConstraints, i.e. to determine if it is a CA
   * or an end entity
   *
   * @return type
   * @see CertificateConstants#CERTTYPE_ROOTCA etc
   */
  public int getType() {
<span class="fc" id="L1855">    return ((Integer) data.get(TYPE)).intValue();</span>
  }

  /**
   * Type is used when setting BasicConstraints, i.e. to determine if it is a CA
   * or an end entity
   *
   * @param type type
   * @see CertificateConstants#CERTTYPE_ROOTCA etc
   */
  public void setType(final int type) {
<span class="fc" id="L1866">    data.put(TYPE, Integer.valueOf(type));</span>
<span class="fc" id="L1867">  }</span>

  /**
   * @return bool
   */
  public boolean isTypeSubCA() {
<span class="fc bfc" id="L1873" title="All 2 branches covered.">    return ((Integer) data.get(TYPE)).intValue()</span>
        == CertificateConstants.CERTTYPE_SUBCA;
  }

  /**
   * @return bool
   */
  public boolean isTypeRootCA() {
<span class="fc bfc" id="L1881" title="All 2 branches covered.">    return ((Integer) data.get(TYPE)).intValue()</span>
        == CertificateConstants.CERTTYPE_ROOTCA;
  }

  /**
   * @return bool
   */
  public boolean isTypeEndEntity() {
<span class="fc bfc" id="L1889" title="All 2 branches covered.">    return ((Integer) data.get(TYPE)).intValue()</span>
        == CertificateConstants.CERTTYPE_ENDENTITY;
  }

  /**
   * @return algos
   */
  public String[] getAvailableKeyAlgorithms() {
<span class="nc" id="L1897">    final List&lt;String&gt; availableKeyAlgorithms =</span>
<span class="nc" id="L1898">        getAvailableKeyAlgorithmsAsList();</span>
<span class="nc" id="L1899">    return availableKeyAlgorithms.toArray(</span>
<span class="nc" id="L1900">        new String[availableKeyAlgorithms.size()]);</span>
  }

  /**
   * @return Algos
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getAvailableKeyAlgorithmsAsList() {
<span class="fc" id="L1908">    return (ArrayList&lt;String&gt;) data.get(AVAILABLEKEYALGORITHMS);</span>
  }

  /**
   * @param availableKeyAlgorithms Algos
   */
  public void setAvailableKeyAlgorithms(final String[] availableKeyAlgorithms) {
<span class="fc" id="L1915">    setAvailableKeyAlgorithmsAsList(Arrays.asList(availableKeyAlgorithms));</span>
<span class="fc" id="L1916">  }</span>

  /**
   * @param availableKeyAlgorithms Algos
   */
  public void setAvailableKeyAlgorithmsAsList(
      final List&lt;String&gt; availableKeyAlgorithms) {
<span class="fc" id="L1923">    data.put(AVAILABLEKEYALGORITHMS, new ArrayList&lt;&gt;(availableKeyAlgorithms));</span>
<span class="fc" id="L1924">  }</span>

  /**
   * @return curves
   */
  public String[] getAvailableEcCurves() {
<span class="nc" id="L1930">    final List&lt;String&gt; availableEcCurves = getAvailableEcCurvesAsList();</span>
<span class="nc" id="L1931">    return availableEcCurves.toArray(new String[availableEcCurves.size()]);</span>
  }

  /**
   * @return curves
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getAvailableEcCurvesAsList() {
<span class="fc" id="L1939">    return (ArrayList&lt;String&gt;) data.get(AVAILABLEECCURVES);</span>
  }

  /**
   * @param availableEcCurves Curves
   */
  public void setAvailableEcCurves(final String[] availableEcCurves) {
<span class="fc" id="L1946">    setAvailableEcCurvesAsList(Arrays.asList(availableEcCurves));</span>
<span class="fc" id="L1947">  }</span>

  /**
   * @param availableEcCurves Curves
   */
  public void setAvailableEcCurvesAsList(final List&lt;String&gt; availableEcCurves) {
<span class="fc" id="L1953">    data.put(AVAILABLEECCURVES, new ArrayList&lt;&gt;(availableEcCurves));</span>
<span class="fc" id="L1954">  }</span>

  /**
   * @return lengths
   */
  public int[] getAvailableBitLengths() {
<span class="fc" id="L1960">    final List&lt;Integer&gt; availablebitlengths = getAvailableBitLengthsAsList();</span>
<span class="fc" id="L1961">    final int[] returnval = new int[availablebitlengths.size()];</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">    for (int i = 0; i &lt; availablebitlengths.size(); i++) {</span>
<span class="fc" id="L1963">      returnval[i] = availablebitlengths.get(i).intValue();</span>
    }
<span class="fc" id="L1965">    return returnval;</span>
  }

  /**
   * @return lengths
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;Integer&gt; getAvailableBitLengthsAsList() {
<span class="fc" id="L1973">    return (ArrayList&lt;Integer&gt;) data.get(AVAILABLEBITLENGTHS);</span>
  }

  /**
   * @param availablebitlengths lengths
   */
  public void setAvailableBitLengths(final List&lt;Integer&gt; availablebitlengths) {
    // Strange values here, but it makes the &lt;&gt; below work for sure
<span class="fc" id="L1981">    int minimumavailablebitlength = 99999999;</span>
<span class="fc" id="L1982">    int maximumavailablebitlength = 0;</span>

<span class="fc bfc" id="L1984" title="All 2 branches covered.">    for (int i = 0; i &lt; availablebitlengths.size(); i++) {</span>
<span class="fc bfc" id="L1985" title="All 2 branches covered.">      if (availablebitlengths.get(i) &gt; maximumavailablebitlength) {</span>
<span class="fc" id="L1986">        maximumavailablebitlength = availablebitlengths.get(i);</span>
      }
<span class="fc bfc" id="L1988" title="All 2 branches covered.">      if (availablebitlengths.get(i) &lt; minimumavailablebitlength) {</span>
<span class="fc" id="L1989">        minimumavailablebitlength = availablebitlengths.get(i);</span>
      }
    }
<span class="fc" id="L1992">    data.put(AVAILABLEBITLENGTHS, availablebitlengths);</span>
<span class="fc" id="L1993">    data.put(</span>
<span class="fc" id="L1994">        MINIMUMAVAILABLEBITLENGTH, Integer.valueOf(minimumavailablebitlength));</span>
<span class="fc" id="L1995">    data.put(</span>
<span class="fc" id="L1996">        MAXIMUMAVAILABLEBITLENGTH, Integer.valueOf(maximumavailablebitlength));</span>
<span class="fc" id="L1997">  }</span>

  /**
   * @param availablebitlengths lengths
   */
  public void setAvailableBitLengths(final int[] availablebitlengths) {
<span class="fc" id="L2003">    ArrayList&lt;Integer&gt; availbitlengths =</span>
        new ArrayList&lt;&gt;(availablebitlengths.length);

<span class="fc bfc" id="L2006" title="All 2 branches covered.">    for (int i = 0; i &lt; availablebitlengths.length; i++) {</span>
<span class="fc" id="L2007">      availbitlengths.add(Integer.valueOf(availablebitlengths[i]));</span>
    }
<span class="fc" id="L2009">    setAvailableBitLengths(availbitlengths);</span>
<span class="fc" id="L2010">  }</span>

  /**
   * @return length
   */
  public int getMinimumAvailableBitLength() {
<span class="fc" id="L2016">    return ((Integer) data.get(MINIMUMAVAILABLEBITLENGTH)).intValue();</span>
  }

  /**
   * @return length
   */
  public int getMaximumAvailableBitLength() {
<span class="fc" id="L2023">    return ((Integer) data.get(MAXIMUMAVAILABLEBITLENGTH)).intValue();</span>
  }

  /**
   * @param keyAlgorithm Algorithm
   * @param keySpecification Spec
   * @return true if the given combination of keyAlgorithm/keySpecification is
   *     allowed by this certificate profile.
   */
  public boolean isKeyTypeAllowed(
      final String keyAlgorithm, final String keySpecification) {
<span class="fc" id="L2034">    final List&lt;String&gt; availableKeyAlgorithms =</span>
<span class="fc" id="L2035">        getAvailableKeyAlgorithmsAsList();</span>
<span class="fc" id="L2036">    final List&lt;Integer&gt; availableBitLengths = getAvailableBitLengthsAsList();</span>
<span class="fc" id="L2037">    final List&lt;String&gt; availableEcCurves = getAvailableEcCurvesAsList();</span>
<span class="fc bfc" id="L2038" title="All 2 branches covered.">    if (!availableKeyAlgorithms.contains(keyAlgorithm)) {</span>
<span class="fc" id="L2039">      return false;</span>
    }
<span class="fc bfc" id="L2041" title="All 2 branches covered.">    if (StringUtils.isNumeric(keySpecification)) {</span>
      // keySpecification is a bit length (RSA)
<span class="fc" id="L2043">      return availableBitLengths.contains(Integer.parseInt(keySpecification));</span>
    } else {
      // keySpecification is a curve name (EC)
<span class="fc bfc" id="L2046" title="All 2 branches covered.">      return availableEcCurves.contains(keySpecification)</span>
<span class="fc bfc" id="L2047" title="All 2 branches covered.">          || availableEcCurves.contains(CertificateProfile.ANY_EC_CURVE);</span>
    }
  }

  /**
   * Returns the chosen algorithm to be used for signing the certificates or
   * null if it is to be inherited from the CA (i.e., it is the same as the
   * algorithm used to sign the CA certificate).
   *
   * @see org.cesecore.certificates.util.AlgorithmConstants#AVAILABLE_SIGALGS
   * @return JCE identifier for the signature algorithm or null if it is to be
   *     inherited from the CA (i.e., it is the same as the algorithm used to
   *     sign the CA certificate).
   */
  public String getSignatureAlgorithm() {
    // If it's null, it is inherited from issuing CA.
<span class="fc" id="L2063">    return (String) data.get(SIGNATUREALGORITHM);</span>
  }

  /**
   * Sets the algorithm to be used for signing the certificates. A null value
   * means that the signature algorithm is to be inherited from the CA (i.e., it
   * is the same as the algorithm used to sign the CA certificate).
   *
   * @param signAlg JCE identifier for the signature algorithm or null if it is
   *     to be inherited from the CA (i.e., it is the same as the algorithm used
   *     to sign the CA certificate).
   * @see org.cesecore.certificates.util.AlgorithmConstants#AVAILABLE_SIGALGS
   */
  public void setSignatureAlgorithm(final String signAlg) {
<span class="fc" id="L2077">    data.put(SIGNATUREALGORITHM, signAlg);</span>
<span class="fc" id="L2078">  }</span>

  /**
   * @return usage
   */
  public boolean[] getKeyUsage() {
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L2085">    ArrayList&lt;Boolean&gt; keyusage = (ArrayList&lt;Boolean&gt;) data.get(KEYUSAGE);</span>
<span class="fc" id="L2086">    boolean[] returnval = new boolean[keyusage.size()];</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">    for (int i = 0; i &lt; keyusage.size(); i++) {</span>
<span class="fc" id="L2088">      returnval[i] = keyusage.get(i).booleanValue();</span>
    }
<span class="fc" id="L2090">    return returnval;</span>
  }

  /**
   * @param keyusageconstant from CertificateConstants.DIGITALSIGNATURE etc
   * @return true or false if the key usage is set or not.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public boolean getKeyUsage(final int keyusageconstant) {
<span class="fc" id="L2099">    return ((ArrayList&lt;Boolean&gt;) data.get(KEYUSAGE))</span>
<span class="fc" id="L2100">        .get(keyusageconstant)</span>
<span class="fc" id="L2101">        .booleanValue();</span>
  }

  /**
   * @param keyusage usage
   */
  public void setKeyUsage(final boolean[] keyusage) {
<span class="fc" id="L2108">    ArrayList&lt;Boolean&gt; keyuse = new ArrayList&lt;Boolean&gt;(keyusage.length);</span>

<span class="fc bfc" id="L2110" title="All 2 branches covered.">    for (int i = 0; i &lt; keyusage.length; i++) {</span>
<span class="fc" id="L2111">      keyuse.add(Boolean.valueOf(keyusage[i]));</span>
    }
<span class="fc" id="L2113">    data.put(KEYUSAGE, keyuse);</span>
<span class="fc" id="L2114">  }</span>

  /**
   * @param keyusageconstant from CertificateConstants.DIGITALSIGNATURE etc
   * @param value true or false if the key usage is set or not.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void setKeyUsage(final int keyusageconstant, final boolean value) {
<span class="fc" id="L2122">    ((ArrayList&lt;Boolean&gt;) data.get(KEYUSAGE))</span>
<span class="fc" id="L2123">        .set(keyusageconstant, Boolean.valueOf(value));</span>
<span class="fc" id="L2124">  }</span>

  /**
   * @param override bool
   */
  public void setAllowKeyUsageOverride(final boolean override) {
<span class="fc" id="L2130">    data.put(ALLOWKEYUSAGEOVERRIDE, Boolean.valueOf(override));</span>
<span class="fc" id="L2131">  }</span>

  /**
   * @return bool
   */
  public boolean getAllowKeyUsageOverride() {
<span class="fc" id="L2137">    return ((Boolean) data.get(ALLOWKEYUSAGEOVERRIDE)).booleanValue();</span>
  }

  /**
   * @param override bool
   */
  public void setAllowBackdatedRevocation(final boolean override) {
<span class="fc" id="L2144">    this.data.put(ALLOWBACKDATEDREVOCATION, Boolean.valueOf(override));</span>
<span class="fc" id="L2145">  }</span>

  /**
   * @return bool
   */
  public boolean getAllowBackdatedRevocation() {
<span class="nc" id="L2151">    final Object value = this.data.get(ALLOWBACKDATEDREVOCATION);</span>
<span class="nc bnc" id="L2152" title="All 4 branches missed.">    return value != null</span>
        &amp;&amp; value instanceof Boolean
<span class="nc bnc" id="L2154" title="All 2 branches missed.">        &amp;&amp; ((Boolean) value).booleanValue();</span>
  }

  /**
   * @param use bool
   */
  public void setUseDocumentTypeList(final boolean use) {
<span class="fc" id="L2161">    data.put(USEDOCUMENTTYPELIST, Boolean.valueOf(use));</span>
<span class="fc" id="L2162">  }</span>

  /**
   * @return bool
   */
  public boolean getUseDocumentTypeList() {
<span class="nc" id="L2168">    return ((Boolean) data.get(USEDOCUMENTTYPELIST)).booleanValue();</span>
  }

  /**
   * @param critical bool
   */
  public void setDocumentTypeListCritical(final boolean critical) {
<span class="fc" id="L2175">    data.put(DOCUMENTTYPELISTCRITICAL, Boolean.valueOf(critical));</span>
<span class="fc" id="L2176">  }</span>

  /**
   * @return bool
   */
  public boolean getDocumentTypeListCritical() {
<span class="nc" id="L2182">    return ((Boolean) data.get(DOCUMENTTYPELISTCRITICAL)).booleanValue();</span>
  }

  /**
   * @param docTypes types
   */
  public void setDocumentTypeList(final ArrayList&lt;String&gt; docTypes) {
<span class="fc" id="L2189">    data.put(DOCUMENTTYPELIST, docTypes);</span>
<span class="fc" id="L2190">  }</span>

  /**
   * @return types
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public ArrayList&lt;String&gt; getDocumentTypeList() {
<span class="nc" id="L2197">    return (ArrayList&lt;String&gt;) data.get(DOCUMENTTYPELIST);</span>
  }

  /**
   * @param use bool
   */
  public void setUseExtendedKeyUsage(final boolean use) {
<span class="fc" id="L2204">    data.put(USEEXTENDEDKEYUSAGE, Boolean.valueOf(use));</span>
<span class="fc" id="L2205">  }</span>

  /**
   * @return bool
   */
  public boolean getUseExtendedKeyUsage() {
<span class="fc" id="L2211">    return ((Boolean) data.get(USEEXTENDEDKEYUSAGE)).booleanValue();</span>
  }

  /**
   * @param critical bool
   */
  public void setExtendedKeyUsageCritical(final boolean critical) {
<span class="fc" id="L2218">    data.put(EXTENDEDKEYUSAGECRITICAL, Boolean.valueOf(critical));</span>
<span class="fc" id="L2219">  }</span>

  /**
   * @return bool
   */
  public boolean getExtendedKeyUsageCritical() {
<span class="fc" id="L2225">    return ((Boolean) data.get(EXTENDEDKEYUSAGECRITICAL)).booleanValue();</span>
  }

  /**
   * Extended Key Usage is an arraylist of oid Strings. Usually oids comes from
   * KeyPurposeId in BC.
   *
   * @param extendedkeyusage oid strings
   */
  public void setExtendedKeyUsage(final ArrayList&lt;String&gt; extendedkeyusage) {
<span class="fc" id="L2235">    data.put(EXTENDEDKEYUSAGE, extendedkeyusage);</span>
<span class="fc" id="L2236">  }</span>

  /**
   * Extended Key Usage is an arraylist of Strings with eku oids.
   *
   * @return oid strings
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public ArrayList&lt;String&gt; getExtendedKeyUsageOids() {
<span class="fc" id="L2245">    return (ArrayList&lt;String&gt;) data.get(EXTENDEDKEYUSAGE);</span>
  }

  /**
   * @param extendedKeyUsageOids OIDs
   */
  public void setExtendedKeyUsageOids(
      final ArrayList&lt;String&gt; extendedKeyUsageOids) {
<span class="nc" id="L2253">    setExtendedKeyUsage(extendedKeyUsageOids);</span>
<span class="nc" id="L2254">  }</span>

  /**
   * @param use bool
   */
  public void setUseCustomDnOrder(final boolean use) {
<span class="fc" id="L2260">    data.put(USECUSTOMDNORDER, Boolean.valueOf(use));</span>
<span class="fc" id="L2261">  }</span>

  /**
   * @return bool
   */
  public boolean getUseCustomDnOrder() {
<span class="nc" id="L2267">    boolean ret = false; // Default value is false here</span>
<span class="nc" id="L2268">    Object o = data.get(USECUSTOMDNORDER);</span>
<span class="nc bnc" id="L2269" title="All 2 branches missed.">    if (o != null) {</span>
<span class="nc" id="L2270">      ret = ((Boolean) o).booleanValue();</span>
    }
<span class="nc" id="L2272">    return ret;</span>
  }

  /**
   * Set to true if we should apply the rules for LDAP DN Order (separate flag)
   * to the custom DN order.
   *
   * @param useldap true or false
   */
  public void setUseCustomDnOrderWithLdap(final boolean useldap) {
<span class="nc" id="L2282">    data.put(USECUSTOMDNORDERLDAP, Boolean.valueOf(useldap));</span>
<span class="nc" id="L2283">  }</span>

  /**
   * @return true if we should apply the rules for LDAP DN Order (separate
   *     flag), default to false for new usage, where no custom order exists,
   *     and to true for old usage to be backward compatible
   */
  public boolean getUseCustomDnOrderWithLdap() {
<span class="nc" id="L2291">    boolean ret = true; // Default value is true here</span>
<span class="nc" id="L2292">    Object o = data.get(USECUSTOMDNORDERLDAP);</span>
<span class="nc bnc" id="L2293" title="All 2 branches missed.">    if (o != null) {</span>
<span class="nc" id="L2294">      ret = ((Boolean) o).booleanValue();</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">    } else if (getCustomDnOrder().isEmpty()) {</span>
      // We have not set a value for this checkbox, and we have no custom DN
      // order defined
      // in this case we default to false (new usage)
<span class="nc" id="L2299">      ret = false;</span>
    }
<span class="nc" id="L2301">    return ret;</span>
  }

  /**
   * Custom DN order is an ArrayList of DN strings.
   *
   * @see DnComponents
   * @return ArrayList of Strings or an empty ArrayList
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public ArrayList&lt;String&gt; getCustomDnOrder() {
<span class="nc bnc" id="L2312" title="All 2 branches missed.">    if (data.get(CUSTOMDNORDER) == null) {</span>
<span class="nc" id="L2313">      return new ArrayList&lt;&gt;();</span>
    }
<span class="nc" id="L2315">    return (ArrayList&lt;String&gt;) data.get(CUSTOMDNORDER);</span>
  }

  /**
   * @param dnOrder Order
   */
  public void setCustomDnOrder(final ArrayList&lt;String&gt; dnOrder) {
<span class="nc" id="L2322">    data.put(CUSTOMDNORDER, dnOrder);</span>
<span class="nc" id="L2323">  }</span>

  /**
   * @return bool
   */
  public boolean getUseLdapDnOrder() {
<span class="fc" id="L2329">    boolean ret = true; // Default value is true here</span>
<span class="fc" id="L2330">    Object o = data.get(USELDAPDNORDER);</span>
<span class="pc bpc" id="L2331" title="1 of 2 branches missed.">    if (o != null) {</span>
<span class="fc" id="L2332">      ret = ((Boolean) o).booleanValue();</span>
    }
<span class="fc" id="L2334">    return ret;</span>
  }

  /**
   * @param use bool
   */
  public void setUseLdapDnOrder(final boolean use) {
<span class="fc" id="L2341">    data.put(USELDAPDNORDER, Boolean.valueOf(use));</span>
<span class="fc" id="L2342">  }</span>

  /**
   * @return bool
   */
  public boolean getUseMicrosoftTemplate() {
<span class="fc" id="L2348">    return ((Boolean) data.get(USEMICROSOFTTEMPLATE)).booleanValue();</span>
  }

  /**
   * @param use bool
   */
  public void setUseMicrosoftTemplate(final boolean use) {
<span class="fc" id="L2355">    data.put(USEMICROSOFTTEMPLATE, Boolean.valueOf(use));</span>
<span class="fc" id="L2356">  }</span>

  /**
   * @return template
   */
  public String getMicrosoftTemplate() {
<span class="fc" id="L2362">    return (String) data.get(MICROSOFTTEMPLATE);</span>
  }

  /**
   * @param mstemplate template
   */
  public void setMicrosoftTemplate(final String mstemplate) {
<span class="fc" id="L2369">    data.put(MICROSOFTTEMPLATE, mstemplate);</span>
<span class="fc" id="L2370">  }</span>
  /**
   * @return bool
   */
  public boolean getUseCardNumber() {
<span class="fc" id="L2375">    return ((Boolean) data.get(USECARDNUMBER)).booleanValue();</span>
  }

  /**
   * @param use bool
   */
  public void setUseCardNumber(final boolean use) {
<span class="fc" id="L2382">    data.put(USECARDNUMBER, Boolean.valueOf(use));</span>
<span class="fc" id="L2383">  }</span>

  /**
   * @return bool
   */
  public boolean getUseCNPostfix() {
<span class="fc" id="L2389">    return ((Boolean) data.get(USECNPOSTFIX)).booleanValue();</span>
  }

  /**
   * @param use bool
   */
  public void setUseCNPostfix(final boolean use) {
<span class="fc" id="L2396">    data.put(USECNPOSTFIX, Boolean.valueOf(use));</span>
<span class="fc" id="L2397">  }</span>

  /**
   * @return postfix
   */
  public String getCNPostfix() {
<span class="fc" id="L2403">    return (String) data.get(CNPOSTFIX);</span>
  }

  /**
   * @param cnpostfix postfix
   */
  public void setCNPostfix(final String cnpostfix) {
<span class="fc" id="L2410">    data.put(CNPOSTFIX, cnpostfix);</span>
<span class="fc" id="L2411">  }</span>

  /**
   * @return bool
   */
  public boolean getUseSubjectDNSubSet() {
<span class="fc" id="L2417">    return ((Boolean) data.get(USESUBJECTDNSUBSET)).booleanValue();</span>
  }

  /**
   * @param use bool
   */
  public void setUseSubjectDNSubSet(final boolean use) {
<span class="fc" id="L2424">    data.put(USESUBJECTDNSUBSET, Boolean.valueOf(use));</span>
<span class="fc" id="L2425">  }</span>

  /**
   * @return a List of Integer (DNFieldExtractor constants) indicating which
   *     subject dn fields that should be used in certificate.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;Integer&gt; getSubjectDNSubSet() {
<span class="fc" id="L2433">    return (List&lt;Integer&gt;) data.get(SUBJECTDNSUBSET);</span>
  }

  /**
   * Should contain a collection of Integer (DNFieldExtractor constants)
   * indicating which subject dn fields that should be used in certificate.
   *
   * &lt;p&gt;Will come in as a list of string from the GUI, because JSP doesn't
   * always care about type safety.
   *
   * @param subjectdns DNs
   */
  public void setSubjectDNSubSet(final List&lt;String&gt; subjectdns) {
<span class="fc" id="L2446">    List&lt;Integer&gt; convertedList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2447" title="All 2 branches covered.">    for (String value : subjectdns) {</span>
<span class="fc" id="L2448">      convertedList.add(Integer.valueOf(value));</span>
<span class="fc" id="L2449">    }</span>
<span class="fc" id="L2450">    data.put(SUBJECTDNSUBSET, convertedList);</span>
<span class="fc" id="L2451">  }</span>

  /**
   * Overridable Extension OIDs is an Set of oid Strings. It is used to list
   * what are the extensions that can be overridden when allow extension
   * override is enabled in the Certificate Profile.
   *
   * @param overridableextensionoids Set of oids (strings), or an empty set,
   *     should not be null
   */
  public void setOverridableExtensionOIDs(
      final Set&lt;String&gt; overridableextensionoids) {
<span class="fc" id="L2463">    data.put(</span>
        OVERRIDABLEEXTENSIONOIDS,
        new LinkedHashSet&lt;String&gt;(overridableextensionoids));
<span class="fc" id="L2466">  }</span>

  /**
   * Overridable Extension OIDs is an Set of oid Strings. It is used to list
   * what are the extensions that can be overridden when allow extension
   * override is enabled in the Certificate Profile.
   *
   * @return Set of strings containing oids, or an empty set, never null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Set&lt;String&gt; getOverridableExtensionOIDs() {
<span class="nc bnc" id="L2477" title="All 2 branches missed.">    if (data.get(OVERRIDABLEEXTENSIONOIDS) == null) {</span>
<span class="nc" id="L2478">      return new LinkedHashSet&lt;String&gt;();</span>
    }
<span class="nc" id="L2480">    return (Set&lt;String&gt;) data.get(OVERRIDABLEEXTENSIONOIDS);</span>
  }

  /**
   * Non Overridable Extension OIDs is a Set of oid Strings. It is used to list
   * what are the extensions that can not be overridden when allow extension
   * override is enabled in the Certificate Profile..
   *
   * @param nonoverridableextensionoids Set of oids (strings) that are not
   *     allowed to be overridden, or empty set to not disallow anything, not
   *     null
   */
  public void setNonOverridableExtensionOIDs(
      final Set&lt;String&gt; nonoverridableextensionoids) {
<span class="fc" id="L2494">    data.put(</span>
        NONOVERRIDABLEEXTENSIONOIDS,
        new LinkedHashSet&lt;String&gt;(nonoverridableextensionoids));
<span class="fc" id="L2497">  }</span>

  /**
   * Non Overridable Extension OIDs is a Set of oid Strings. It is used to list
   * what are the extensions that can not be overridde when allow extension
   * override is enabled in the Certificate Profile..
   *
   * @return Set of strings containing oids, or an empty set, never null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Set&lt;String&gt; getNonOverridableExtensionOIDs() {
<span class="nc bnc" id="L2508" title="All 2 branches missed.">    if (data.get(NONOVERRIDABLEEXTENSIONOIDS) == null) {</span>
<span class="nc" id="L2509">      return new LinkedHashSet&lt;String&gt;();</span>
    }
<span class="nc" id="L2511">    return (Set&lt;String&gt;) data.get(NONOVERRIDABLEEXTENSIONOIDS);</span>
  }

  /**
   * Method taking a full user dn and returns a DN only containing the DN fields
   * specified in the subjectdn sub set array.
   *
   * @param dn DN
   * @return a subset of original DN
   */
  public String createSubjectDNSubSet(final String dn) {
<span class="fc" id="L2522">    DNFieldExtractor extractor =</span>
        new DNFieldExtractor(dn, DNFieldExtractor.TYPE_SUBJECTDN);
<span class="fc" id="L2524">    return constructUserData(extractor, getSubjectDNSubSet(), true);</span>
  }

  /** @return bool */
  public boolean getUseSubjectAltNameSubSet() {
<span class="fc" id="L2529">    return ((Boolean) data.get(USESUBJECTALTNAMESUBSET)).booleanValue();</span>
  }

  /**
   * @param use bool
   */
  public void setUseSubjectAltNameSubSet(final boolean use) {
<span class="fc" id="L2536">    data.put(USESUBJECTALTNAMESUBSET, Boolean.valueOf(use));</span>
<span class="fc" id="L2537">  }</span>

  /**
   * @return a List of Integer (DNFieldExtractor constants) indicating which
   *     subject altnames fields that should be used in certificate.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;Integer&gt; getSubjectAltNameSubSet() {
<span class="fc" id="L2545">    return (List&lt;Integer&gt;) data.get(SUBJECTALTNAMESUBSET);</span>
  }

  /**
   * Sets a List of Integer (DNFieldExtractor constants) indicating which
   * subject altnames fields that should be used in certificate.
   *
   * @param subjectaltnames names
   */
  public void setSubjectAltNameSubSet(final List&lt;Integer&gt; subjectaltnames) {
<span class="fc" id="L2555">    data.put(SUBJECTALTNAMESUBSET, subjectaltnames);</span>
<span class="fc" id="L2556">  }</span>

  /**
   * Method taking a full user dn and returns a AltName only containing the
   * AltName fields specified in the subjectaltname sub set array.
   *
   * @param subjectaltname Alt Name
   * @return a subset of original DN
   */
  public String createSubjectAltNameSubSet(final String subjectaltname) {
<span class="fc" id="L2566">    DNFieldExtractor extractor =</span>
        new DNFieldExtractor(
            subjectaltname, DNFieldExtractor.TYPE_SUBJECTALTNAME);
<span class="fc" id="L2569">    return constructUserData(extractor, getSubjectAltNameSubSet(), false);</span>
  }

  /**
   * Help method converting a full DN or Subject Alt Name to one usng only
   * specified fields.
   *
   * @param extractor extractor
   * @param usefields fields
   * @param subjectdn DN
   * @return data
   */
  protected static String constructUserData(
      final DNFieldExtractor extractor,
      final Collection&lt;Integer&gt; usefields,
      final boolean subjectdn) {
<span class="fc" id="L2585">    String retval = &quot;&quot;;</span>

<span class="pc bpc" id="L2587" title="1 of 2 branches missed.">    if (usefields instanceof List&lt;?&gt;) {</span>
<span class="fc" id="L2588">      Collections.sort((List&lt;Integer&gt;) usefields);</span>
    }
<span class="fc" id="L2590">    String dnField = null;</span>
<span class="fc bfc" id="L2591" title="All 2 branches covered.">    for (Integer next : usefields) {</span>
<span class="fc" id="L2592">      dnField = extractor.getFieldString(next.intValue());</span>
<span class="pc bpc" id="L2593" title="1 of 2 branches missed.">      if (StringUtils.isNotEmpty(dnField)) {</span>
<span class="fc bfc" id="L2594" title="All 2 branches covered.">        if (retval.length() == 0) {</span>
<span class="fc" id="L2595">          retval += dnField; // first item, don't start with a comma</span>
        } else {
<span class="fc" id="L2597">          retval += &quot;,&quot; + dnField;</span>
        }
      }
<span class="fc" id="L2600">    }</span>
<span class="pc bpc" id="L2601" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2602">      LOG.debug(&quot;CertificateProfile: constructed DN or AltName: &quot; + retval);</span>
    }
<span class="fc" id="L2604">    return retval;</span>
  }

  /**
   * @return a List of caids (Integer), indicating which CAs the profile should
   *     be applicable to.
   *     &lt;p&gt;If it contains the constant ANYCA then the profile is applicable to
   *     all CAs
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;Integer&gt; getAvailableCAs() {
<span class="fc" id="L2615">    return (List&lt;Integer&gt;) data.get(AVAILABLECAS);</span>
  }

  /**
   * Saves the CertificateProfile's list of CAs the cert profile is applicable
   * to.
   *
   * @param availablecas a List of caids (Integer)
   */
  public void setAvailableCAs(final List&lt;Integer&gt; availablecas) {
<span class="fc" id="L2625">    data.put(AVAILABLECAS, availablecas);</span>
<span class="fc" id="L2626">  }</span>

 /** @return bool */
  @SuppressWarnings(&quot;unchecked&quot;)
  public boolean isApplicableToAnyCA() {
<span class="fc" id="L2631">    return ((List&lt;Integer&gt;) data.get(AVAILABLECAS))</span>
<span class="fc" id="L2632">        .contains(Integer.valueOf(ANYCA));</span>
  }

  /**
   * @return a List of publisher id's (Integer) indicating which publishers a
   *     certificate created with this profile should be published to. Never
   *     returns null.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;Integer&gt; getPublisherList() {
<span class="fc" id="L2642">    Object o = data.get(USEDPUBLISHERS);</span>
<span class="pc bpc" id="L2643" title="1 of 2 branches missed.">    if (o == null) {</span>
<span class="nc" id="L2644">      o = new ArrayList&lt;Integer&gt;();</span>
    }
<span class="fc" id="L2646">    return (List&lt;Integer&gt;) o;</span>
  }

  /**
   * Saves the CertificateProfile's list of publishers that certificates created
   * with this profile should be published to.
   *
   * @param publisher a List&amp;lt;Integer&amp;gt; of publisher Ids
   */
  public void setPublisherList(final List&lt;Integer&gt; publisher) {
<span class="fc" id="L2656">    data.put(USEDPUBLISHERS, publisher);</span>
<span class="fc" id="L2657">  }</span>

  /**
   * Method indicating that Path Length Constraint should be used in the
   * BasicConstaint.
   *
   * @return boolean
   */
  public boolean getUsePathLengthConstraint() {
<span class="fc" id="L2666">    return ((Boolean) data.get(USEPATHLENGTHCONSTRAINT)).booleanValue();</span>
  }

  /**
   * Method indicating that Path Length Constraint should be used in the
   * BasicConstaint.
   *
   * @param use boolean
   */
  public void setUsePathLengthConstraint(final boolean use) {
<span class="fc" id="L2676">    data.put(USEPATHLENGTHCONSTRAINT, Boolean.valueOf(use));</span>
<span class="fc" id="L2677">  }</span>

  /**
   * @return Length
   */
  public int getPathLengthConstraint() {
<span class="fc" id="L2683">    return ((Integer) data.get(PATHLENGTHCONSTRAINT)).intValue();</span>
  }
  /**
   * @param pathlength Length
   */
  public void setPathLengthConstraint(final int pathlength) {
<span class="fc" id="L2689">    data.put(PATHLENGTHCONSTRAINT, Integer.valueOf(pathlength));</span>
<span class="fc" id="L2690">  }</span>

  /**
   * @param caIssuers List of issuers
   */
  public void setCaIssuers(final List&lt;String&gt; caIssuers) {
<span class="fc" id="L2696">    data.put(CAISSUERS, caIssuers);</span>
<span class="fc" id="L2697">  }</span>

  /**
   * @param ocaIssuer Issuer
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public void addCaIssuer(final String ocaIssuer) {
<span class="fc" id="L2704">    String caIssuer = ocaIssuer.trim();</span>
<span class="fc bfc" id="L2705" title="All 2 branches covered.">    if (caIssuer.length() &lt; 1) {</span>
<span class="fc" id="L2706">      return;</span>
    }
<span class="pc bpc" id="L2708" title="1 of 2 branches missed.">    if (data.get(CAISSUERS) == null) {</span>
<span class="nc" id="L2709">      List&lt;String&gt; caIssuers = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2710">      caIssuers.add(caIssuer);</span>
<span class="nc" id="L2711">      this.setCaIssuers(caIssuers);</span>
<span class="nc" id="L2712">    } else {</span>
<span class="fc" id="L2713">      ((List&lt;String&gt;) data.get(CAISSUERS)).add(caIssuer);</span>
    }
<span class="fc" id="L2715">  }</span>

  /** @return list of issuers */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;String&gt; getCaIssuers() {
<span class="fc bfc" id="L2720" title="All 2 branches covered.">    if (data.get(CAISSUERS) == null) {</span>
<span class="fc" id="L2721">      return new ArrayList&lt;&gt;();</span>
    } else {
<span class="fc" id="L2723">      return (List&lt;String&gt;) data.get(CAISSUERS);</span>
    }
  }

  /**
   * @param caIssuer issuer
   */
  public void removeCaIssuer(final String caIssuer) {
<span class="pc bpc" id="L2731" title="1 of 2 branches missed.">    if (data.get(CAISSUERS) != null) {</span>
<span class="fc" id="L2732">      ((List&lt;?&gt;) data.get(CAISSUERS)).remove(caIssuer);</span>
    }
<span class="fc" id="L2734">  }</span>

  /** @return bool */
  public boolean getUseOcspNoCheck() {
<span class="pc bpc" id="L2738" title="1 of 2 branches missed.">    if (data.get(USEOCSPNOCHECK) == null) {</span>
<span class="nc" id="L2739">      return false;</span>
    } else {
<span class="fc" id="L2741">      return ((Boolean) data.get(USEOCSPNOCHECK)).booleanValue();</span>
    }
  }

  /**
   * @param useocspnocheck bool
   */
  public void setUseOcspNoCheck(final boolean useocspnocheck) {
<span class="fc" id="L2749">    data.put(USEOCSPNOCHECK, Boolean.valueOf(useocspnocheck));</span>
<span class="fc" id="L2750">  }</span>

  /** @return bool */
  public boolean getUseAuthorityInformationAccess() {
<span class="fc" id="L2754">    return ((Boolean) data.get(USEAUTHORITYINFORMATIONACCESS)).booleanValue();</span>
  }

  /**
   * @param useauthorityinformationaccess bool
   */
  public void setUseAuthorityInformationAccess(
      final boolean useauthorityinformationaccess) {
<span class="fc" id="L2762">    data.put(</span>
        USEAUTHORITYINFORMATIONACCESS,
<span class="fc" id="L2764">        Boolean.valueOf(useauthorityinformationaccess));</span>
<span class="fc" id="L2765">  }</span>

  /** @return bool */
  public boolean getUseDefaultCAIssuer() {
    // Lazy instantiation in case upgrade for some reason fails
<span class="nc bnc" id="L2770" title="All 2 branches missed.">    if (data.get(USEDEFAULTCAISSUER) == null) {</span>
<span class="nc" id="L2771">      data.put(USEDEFAULTCAISSUER, false);</span>
    }
<span class="nc" id="L2773">    return ((Boolean) data.get(USEDEFAULTCAISSUER)).booleanValue();</span>
  }

  /**
   * @param usedefaultcaissuer bool
   */
  public void setUseDefaultCAIssuer(final boolean usedefaultcaissuer) {
<span class="fc" id="L2780">    data.put(USEDEFAULTCAISSUER, Boolean.valueOf(usedefaultcaissuer));</span>
<span class="fc" id="L2781">  }</span>

  /** @return bool */
  public boolean getUseDefaultOCSPServiceLocator() {
<span class="fc" id="L2785">    return ((Boolean) data.get(USEDEFAULTOCSPSERVICELOCATOR)).booleanValue();</span>
  }

  /**
   * @param usedefaultocspservicelocator bool
   */
  public void setUseDefaultOCSPServiceLocator(
      final boolean usedefaultocspservicelocator) {
<span class="fc" id="L2793">    data.put(</span>
        USEDEFAULTOCSPSERVICELOCATOR,
<span class="fc" id="L2795">        Boolean.valueOf(usedefaultocspservicelocator));</span>
<span class="fc" id="L2796">  }</span>

  /** @return URI */
  public String getOCSPServiceLocatorURI() {
<span class="fc" id="L2800">    return (String) data.get(OCSPSERVICELOCATORURI);</span>
  }

  /**
   * @param ocspservicelocatoruri URI
   */
  public void setOCSPServiceLocatorURI(final String ocspservicelocatoruri) {
<span class="fc bfc" id="L2807" title="All 2 branches covered.">    if (ocspservicelocatoruri == null) {</span>
<span class="fc" id="L2808">      data.put(OCSPSERVICELOCATORURI, &quot;&quot;);</span>
    } else {
<span class="fc" id="L2810">      data.put(OCSPSERVICELOCATORURI, ocspservicelocatoruri);</span>
    }
<span class="fc" id="L2812">  }</span>

  /** @return bool */
  public boolean getUseQCStatement() {
<span class="fc" id="L2816">    return ((Boolean) data.get(USEQCSTATEMENT)).booleanValue();</span>
  }

  /**
   * @param useqcstatement bool
   */
  public void setUseQCStatement(final boolean useqcstatement) {
<span class="fc" id="L2823">    data.put(USEQCSTATEMENT, Boolean.valueOf(useqcstatement));</span>
<span class="fc" id="L2824">  }</span>

  /** @return bool */
  public boolean getUsePkixQCSyntaxV2() {
<span class="fc" id="L2828">    return ((Boolean) data.get(USEPKIXQCSYNTAXV2)).booleanValue();</span>
  }

  /**
   * @param pkixqcsyntaxv2 bool
   */
  public void setUsePkixQCSyntaxV2(final boolean pkixqcsyntaxv2) {
<span class="fc" id="L2835">    data.put(USEPKIXQCSYNTAXV2, Boolean.valueOf(pkixqcsyntaxv2));</span>
<span class="fc" id="L2836">  }</span>

  /** @return bool */
  public boolean getQCStatementCritical() {
<span class="fc" id="L2840">    return ((Boolean) data.get(QCSTATEMENTCRITICAL)).booleanValue();</span>
  }

  /**
   * @param qcstatementcritical bool
   */
  public void setQCStatementCritical(final boolean qcstatementcritical) {
<span class="fc" id="L2847">    data.put(QCSTATEMENTCRITICAL, Boolean.valueOf(qcstatementcritical));</span>
<span class="fc" id="L2848">  }</span>

  /** @return String with RAName or empty string */
  public String getQCStatementRAName() {
<span class="fc" id="L2852">    return (String) data.get(QCSTATEMENTRANAME);</span>
  }

  /**
   * @param qcstatementraname RA name
   */
  public void setQCStatementRAName(final String qcstatementraname) {
<span class="pc bpc" id="L2859" title="1 of 2 branches missed.">    if (qcstatementraname == null) {</span>
<span class="fc" id="L2860">      data.put(QCSTATEMENTRANAME, &quot;&quot;);</span>
    } else {
<span class="nc" id="L2862">      data.put(QCSTATEMENTRANAME, qcstatementraname);</span>
    }
<span class="fc" id="L2864">  }</span>

  /** @return String with SemanticsId or empty string */
  public String getQCSemanticsId() {
<span class="fc" id="L2868">    return (String) data.get(QCSSEMANTICSID);</span>
  }

  /**
   * @param qcsemanticsid ID
   */
  public void setQCSemanticsId(final String qcsemanticsid) {
<span class="fc bfc" id="L2875" title="All 2 branches covered.">    if (qcsemanticsid == null) {</span>
<span class="fc" id="L2876">      data.put(QCSSEMANTICSID, &quot;&quot;);</span>
    } else {
<span class="fc" id="L2878">      data.put(QCSSEMANTICSID, qcsemanticsid);</span>
    }
<span class="fc" id="L2880">  }</span>

  /** @return bool */
  public boolean getUseQCEtsiQCCompliance() {
<span class="fc" id="L2884">    return ((Boolean) data.get(USEQCETSIQCCOMPLIANCE)).booleanValue();</span>
  }

  /**
   * @param useqcetsiqccompliance bool
   */
  public void setUseQCEtsiQCCompliance(final boolean useqcetsiqccompliance) {
<span class="fc" id="L2891">    data.put(USEQCETSIQCCOMPLIANCE, Boolean.valueOf(useqcetsiqccompliance));</span>
<span class="fc" id="L2892">  }</span>

  /** @return limit */
  public boolean getUseQCEtsiValueLimit() {
<span class="fc" id="L2896">    return ((Boolean) data.get(USEQCETSIVALUELIMIT)).booleanValue();</span>
  }

  /**
   * @param useqcetsivaluelimit limit
   */
  public void setUseQCEtsiValueLimit(final boolean useqcetsivaluelimit) {
<span class="fc" id="L2903">    data.put(USEQCETSIVALUELIMIT, Boolean.valueOf(useqcetsivaluelimit));</span>
<span class="fc" id="L2904">  }</span>

  /** @return limit */
  public int getQCEtsiValueLimit() {
<span class="fc" id="L2908">    return ((Integer) data.get(QCETSIVALUELIMIT)).intValue();</span>
  }

  /**
   * @param qcetsivaluelimit limit
   */
  public void setQCEtsiValueLimit(final int qcetsivaluelimit) {
<span class="fc" id="L2915">    data.put(QCETSIVALUELIMIT, Integer.valueOf(qcetsivaluelimit));</span>
<span class="fc" id="L2916">  }</span>

  /** @return limit */
  public int getQCEtsiValueLimitExp() {
<span class="fc" id="L2920">    return ((Integer) data.get(QCETSIVALUELIMITEXP)).intValue();</span>
  }

  /**
   * @param qcetsivaluelimitexp limit
   */
  public void setQCEtsiValueLimitExp(final int qcetsivaluelimitexp) {
<span class="fc" id="L2927">    data.put(QCETSIVALUELIMITEXP, Integer.valueOf(qcetsivaluelimitexp));</span>
<span class="fc" id="L2928">  }</span>

  /** @return String with Currency or empty string */
  public String getQCEtsiValueLimitCurrency() {
<span class="fc" id="L2932">    return (String) data.get(QCETSIVALUELIMITCURRENCY);</span>
  }

  /**
   * @param qcetsivaluelimitcurrency Limit
   */
  public void setQCEtsiValueLimitCurrency(
          final String qcetsivaluelimitcurrency) {
<span class="pc bpc" id="L2940" title="1 of 2 branches missed.">    if (qcetsivaluelimitcurrency == null) {</span>
<span class="fc" id="L2941">      data.put(QCETSIVALUELIMITCURRENCY, &quot;&quot;);</span>
    } else {
<span class="nc" id="L2943">      data.put(QCETSIVALUELIMITCURRENCY, qcetsivaluelimitcurrency);</span>
    }
<span class="fc" id="L2945">  }</span>

  /** @return bool */
  public boolean getUseQCEtsiRetentionPeriod() {

<span class="fc" id="L2950">    return ((Boolean) data.get(USEQCETSIRETENTIONPERIOD)).booleanValue();</span>
  }

  /**
   * @param useqcetsiretentionperiod bool
   */
  public void setUseQCEtsiRetentionPeriod(
          final boolean useqcetsiretentionperiod) {
<span class="fc" id="L2958">    data.put(</span>
<span class="fc" id="L2959">        USEQCETSIRETENTIONPERIOD, Boolean.valueOf(useqcetsiretentionperiod));</span>
<span class="fc" id="L2960">  }</span>

  /** @return period */
  public int getQCEtsiRetentionPeriod() {
<span class="fc" id="L2964">    return ((Integer) data.get(QCETSIRETENTIONPERIOD)).intValue();</span>
  }

  /**
   * @param qcetsiretentionperiod period
   */
  public void setQCEtsiRetentionPeriod(final int qcetsiretentionperiod) {
<span class="fc" id="L2971">    data.put(QCETSIRETENTIONPERIOD, Integer.valueOf(qcetsiretentionperiod));</span>
<span class="fc" id="L2972">  }</span>

  /** @return bool */
  public boolean getUseQCEtsiSignatureDevice() {
<span class="fc" id="L2976">    return ((Boolean) data.get(USEQCETSISIGNATUREDEVICE)).booleanValue();</span>
  }

  /**
   * @param useqcetsisignaturedevice bool
   */
  public void setUseQCEtsiSignatureDevice(
          final boolean useqcetsisignaturedevice) {
<span class="fc" id="L2984">    data.put(</span>
<span class="fc" id="L2985">        USEQCETSISIGNATUREDEVICE, Boolean.valueOf(useqcetsisignaturedevice));</span>
<span class="fc" id="L2986">  }</span>

  /**
   * @return String with Type OID or null (or empty string) if it's not to be
   *     used (EN 319 412-05) 0.4.0.1862.1.6.1 = id-etsi-qct-esign
   *     0.4.0.1862.1.6.2 = id-etsi-qct-eseal 0.4.0.1862.1.6.3 = id-etsi-qct-web
   */
  public String getQCEtsiType() {
<span class="fc" id="L2994">    return (String) data.get(QCETSITYPE);</span>
  }

  /**
   * @param qcetsitype type
   */
  public void setQCEtsiType(final String qcetsitype) {
<span class="fc" id="L3001">    data.put(QCETSITYPE, qcetsitype);</span>
<span class="fc" id="L3002">  }</span>

  /**
   * @return the PKI Disclosure Statements (EN 319 412-05) used in this profile,
   *     or null if none are present.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;PKIDisclosureStatement&gt; getQCEtsiPds() {
<span class="fc" id="L3010">    List&lt;PKIDisclosureStatement&gt; result = null;</span>
<span class="fc" id="L3011">    List&lt;PKIDisclosureStatement&gt; pdsList =</span>
<span class="fc" id="L3012">        (List&lt;PKIDisclosureStatement&gt;) data.get(QCETSIPDS);</span>
<span class="pc bpc" id="L3013" title="1 of 4 branches missed.">    if (pdsList != null &amp;&amp; !pdsList.isEmpty()) {</span>
<span class="fc" id="L3014">      result = new ArrayList&lt;&gt;(pdsList.size());</span>
      try {
<span class="fc bfc" id="L3016" title="All 2 branches covered.">        for (final PKIDisclosureStatement pds : pdsList) {</span>
<span class="fc" id="L3017">          result.add((PKIDisclosureStatement) pds.clone());</span>
<span class="fc" id="L3018">        }</span>
<span class="nc" id="L3019">      } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L3020">        throw new IllegalStateException(e);</span>
<span class="fc" id="L3021">      }</span>
    }
<span class="fc" id="L3023">    return result;</span>
  }

  /**
   * Sets the PKI Disclosure Statements (EN 319 412-05). Both null and empty
   * lists are interpreted as an &quot;none&quot;.
   *
   * @param pds list of disclosure statements
   */
  public void setQCEtsiPds(final List&lt;PKIDisclosureStatement&gt; pds) {
<span class="fc bfc" id="L3033" title="All 4 branches covered.">    if (pds == null || pds.isEmpty()) { // never store an empty list</span>
<span class="fc" id="L3034">      data.put(QCETSIPDS, null);</span>
    } else {
<span class="fc" id="L3036">      data.put(QCETSIPDS, new ArrayList&lt;&gt;(pds));</span>
    }
    // Remove old data from EJBCA &lt; 6.6.1
<span class="fc" id="L3039">    data.remove(QCETSIPDSURL);</span>
<span class="fc" id="L3040">    data.remove(QCETSIPDSLANG);</span>
<span class="fc" id="L3041">  }</span>

  /** @return bool */
  public boolean getUseQCCustomString() {
<span class="fc" id="L3045">    return ((Boolean) data.get(USEQCCUSTOMSTRING)).booleanValue();</span>
  }

  /**
   * @param useqccustomstring bool
   */
  public void setUseQCCustomString(final boolean useqccustomstring) {
<span class="fc" id="L3052">    data.put(USEQCCUSTOMSTRING, Boolean.valueOf(useqccustomstring));</span>
<span class="fc" id="L3053">  }</span>

  /** @return String with oid or empty string */
  public String getQCCustomStringOid() {
<span class="fc" id="L3057">    return (String) data.get(QCCUSTOMSTRINGOID);</span>
  }

  /**
   *  @param qccustomstringoid OID
   */
  public void setQCCustomStringOid(final String qccustomstringoid) {
<span class="pc bpc" id="L3064" title="1 of 2 branches missed.">    if (qccustomstringoid == null) {</span>
<span class="fc" id="L3065">      data.put(QCCUSTOMSTRINGOID, &quot;&quot;);</span>
    } else {
<span class="nc" id="L3067">      data.put(QCCUSTOMSTRINGOID, qccustomstringoid);</span>
    }
<span class="fc" id="L3069">  }</span>

  /** @return String with custom text or empty string */
  public String getQCCustomStringText() {
<span class="fc" id="L3073">    return (String) data.get(QCCUSTOMSTRINGTEXT);</span>
  }

  /**
   * @param qccustomstringtext text
   */
  public void setQCCustomStringText(final String qccustomstringtext) {
<span class="pc bpc" id="L3080" title="1 of 2 branches missed.">    if (qccustomstringtext == null) {</span>
<span class="fc" id="L3081">      data.put(QCCUSTOMSTRINGTEXT, &quot;&quot;);</span>
    } else {
<span class="nc" id="L3083">      data.put(QCCUSTOMSTRINGTEXT, qccustomstringtext);</span>
    }
<span class="fc" id="L3085">  }</span>

  /** @return bool */
  public boolean getUseNameConstraints() {
<span class="nc" id="L3089">    Boolean b = (Boolean) data.get(USENAMECONSTRAINTS);</span>
<span class="nc bnc" id="L3090" title="All 4 branches missed.">    return b != null &amp;&amp; b.booleanValue();</span>
  }

  /** @param use bool */
  public void setUseNameConstraints(final boolean use) {
<span class="fc" id="L3095">    data.put(USENAMECONSTRAINTS, Boolean.valueOf(use));</span>
<span class="fc" id="L3096">  }</span>

  /** @return bool */
  public boolean getNameConstraintsCritical() {
<span class="nc" id="L3100">    Boolean b = (Boolean) data.get(NAMECONSTRAINTSCRITICAL);</span>
<span class="nc bnc" id="L3101" title="All 4 branches missed.">    return b != null &amp;&amp; b.booleanValue();</span>
  }

  /** @param use bool */
  public void setNameConstraintsCritical(final boolean use) {
<span class="nc" id="L3106">    data.put(NAMECONSTRAINTSCRITICAL, Boolean.valueOf(use));</span>
<span class="nc" id="L3107">  }</span>

  /** @return bool */
  public boolean getUseSubjectDirAttributes() {
<span class="fc" id="L3111">    return ((Boolean) data.get(USESUBJECTDIRATTRIBUTES)).booleanValue();</span>
  }

  /** @param use bool */
  public void setUseSubjectDirAttributes(final boolean use) {
<span class="fc" id="L3116">    data.put(USESUBJECTDIRATTRIBUTES, Boolean.valueOf(use));</span>
<span class="fc" id="L3117">  }</span>

  /** @param enabled bool */
  public void setSingleActiveCertificateConstraint(final boolean enabled) {
<span class="fc" id="L3121">    data.put(USERSINGLEACTIVECERTIFICATECONSTRAINT, Boolean.valueOf(enabled));</span>
<span class="fc" id="L3122">  }</span>

  /** @return bool */
  public boolean isSingleActiveCertificateConstraint() {
<span class="nc" id="L3126">    Object constraintObject = data.get(USERSINGLEACTIVECERTIFICATECONSTRAINT);</span>
<span class="nc bnc" id="L3127" title="All 2 branches missed.">    if (constraintObject == null) {</span>
      // For upgrading from versions prior to 6.3.1
<span class="nc" id="L3129">      setSingleActiveCertificateConstraint(false);</span>
<span class="nc" id="L3130">      return false;</span>
    } else {
<span class="nc" id="L3132">      return ((Boolean) data.get(USERSINGLEACTIVECERTIFICATECONSTRAINT))</span>
<span class="nc" id="L3133">          .booleanValue();</span>
    }
  }

  /**
   * Returns which type of terminals are used in this ca/certificate hierarchy.
   * The values correspond to the id-roles-1/2/3 OIDs.
   *
   * @return type
   */
  public int getCVCTerminalType() {
<span class="nc bnc" id="L3144" title="All 2 branches missed.">    if (data.get(CVCTERMINALTYPE) == null) {</span>
<span class="nc" id="L3145">      return CertificateProfile.CVC_TERMTYPE_IS;</span>
    }
<span class="nc" id="L3147">    return ((Integer) data.get(CVCTERMINALTYPE)).intValue();</span>
  }

  /** @param termtype type */
  public void setCVCTerminalType(final int termtype) {
<span class="nc" id="L3152">    data.put(CVCTERMINALTYPE, Integer.valueOf(termtype));</span>
<span class="nc" id="L3153">  }</span>

  /** @return bool */
  public boolean isCvcTerminalTypeIs() {
<span class="nc bnc" id="L3157" title="All 2 branches missed.">    return getCVCTerminalType() == CertificateProfile.CVC_TERMTYPE_IS;</span>
  }

  /** @return bool */
  public boolean isCvcTerminalTypeAt() {
<span class="nc bnc" id="L3162" title="All 2 branches missed.">    return getCVCTerminalType() == CertificateProfile.CVC_TERMTYPE_AT;</span>
  }

  /** @return bool */
  public boolean isCvcTerminalTypeSt() {
<span class="nc bnc" id="L3167" title="All 2 branches missed.">    return getCVCTerminalType() == CertificateProfile.CVC_TERMTYPE_ST;</span>
  }

  /**  @return rights */
  public int getCVCAccessRights() {
<span class="pc bpc" id="L3172" title="1 of 2 branches missed.">    if (data.get(CVCACCESSRIGHTS) == null) {</span>
<span class="nc" id="L3173">      return CertificateProfile.CVC_ACCESS_NONE;</span>
    }
<span class="fc" id="L3175">    return ((Integer) data.get(CVCACCESSRIGHTS)).intValue();</span>
  }

  /** @param access access */
  public void setCVCAccessRights(final int access) {
<span class="fc" id="L3180">    data.put(CVCACCESSRIGHTS, Integer.valueOf(access));</span>
<span class="fc" id="L3181">  }</span>

  /**
   * Used for bitmasks that don't fit in an int. E.g. the 5-byte bitmask for
   * Authentication Terminals
   *
   * @return rights
   */
  public byte[] getCVCLongAccessRights() {
<span class="nc bnc" id="L3190" title="All 2 branches missed.">    if (data.get(CVCLONGACCESSRIGHTS) == null) {</span>
<span class="nc" id="L3191">      return null;</span>
    }
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L3194">    List&lt;Byte&gt; rightsList = (List&lt;Byte&gt;) data.get(CVCLONGACCESSRIGHTS);</span>
<span class="nc" id="L3195">    return ArrayUtils.toPrimitive(rightsList.toArray(new Byte[0]));</span>
  }

  /** @param access access */
  public void setCVCLongAccessRights(final byte[] access) {
<span class="nc bnc" id="L3200" title="All 2 branches missed.">    if (access == null) {</span>
<span class="nc" id="L3201">      data.put(CVCLONGACCESSRIGHTS, null);</span>
    } else {
      // Convert to List&lt;Byte&gt; since byte[] doesn't work with database
      // protection
<span class="nc" id="L3205">      data.put(</span>
          CVCLONGACCESSRIGHTS,
<span class="nc" id="L3207">          new ArrayList&lt;&gt;(Arrays.asList(ArrayUtils.toObject(access))));</span>
    }
<span class="nc" id="L3209">  }</span>

  /** @return type */
  public int getCVCSignTermDVType() {
<span class="nc bnc" id="L3213" title="All 2 branches missed.">    if (data.get(CVCSIGNTERMDVTYPE) == null) {</span>
<span class="nc" id="L3214">      return CertificateProfile.CVC_SIGNTERM_DV_CSP;</span>
    }
<span class="nc" id="L3216">    return ((Integer) data.get(CVCSIGNTERMDVTYPE)).intValue();</span>
  }

  /**
   * @param type Type
   */
  public void setCVCSignTermDVType(final int type) {
<span class="nc" id="L3223">    data.put(CVCSIGNTERMDVTYPE, Integer.valueOf(type));</span>
<span class="nc" id="L3224">  }</span>

  /**
   * Method returning a list of (Integers) of ids of used CUSTOM certificate
   * extensions. I.e. those custom certificate extensions selected for this
   * profile. Never null.
   *
   * &lt;p&gt;Autoupgradable method
   *
   * @return extensions
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public List&lt;Integer&gt; getUsedCertificateExtensions() {
<span class="pc bpc" id="L3237" title="1 of 2 branches missed.">    if (data.get(USEDCERTIFICATEEXTENSIONS) == null) {</span>
<span class="nc" id="L3238">      return new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L3240">    return (List&lt;Integer&gt;) data.get(USEDCERTIFICATEEXTENSIONS);</span>
  }

  /**
   * Method setting a list of used certificate extensions a list of Integers
   * containing CertificateExtension Id is expected.
   *
   * @param usedCertificateExtensions extensions
   */
  public void setUsedCertificateExtensions(
      final List&lt;Integer&gt; usedCertificateExtensions) {
<span class="pc bpc" id="L3251" title="1 of 2 branches missed.">    if (usedCertificateExtensions == null) {</span>
<span class="nc" id="L3252">      data.put(USEDCERTIFICATEEXTENSIONS, new ArrayList&lt;Integer&gt;());</span>
    } else {
<span class="fc" id="L3254">      data.put(USEDCERTIFICATEEXTENSIONS, usedCertificateExtensions);</span>
    }
<span class="fc" id="L3256">  }</span>

  /**
   * Function that looks up in the profile all certificate extensions that we
   * should use if the value is that we should use it, the oid for this
   * extension is returned in the list.
   *
   * @return List of oid Strings for standard certificate extensions that should
   *     be used
   */
  public List&lt;String&gt; getUsedStandardCertificateExtensions() {
<span class="fc" id="L3267">    ArrayList&lt;String&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3268">    Iterator&lt;String&gt; iter =</span>
<span class="fc" id="L3269">        USE_STD_CERT_EXTENSIONS.keySet().iterator();</span>
<span class="fc bfc" id="L3270" title="All 2 branches covered.">    while (iter.hasNext()) {</span>
<span class="fc" id="L3271">      String s = iter.next();</span>
<span class="pc bpc" id="L3272" title="1 of 4 branches missed.">      if ((data.get(s) != null) &amp;&amp; ((Boolean) data.get(s)).booleanValue()) {</span>
<span class="fc" id="L3273">        ret.add(USE_STD_CERT_EXTENSIONS.get(s));</span>
<span class="pc bpc" id="L3274" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L3275">          LOG.debug(&quot;Using standard certificate extension: &quot; + s);</span>
        }
      } else {
<span class="pc bpc" id="L3278" title="1 of 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L3279">          LOG.debug(&quot;Not using standard certificate extensions: &quot; + s);</span>
        }
      }
<span class="fc" id="L3282">    }</span>
<span class="fc" id="L3283">    return ret;</span>
  }

  /**
   * @return a List of Integers (CAInfo.REQ_APPROVAL_ constants) of which action
   *     that requires approvals, default none, never null
   * @deprecated since 6.8.0. Use getApprovals() instead;
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  @Deprecated
  public List&lt;Integer&gt; getApprovalSettings() {
<span class="nc" id="L3294">    List&lt;Integer&gt; approvalSettings = (List&lt;Integer&gt;) data.get(APPROVALSETTINGS);</span>
<span class="nc bnc" id="L3295" title="All 2 branches missed.">    if (approvalSettings != null) {</span>
<span class="nc" id="L3296">      return approvalSettings;</span>
    } else {
<span class="nc" id="L3298">      return new ArrayList&lt;&gt;();</span>
    }
  }

  /**
   * List of Integers (CAInfo.REQ_APPROVAL_ constants) of which action that
   * requires approvals.
   *
   * @param approvalSettings settings
   * @deprecated since 6.8.0. Use setApprovals() instead;
   */
  @Deprecated
  public void setApprovalSettings(final List&lt;Integer&gt; approvalSettings) {
<span class="fc" id="L3311">    data.put(APPROVALSETTINGS, approvalSettings);</span>
<span class="fc" id="L3312">  }</span>

  /**
   * Returns the number of different administrators that needs to approve an
   * action, default 1.
   *
   * @return number of required approvals
   * @deprecated since 6.6.0, use the appropriate approval profile instead
   *     Needed for a while in order to be able to import old statedumps from
   *     6.5 and earlier
   */
  @Deprecated
  public int getNumOfReqApprovals() {
<span class="nc" id="L3325">    Integer result = (Integer) data.get(NUMOFREQAPPROVALS);</span>
<span class="nc bnc" id="L3326" title="All 2 branches missed.">    if (result != null) {</span>
<span class="nc" id="L3327">      return result.intValue();</span>
    } else {
<span class="nc" id="L3329">      return 1;</span>
    }
  }

  /**
   * The number of different administrators that needs to approve.
   *
   * @param numOfReqApprovals number of required approvals
   * @deprecated since 6.6.0, use the appropriate approval profile instead
   *     Needed for a while in order to be able to import old statedumps from
   *     6.5 and earlier
   */
  @Deprecated
  public void setNumOfReqApprovals(final int numOfReqApprovals) {
<span class="fc" id="L3343">    data.put(NUMOFREQAPPROVALS, Integer.valueOf(numOfReqApprovals));</span>
<span class="fc" id="L3344">  }</span>

  /**
   * @return the id of the approval profile. ID -1 means that no approval
   *     profile was set
   * @deprecated since 6.8.0. Use getApprovals() instead;
   */
  @Deprecated
  public int getApprovalProfileID() {
<span class="fc" id="L3353">    Integer approvalProfileId = (Integer) data.get(APPROVALPROFILE);</span>
<span class="pc bpc" id="L3354" title="1 of 2 branches missed.">    if (approvalProfileId != null) {</span>
<span class="fc" id="L3355">      return approvalProfileId.intValue();</span>
    } else {
<span class="nc" id="L3357">      return -1;</span>
    }
  }

  /**
   * @param approvalProfileID ID
   * @deprecated since 6.8.0. Use setApprovals() instead;
   */
  @Deprecated
  public void setApprovalProfileID(final int approvalProfileID) {
<span class="fc" id="L3367">    data.put(APPROVALPROFILE, Integer.valueOf(approvalProfileID));</span>
<span class="fc" id="L3368">  }</span>

  /**
   * @param oapprovals Approvals
   */
  public void setApprovals(final Map&lt;ApprovalRequestType, Integer&gt; oapprovals) {
    LinkedHashMap&lt;ApprovalRequestType, Integer&gt; approvals;
<span class="pc bpc" id="L3375" title="1 of 2 branches missed.">    if (oapprovals == null) {</span>
<span class="nc" id="L3376">      approvals = new LinkedHashMap&lt;&gt;();</span>
    } else {
<span class="fc" id="L3378">      approvals = new LinkedHashMap&lt;ApprovalRequestType, Integer&gt;(oapprovals);</span>
    }
    // We must store this as a predictable order map in the database, in order
    // for databaseprotection to work
<span class="fc" id="L3382">    data.put(</span>
        APPROVALS, approvals);
<span class="fc" id="L3384">  }</span>

  /**
   * @return a map of approvals, mapped as approval setting (as defined in this
   *     class) : approval profile ID. Never returns null.
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Map&lt;ApprovalRequestType, Integer&gt; getApprovals() {
<span class="fc bfc" id="L3392" title="All 2 branches covered.">    if (data.get(APPROVALS) == null) {</span>
<span class="fc" id="L3393">      Map&lt;ApprovalRequestType, Integer&gt; approvals = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L3394">      int approvalProfileId = getApprovalProfileID();</span>
<span class="pc bpc" id="L3395" title="1 of 2 branches missed.">      if (approvalProfileId != -1) {</span>
<span class="nc bnc" id="L3396" title="All 2 branches missed.">        for (int approvalSetting : getApprovalSettings()) {</span>
<span class="nc" id="L3397">          approvals.put(</span>
<span class="nc" id="L3398">              ApprovalRequestType.getFromIntegerValue(approvalSetting),</span>
<span class="nc" id="L3399">              approvalProfileId);</span>
<span class="nc" id="L3400">        }</span>
      }
<span class="fc" id="L3402">      setApprovals(approvals);</span>
    }
<span class="fc" id="L3404">    return (Map&lt;ApprovalRequestType, Integer&gt;) data.get(APPROVALS);</span>
  }

  /**
   * @return If the PrivateKeyUsagePeriod extension should be used and with the
   *     notBefore component.
   */
  public boolean isUsePrivateKeyUsagePeriodNotBefore() {
<span class="pc bpc" id="L3412" title="1 of 2 branches missed.">    if (data.get(USEPRIVKEYUSAGEPERIODNOTAFTER) == null) {</span>
<span class="nc" id="L3413">      return false;</span>
    }
<span class="fc" id="L3415">    return ((Boolean) data.get(USEPRIVKEYUSAGEPERIODNOTBEFORE)).booleanValue();</span>
  }

  /**
   * Sets if the PrivateKeyUsagePeriod extension should be used and with the
   * notBefore component. Setting this to true means that there will be an
   * PrivateKeyUsagePeriod extension and that it also at least will contain an
   * notBefore component. Setting this to false means that the extension will
   * not contain an notBefore component. In that case if there will be an
   * extension depends on if {@link #isUsePrivateKeyUsagePeriodNotAfter()} is
   * true.
   *
   * @param use True if the notBefore component should be used.
   */
  public void setUsePrivateKeyUsagePeriodNotBefore(final boolean use) {
<span class="fc" id="L3430">    data.put(USEPRIVKEYUSAGEPERIODNOTBEFORE, use);</span>
<span class="fc bfc" id="L3431" title="All 2 branches covered.">    data.put(</span>
<span class="pc bpc" id="L3432" title="1 of 2 branches missed.">        USEPRIVKEYUSAGEPERIOD, use || isUsePrivateKeyUsagePeriodNotAfter());</span>
<span class="fc" id="L3433">  }</span>

  /**
   * @return If the PrivateKeyUsagePeriod extension should be used and with the
   *     notAfter component.
   */
  public boolean isUsePrivateKeyUsagePeriodNotAfter() {
<span class="pc bpc" id="L3440" title="1 of 2 branches missed.">    if (data.get(USEPRIVKEYUSAGEPERIODNOTAFTER) == null) {</span>
<span class="fc" id="L3441">      return false;</span>
    }
<span class="nc" id="L3443">    return ((Boolean) data.get(USEPRIVKEYUSAGEPERIODNOTAFTER)).booleanValue();</span>
  }

  /**
   * Sets if the PrivateKeyUsagePeriod extension should be used and with the
   * notAfter component. Setting this to true means that there will be an
   * PrivateKeyUsagePeriod extension and that it also at least will contain an
   * notAfter component. Setting this to false means that the extension will not
   * contain an notAfter component. In that case if there will be an extension
   * depends on if {@link #isUsePrivateKeyUsagePeriodNotBefore()} is true.
   *
   * @param use True if the notAfter component should be used.
   */
  public void setUsePrivateKeyUsagePeriodNotAfter(final boolean use) {
<span class="fc" id="L3457">    data.put(USEPRIVKEYUSAGEPERIODNOTAFTER, use);</span>
<span class="fc bfc" id="L3458" title="All 2 branches covered.">    data.put(</span>
<span class="pc bpc" id="L3459" title="1 of 2 branches missed.">        USEPRIVKEYUSAGEPERIOD, use || isUsePrivateKeyUsagePeriodNotBefore());</span>
<span class="fc" id="L3460">  }</span>

  /**
   * @return How long (in seconds) after the certificate's notBefore date the
   *     PrivateKeyUsagePeriod's notBefore date should be.
   */
  public long getPrivateKeyUsagePeriodStartOffset() {
<span class="nc" id="L3467">    return ((Long) data.get(PRIVKEYUSAGEPERIODSTARTOFFSET)).longValue();</span>
  }

  /**
   * Sets how long (in seconds) after the certificate's notBefore date the
   * PrivateKeyUsagePeriod's notBefore date should be.
   *
   * @param start Offset from certificate issuance.
   */
  public void setPrivateKeyUsagePeriodStartOffset(final long start) {
<span class="fc" id="L3477">    data.put(PRIVKEYUSAGEPERIODSTARTOFFSET, start);</span>
<span class="fc" id="L3478">  }</span>

  /**
   * @return The private key usage period (private key validity) length (in
   *     seconds).
   */
  public long getPrivateKeyUsagePeriodLength() {
<span class="nc" id="L3485">    return ((Long) data.get(PRIVKEYUSAGEPERIODLENGTH)).longValue();</span>
  }

  /**
   * Sets the private key usage period (private key validity) length (in
   * seconds).
   *
   * @param validity The length.
   */
  public void setPrivateKeyUsagePeriodLength(final long validity) {
<span class="fc" id="L3495">    data.put(PRIVKEYUSAGEPERIODLENGTH, validity);</span>
<span class="fc" id="L3496">  }</span>

  /**
   * @return Whether Certificate Transparency (CT) should be used when
   *     generating new certificates. CT is specified in RFC 6962
   */
  public boolean isUseCertificateTransparencyInCerts() {
<span class="nc bnc" id="L3503" title="All 2 branches missed.">    if (data.get(USECERTIFICATETRANSPARENCYINCERTS) == null) {</span>
<span class="nc" id="L3504">      return false;</span>
    }
<span class="nc" id="L3506">    return ((Boolean) data.get(USECERTIFICATETRANSPARENCYINCERTS))</span>
<span class="nc" id="L3507">        .booleanValue();</span>
  }

  /** @param use bool  */
  public void setUseCertificateTransparencyInCerts(final boolean use) {
<span class="fc" id="L3512">    data.put(USECERTIFICATETRANSPARENCYINCERTS, use);</span>
<span class="fc" id="L3513">  }</span>

  /**
   * @return Whether Certificate Transparency (CT) should be used in OCSP
   *     responses. CT is specified in RFC 6962
   */
  public boolean isUseCertificateTransparencyInOCSP() {
<span class="nc bnc" id="L3520" title="All 2 branches missed.">    if (data.get(USECERTIFICATETRANSPARENCYINOCSP) == null) {</span>
<span class="nc" id="L3521">      return false;</span>
    }
<span class="nc" id="L3523">    return ((Boolean) data.get(USECERTIFICATETRANSPARENCYINOCSP))</span>
<span class="nc" id="L3524">        .booleanValue();</span>
  }

  /** @param use bool  */
  public void setUseCertificateTransparencyInOCSP(final boolean use) {
<span class="fc" id="L3529">    data.put(USECERTIFICATETRANSPARENCYINOCSP, use);</span>
<span class="fc" id="L3530">  }</span>

  /**
   * @return Whether Certificate Transparency (CT) should be used in publishers.
   *     You have to create a publisher and enable it in the profile also!
   */
  public boolean isUseCertificateTransparencyInPublishers() {
<span class="nc bnc" id="L3537" title="All 2 branches missed.">    if (data.get(USECERTIFICATETRANSPARENCYINPUBLISHERS) == null) {</span>
      // Default to being enabled if CT in OCSP was enabled
<span class="nc" id="L3539">      return isUseCertificateTransparencyInOCSP();</span>
    }
<span class="nc" id="L3541">    return ((Boolean) data.get(USECERTIFICATETRANSPARENCYINPUBLISHERS))</span>
<span class="nc" id="L3542">        .booleanValue();</span>
  }

  /** @param use bool  */
  public void setUseCertificateTransparencyInPublishers(final boolean use) {
<span class="fc" id="L3547">    data.put(USECERTIFICATETRANSPARENCYINPUBLISHERS, use);</span>
<span class="fc" id="L3548">  }</span>

  /** @return bool */
  public boolean isCtEnabled() {
<span class="nc bnc" id="L3552" title="All 2 branches missed.">    return isUseCertificateTransparencyInCerts()</span>
<span class="nc bnc" id="L3553" title="All 2 branches missed.">        || isUseCertificateTransparencyInOCSP()</span>
<span class="nc bnc" id="L3554" title="All 2 branches missed.">        || isUseCertificateTransparencyInPublishers();</span>
  }

  /** @return bool */
  public boolean isNumberOfSctByValidity() {
<span class="nc bnc" id="L3559" title="All 2 branches missed.">    if (data.get(CT_NUMBER_OF_SCTS_BY_VALIDITY) == null) {</span>
      // Default value
<span class="nc" id="L3561">      return true;</span>
    }
<span class="nc" id="L3563">    return (Boolean) data.get(CT_NUMBER_OF_SCTS_BY_VALIDITY);</span>
  }

  /** @param use bool  */
  public void setNumberOfSctByValidity(final boolean use) {
<span class="nc" id="L3568">    data.put(CT_NUMBER_OF_SCTS_BY_VALIDITY, use);</span>
<span class="nc" id="L3569">  }</span>

  /** @return bool */
  public boolean isNumberOfSctByCustom() {
<span class="nc bnc" id="L3573" title="All 2 branches missed.">    if (data.get(CT_NUMBER_OF_SCTS_BY_CUSTOM) == null) {</span>
      // Default value
<span class="nc" id="L3575">      return false;</span>
    }
<span class="nc" id="L3577">    return (Boolean) data.get(CT_NUMBER_OF_SCTS_BY_CUSTOM);</span>
  }

  /** @param use bool  */
  public void setNumberOfSctByCustom(final boolean use) {
<span class="nc" id="L3582">    data.put(CT_NUMBER_OF_SCTS_BY_CUSTOM, use);</span>
<span class="nc" id="L3583">  }</span>

  /** @return bool */
  public boolean isMaxNumberOfSctByValidity() {
<span class="nc bnc" id="L3587" title="All 2 branches missed.">    if (data.get(CT_MAX_NUMBER_OF_SCTS_BY_VALIDITY) == null) {</span>
      // Default value
<span class="nc" id="L3589">      return false;</span>
    }
<span class="nc" id="L3591">    return (Boolean) data.get(CT_MAX_NUMBER_OF_SCTS_BY_VALIDITY);</span>
  }
  /** @param use bool  */
  public void setMaxNumberOfSctByValidity(final boolean use) {
<span class="nc" id="L3595">    data.put(CT_MAX_NUMBER_OF_SCTS_BY_VALIDITY, use);</span>
<span class="nc" id="L3596">  }</span>

  /** @return bool */
  public boolean isMaxNumberOfSctByCustom() {
<span class="nc bnc" id="L3600" title="All 2 branches missed.">    if (data.get(CT_MAX_NUMBER_OF_SCTS_BY_CUSTOM) == null) {</span>
      // Default value
<span class="nc" id="L3602">      return true;</span>
    }
<span class="nc" id="L3604">    return (Boolean) data.get(CT_MAX_NUMBER_OF_SCTS_BY_CUSTOM);</span>
  }
 /** @param use bool */
  public void setMaxNumberOfSctByCustom(final boolean use) {
<span class="nc" id="L3608">    data.put(CT_MAX_NUMBER_OF_SCTS_BY_CUSTOM, use);</span>
<span class="nc" id="L3609">  }</span>

  /**
   * @return Whether existing certificates should be submitted by the CT
   *     publisher and the CT OCSP extension class.
   */
  public boolean isUseCTSubmitExisting() {
<span class="nc bnc" id="L3616" title="All 2 branches missed.">    if (data.get(CTSUBMITEXISTING) == null) {</span>
<span class="nc" id="L3617">      return true;</span>
    }
<span class="nc" id="L3619">    return ((Boolean) data.get(CTSUBMITEXISTING)).booleanValue();</span>
  }

  /** @param use bool*/
  public void setUseCTSubmitExisting(final boolean use) {
<span class="nc" id="L3624">    data.put(CTSUBMITEXISTING, use);</span>
<span class="nc" id="L3625">  }</span>

  /** @return the IDs of the CT logs that are activated in this profile. */
  @SuppressWarnings(&quot;unchecked&quot;)
  @Deprecated
  public Set&lt;Integer&gt; getEnabledCTLogs() {
<span class="nc bnc" id="L3631" title="All 2 branches missed.">    if (data.get(CTLOGS) == null) {</span>
<span class="nc" id="L3632">      return new LinkedHashSet&lt;&gt;();</span>
    }

<span class="nc" id="L3635">    return (Set&lt;Integer&gt;) data.get(CTLOGS);</span>
  }

  /**
   * Sets the enabled CT logs. NOTE: The argument must be a LinkedHashSet, since
   * order is important
   *
   * @param logIds IDs
   */
  @Deprecated
  public void setEnabledCTLogs(final LinkedHashSet&lt;Integer&gt; logIds) {
<span class="nc" id="L3646">    data.put(CTLOGS, new LinkedHashSet&lt;&gt;(logIds));</span>
<span class="nc" id="L3647">  }</span>

  /** @return labels */
  @SuppressWarnings(&quot;unchecked&quot;)
  public Set&lt;String&gt; getEnabledCtLabels() {
<span class="nc bnc" id="L3652" title="All 2 branches missed.">    if (data.get(CTLABELS) == null) {</span>
<span class="nc" id="L3653">      return new LinkedHashSet&lt;&gt;();</span>
    }
<span class="nc" id="L3655">    return (Set&lt;String&gt;) data.get(CTLABELS);</span>
  }

  /** @param ctLabels Labels */
  public void setEnabledCTLabels(final LinkedHashSet&lt;String&gt; ctLabels) {
<span class="nc" id="L3660">    data.put(CTLABELS, ctLabels);</span>
<span class="nc" id="L3661">  }</span>

  /**
   * Number of CT logs to require an SCT from, or it will be considered an
   * error. If zero, CT is completely optional and ignored if no log servers can
   * be contacted.
   *
   * &lt;p&gt;This value is used for certificates and publishers. For OCSP
   * responses, @see CertificateProfile#getCtMinTotalSctsOcsp
   *
   * &lt;p&gt;
   *
   * @return the total number of SCTs required
   */
  @Deprecated
  public int getCtMinTotalScts() {
<span class="nc bnc" id="L3677" title="All 2 branches missed.">    if (data.get(CT_MIN_TOTAL_SCTS) == null) {</span>
<span class="nc" id="L3678">      return 0; // setting is OFF</span>
    }
<span class="nc" id="L3680">    return (Integer) data.get(CT_MIN_TOTAL_SCTS);</span>
  }

  /** @param value minimum number of SCTs required in total */
  @Deprecated
  public void setCtMinTotalScts(final int value) {
<span class="nc" id="L3686">    data.put(CT_MIN_TOTAL_SCTS, value);</span>
<span class="nc" id="L3687">  }</span>

  /**
   * @return sets
   * @see CertificateProfile#getCtMinTotalScts
   */
  @Deprecated
  public int getCtMinTotalSctsOcsp() {
<span class="nc bnc" id="L3695" title="All 2 branches missed.">    if (data.get(CT_MIN_TOTAL_SCTS_OCSP) == null) {</span>
<span class="nc" id="L3696">      return getCtMinTotalScts();</span>
    }
<span class="nc" id="L3698">    return (Integer) data.get(CT_MIN_TOTAL_SCTS_OCSP);</span>
  }

  /**
   * @param value minimum number of SCTs for OCSP responses required in total
   */
  @Deprecated
  public void setCtMinTotalSctsOcsp(final int value) {
<span class="nc" id="L3706">    data.put(CT_MIN_TOTAL_SCTS_OCSP, value);</span>
<span class="nc" id="L3707">  }</span>

  /**
   * Number of SCTs retrieved after which we will stop contacting non-mandatory
   * log servers.
   *
   * @return the maximum number of non-mandatory SCTs
   */
  @Deprecated
  public int getCtMaxNonMandatoryScts() {
<span class="nc bnc" id="L3717" title="All 2 branches missed.">    if (data.get(CT_MAX_NONMANDATORY_SCTS) == null) {</span>
<span class="nc bnc" id="L3718" title="All 2 branches missed.">      if (data.get(CT_MAX_SCTS) == null) {</span>
<span class="nc" id="L3719">        LOG.info(</span>
            &quot;CT_MAX_NON_MANDATORY_SCTS is null =&gt; legacy value is also null,&quot;
                + &quot; using 1 log as default.&quot;);
<span class="nc" id="L3722">        return 1;</span>
      }
<span class="nc" id="L3724">      LOG.info(</span>
          &quot;CT_MAX_NON_MANDATORY_SCTS is null =&gt; using legacy value: &quot;
<span class="nc" id="L3726">              + data.get(CT_MAX_SCTS));</span>
<span class="nc" id="L3727">      return (Integer) data.get(CT_MAX_SCTS);</span>
    }
<span class="nc" id="L3729">    return (Integer) data.get(CT_MAX_NONMANDATORY_SCTS);</span>
  }

  /** @param value the maximum number of non-mandatory SCTs */
  @Deprecated
  public void setCtMaxNonMandatoryScts(final int value) {
<span class="nc" id="L3735">    data.put(CT_MAX_NONMANDATORY_SCTS, value);</span>
<span class="nc" id="L3736">  }</span>

  /**
   * @return sets
   * @see CertificateProfile#getCtMaxNonMandatoryScts
   */
  @Deprecated
  public int getCtMaxNonMandatorySctsOcsp() {
<span class="nc bnc" id="L3744" title="All 2 branches missed.">    if (data.get(CT_MAX_NONMANDATORY_SCTS_OCSP) == null) {</span>
<span class="nc bnc" id="L3745" title="All 2 branches missed.">      if (data.get(CT_MAX_SCTS_OCSP) == null) {</span>
<span class="nc" id="L3746">        LOG.info(</span>
            &quot;CT_MAX_NON_MANDATORY_SCTS_OCSP is null =&gt; legacy value is also&quot;
                + &quot; null, using 1 log as default.&quot;);
<span class="nc" id="L3749">        return 1;</span>
      }
<span class="nc" id="L3751">      LOG.info(</span>
          &quot;CT_MAX_NON_MANDATORY_SCTS_OCSP is null =&gt; using legacy value: &quot;
<span class="nc" id="L3753">              + data.get(CT_MAX_SCTS_OCSP));</span>
<span class="nc" id="L3754">      return (Integer) data.get(CT_MAX_SCTS_OCSP);</span>
    }
<span class="nc" id="L3756">    return (Integer) data.get(CT_MAX_NONMANDATORY_SCTS_OCSP);</span>
  }

  /**
   * @param value maximum value number of non-mandatory SCTs for OCSP responses
   */
  @Deprecated
  public void setCtMaxNonMandatorySctsOcsp(final int value) {
<span class="nc" id="L3764">    data.put(CT_MAX_NONMANDATORY_SCTS_OCSP, value);</span>
<span class="nc" id="L3765">  }</span>

  /**
   * Number of CT logs marked as &quot;not mandatory&quot; to require an SCT from, or it
   * will be considered an error. Default is zero logs.
   *
   * &lt;p&gt;For publishers, certificates are submitted to all enabled logs.
   *
   * @return scts
   */
  @Deprecated
  public int getCtMinNonMandatoryScts() {
<span class="nc bnc" id="L3777" title="All 2 branches missed.">    if (data.get(CT_MIN_NONMANDATORY_SCTS) == null) {</span>
<span class="nc" id="L3778">      return getCtMinTotalScts();</span>
    }
<span class="nc" id="L3780">    return (Integer) data.get(CT_MIN_NONMANDATORY_SCTS);</span>
  }

  /** @param value minimum number of non-mandatory SCTs */
  @Deprecated
  public void setCtMinNonMandatoryScts(final int value) {
<span class="nc" id="L3786">    data.put(CT_MIN_NONMANDATORY_SCTS, value);</span>
<span class="nc" id="L3787">  }</span>

  /**
   * @return scts
   * @see CertificateProfile#getCtMinNonMandatoryScts
   */
  @Deprecated
  public int getCtMinNonMandatorySctsOcsp() {
<span class="nc bnc" id="L3795" title="All 2 branches missed.">    if (data.get(CT_MIN_NONMANDATORY_SCTS_OCSP) == null) {</span>
<span class="nc" id="L3796">      return getCtMinNonMandatoryScts();</span>
    }
<span class="nc" id="L3798">    return (Integer) data.get(CT_MIN_NONMANDATORY_SCTS_OCSP);</span>
  }

  /** @param value minimum number of non-mandatory SCTs */
  @Deprecated
  public void setCtMinNonMandatorySctsOcsp(final int value) {
<span class="nc" id="L3804">    data.put(CT_MIN_NONMANDATORY_SCTS_OCSP, value);</span>
<span class="nc" id="L3805">  }</span>

  /** @return Min SCTs */
  public int getCtMinScts() {
<span class="nc bnc" id="L3809" title="All 2 branches missed.">    if (data.get(CT_SCTS_MIN) == null) {</span>
<span class="nc" id="L3810">      return getCtMinTotalScts();</span>
    }
<span class="nc" id="L3812">    return (Integer) data.get(CT_SCTS_MIN);</span>
  }

  /** @param value Min SCTs*/
  public void setCtMinScts(final int value) {
<span class="nc" id="L3817">    data.put(CT_SCTS_MIN, value);</span>
<span class="nc" id="L3818">  }</span>

  /** @return max scts */
  public int getCtMaxScts() {
<span class="nc bnc" id="L3822" title="All 2 branches missed.">    if (data.get(CT_SCTS_MAX) == null) {</span>
<span class="nc" id="L3823">      return getCtMinTotalScts();</span>
    }
<span class="nc" id="L3825">    return (Integer) data.get(CT_SCTS_MAX);</span>
  }

  /** @param value Max SCTs*/
  public void setCtMaxScts(final int value) {
<span class="nc" id="L3830">    data.put(CT_SCTS_MAX, value);</span>
<span class="nc" id="L3831">  }</span>

  /** @return Min SCTs */
  public int getCtMinSctsOcsp() {
<span class="nc bnc" id="L3835" title="All 2 branches missed.">    if (data.get(CT_SCTS_MIN_OCSP) == null) {</span>
<span class="nc" id="L3836">      return getCtMinTotalScts();</span>
    }
<span class="nc" id="L3838">    return (Integer) data.get(CT_SCTS_MIN_OCSP);</span>
  }

  /** @param value Min SCTs*/
  public void setCtMinSctsOcsp(final int value) {
<span class="nc" id="L3843">    data.put(CT_SCTS_MIN_OCSP, value);</span>
<span class="nc" id="L3844">  }</span>

  /** @return max scts */
  public int getCtMaxSctsOcsp() {
<span class="nc bnc" id="L3848" title="All 2 branches missed.">    if (data.get(CT_SCTS_MAX_OCSP) == null) {</span>
<span class="nc" id="L3849">      return getCtMinTotalScts();</span>
    }
<span class="nc" id="L3851">    return (Integer) data.get(CT_SCTS_MAX_OCSP);</span>
  }
 /** @param value value */
  public void setCtMaxSctsOcsp(final int value) {
<span class="nc" id="L3855">    data.put(CT_SCTS_MAX_OCSP, value);</span>
<span class="nc" id="L3856">  }</span>

  /**
   * @return Number of times to retry connecting to a Certificate Transparency
   *     log
   */
  public int getCTMaxRetries() {
<span class="nc bnc" id="L3863" title="All 2 branches missed.">    if (data.get(CTMAXRETRIES) == null) {</span>
<span class="nc" id="L3864">      return 0;</span>
    }
<span class="nc" id="L3866">    return (Integer) data.get(CTMAXRETRIES);</span>
  }

  /** @param numRetries retries*/
  public void setCTMaxRetries(final int numRetries) {
<span class="nc" id="L3871">    data.put(CTMAXRETRIES, numRetries);</span>
<span class="nc" id="L3872">  }</span>

  /**
   * Usage only intended for post upgrade! Removes CT data prior to EJBCA 6.10.1
   * from certificate profile.
   */
  public void removeLegacyCtData() {
<span class="nc bnc" id="L3879" title="All 2 branches missed.">    if (data.get(CT_MAX_SCTS) != null) {</span>
<span class="nc" id="L3880">      data.remove(CT_MAX_SCTS);</span>
    }
<span class="nc bnc" id="L3882" title="All 2 branches missed.">    if (data.get(CT_MAX_SCTS_OCSP) != null) {</span>
<span class="nc" id="L3883">      data.remove(CT_MAX_SCTS_OCSP);</span>
    }
<span class="nc bnc" id="L3885" title="All 2 branches missed.">    if (data.get(CT_MIN_MANDATORY_SCTS) != null) {</span>
<span class="nc" id="L3886">      data.remove(CT_MIN_MANDATORY_SCTS);</span>
    }
<span class="nc bnc" id="L3888" title="All 2 branches missed.">    if (data.get(CT_MAX_MANDATORY_SCTS) != null) {</span>
<span class="nc" id="L3889">      data.remove(CT_MAX_MANDATORY_SCTS);</span>
    }
<span class="nc bnc" id="L3891" title="All 2 branches missed.">    if (data.get(CT_MIN_MANDATORY_SCTS_OCSP) != null) {</span>
<span class="nc" id="L3892">      data.remove(CT_MIN_MANDATORY_SCTS_OCSP);</span>
    }
<span class="nc bnc" id="L3894" title="All 2 branches missed.">    if (data.get(CT_MAX_MANDATORY_SCTS_OCSP) != null) {</span>
<span class="nc" id="L3895">      data.remove(CT_MAX_MANDATORY_SCTS_OCSP);</span>
    }
<span class="nc bnc" id="L3897" title="All 2 branches missed.">    if (data.get(CT_MIN_NONMANDATORY_SCTS) != null) {</span>
<span class="nc" id="L3898">      data.remove(CT_MIN_NONMANDATORY_SCTS);</span>
    }
<span class="nc bnc" id="L3900" title="All 2 branches missed.">    if (data.get(CT_MAX_NONMANDATORY_SCTS) != null) {</span>
<span class="nc" id="L3901">      data.remove(CT_MAX_NONMANDATORY_SCTS);</span>
    }
<span class="nc bnc" id="L3903" title="All 2 branches missed.">    if (data.get(CT_MIN_NONMANDATORY_SCTS_OCSP) != null) {</span>
<span class="nc" id="L3904">      data.remove(CT_MIN_NONMANDATORY_SCTS_OCSP);</span>
    }
<span class="nc bnc" id="L3906" title="All 2 branches missed.">    if (data.get(CT_MAX_NONMANDATORY_SCTS_OCSP) != null) {</span>
<span class="nc" id="L3907">      data.remove(CT_MAX_NONMANDATORY_SCTS_OCSP);</span>
    }
<span class="nc" id="L3909">  }</span>

  /**
   * Checks that a public key fulfills the policy in the CertificateProfile.
   *
   * @param publicKey PublicKey to verify
   * @throws IllegalKeyException if the PublicKey does not fulfill policy in
   *     CertificateProfile
   */
  public void verifyKey(final PublicKey publicKey) throws IllegalKeyException {
<span class="fc" id="L3919">    final String keyAlgorithm = AlgorithmTools.getKeyAlgorithm(publicKey);</span>
<span class="fc" id="L3920">    final int keyLength = KeyTools.getKeyLength(publicKey);</span>
<span class="pc bpc" id="L3921" title="1 of 2 branches missed.">    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L3922">      LOG.debug(&quot;KeyAlgorithm: &quot; + keyAlgorithm + &quot; KeyLength: &quot; + keyLength);</span>
    }
    // Verify that the key algorithm is compliant with the certificate profile
<span class="fc bfc" id="L3925" title="All 2 branches covered.">    if (!getAvailableKeyAlgorithmsAsList().contains(keyAlgorithm)) {</span>
<span class="pc bpc" id="L3926" title="1 of 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L3927">        LOG.debug(</span>
            &quot;List of available algorithms &quot;
<span class="nc" id="L3929">                + getAvailableKeyAlgorithmsAsList()</span>
                + &quot; does not contain the on of the public key: &quot;
                + keyAlgorithm);
      }
<span class="fc" id="L3933">      throw new IllegalKeyException(</span>
<span class="fc" id="L3934">          INT_RES.getLocalizedMessage(</span>
              &quot;createcert.illegalkeyalgorithm&quot;, keyAlgorithm));
    }
<span class="fc bfc" id="L3937" title="All 2 branches covered.">    if (AlgorithmConstants.KEYALGORITHM_ECDSA.equals(keyAlgorithm)) {</span>
<span class="fc" id="L3938">      final List&lt;String&gt; availableEcCurves = getAvailableEcCurvesAsList();</span>
<span class="fc" id="L3939">      final String keySpecification =</span>
<span class="fc" id="L3940">          AlgorithmTools.getKeySpecification(publicKey);</span>
      for (final String ecNamedCurveAlias
<span class="fc bfc" id="L3942" title="All 2 branches covered.">          : AlgorithmTools.getEcKeySpecAliases(keySpecification)) {</span>
<span class="fc bfc" id="L3943" title="All 2 branches covered.">        if (availableEcCurves.contains(ecNamedCurveAlias)) {</span>
          // Curve is allowed, so we don't check key strength
<span class="fc" id="L3945">          return;</span>
        }
<span class="fc" id="L3947">      }</span>
<span class="fc bfc" id="L3948" title="All 2 branches covered.">      if (!availableEcCurves.contains(ANY_EC_CURVE)) {</span>
        // Curve will never be allowed by bit length check
<span class="fc" id="L3950">        throw new IllegalKeyException(</span>
<span class="fc" id="L3951">            INT_RES.getLocalizedMessage(</span>
                &quot;createcert.illegaleccurve&quot;, keySpecification));
      }
    }
    // Verify key length that it is compliant with certificate profile
<span class="pc bpc" id="L3956" title="1 of 2 branches missed.">    if (keyLength == -1) {</span>
<span class="nc" id="L3957">      throw new IllegalKeyException(</span>
<span class="nc" id="L3958">          INT_RES.getLocalizedMessage(</span>
<span class="nc" id="L3959">              &quot;createcert.unsupportedkeytype&quot;, publicKey.getClass().getName()));</span>
    }
<span class="fc bfc" id="L3961" title="All 2 branches covered.">    if ((keyLength &lt; (getMinimumAvailableBitLength() - 1))</span>
<span class="pc bpc" id="L3962" title="1 of 2 branches missed.">        || (keyLength &gt; (getMaximumAvailableBitLength()))) {</span>
<span class="fc" id="L3963">      throw new IllegalKeyException(</span>
<span class="fc" id="L3964">          INT_RES.getLocalizedMessage(</span>
<span class="fc" id="L3965">              &quot;createcert.illegalkeylength&quot;, Integer.valueOf(keyLength)));</span>
    }
<span class="fc" id="L3967">  }</span>

  /**
   * Checks that provided caId is allowed.
   *
   * @param caId caId to verify
   * @return Returns true, if caId belongs to availableCas or if any CA is
   *     allowed (-1 is in availableCAs list)
   */
  public boolean isCaAllowed(final int caId) {
<span class="nc" id="L3977">    List&lt;Integer&gt; availableCAs = getAvailableCAs();</span>
<span class="nc bnc" id="L3978" title="All 4 branches missed.">    return availableCAs.contains(-1) || availableCAs.contains(caId);</span>
  }

  @Override
  public CertificateProfile clone() throws CloneNotSupportedException {
<span class="fc" id="L3983">    final CertificateProfile clone = new CertificateProfile(0);</span>
    // We need to make a deep copy of the hashmap here
<span class="fc" id="L3985">    clone.data = new LinkedHashMap&lt;&gt;(data.size());</span>
<span class="fc bfc" id="L3986" title="All 2 branches covered.">    for (final Entry&lt;Object, Object&gt; entry : data.entrySet()) {</span>
<span class="fc" id="L3987">      Object value = entry.getValue();</span>
<span class="fc bfc" id="L3988" title="All 2 branches covered.">      if (value instanceof ArrayList&lt;?&gt;) {</span>
        // We need to make a clone of this object, but the stored immutables can
        // still be referenced
<span class="fc" id="L3991">        value = ((ArrayList&lt;?&gt;) value).clone();</span>
      }
<span class="fc" id="L3993">      clone.data.put(entry.getKey(), value);</span>
<span class="fc" id="L3994">    }</span>
<span class="fc" id="L3995">    return clone;</span>
  }

  /** Implementation of UpgradableDataHashMap function getLatestVersion. */
  @Override
  public float getLatestVersion() {
<span class="fc" id="L4001">    return LATEST_VERSION;</span>
  }

  /**
   * Function setting the current version of the class data. Used for JUnit
   * testing
   *
   * @param version version
   */
  protected void setVersion(final float version) {
<span class="nc" id="L4011">    data.put(VERSION, Float.valueOf(version));</span>
<span class="nc" id="L4012">  }</span>

  /** Implementation of UpgradableDataHashMap function upgrade. */
  @SuppressWarnings(&quot;deprecation&quot;)
  @Override
  public void upgrade() {
<span class="pc bpc" id="L4018" title="1 of 2 branches missed.">    if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L4019">      LOG.trace(&quot;&gt;upgrade: &quot; + getLatestVersion() + &quot;, &quot; + getVersion());</span>
    }
<span class="pc bpc" id="L4021" title="1 of 2 branches missed.">    if (Float.compare(getLatestVersion(), getVersion()) != 0) {</span>
      // New version of the class, upgrade
<span class="fc" id="L4023">      String msg =</span>
<span class="fc" id="L4024">          INT_RES.getLocalizedMessage(</span>
<span class="fc" id="L4025">              &quot;certprofile.upgrade&quot;, new Float(getVersion()));</span>
<span class="fc" id="L4026">      LOG.info(msg);</span>

<span class="pc bpc" id="L4028" title="1 of 2 branches missed.">      if (data.get(ALLOWKEYUSAGEOVERRIDE) == null) {</span>
<span class="fc" id="L4029">        data.put(ALLOWKEYUSAGEOVERRIDE, Boolean.TRUE);</span>
      }
<span class="pc bpc" id="L4031" title="1 of 2 branches missed.">      if (data.get(USEEXTENDEDKEYUSAGE) == null) {</span>
<span class="fc" id="L4032">        data.put(USEEXTENDEDKEYUSAGE, Boolean.FALSE);</span>
      }
<span class="pc bpc" id="L4034" title="1 of 2 branches missed.">      if (data.get(EXTENDEDKEYUSAGE) == null) {</span>
<span class="fc" id="L4035">        data.put(EXTENDEDKEYUSAGE, new ArrayList&lt;String&gt;());</span>
      }
<span class="pc bpc" id="L4037" title="1 of 2 branches missed.">      if (data.get(EXTENDEDKEYUSAGECRITICAL) == null) {</span>
<span class="fc" id="L4038">        data.put(EXTENDEDKEYUSAGECRITICAL, Boolean.FALSE);</span>
      }
<span class="pc bpc" id="L4040" title="1 of 2 branches missed.">      if (data.get(AVAILABLECAS) == null) {</span>
<span class="fc" id="L4041">        ArrayList&lt;Integer&gt; availablecas = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L4042">        availablecas.add(Integer.valueOf(ANYCA));</span>
<span class="fc" id="L4043">        data.put(AVAILABLECAS, availablecas);</span>
      }
<span class="pc bpc" id="L4045" title="1 of 2 branches missed.">      if (data.get(USEDPUBLISHERS) == null) {</span>
<span class="fc" id="L4046">        data.put(USEDPUBLISHERS, new ArrayList&lt;Integer&gt;());</span>
      }
<span class="pc bpc" id="L4048" title="1 of 2 branches missed.">      if ((data.get(USEOCSPSERVICELOCATOR) == null)</span>
<span class="pc bpc" id="L4049" title="1 of 2 branches missed.">          &amp;&amp; (data.get(USEAUTHORITYINFORMATIONACCESS) == null)) {</span>
        // Only set this flag if we have not already set the new flag
        // USEAUTHORITYINFORMATIONACCESS
        // setUseOCSPServiceLocator(false);
<span class="fc" id="L4053">        data.put(USEOCSPSERVICELOCATOR, Boolean.FALSE);</span>
<span class="fc" id="L4054">        setOCSPServiceLocatorURI(&quot;&quot;);</span>
      }

<span class="pc bpc" id="L4057" title="1 of 2 branches missed.">      if (data.get(USEMICROSOFTTEMPLATE) == null) {</span>
<span class="fc" id="L4058">        setUseMicrosoftTemplate(false);</span>
<span class="fc" id="L4059">        setMicrosoftTemplate(&quot;&quot;);</span>
      }

<span class="pc bpc" id="L4062" title="1 of 2 branches missed.">      if (data.get(USECNPOSTFIX) == null) {</span>
<span class="fc" id="L4063">        setUseCNPostfix(false);</span>
<span class="fc" id="L4064">        setCNPostfix(&quot;&quot;);</span>
      }

<span class="pc bpc" id="L4067" title="1 of 2 branches missed.">      if (data.get(USESUBJECTDNSUBSET) == null) {</span>
<span class="fc" id="L4068">        setUseSubjectDNSubSet(false);</span>
<span class="fc" id="L4069">        setSubjectDNSubSet(new ArrayList&lt;String&gt;());</span>
<span class="fc" id="L4070">        setUseSubjectAltNameSubSet(false);</span>
<span class="fc" id="L4071">        setSubjectAltNameSubSet(new ArrayList&lt;Integer&gt;());</span>
      }

<span class="pc bpc" id="L4074" title="1 of 2 branches missed.">      if (data.get(USEPATHLENGTHCONSTRAINT) == null) {</span>
<span class="fc" id="L4075">        setUsePathLengthConstraint(false);</span>
<span class="fc" id="L4076">        setPathLengthConstraint(0);</span>
      }

<span class="pc bpc" id="L4079" title="1 of 2 branches missed.">      if (data.get(USEQCSTATEMENT) == null) {</span>
<span class="fc" id="L4080">        setUseQCStatement(false);</span>
<span class="fc" id="L4081">        setUsePkixQCSyntaxV2(false);</span>
<span class="fc" id="L4082">        setQCStatementCritical(false);</span>
<span class="fc" id="L4083">        setQCStatementRAName(null);</span>
<span class="fc" id="L4084">        setQCSemanticsId(null);</span>
<span class="fc" id="L4085">        setUseQCEtsiQCCompliance(false);</span>
<span class="fc" id="L4086">        setUseQCEtsiSignatureDevice(false);</span>
<span class="fc" id="L4087">        setUseQCEtsiValueLimit(false);</span>
<span class="fc" id="L4088">        setUseQCEtsiRetentionPeriod(false);</span>
<span class="fc" id="L4089">        setQCEtsiRetentionPeriod(0);</span>
<span class="fc" id="L4090">        setQCEtsiValueLimit(0);</span>
<span class="fc" id="L4091">        setQCEtsiValueLimitExp(0);</span>
<span class="fc" id="L4092">        setQCEtsiValueLimitCurrency(null);</span>
      }

<span class="pc bpc" id="L4095" title="1 of 2 branches missed.">      if (data.get(USEDEFAULTCRLDISTRIBUTIONPOINT) == null) {</span>
<span class="fc" id="L4096">        setUseDefaultCRLDistributionPoint(false);</span>
<span class="fc" id="L4097">        setUseDefaultOCSPServiceLocator(false);</span>
      }

<span class="pc bpc" id="L4100" title="1 of 2 branches missed.">      if (data.get(USEQCCUSTOMSTRING) == null) {</span>
<span class="fc" id="L4101">        setUseQCCustomString(false);</span>
<span class="fc" id="L4102">        setQCCustomStringOid(null);</span>
<span class="fc" id="L4103">        setQCCustomStringText(null);</span>
      }
<span class="pc bpc" id="L4105" title="1 of 2 branches missed.">      if (data.get(USESUBJECTDIRATTRIBUTES) == null) {</span>
<span class="fc" id="L4106">        setUseSubjectDirAttributes(false);</span>
      }
<span class="pc bpc" id="L4108" title="1 of 2 branches missed.">      if (data.get(ALLOWVALIDITYOVERRIDE) == null) {</span>
<span class="fc" id="L4109">        setAllowValidityOverride(false);</span>
      }

<span class="pc bpc" id="L4112" title="1 of 2 branches missed.">      if (data.get(CRLISSUER) == null) {</span>
<span class="fc" id="L4113">        setCRLIssuer(null); // v20</span>
      }

<span class="pc bpc" id="L4116" title="1 of 2 branches missed.">      if (data.get(USEOCSPNOCHECK) == null) {</span>
<span class="fc" id="L4117">        setUseOcspNoCheck(false); // v21</span>
      }
<span class="pc bpc" id="L4119" title="1 of 2 branches missed.">      if (data.get(USEFRESHESTCRL) == null) {</span>
<span class="fc" id="L4120">        setUseFreshestCRL(false); // v22</span>
<span class="fc" id="L4121">        setUseCADefinedFreshestCRL(false);</span>
<span class="fc" id="L4122">        setFreshestCRLURI(null);</span>
      }

<span class="pc bpc" id="L4125" title="1 of 2 branches missed.">      if (data.get(CERTIFICATE_POLICIES) == null) { // v23</span>
<span class="pc bpc" id="L4126" title="1 of 2 branches missed.">        if (data.get(CERTIFICATEPOLICYID) != null) {</span>
<span class="nc" id="L4127">          String ids = (String) data.get(CERTIFICATEPOLICYID);</span>
<span class="nc" id="L4128">          String unotice = null;</span>
<span class="nc" id="L4129">          String cpsuri = null;</span>
<span class="nc bnc" id="L4130" title="All 2 branches missed.">          if (data.get(POLICY_NOTICE_UNOTICE_TEXT) != null) {</span>
<span class="nc" id="L4131">            unotice = (String) data.get(POLICY_NOTICE_UNOTICE_TEXT);</span>
          }
<span class="nc bnc" id="L4133" title="All 2 branches missed.">          if (data.get(POLICY_NOTICE_CPS_URL) != null) {</span>
<span class="nc" id="L4134">            cpsuri = (String) data.get(POLICY_NOTICE_CPS_URL);</span>
          }
          // Only the first policy could have user notice and cpsuri in the old
          // scheme
<span class="nc" id="L4138">          StringTokenizer tokenizer = new StringTokenizer(ids, &quot;;&quot;, false);</span>
<span class="nc bnc" id="L4139" title="All 2 branches missed.">          if (tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L4140">            String id = tokenizer.nextToken();</span>
<span class="nc" id="L4141">            CertificatePolicy newpolicy = null;</span>
<span class="nc bnc" id="L4142" title="All 2 branches missed.">            if (StringUtils.isNotEmpty(unotice)) {</span>
<span class="nc" id="L4143">              newpolicy =</span>
                  new CertificatePolicy(
                      id, CertificatePolicy.ID_QT_UNNOTICE, unotice);
<span class="nc" id="L4146">              addCertificatePolicy(newpolicy);</span>
            }
<span class="nc bnc" id="L4148" title="All 2 branches missed.">            if (StringUtils.isNotEmpty(cpsuri)) {</span>
<span class="nc" id="L4149">              newpolicy =</span>
                  new CertificatePolicy(
                      id, CertificatePolicy.ID_QT_CPS, cpsuri);
<span class="nc" id="L4152">              addCertificatePolicy(newpolicy);</span>
            }
            // If it was a lonely policy id
<span class="nc bnc" id="L4155" title="All 2 branches missed.">            if (newpolicy == null) {</span>
<span class="nc" id="L4156">              newpolicy = new CertificatePolicy(id, null, null);</span>
<span class="nc" id="L4157">              addCertificatePolicy(newpolicy);</span>
            }
          }
<span class="nc bnc" id="L4160" title="All 2 branches missed.">          while (tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L4161">            String id = tokenizer.nextToken();</span>
<span class="nc" id="L4162">            CertificatePolicy newpolicy = new CertificatePolicy(id, null, null);</span>
<span class="nc" id="L4163">            addCertificatePolicy(newpolicy);</span>
<span class="nc" id="L4164">          }</span>
        }
      }

<span class="pc bpc" id="L4168" title="1 of 2 branches missed.">      if ((data.get(USECAISSUERS) == null)</span>
<span class="pc bpc" id="L4169" title="1 of 2 branches missed.">          &amp;&amp; (data.get(USEAUTHORITYINFORMATIONACCESS) == null)) {</span>
        // Only set this flag if we have not already set the new flag
        // USEAUTHORITYINFORMATIONACCESS
        // setUseCaIssuers(false); // v24
<span class="fc" id="L4173">        data.put(USECAISSUERS, Boolean.FALSE); // v24</span>
<span class="fc" id="L4174">        setCaIssuers(new ArrayList&lt;String&gt;());</span>
      }
<span class="pc bpc" id="L4176" title="1 of 2 branches missed.">      if (((data.get(USEOCSPSERVICELOCATOR) != null)</span>
<span class="pc bnc" id="L4177" title="All 2 branches missed.">              || (data.get(USECAISSUERS) != null))</span>
<span class="pc bpc" id="L4178" title="1 of 2 branches missed.">          &amp;&amp; (data.get(USEAUTHORITYINFORMATIONACCESS) == null)) {</span>
        // Only do this if we have not already set the new flag
        // USEAUTHORITYINFORMATIONACCESS
<span class="fc" id="L4181">        boolean ocsp = false;</span>
<span class="pc bpc" id="L4182" title="1 of 2 branches missed.">        if ((data.get(USEOCSPSERVICELOCATOR) != null)) {</span>
<span class="fc" id="L4183">          ocsp = ((Boolean) data.get(USEOCSPSERVICELOCATOR)).booleanValue();</span>
        }
<span class="fc" id="L4185">        boolean caissuers = false;</span>
<span class="pc bpc" id="L4186" title="1 of 2 branches missed.">        if ((data.get(USECAISSUERS) != null)) {</span>
<span class="fc" id="L4187">          caissuers = ((Boolean) data.get(USECAISSUERS)).booleanValue();</span>
        }
<span class="pc bpc" id="L4189" title="2 of 4 branches missed.">        if (ocsp || caissuers) {</span>
<span class="nc" id="L4190">          setUseAuthorityInformationAccess(true); // v25</span>
        } else {
<span class="fc" id="L4192">          setUseAuthorityInformationAccess(false); // v25</span>
        }
<span class="pc bnc" id="L4194" title="All 2 branches missed.">      } else if (data.get(USEAUTHORITYINFORMATIONACCESS) == null) {</span>
<span class="nc" id="L4195">        setUseAuthorityInformationAccess(false);</span>
      }

<span class="pc bpc" id="L4198" title="1 of 2 branches missed.">      if (data.get(ALLOWEXTENSIONOVERRIDE) == null) {</span>
<span class="fc" id="L4199">        setAllowExtensionOverride(false); // v26</span>
      }

<span class="pc bpc" id="L4202" title="1 of 2 branches missed.">      if (data.get(USEQCETSIRETENTIONPERIOD) == null) {</span>
<span class="nc" id="L4203">        setUseQCEtsiRetentionPeriod(false); // v27</span>
<span class="nc" id="L4204">        setQCEtsiRetentionPeriod(0);</span>
      }

<span class="pc bpc" id="L4207" title="1 of 2 branches missed.">      if (data.get(CVCACCESSRIGHTS) == null) {</span>
<span class="fc" id="L4208">        setCVCAccessRights(CertificateProfile.CVC_ACCESS_NONE); // v28</span>
      }

<span class="pc bpc" id="L4211" title="1 of 2 branches missed.">      if (data.get(USELDAPDNORDER) == null) {</span>
<span class="fc" id="L4212">        setUseLdapDnOrder(true); // v29, default value is true</span>
      }

<span class="pc bpc" id="L4215" title="1 of 2 branches missed.">      if (data.get(USECARDNUMBER) == null) { // v30, default value is false</span>
<span class="fc" id="L4216">        setUseCardNumber(false);</span>
      }

<span class="pc bpc" id="L4219" title="1 of 2 branches missed.">      if (data.get(ALLOWDNOVERRIDE) == null) {</span>
<span class="fc" id="L4220">        setAllowDNOverride(false); // v31</span>
      }

<span class="pc bpc" id="L4223" title="1 of 2 branches missed.">      if (data.get(NUMOFREQAPPROVALS) == null) { // v 33</span>
<span class="fc" id="L4224">        setNumOfReqApprovals(1);</span>
      }
<span class="pc bpc" id="L4226" title="1 of 2 branches missed.">      if (data.get(APPROVALSETTINGS) == null) { // v 33</span>
<span class="fc" id="L4227">        setApprovalSettings(new ArrayList&lt;Integer&gt;());</span>
      }

<span class="pc bpc" id="L4230" title="1 of 2 branches missed.">      if (data.get(SIGNATUREALGORITHM) == null) { // v 34</span>
<span class="fc" id="L4231">        setSignatureAlgorithm(null);</span>
      }

<span class="pc bpc" id="L4234" title="1 of 2 branches missed.">      if (data.get(USEPRIVKEYUSAGEPERIODNOTBEFORE) == null) { // v 35</span>
<span class="fc" id="L4235">        setUsePrivateKeyUsagePeriodNotBefore(false);</span>
      }
<span class="pc bpc" id="L4237" title="1 of 2 branches missed.">      if (data.get(USEPRIVKEYUSAGEPERIODNOTAFTER) == null) { // v 35</span>
<span class="fc" id="L4238">        setUsePrivateKeyUsagePeriodNotAfter(false);</span>
      }
<span class="pc bpc" id="L4240" title="1 of 2 branches missed.">      if (data.get(PRIVKEYUSAGEPERIODSTARTOFFSET) == null) { // v 35</span>
<span class="fc" id="L4241">        setPrivateKeyUsagePeriodStartOffset(</span>
            DEFAULT_PRIVATE_KEY_USAGE_PERIOD_OFFSET);
      }
<span class="pc bpc" id="L4244" title="1 of 2 branches missed.">      if (data.get(PRIVKEYUSAGEPERIODLENGTH) == null) { // v 35</span>
<span class="fc" id="L4245">        setPrivateKeyUsagePeriodLength(DEFAULT_PRIVATE_KEY_USAGE_PERIOD_LENGTH);</span>
      }
<span class="pc bpc" id="L4247" title="1 of 2 branches missed.">      if (data.get(USEISSUERALTERNATIVENAME) == null) { // v 36</span>
<span class="fc" id="L4248">        setUseIssuerAlternativeName(false);</span>
      }
<span class="pc bpc" id="L4250" title="1 of 2 branches missed.">      if (data.get(ISSUERALTERNATIVENAMECRITICAL) == null) { // v 36</span>
<span class="fc" id="L4251">        setIssuerAlternativeNameCritical(false);</span>
      }
<span class="pc bpc" id="L4253" title="1 of 2 branches missed.">      if (data.get(USEDOCUMENTTYPELIST) == null) { // v 37</span>
<span class="fc" id="L4254">        setUseDocumentTypeList(false);</span>
      }
<span class="pc bpc" id="L4256" title="1 of 2 branches missed.">      if (data.get(DOCUMENTTYPELISTCRITICAL) == null) { // v 37</span>
<span class="fc" id="L4257">        setDocumentTypeListCritical(false);</span>
      }
<span class="pc bpc" id="L4259" title="1 of 2 branches missed.">      if (data.get(DOCUMENTTYPELIST) == null) { // v 37</span>
<span class="fc" id="L4260">        setDocumentTypeList(new ArrayList&lt;String&gt;());</span>
      }
<span class="pc bpc" id="L4262" title="1 of 2 branches missed.">      if (data.get(AVAILABLEKEYALGORITHMS) == null) { // v 39</span>
        // Make some intelligent guesses what key algorithm this profile is used
        // for
        final List&lt;String&gt; availableKeyAlgorithms =
<span class="fc" id="L4266">            AlgorithmTools.getAvailableKeyAlgorithms();</span>
<span class="pc bpc" id="L4267" title="1 of 2 branches missed.">        if (getMinimumAvailableBitLength() &gt; MIN_EC_SIZE) {</span>
<span class="fc" id="L4268">          availableKeyAlgorithms.remove(AlgorithmConstants.KEYALGORITHM_ECDSA);</span>
<span class="fc" id="L4269">          availableKeyAlgorithms.remove(</span>
              AlgorithmConstants.KEYALGORITHM_DSTU4145);
<span class="fc" id="L4271">          availableKeyAlgorithms.remove(</span>
              AlgorithmConstants.KEYALGORITHM_ECGOST3410);
        }
<span class="pc bpc" id="L4274" title="1 of 2 branches missed.">        if (getMinimumAvailableBitLength() &gt; MIN_RSA_DSA_SIZE</span>
<span class="pc bpc" id="L4275" title="1 of 2 branches missed.">            || getMaximumAvailableBitLength() &lt; MIN_RSA_DSA_SIZE) {</span>
<span class="nc" id="L4276">          availableKeyAlgorithms.remove(AlgorithmConstants.KEYALGORITHM_DSA);</span>
        }
<span class="pc bpc" id="L4278" title="1 of 2 branches missed.">        if (getMaximumAvailableBitLength() &lt; MIN_RSA_DSA_SIZE) {</span>
<span class="nc" id="L4279">          availableKeyAlgorithms.remove(AlgorithmConstants.KEYALGORITHM_RSA);</span>
        }
<span class="fc" id="L4281">        setAvailableKeyAlgorithmsAsList(availableKeyAlgorithms);</span>
      }
<span class="pc bpc" id="L4283" title="1 of 2 branches missed.">      if (data.get(AVAILABLEECCURVES) == null) { // v 40</span>
<span class="fc" id="L4284">        setAvailableEcCurves(new String[] {ANY_EC_CURVE});</span>
      }
<span class="pc bpc" id="L4286" title="1 of 2 branches missed.">      if (data.get(APPROVALPROFILE) == null) { // v41</span>
<span class="fc" id="L4287">        setApprovalProfileID(-1);</span>
      }
      // v42. ETSI QC Type and PDS specified in EN 319 412-05.
      // Nothing to set though, since null values means to not use the new
      // values

      // v43, ECA-5304.
<span class="pc bpc" id="L4294" title="1 of 2 branches missed.">      if (data.get(USEDEFAULTCAISSUER) == null) {</span>
<span class="fc" id="L4295">        setUseDefaultCAIssuer(false);</span>
      }

      // v44. ECA-5141
      // 'encodedValidity' is derived by the former long value!
<span class="pc bpc" id="L4300" title="1 of 2 branches missed.">      if (null == data.get(ENCODED_VALIDITY)) {</span>
<span class="pc bpc" id="L4301" title="1 of 2 branches missed.">        if (data.get(VALIDITY)</span>
            != null) { // avoid NPE if this is a very raw profile
<span class="nc" id="L4303">          setEncodedValidity(</span>
<span class="nc" id="L4304">              ValidityDate.getStringBeforeVersion661(getValidity()));</span>
        }
        // Don't upgrade to anything is there was nothing to upgrade
      }
      // v44. ECA-5330
      // initialize fields for expiration restriction for weekdays. use is false
      // because of backward compatibility, the before restriction default is
      // true
<span class="pc bpc" id="L4312" title="1 of 2 branches missed.">      if (null == data.get(USE_EXPIRATION_RESTRICTION_FOR_WEEKDAYS)) {</span>
<span class="fc" id="L4313">        setUseExpirationRestrictionForWeekdays(false);</span>
      }
<span class="pc bpc" id="L4315" title="1 of 2 branches missed.">      if (null == data.get(EXPIRATION_RESTRICTION_WEEKDAYS)) {</span>
<span class="fc" id="L4316">        setDefaultExpirationRestrictionWeekdays();</span>
      }
<span class="pc bpc" id="L4318" title="1 of 2 branches missed.">      if (null == data.get(EXPIRATION_RESTRICTION_FOR_WEEKDAYS_BEFORE)) {</span>
<span class="fc" id="L4319">        setExpirationRestrictionForWeekdaysExpireBefore(true);</span>
      }
      // v44. ECA-3554
      // initialize default certificate not before offset (default '-10m'
      // because of backward compatibility).
<span class="pc bpc" id="L4324" title="1 of 2 branches missed.">      if (null == data.get(USE_CERTIFICATE_VALIDITY_OFFSET)) {</span>
<span class="fc" id="L4325">        setUseCertificateValidityOffset(false);</span>
      }
<span class="pc bpc" id="L4327" title="1 of 2 branches missed.">      if (null == data.get(CERTIFICATE_VALIDITY_OFFSET)) {</span>
<span class="fc" id="L4328">        setCertificateValidityOffset(DEFAULT_CERTIFICATE_VALIDITY_OFFSET);</span>
      }

      // v45: Multiple ETSI QC PDS values (ECA-5478)
<span class="pc bpc" id="L4332" title="1 of 2 branches missed.">      if (!data.containsKey(QCETSIPDS)) {</span>
<span class="fc" id="L4333">        final String url = (String) data.get(QCETSIPDSURL);</span>
<span class="fc" id="L4334">        final String lang = (String) data.get(QCETSIPDSLANG);</span>
<span class="fc bfc" id="L4335" title="All 2 branches covered.">        if (StringUtils.isNotEmpty(url)) {</span>
<span class="fc" id="L4336">          final List&lt;PKIDisclosureStatement&gt; pdsList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L4337">          pdsList.add(new PKIDisclosureStatement(url, lang));</span>
<span class="fc" id="L4338">          data.put(QCETSIPDS, pdsList);</span>
<span class="fc" id="L4339">        } else {</span>
<span class="fc" id="L4340">          data.put(QCETSIPDS, null);</span>
        }
      }
      // v46: approvals changed type to LinkedHashMap
<span class="fc" id="L4344">      setApprovals(getApprovals());</span>

<span class="fc" id="L4346">      data.put(VERSION, new Float(LATEST_VERSION));</span>
    }
<span class="fc" id="L4348">    LOG.trace(&quot;&lt;upgrade&quot;);</span>
<span class="fc" id="L4349">  }</span>
  /** Min RSA/DSA key size. */
  private static final int MIN_RSA_DSA_SIZE = 1024;
  /** Min EC key size. */
  private static final int MIN_EC_SIZE = 521;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>