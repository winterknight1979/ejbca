<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DNFieldsUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.util.dn</a> &gt; <span class="el_source">DNFieldsUtil.java</span></div><h1>DNFieldsUtil.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.util.dn;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.util.CeSecoreNameStyle;

/**
 * DN string utilities.
 *
 * &lt;p&gt;Optimized to lower object instantiation by performing manipulations
 * &quot;in-place&quot; using StringBuilder and char[].
 *
 * &lt;p&gt;Not built to handle '+' char separators or take special consideration to
 * Unicode. Current implementation will treat unescaped '=' in values as ok
 * (backwards compatible).
 *
 * @version $Id: DNFieldsUtil.java 25580 2017-03-22 14:30:19Z anatom $
 */
<span class="nc" id="L35">public abstract class DNFieldsUtil {</span>

    /** Logger. */
<span class="fc" id="L38">  private static final Logger LOG = Logger.getLogger(DNFieldsUtil.class);</span>
  /** Empty. */
  private static final int EMPTY = -1;
  /** Message. */
  private static final String MSG_ERROR_MISSING_EQUAL =
      &quot;DN field definition is missing the '=': &quot;;
  /** Sep. */
  private static final String ATTRIBUTE_SEPARATOR = &quot;,&quot;;
  /** Sep. */
  private static final String KEY_VALUE_SEPARATOR = &quot;=&quot;;

  /**
   * The method splits an DN string into a map of it's attributes and values.
   *
   * @param dnString the DN String to split (i.e.: 'C=DE,CN=test,SN=1').
   * @return a map containing the attributes and values.
   */
  public static final Map&lt;String, String&gt; dnStringToMap(final String dnString) {
<span class="fc" id="L56">    final String[] dnTokens = dnString.split(ATTRIBUTE_SEPARATOR);</span>
<span class="fc" id="L57">    final Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;();</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">    if (StringUtils.isNotBlank(dnString)) {</span>
      String[] tokens;
<span class="fc bfc" id="L60" title="All 2 branches covered.">      for (int i = 0; i &lt; dnTokens.length; i++) {</span>
<span class="fc" id="L61">        tokens = dnTokens[i].split(KEY_VALUE_SEPARATOR);</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (tokens.length &gt; 1) {</span>
<span class="fc" id="L63">          result.put(tokens[0], tokens[1]);</span>
        } else {
<span class="fc" id="L65">          result.put(tokens[0], StringUtils.EMPTY);</span>
        }
      }
    }
<span class="fc" id="L69">    return result;</span>
  }

  /**
   * The method checks if the subject-DN contains both C and CN attributes (in a
   * potential CVCA/CSCA certificate at least the attributes C and CN must be
   * set).
   *
   * @param map the map of DN attributes and values.
   * @return true if the DN map contains non-empty values for both C and CN.
   */
  public static final boolean mapContainsCountryAndCN(
      final Map&lt;String, String&gt; map) {
<span class="nc" id="L82">    boolean result = false;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">    if (map.size() &gt;= 2) {</span>
<span class="nc" id="L84">      result =</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">          StringUtils.isNotBlank(</span>
<span class="nc" id="L86">                  map.get(</span>
<span class="nc" id="L87">                      CeSecoreNameStyle.DEFAULT_SYMBOLS.get(</span>
                          CeSecoreNameStyle.C)))
<span class="nc bnc" id="L89" title="All 2 branches missed.">              &amp;&amp; StringUtils.isNotBlank(</span>
<span class="nc" id="L90">                  CeSecoreNameStyle.DEFAULT_SYMBOLS.get(CeSecoreNameStyle.CN));</span>
    }
<span class="nc" id="L92">    return result;</span>
  }

  /**
   * The method checks if the two subject-DN maps are equal except the 'SN'
   * attribute.
   *
   * @param map1 the left side subject-DN map.
   * @param map2 the right side subject-DN map.
   * @return true if both subject-DN are equal except the 'SN' attribute
   *     (accepts null or empty Strings as values, but not for 'SN' attribute).
   */
  public static final boolean dnEqualsWithOtherSerialNumber(
      final Map&lt;String, String&gt; map1, final Map&lt;String, String&gt; map2) {
<span class="pc bpc" id="L106" title="2 of 6 branches missed.">    if (map1.size() &lt; 2 || map2.size() &lt; 2 || map1.size() != map2.size()) {</span>
<span class="fc" id="L107">      return false;</span>
    }
    String key;
    String value1;
    String value2;
<span class="fc" id="L112">    final String snAttributeKey =</span>
<span class="fc" id="L113">        CeSecoreNameStyle.DEFAULT_SYMBOLS.get(CeSecoreNameStyle.SN);</span>
<span class="fc" id="L114">    boolean result = true;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">    for (Map.Entry&lt;String, String&gt; entry : map1.entrySet()) {</span>
<span class="fc" id="L116">      key = entry.getKey();</span>
<span class="fc" id="L117">      value1 = entry.getValue();</span>
<span class="fc" id="L118">      value2 = map2.get(key);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">      if (snAttributeKey.equals(</span>
          key)) { // check that serial numbers are not blank and not equal.
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (StringUtils.isBlank(value1)</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">            || StringUtils.isBlank(value2)</span>
            || value1 == value2) {
<span class="nc" id="L124">          result = false;</span>
        }
      } else { // All other DN attributes must be equal.
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (!StringUtils.equals(value1, value2)) {</span>
<span class="nc" id="L128">          result = false;</span>
        }
      }
<span class="fc" id="L131">    }</span>
<span class="fc" id="L132">    return result;</span>
  }

  /**
   * Invoke removeEmpties and only return the fully clean dn String.
   *
   * @param dn DN
   * @return clean DN
   */
  public static String removeAllEmpties(final String dn) {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">    if (dn == null) {</span>
<span class="nc" id="L143">      return null;</span>
    }
<span class="fc" id="L145">    final StringBuilder removedAllEmpties = new StringBuilder(dn.length());</span>
<span class="fc" id="L146">    DNFieldsUtil.removeEmpties(dn, removedAllEmpties, false);</span>
<span class="fc" id="L147">    return removedAllEmpties.toString();</span>
  }

  /**
   * This method will take the supplied string and fill the two provided empty
   * StringBuilders.
   *
   * &lt;p&gt;removedTrailingEmpties is produced by: Removes fields (key=value) where
   * the value is empty if it is the last value with the same key. Example:
   * &quot;CN=abc,CN=,CN=def,O=,O=abc,O=&quot; will become &quot;CN=abc,CN=,CN=def,O=,O=abc&quot;.
   * Example: &quot;CN=abc,DC=,O=,CN=def,O=,O=abc,O=&quot; will become
   * &quot;CN=abc,O=,CN=def,O=,O=abc&quot;.
   *
   * &lt;p&gt;removedAllEmpties is produced by: Removes all fields (key=value) where
   * the value is empty. Example: &quot;CN=abc,CN=,O=,CN=def,O=,O=abc,O=&quot; will become
   * &quot;CN=abc,CN=def,O=abc&quot;.
   *
   * &lt;p&gt;Since the algorithms are very similar for these two it makes sense to
   * calculate them both at the same time for use in EndEntityInformation.
   *
   * @param sDN the String to clean.
   * @param removedAllEmpties StringBuilder
   * @param processTrailing true is removedTrailingEmpties should be considered.
   * @return removedTrailingEmpties StringBuilder if both types of cleaning give
   *     different results or null if they are the same.
   */
  public static StringBuilder removeEmpties(
      final String sDN,
      final StringBuilder removedAllEmpties,
      final boolean processTrailing) {
<span class="fc" id="L177">    StringBuilder removedTrailingEmpties = null;</span>
    // First make a list of where all the key=value pairs start and if they are
    // empty or not
<span class="fc" id="L180">    final List&lt;Integer&gt; startOfPairs = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L181">    final List&lt;Integer&gt; startOfValues = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L182">    final char[] buf = sDN.toCharArray();</span>
<span class="fc" id="L183">    populatePositionLists(startOfPairs, startOfValues, buf);</span>
<span class="fc" id="L184">    boolean areStringBuildersEqual = true;</span>
    // Go through all the pairs from first to last
<span class="fc bfc" id="L186" title="All 2 branches covered.">    for (int i = 0; i &lt; startOfPairs.size(); i++) {</span>
<span class="fc" id="L187">      final int startOfThisPair = startOfPairs.get(i).intValue();</span>
      final int startOfNextPair;
<span class="fc bfc" id="L189" title="All 2 branches covered.">      if (i == startOfPairs.size() - 1) {</span>
<span class="fc" id="L190">        startOfNextPair =</span>
            buf.length; // The &quot;next element&quot; begins at the end of the buffer
      } else {
<span class="fc" id="L193">        startOfNextPair = startOfPairs.get(i + 1).intValue();</span>
      }
<span class="fc" id="L195">      final int startOfThisValue = startOfValues.get(i).intValue();</span>
<span class="fc" id="L196">      boolean addOnlyNonTrailingEmpties = true;</span>
<span class="fc" id="L197">      boolean addAllNonEmpties = true;</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">      if (startOfThisValue == EMPTY) {</span>
        // If a pair is empty
<span class="fc" id="L200">        addOnlyNonTrailingEmpties = false;</span>
<span class="fc" id="L201">        addAllNonEmpties = false;</span>
        // If we only remove trailing empties there is a second chance that we
        // will still add it..
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (processTrailing) {</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">          for (int j = i + 1; j &lt; startOfPairs.size(); j++) {</span>
<span class="fc" id="L206">            final int startOfThisPair2 = startOfPairs.get(j).intValue();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (hasSameKey(buf, startOfThisPair, startOfThisPair2)</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                &amp;&amp; startOfValues.get(j).intValue() != EMPTY) {</span>
              // if this was not the last pair with this key and one of the
              // later ones is not empty: add it!
<span class="fc" id="L211">              addOnlyNonTrailingEmpties = true;</span>
<span class="fc" id="L212">              break;</span>
            }
          }
        }
      }
<span class="fc bfc" id="L217" title="All 4 branches covered.">      if (areStringBuildersEqual</span>
          &amp;&amp; (addOnlyNonTrailingEmpties != addAllNonEmpties)) {
        // The StringBuilders are no longer equal, so we need to populate the
        // empty one and let them diverge
<span class="fc" id="L221">        areStringBuildersEqual = false;</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (processTrailing) {</span>
<span class="fc" id="L223">          removedTrailingEmpties = new StringBuilder(removedAllEmpties);</span>
        }
      }
<span class="fc bfc" id="L226" title="All 2 branches covered.">      if (addAllNonEmpties) {</span>
<span class="fc" id="L227">        removedAllEmpties.append(</span>
            buf, startOfThisPair, startOfNextPair - startOfThisPair);
      }
<span class="fc bfc" id="L230" title="All 6 branches covered.">      if (processTrailing</span>
          &amp;&amp; !areStringBuildersEqual
          &amp;&amp; addOnlyNonTrailingEmpties) {
<span class="fc" id="L233">        removedTrailingEmpties.append(</span>
            buf, startOfThisPair, startOfNextPair - startOfThisPair);
      }
    }
<span class="fc" id="L237">    removeUnwatedLastChars(removedAllEmpties);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">    if (!areStringBuildersEqual) {</span>
<span class="fc" id="L239">      removeUnwatedLastChars(removedTrailingEmpties);</span>
    }
<span class="fc" id="L241">    return removedTrailingEmpties;</span>
  }

  /**
   * If we end up with a buffer ending with &quot;,&quot; or &quot;, &quot; we need to remove these
   * chars unless they've been escaped with a '\'.
   *
   * @param sb A StringBuilder to work in.
   */
  private static void removeUnwatedLastChars(final StringBuilder sb) {
<span class="fc bfc" id="L251" title="All 2 branches covered.">    if (sb.length() &gt; 0) {</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">      for (int i = sb.length() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L253">        final char c = sb.charAt(i);</span>
<span class="fc bfc" id="L254" title="All 4 branches covered.">        if (c == ' ' || c == ',') {</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">          if (sb.charAt(i - 1) == '\\') {</span>
<span class="fc" id="L256">            break;</span>
          } else {
<span class="fc" id="L258">            sb.deleteCharAt(i);</span>
          }
        } else {
          break;
        }
      }
    }
<span class="fc" id="L265">  }</span>

  /**
   * Populates the two lists with starting positions in the character buffer
   * where the value=key pair begins and keys begin.
   *
   * @param startOfPairs pairs start
   * @param startOfValues values start
   * @param buf buffer
   */
  private static void populatePositionLists(
      final List&lt;Integer&gt; startOfPairs,
      final List&lt;Integer&gt; startOfValues,
      final char[] buf) {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">    if (buf.length &gt; 0) {</span>
<span class="fc" id="L280">      startOfPairs.add(Integer.valueOf(0));</span>
    }
<span class="fc" id="L282">    boolean notEscaped = true; // Keep track of what is escapes and not</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">    for (int i = 0; i &lt; buf.length; i++) {</span>
<span class="fc bfc" id="L284" title="All 4 branches covered.">      switch (buf[i]) {</span>
        case '\\':
<span class="fc" id="L286">          notEscaped ^= true;</span>
<span class="fc" id="L287">          break;</span>
        case ',':
<span class="fc bfc" id="L289" title="All 2 branches covered.">          if (notEscaped) {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">            if (startOfPairs.size() &gt; startOfValues.size()) {</span>
              // We are missing a '=' in the DN!
<span class="fc" id="L292">              LOG.info(MSG_ERROR_MISSING_EQUAL + new String(buf));</span>
            }
<span class="fc" id="L294">            int j = i + 1;</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">            while (j &lt; buf.length &amp;&amp; buf[j] == ' ') {</span>
<span class="fc" id="L296">              j++; // Ignore spaces</span>
            }
<span class="fc" id="L298">            startOfPairs.add(Integer.valueOf(j));</span>
<span class="fc" id="L299">          } else {</span>
<span class="fc" id="L300">            notEscaped = true;</span>
          }
<span class="fc" id="L302">          break;</span>
        case '=':
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">          if (notEscaped) {</span>
            // Only use the first '=' after a ',' (backwards compatible)
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (startOfPairs.size() &gt; startOfValues.size()) {</span>
<span class="fc" id="L307">              int j = i + 1;</span>
<span class="fc bfc" id="L308" title="All 4 branches covered.">              while (j &lt; buf.length &amp;&amp; buf[j] == ' ') {</span>
<span class="fc" id="L309">                j++; // Ignore spaces</span>
              }
<span class="fc bfc" id="L311" title="All 4 branches covered.">              if (j &gt;= buf.length || buf[j] == ',') {</span>
<span class="fc" id="L312">                startOfValues.add(</span>
<span class="fc" id="L313">                    Integer.valueOf(</span>
                        EMPTY)); // Use -1 to mark that the value is empty
              } else {
<span class="fc" id="L316">                startOfValues.add(Integer.valueOf(j));</span>
              }
<span class="fc" id="L318">            }</span>
          } else {
<span class="nc" id="L320">            notEscaped = true;</span>
          }
<span class="nc" id="L322">          break;</span>
        default:
<span class="fc" id="L324">          notEscaped = true;</span>
      }
    }
<span class="fc" id="L327">  }</span>

  /**
   * Compares the two character sequences in the buffer at the positions until a
   * not escaped '=' is found.
   *
   * @param sb buffer
   * @param opos1 position 1
   * @param opos2 position 2
   * @return boolean
   */
  private static boolean hasSameKey(final char[] sb,
          final int opos1, final int opos2) {
<span class="fc" id="L340">    int pos1 = opos1;</span>
<span class="fc" id="L341">    int pos2 = opos2;</span>
<span class="fc" id="L342">    final int len = sb.length;</span>
<span class="fc" id="L343">    boolean notEscaped = true; // Keep track of what is escapes and not</span>
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">    while (len &gt; pos1 &amp;&amp; len &gt; pos2) {</span>
<span class="fc" id="L345">      final char c1 = sb[pos1];</span>
<span class="pc bpc" id="L346" title="1 of 3 branches missed.">      switch (c1) {</span>
        case '\\':
<span class="nc" id="L348">          notEscaped ^= true;</span>
<span class="nc" id="L349">          break;</span>
        case '=':
<span class="pc bpc" id="L351" title="1 of 4 branches missed.">          if (notEscaped &amp;&amp; c1 == sb[pos2]) {</span>
<span class="fc" id="L352">            return true;</span>
          } // else.. continue with the default action..
        default:
<span class="fc bfc" id="L355" title="All 2 branches covered.">          if (c1 != sb[pos2]) {</span>
<span class="fc" id="L356">            return false;</span>
          }
<span class="fc" id="L358">          notEscaped = true;</span>
      }
<span class="fc" id="L360">      pos1++;</span>
<span class="fc" id="L361">      pos2++;</span>
<span class="fc" id="L362">    }</span>
<span class="nc" id="L363">    return false;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>