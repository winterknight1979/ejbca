<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CryptoTokenFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CeSeCore Security Common Code</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.keys.token</a> &gt; <span class="el_source">CryptoTokenFactory.java</span></div><h1>CryptoTokenFactory.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.keys.token;

import java.lang.reflect.InvocationTargetException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import org.apache.log4j.Logger;
import org.cesecore.internal.InternalResources;
import org.cesecore.keys.token.p11.exception.NoSuchSlotException;

/**
 * Class managing available Crypto Tokens and instantiated Crypto Tokens. Each
 * CryptoToken plug-in should register itself by using the method register.
 *
 * @version $Id: CryptoTokenFactory.java 21361 2015-05-26 11:10:24Z jeklund $
 */
public final class CryptoTokenFactory {

  /** Logger.*/
<span class="fc" id="L33">  private static transient Logger log =</span>
<span class="fc" id="L34">      Logger.getLogger(CryptoTokenFactory.class);</span>

  /** Number of available hard ca token classes that can be instantiated. */
  private static final int TOKEN_SIZE = 4;
  /** Registry of available hard ca token classes that can be instantiated. */
<span class="fc" id="L39">  private Map&lt;String, AvailableCryptoToken&gt; availabletokens =</span>
      new HashMap&lt;String, AvailableCryptoToken&gt;(TOKEN_SIZE);

  /** Implementing the Singleton pattern. */
<span class="fc" id="L43">  private static CryptoTokenFactory instance = null;</span>

  /**
   * Don't allow external creation of this class, implementing the Singleton
   * pattern.
   */
<span class="fc" id="L49">  private CryptoTokenFactory() { }</span>

  /**
   * Get the instance of this singleton.
   *
   * @return instance
   */
  public static synchronized CryptoTokenFactory instance() {
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">    if (instance == null) {</span>
<span class="fc" id="L58">      instance = new CryptoTokenFactory();</span>
      /*
       * Can't use class.getName() here because this class is not always
       * available
       */
<span class="fc" id="L63">      instance.addAvailableCryptoToken(</span>
          &quot;se.primeKey.caToken.card.PrimeCAToken&quot;, &quot;PrimeCAToken&quot;, false, true);
<span class="fc" id="L65">      instance.addAvailableCryptoToken(</span>
<span class="fc" id="L66">          PKCS11CryptoToken.class.getName(), &quot;PKCS#11&quot;, false, true);</span>
<span class="fc" id="L67">      instance.addAvailableCryptoToken(</span>
<span class="fc" id="L68">          SoftCryptoToken.class.getName(), &quot;SOFT&quot;, true, true);</span>
<span class="fc" id="L69">      instance.addAvailableCryptoToken(</span>
<span class="fc" id="L70">          NullCryptoToken.class.getName(), &quot;Null&quot;, false, false);</span>
    }
<span class="fc" id="L72">    return instance;</span>
  }

  /**
   * Method returning to the system available CryptoToken implementations.
   *
   * @return a Collection (AvailableCryptoToken) of registered plug-ins.
   */
  public Collection&lt;AvailableCryptoToken&gt; getAvailableCryptoTokens() {
<span class="fc" id="L81">    return availabletokens.values();</span>
  }

  /**
   * Method returning to the available CryptoToken implementations with given
   * classpath.
   *
   * @param classname name
   * @return the corresponding AvailableCryptoToken or null of classpath
   *     couldn't be found
   */
  public AvailableCryptoToken getAvailableCryptoToken(final String classname) {
<span class="nc bnc" id="L93" title="All 2 branches missed.">    if (classname == null) {</span>
<span class="nc" id="L94">      return null;</span>
    }
<span class="nc" id="L96">    return (AvailableCryptoToken) availabletokens.get(classname);</span>
  }

  /**
   * Method registering a crypto token plug-in as available to the system.
   *
   * @param classname the full classname of the crypto token implementation
   *     class
   * @param name the general name used in adminweb-gui.
   * @param translateable indicates if the name should be translated in
   *     adminweb-gui
   * @param use indicates if this plug-in should be used.
   * @return true if registration went successful, false if the classpath could
   *     not be found or the classpath was already registered.
   */
  /*package*/ boolean addAvailableCryptoToken(
      final String classname,
      final String name,
      final boolean translateable,
      final boolean use) {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">    if (log.isTraceEnabled()) {</span>
<span class="nc" id="L117">      log.trace(&quot;&gt;addAvailableCryptoToken: &quot; + classname);</span>
    }
<span class="fc" id="L119">    boolean retval = false;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">    if (!availabletokens.containsKey(classname)) {</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">      if (log.isDebugEnabled()) {</span>
<span class="nc" id="L122">        log.debug(</span>
            &quot;CryptoTokenFactory adding available crypto token &quot; + classname);
      }
<span class="fc bfc" id="L125" title="All 2 branches covered.">      if (loadClass(classname)) {</span>
        // Add to the available tokens
<span class="fc" id="L127">        availabletokens.put(</span>
            classname,
            new AvailableCryptoToken(classname, name, translateable, use));
<span class="fc" id="L130">        retval = true;</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L132">          log.debug(&quot;Registered &quot; + classname + &quot; successfully.&quot;);</span>
        }
      } else {
        // Normally not an error, since these classes are provided by HSM vendor
<span class="fc" id="L136">        log.info(</span>
<span class="fc" id="L137">            InternalResources.getInstance()</span>
<span class="fc" id="L138">                .getLocalizedMessage(&quot;token.inforegisterclasspath&quot;, classname));</span>
      }
    }
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">    if (log.isTraceEnabled()) {</span>
<span class="nc" id="L142">      log.trace(&quot;&lt;addAvailableCryptoToken: &quot; + classname);</span>
    }
<span class="fc" id="L144">    return retval;</span>
  }

  /**
   * Method loading a class in order to test if it can be instantiated.
   *
   * @param classname name
   * @return boolean
   */
  private boolean loadClass(final String classname) {
    try {
<span class="fc" id="L155">      Thread.currentThread()</span>
<span class="fc" id="L156">          .getContextClassLoader()</span>
<span class="fc" id="L157">          .loadClass(classname)</span>
<span class="fc" id="L158">          .getConstructor()</span>
<span class="fc" id="L159">          .newInstance();</span>
<span class="fc" id="L160">      return true;</span>
<span class="fc" id="L161">    } catch (ClassNotFoundException | NoSuchMethodException e) {</span>
<span class="fc" id="L162">      log.info(</span>
<span class="fc" id="L163">          InternalResources.getInstance()</span>
<span class="fc" id="L164">              .getLocalizedMessage(&quot;token.classnotfound&quot;, classname));</span>
<span class="nc" id="L165">    } catch (InstantiationException | InvocationTargetException e) {</span>
<span class="nc" id="L166">      log.info(</span>
<span class="nc" id="L167">          InternalResources.getInstance()</span>
<span class="nc" id="L168">              .getLocalizedMessage(</span>
<span class="nc" id="L169">                  &quot;token.errorinstansiate&quot;, classname, e.getMessage()));</span>
<span class="nc" id="L170">    } catch (IllegalAccessException e) {</span>
<span class="nc" id="L171">      log.error(&quot;IllegalAccessException: &quot; + classname, e);</span>
<span class="nc" id="L172">    } catch (NoClassDefFoundError e) {</span>
      // This happens more rarely and should be flagged as an error
<span class="nc" id="L174">      log.error(&quot;NoClassDefFoundError: &quot; + classname, e);</span>
<span class="pc" id="L175">    }</span>
<span class="fc" id="L176">    return false;</span>
  }

  /**
   * Creates a crypto token using reflection to construct the class from
   * classname and initializing the CryptoToken.
   *
   * @param inClassname the full classname of the crypto token implementation
   *     class
   * @param properties properties passed to the init method of the CryptoToken
   * @param data byte data passed to the init method of the CryptoToken
   * @param cryptoTokenId id passed to the init method of the CryptoToken, the
   *     id is user defined and not used internally for anything but logging.
   * @param tokenName user friendly identifier
   * @return token
   * @throws NoSuchSlotException if no slot as defined in properties could be
   *     found.
   */
  public static CryptoToken createCryptoToken(
      final String inClassname,
      final Properties properties,
      final byte[] data,
      final int cryptoTokenId,
      final String tokenName)
      throws NoSuchSlotException {
<span class="fc" id="L201">    final boolean allowNonExistingSlot =</span>
<span class="fc" id="L202">        Boolean.valueOf(</span>
<span class="fc" id="L203">            properties.getProperty(</span>
                CryptoToken.ALLOW_NONEXISTING_SLOT_PROPERTY,
<span class="fc" id="L205">                Boolean.FALSE.toString()));</span>
<span class="fc" id="L206">    return createCryptoToken(</span>
        inClassname,
        properties,
        data,
        cryptoTokenId,
        tokenName,
        allowNonExistingSlot);
  }

  /**
   * Creates a crypto token using reflection to construct the class from
   * classname and initializing the CryptoToken.
   *
   * @param inClassname the full classname of the crypto token implementation
   *     class
   * @param properties properties passed to the init method of the CryptoToken
   * @param data byte data passed to the init method of the CryptoToken
   * @param cryptoTokenId id passed to the init method of the CryptoToken, the
   *     id is user defined and not used internally for anything but logging.
   * @param tokenName user friendly identifier
   * @param allowNonExistingSlot if the NoSuchSlotException should be used
   * @return token
   * @throws NoSuchSlotException if no slot as defined in properties could be
   *     found.
   */
  public static CryptoToken createCryptoToken(
      final String inClassname,
      final Properties properties,
      final byte[] data,
      final int cryptoTokenId,
      final String tokenName,
      final boolean allowNonExistingSlot)
      throws NoSuchSlotException {
    final String classname;
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if (inClassname != null) {</span>
<span class="fc" id="L241">      classname = inClassname;</span>
    } else {
<span class="nc" id="L243">      classname = NullCryptoToken.class.getName();</span>
<span class="nc" id="L244">      log.info(</span>
          &quot;This must be an imported CA that is being upgraded. Use&quot;
              + &quot; NullCryptoToken.&quot;);
    }
<span class="fc" id="L248">    final CryptoToken token = createTokenFromClass(classname);</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    if (token == null) {</span>
<span class="nc" id="L250">      log.error(&quot;No token. Classpath=&quot; + classname);</span>
<span class="nc" id="L251">      return null;</span>
    }
    try {
<span class="fc" id="L254">      token.init(properties, data, cryptoTokenId);</span>
<span class="nc" id="L255">    } catch (NoSuchSlotException e) {</span>
<span class="nc" id="L256">      final String msg =</span>
          &quot;Unable to access PKCS#11 slot for crypto token '&quot;
              + tokenName
              + &quot;' (&quot;
              + cryptoTokenId
              + &quot;). Perhaps the token was removed? &quot;
<span class="nc" id="L262">              + e.getMessage();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">      if (allowNonExistingSlot) {</span>
<span class="nc" id="L264">        log.warn(msg);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L266">          log.debug(msg, e);</span>
        }
      } else {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L270">          log.debug(msg, e);</span>
        }
<span class="nc" id="L272">        throw e;</span>
      }
<span class="nc" id="L274">    } catch (Exception e) {</span>
<span class="nc" id="L275">      log.error(&quot;Error initializing Crypto Token. Classpath=&quot; + classname, e);</span>
<span class="pc" id="L276">    }</span>
<span class="fc" id="L277">    token.setTokenName(tokenName);</span>
<span class="fc" id="L278">    return token;</span>
  }

  private static CryptoToken createTokenFromClass(
      final String classpath) {
    try {
<span class="fc" id="L284">      Class&lt;?&gt; implClass = Class.forName(classpath);</span>
<span class="fc" id="L285">      Object obj = implClass.getConstructor().newInstance();</span>
<span class="fc" id="L286">      return (CryptoToken) obj;</span>
<span class="nc" id="L287">    } catch (Throwable e) {</span>
<span class="nc" id="L288">      log.error(</span>
          &quot;Error contructing Crypto Token (setting to null). Classpath=&quot;
              + classpath,
          e);
<span class="nc" id="L292">      return null;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>