<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CAToken.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-common-entity-tests</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca.catoken</a> &gt; <span class="el_source">CAToken.java</span></div><h1>CAToken.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca.catoken;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringReader;
import java.io.StringWriter;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Properties;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.internal.InternalResources;
import org.cesecore.internal.UpgradeableDataHashMap;
import org.cesecore.keys.token.CryptoToken;
import org.cesecore.keys.token.CryptoTokenOfflineException;
import org.cesecore.util.StringTools;

/**
 * The CAToken is keeps references to the CA's key aliases and the CryptoToken where the keys are stored.
 * 
 * The signing key can have 3 stages:
 * - Next:     Can become the new current CA key when a valid signing certificate is present
 * - Current:  Is used to issue certificates and has a CA certificate
 * - Previous: The signing key before the latest CA renewal.
 * 
 * Each CA signing key &quot;generation&quot; has a corresponding key sequence number that is kept track of
 * via this class. The key sequence also have the states next, current and previous.
 * 
 * The CA token stores a reference (an integer) to the CryptoToken where the CA keys are stored.
 * 
 * @version $Id: CAToken.java 26093 2017-06-28 15:05:13Z anatom $
 */
public class CAToken extends UpgradeableDataHashMap {

    private static final long serialVersionUID = -459748276141898509L;

    /** Log4j instance */
<span class="fc" id="L53">    private static final Logger log = Logger.getLogger(CAToken.class);</span>
    /** Internal localization of logs and errors */
<span class="fc" id="L55">    private static final InternalResources intres = InternalResources.getInstance();</span>

    /** Latest version of the UpgradeableHashMap, this determines if we need to auto-upgrade any data. */
    public static final float LATEST_VERSION = 8;

    @Deprecated // Used by upgrade code
    public static final String CLASSPATH = &quot;classpath&quot;;
    public static final String PROPERTYDATA = &quot;propertydata&quot;;
    @Deprecated // Used by upgrade code
    public static final String KEYSTORE = &quot;KEYSTORE&quot;;

    // The Initial sequence number is 00000-99999 or starts at 00001 according to generated doc 2012-12-03.
    public static final String DEFAULT_KEYSEQUENCE = &quot;00000&quot;;

    public static final String SOFTPRIVATESIGNKEYALIAS = &quot;signKey&quot;;
    public static final String SOFTPRIVATEDECKEYALIAS = &quot;encryptKey&quot;;
    /** These aliases were changed in EJBCA 6.4.1 */
    private static final String OLDPRIVATESIGNKEYALIAS = &quot;privatesignkeyalias&quot;;   
    protected static final String OLDPRIVATEDECKEYALIAS = &quot;privatedeckeyalias&quot;;

    /** A sequence for the keys, updated when keys are re-generated */
    public static final String SEQUENCE = &quot;sequence&quot;;
    /** Format of the key sequence, the value for this property is one of StringTools.KEY_SEQUENCE_FORMAT_XX */
    public static final String SEQUENCE_FORMAT = &quot;sequenceformat&quot;;
    public static final String SIGNATUREALGORITHM = &quot;signaturealgorithm&quot;;
    public static final String ENCRYPTIONALGORITHM = &quot;encryptionalgorithm&quot;;
    public static final String CRYPTOTOKENID = &quot;cryptotokenid&quot;;

    private int cryptoTokenId;
<span class="fc" id="L84">    private transient PurposeMapping keyStrings = null;</span>

    public CAToken(final int cryptoTokenId, final Properties caTokenProperties) {
<span class="fc" id="L87">        super();</span>
<span class="fc" id="L88">        setCryptoTokenId(cryptoTokenId);</span>
<span class="fc" id="L89">        internalInit(caTokenProperties);</span>
<span class="fc" id="L90">    }</span>

	/** Common code to initialize object called from all constructors. 
	 * @param caTokenProperties properties*/
	private void internalInit(Properties caTokenProperties) {
<span class="fc" id="L95">        this.keyStrings = new PurposeMapping(caTokenProperties);</span>
<span class="fc" id="L96">        setCATokenPropertyData(storeProperties(caTokenProperties));</span>
<span class="fc" id="L97">	}</span>

    /** Constructor used to initialize a stored CA token, when the UpgradeableHashMap has been stored as is.
     * 
     * @param tokendata LinkedHashMap
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L104">    public CAToken(final HashMap tokendata) {</span>
<span class="fc" id="L105">		loadData(tokendata);</span>
<span class="fc" id="L106">		final Object cryptoTokenIdObject = data.get(CAToken.CRYPTOTOKENID);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">		if (cryptoTokenIdObject==null) {</span>
<span class="nc" id="L108">		    log.warn(&quot;No CryptoTokenId in CAToken map. This can safely be ignored if shown during an upgrade from EJBCA 5.0.x or lower.&quot;);</span>
		} else {
<span class="fc" id="L110">            this.cryptoTokenId = Integer.parseInt((String) cryptoTokenIdObject);</span>
		}
<span class="fc" id="L112">        final Properties caTokenProperties = getProperties();</span>
<span class="fc" id="L113">        internalInit(caTokenProperties);</span>
<span class="fc" id="L114">    }</span>
    
    /** Verifies that the all the mapped keys are present in the CryptoToken and optionally that the test key is usable. 
     * @param caTokenSignTest bool
     * @param cryptoToken token
     * @return status code*/
    public int getTokenStatus(boolean caTokenSignTest, CryptoToken cryptoToken) {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L122">            log.trace(&quot;&gt;getCATokenStatus&quot;);</span>
        }
<span class="fc" id="L124">        int ret = CryptoToken.STATUS_OFFLINE;</span>
        // If we have no key aliases, no point in continuing...
        try {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        	if (keyStrings != null) {</span>
<span class="fc" id="L128">        		final String aliases[] = keyStrings.getAliases();</span>
<span class="fc" id="L129">        		final String aliasCertSignKeyPrevious = keyStrings.getAlias(CATokenConstants.CAKEYPURPOSE_CERTSIGN_PREVIOUS);</span>
<span class="fc" id="L130">                final String aliasCertSignKeyNext = keyStrings.getAlias(CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT);</span>
<span class="fc" id="L131">                final String aliasTestKey = getAliasFromPurpose(CATokenConstants.CAKEYPURPOSE_KEYTEST);</span>
<span class="fc" id="L132">        		int foundKeys = 0;</span>
                // Loop that checks  if there all key aliases have keys
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        		if (cryptoToken!=null) {</span>
<span class="fc" id="L135">                    final HashMap&lt;String, PrivateKey&gt; aliasMap = new HashMap&lt;String, PrivateKey&gt;();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">                    for (final String alias : aliases) {</span>
<span class="fc" id="L137">                        PrivateKey privateKey = aliasMap.get(alias);</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">                        if (privateKey==null) {</span>
                            try {
<span class="fc" id="L140">                                privateKey = cryptoToken.getPrivateKey(alias);</span>
                                // Cache lookup to avoid having to retrieve the same key when used for multiple purposes
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">                                if (privateKey!=null) {</span>
<span class="fc" id="L143">                                    aliasMap.put(alias, privateKey);</span>
                                }
<span class="fc" id="L145">                            } catch (CryptoTokenOfflineException e) {</span>
<span class="fc" id="L146">                                privateKey = null;</span>
<span class="fc" id="L147">                            }</span>
                        }
<span class="fc bfc" id="L149" title="All 2 branches covered.">                        if (privateKey==null) {</span>
                            // We don't consider it critical if currently unused certificate signing keys has been deleted (as long as it isn't mapped for any other purposes)
<span class="fc bfc" id="L151" title="All 4 branches covered.">                            if (alias.equals(aliasCertSignKeyPrevious) &amp;&amp; keyStrings.isAliasMappedForSinglePurpose(aliasCertSignKeyPrevious)) {</span>
<span class="fc" id="L152">                                foundKeys++;</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">                                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L154">                                    log.debug(&quot;Missing private key for alias: &quot;+alias + &quot; (Not treated as an error, since it is only mapped as the previous CA signing key.)&quot;);</span>
                                }
<span class="fc bfc" id="L156" title="All 4 branches covered.">                            } else if (alias.equals(aliasCertSignKeyNext) &amp;&amp; keyStrings.isAliasMappedForSinglePurpose(aliasCertSignKeyNext)) {</span>
<span class="fc" id="L157">                                    foundKeys++;</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L159">                                        log.debug(&quot;Missing private key for alias: &quot;+alias + &quot; (Not treated as an error, since it is only mapped as the next CA signing key.)&quot;);</span>
                                    }
                            } else {
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L163">                                    log.debug(&quot;Missing private key for alias: &quot;+alias);</span>
                                }
                            }
                        } else {
<span class="fc" id="L167">                            foundKeys++;</span>
                        }
<span class="fc bfc" id="L169" title="All 2 branches covered.">                        if (alias.equals(aliasTestKey)) {</span>
                            PublicKey publicKey;
                            try {
<span class="fc" id="L172">                                publicKey = cryptoToken.getPublicKey(aliasTestKey);</span>
<span class="fc" id="L173">                            } catch (CryptoTokenOfflineException e) {</span>
<span class="fc" id="L174">                                publicKey = null;</span>
<span class="fc" id="L175">                            }</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                            if (publicKey == null) {</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">                                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L178">                                    log.debug(&quot;Missing public key for alias: &quot;+alias);</span>
                                }
                            }
                            // Check that that the testkey is usable by doing a test signature.
                            try {
<span class="fc bfc" id="L183" title="All 2 branches covered.">                                if (caTokenSignTest) {</span>
<span class="fc" id="L184">                                    cryptoToken.testKeyPair(alias, publicKey, privateKey);</span>
                                }
                                // If we can test the testkey, we are finally active!
<span class="fc" id="L187">                                ret = CryptoToken.STATUS_ACTIVE;</span>
<span class="fc" id="L188">                            } catch (Throwable th) { // NOPMD: we need to catch _everything_ when dealing with HSMs</span>
<span class="fc" id="L189">                                log.error(intres.getLocalizedMessage(&quot;token.activationtestfail&quot;, cryptoToken.getId()), th);</span>
<span class="fc" id="L190">                            }</span>
                        }
                    }
        		}
<span class="fc bfc" id="L194" title="All 2 branches covered.">                if (foundKeys &lt; aliases.length) {</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        			if (log.isDebugEnabled()) {</span>
<span class="nc" id="L196">        				StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        				for (int j = 0; j &lt; aliases.length; j++) {</span>
<span class="nc" id="L198">        					builder.append(' ').append(aliases[j]);</span>
        				}
<span class="nc" id="L200">        				log.debug(&quot;Not enough keys for the key aliases: &quot;+builder.toString());</span>
        			}
<span class="fc" id="L202">                    ret = CryptoToken.STATUS_OFFLINE;</span>
        		}
        	}
<span class="nc" id="L205">        } catch (CryptoTokenOfflineException e) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        	if (log.isDebugEnabled()) {</span>
<span class="nc" id="L207">        		log.debug(&quot;CryptoToken offline: &quot;+e.getMessage());</span>
        	}
<span class="fc" id="L209">        }</span>

<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L212">        	log.trace(&quot;&lt;getCATokenStatus: &quot; + ret);</span>
        }
<span class="fc" id="L214">        return ret;</span>
    }

    /** @param purpose purpose
     * @return the key pair alias in the CryptoToken from the CATokenConstants.CAKEYPURPOSE_.. 
     * @throws CryptoTokenOfflineException if offline */
    public String getAliasFromPurpose(final int purpose) throws CryptoTokenOfflineException {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (keyStrings==null) {</span>
            // keyStrings is transient and can be null after serialization
<span class="nc" id="L223">            keyStrings = new PurposeMapping(getProperties());</span>
        }
<span class="fc" id="L225">        final String alias = keyStrings.getAlias(purpose);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (alias == null) {</span>
<span class="fc" id="L227">            throw new CryptoTokenOfflineException(&quot;No alias for key purpose &quot; + purpose);</span>
        }
<span class="fc" id="L229">        return alias;</span>
    }

    /** @return the reference to the CA's CryptoToken */
    public int getCryptoTokenId() {
<span class="fc" id="L234">        return cryptoTokenId;</span>
    }
    /** Set the reference to the CA's CryptoToken. Use with care! 
     * @param cryptoTokenId ID*/
    public void setCryptoTokenId(final int cryptoTokenId) {
<span class="fc" id="L239">        this.cryptoTokenId = cryptoTokenId;</span>
<span class="fc" id="L240">        data.put(CAToken.CRYPTOTOKENID, String.valueOf(cryptoTokenId));</span>
<span class="fc" id="L241">    }</span>

    /** Set a property and update underlying Map 
     * @param key Key
     * @param value Value*/
    public void setProperty(String key, String value) {
<span class="nc" id="L247">        final Properties caTokenProperties = getProperties();</span>
<span class="nc" id="L248">        caTokenProperties.setProperty(key, value);</span>
<span class="nc" id="L249">        setCATokenPropertyData(storeProperties(caTokenProperties));</span>
<span class="nc" id="L250">    }</span>

    /**
     * Internal method just to get rid of the always present date that is part of the standard Properties.store().
     * 
     * @param caTokenProperties properties
     * @return String that can be loaded by Properties.load
     */
    private String storeProperties(Properties caTokenProperties) {
<span class="fc" id="L259">        this.keyStrings = new PurposeMapping(caTokenProperties);</span>
<span class="fc" id="L260">        final StringWriter sw = new StringWriter();</span>
<span class="fc" id="L261">        try ( final PrintWriter writer = new PrintWriter(sw); ) {</span>
<span class="fc" id="L262">            final Enumeration&lt;Object&gt; e = caTokenProperties.keys();</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">            while (e.hasMoreElements()) {</span>
<span class="fc" id="L264">                final Object s = e.nextElement();</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">                if (caTokenProperties.get(s) != null) {</span>
<span class="fc" id="L266">                    writer.println(s + &quot;=&quot; + caTokenProperties.get(s));</span>
                }
<span class="fc" id="L268">            }</span>
        }
<span class="fc" id="L270">        return sw.toString();</span>
    }

    /** Sets the propertydata used to configure this CA Token. 
     * @param propertydata data*/
    private void setCATokenPropertyData(String propertydata) {
<span class="fc" id="L276">        data.put(CAToken.PROPERTYDATA, propertydata);</span>
<span class="fc" id="L277">    }</span>

    public Properties getProperties() {
<span class="fc" id="L280">        String propertyStr = null;</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (data != null) {</span>
<span class="fc" id="L282">            propertyStr = (String) data.get(CAToken.PROPERTYDATA);</span>
        }
<span class="fc" id="L284">        return getPropertiesFromString(propertyStr);</span>
    }
    
    public static Properties getPropertiesFromString(final String propertyStr) {
<span class="fc" id="L288">        final Properties prop = new Properties();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (StringUtils.isNotEmpty(propertyStr)) {</span>
            try {
                // If the input string contains \ (backslash on windows) we must convert it to \\
                // Otherwise properties.load will parse it as an escaped character, and that is not good
<span class="fc" id="L293">                final String propertyStrAdjusted = StringUtils.replace(propertyStr, &quot;\\&quot;, &quot;\\\\&quot;);</span>
<span class="fc" id="L294">                prop.load(new StringReader(propertyStrAdjusted));</span>
                // Trim whitespace in values
<span class="fc bfc" id="L296" title="All 2 branches covered.">                for (final Object keyObj : prop.keySet()) {</span>
<span class="fc" id="L297">                    String key = (String)keyObj;</span>
<span class="fc" id="L298">                    String value = prop.getProperty(key);</span>
<span class="fc" id="L299">                    prop.setProperty(key, value.trim());</span>
<span class="fc" id="L300">                }</span>
<span class="nc" id="L301">            } catch (IOException e) {</span>
<span class="nc" id="L302">                log.error(&quot;Error getting PKCS#11 token properties: &quot;, e);</span>
<span class="fc" id="L303">            }</span>
        }
<span class="fc" id="L305">        return prop;</span>
    }

    /** @return the Sequence, that is a sequence that is updated when keys are re-generated */
    public String getKeySequence() {
<span class="fc" id="L310">        Object seq = data.get(SEQUENCE);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (seq == null) {</span>
<span class="fc" id="L312">            seq = new String(CAToken.DEFAULT_KEYSEQUENCE);</span>
        }
<span class="fc" id="L314">        return (String) seq;</span>
    }

    /** Sets the key sequence 
     * @param sequence sequence*/
    public void setKeySequence(String sequence) {
<span class="fc" id="L320">        data.put(SEQUENCE, sequence);</span>
<span class="fc" id="L321">    }</span>

    /** Sets the SequenceFormat 
     * @param sequence format*/
    public void setKeySequenceFormat(int sequence) {
<span class="fc" id="L326">        data.put(SEQUENCE_FORMAT, sequence);</span>
<span class="fc" id="L327">    }</span>

    /** @return the Sequence format, that is the format of the key sequence */
    public int getKeySequenceFormat() {
<span class="fc" id="L331">        Object seqF = data.get(SEQUENCE_FORMAT);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (seqF == null) {</span>
<span class="fc" id="L333">            seqF = Integer.valueOf(StringTools.KEY_SEQUENCE_FORMAT_NUMERIC);</span>
        }
<span class="fc" id="L335">        return (Integer) seqF;</span>
    }

    /** @return the SignatureAlgoritm */
    public String getSignatureAlgorithm() {
<span class="fc" id="L340">        return (String) data.get(CAToken.SIGNATUREALGORITHM);</span>
    }

    /** Sets the SignatureAlgoritm 
     * @param signaturealgoritm Algo*/
    public void setSignatureAlgorithm(String signaturealgoritm) {
<span class="fc" id="L346">        data.put(CAToken.SIGNATUREALGORITHM, signaturealgoritm);</span>
<span class="fc" id="L347">    }</span>

    /** @return the EncryptionAlgoritm */
    public String getEncryptionAlgorithm() {
<span class="fc" id="L351">        return (String) data.get(CAToken.ENCRYPTIONALGORITHM);</span>
    }

    /** Sets the EncryptionAlgoritm 
     * @param encryptionalgo Algo*/
    public void setEncryptionAlgorithm(String encryptionalgo) {
<span class="fc" id="L357">        data.put(CAToken.ENCRYPTIONALGORITHM, encryptionalgo);</span>
<span class="fc" id="L358">    }</span>

    /** @see org.cesecore.internal.UpgradeableDataHashMap#getLatestVersion() */
    @Override
    public float getLatestVersion() {
<span class="fc" id="L363">        return LATEST_VERSION;</span>
    }

    /** @see org.cesecore.internal.UpgradeableDataHashMap#upgrade() */
    @Override
    public void upgrade() {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (Float.compare(LATEST_VERSION, getVersion()) != 0) {</span>
            // New version of the class, upgrade
<span class="nc" id="L371">            String msg = intres.getLocalizedMessage(&quot;token.upgrade&quot;, Float.valueOf(getVersion()));</span>
<span class="nc" id="L372">            log.info(msg);</span>
            // Put upgrade stuff here
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (data.get(CAToken.SEQUENCE_FORMAT) == null) { // v7</span>
<span class="nc" id="L375">                log.info(&quot;Adding new sequence format to CA Token data: &quot; + StringTools.KEY_SEQUENCE_FORMAT_NUMERIC);</span>
<span class="nc" id="L376">                data.put(CAToken.SEQUENCE_FORMAT, StringTools.KEY_SEQUENCE_FORMAT_NUMERIC);</span>
            }
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (data.get(CAToken.SEQUENCE) == null) { // v7</span>
<span class="nc" id="L379">                log.info(&quot;Adding new default key sequence to CA Token data: &quot; + CAToken.DEFAULT_KEYSEQUENCE);</span>
<span class="nc" id="L380">                data.put(CAToken.SEQUENCE, CAToken.DEFAULT_KEYSEQUENCE);</span>
            }

<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (data.get(CAToken.CLASSPATH) != null) { // v8 upgrade of classpaths for CESeCore</span>
<span class="nc" id="L384">                final String classpath = (String) data.get(CAToken.CLASSPATH);</span>
<span class="nc" id="L385">                log.info(&quot;Upgrading CA token classpath: &quot;+classpath);</span>
<span class="nc" id="L386">                String newclasspath = classpath;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (StringUtils.equals(classpath, &quot;org.ejbca.core.model.ca.catoken.SoftCAToken&quot;)) {</span>
<span class="nc" id="L388">                	newclasspath = &quot;org.cesecore.keys.token.SoftCryptoToken&quot;;</span>
                	// Upgrade properties to set a default key, also for soft crypto tokens
<span class="nc" id="L390">                	Properties prop = getProperties();</span>
                    // A small unfortunate special property that we have to make in order to 
                    // be able to use soft keystores that does not have a specific test or default key
<span class="nc bnc" id="L393" title="All 2 branches missed.">                    if ((prop.getProperty(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING) == null) &amp;&amp;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                    		(prop.getProperty(CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING) == null)) {</span>
                        // The soft key alias was changed from privatesignkeyalias to signKey in EJBCA 6.4.1, which is long after
                        // we changed the classpath. So if we come in here, we are upgrading a token that is way before 6.4.1, meaning 
                        // that it uses the old key aliases
<span class="nc" id="L398">                    	log.info(&quot;Setting CAKEYPURPOSE_CERTSIGN_STRING and CAKEYPURPOSE_CRLSIGN_STRING to privatesignkeyalias.&quot;);</span>
<span class="nc" id="L399">                    	prop.setProperty(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING, CAToken.OLDPRIVATESIGNKEYALIAS);</span>
<span class="nc" id="L400">                    	prop.setProperty(CATokenConstants.CAKEYPURPOSE_CRLSIGN_STRING, CAToken.OLDPRIVATESIGNKEYALIAS);</span>
                    }
<span class="nc bnc" id="L402" title="All 2 branches missed.">                    if ((prop.getProperty(CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING) == null) &amp;&amp;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                    		(prop.getProperty(CATokenConstants.CAKEYPURPOSE_TESTKEY_STRING) == null)) {</span>
                        // Same as above regarding key aliases
<span class="nc" id="L405">                        log.info(&quot;Setting CAKEYPURPOSE_DEFAULT_STRING to privatedeckeyalias.&quot;);</span>
<span class="nc" id="L406">                    	prop.setProperty(CATokenConstants.CAKEYPURPOSE_DEFAULT_STRING, CAToken.OLDPRIVATEDECKEYALIAS);</span>
                    }
<span class="nc" id="L408">                    setCATokenPropertyData(storeProperties(prop)); // Stores property string in &quot;data&quot;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                } else if (StringUtils.equals(classpath, &quot;org.ejbca.core.model.ca.catoken.PKCS11CAToken&quot;)) {</span>
<span class="nc" id="L410">                	newclasspath = &quot;org.cesecore.keys.token.PKCS11CryptoToken&quot;;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                } else if (StringUtils.equals(classpath, &quot;org.ejbca.core.model.ca.catoken.NullCAToken&quot;)) {</span>
<span class="nc" id="L412">                	newclasspath = &quot;org.cesecore.keys.token.NullCryptoToken&quot;;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                } else if (StringUtils.equals(classpath, &quot;org.ejbca.core.model.ca.catoken.NFastCAToken&quot;)) {</span>
<span class="nc" id="L414">                	log.error(&quot;Upgrading of NFastCAToken not supported, you need to convert to using PKCS11CAToken before upgrading.&quot;);</span>
                }
<span class="nc" id="L416">                data.put(CAToken.CLASSPATH, newclasspath);</span>
            }

<span class="nc" id="L419">            data.put(VERSION, Float.valueOf(LATEST_VERSION));</span>
        }
<span class="nc" id="L421">    }</span>

    /**
     * Use current key sequence to generate and store a &quot;next&quot; key sequence and &quot;next&quot; singing key alias.
     * @return the next sign key alias.
     */
    public String generateNextSignKeyAlias() {
        // Generate a new key sequence
<span class="fc" id="L429">        final String currentKeySequence = getKeySequence();</span>
<span class="fc" id="L430">        final String newKeySequence = StringTools.incrementKeySequence(getKeySequenceFormat(), currentKeySequence);</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L432">            log.debug(&quot;Current key sequence: &quot; + currentKeySequence + &quot;  New key sequence: &quot; + newKeySequence);</span>
        }
        // Generate a key alias based on the new key sequence
<span class="fc" id="L435">        final String currentCertSignKeyLabel = keyStrings.getAlias(CATokenConstants.CAKEYPURPOSE_CERTSIGN);</span>
<span class="fc" id="L436">        final String newCertSignKeyLabel = StringUtils.removeEnd(currentCertSignKeyLabel, currentKeySequence) + newKeySequence;</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L438">            log.debug(&quot;Current sign key alias: &quot; + currentCertSignKeyLabel + &quot;  New sign key alias: &quot; + newCertSignKeyLabel);</span>
        }
        // Store the new values in the properties of this token
<span class="fc" id="L441">        setNextCertSignKey(newCertSignKeyLabel);</span>
<span class="fc" id="L442">        setNextKeySequence(newKeySequence);</span>
<span class="fc" id="L443">        return newCertSignKeyLabel;</span>
    }

    /** Next sign key becomes current. Current becomes previous. Same goes for KeySequence. CRL sign key is updated if it is the same as cert sign key */
    public void activateNextSignKey() {
<span class="fc" id="L448">        final Properties caTokenProperties = getProperties();</span>
        // Replace certificate (and crl) signing key aliases (if present)
<span class="fc" id="L450">        boolean swichedSigningKey = false;</span>
<span class="fc" id="L451">        final String nextCertSignKeyLabel = keyStrings.getAlias(CATokenConstants.CAKEYPURPOSE_CERTSIGN_NEXT);</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        if (nextCertSignKeyLabel!=null) {</span>
<span class="fc" id="L453">            final String currentCertSignKeyLabel = keyStrings.getAlias(CATokenConstants.CAKEYPURPOSE_CERTSIGN);</span>
<span class="fc" id="L454">            final String currentCrlSignKeyLabel = keyStrings.getAlias(CATokenConstants.CAKEYPURPOSE_CRLSIGN);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L456">                log.debug(&quot;CERTSIGN_NEXT: &quot; + nextCertSignKeyLabel);</span>
<span class="nc" id="L457">                log.debug(&quot;CERTSIGN:      &quot; + currentCertSignKeyLabel);</span>
<span class="nc" id="L458">                log.debug(&quot;CRLSIGN:       &quot; + currentCrlSignKeyLabel);</span>
            }
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">            if (StringUtils.equals(currentCertSignKeyLabel, currentCrlSignKeyLabel)) {</span>
<span class="fc" id="L461">                log.info(&quot;Setting CRL signing key alias to: &quot; + nextCertSignKeyLabel);</span>
<span class="fc" id="L462">                caTokenProperties.setProperty(CATokenConstants.CAKEYPURPOSE_CRLSIGN_STRING, nextCertSignKeyLabel);</span>
            }
<span class="fc" id="L464">            log.info(&quot;Setting certificate signing key alias to: &quot; + nextCertSignKeyLabel);</span>
<span class="fc" id="L465">            caTokenProperties.setProperty(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING_PREVIOUS, currentCertSignKeyLabel);</span>
<span class="fc" id="L466">            caTokenProperties.setProperty(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING, nextCertSignKeyLabel);</span>
<span class="fc" id="L467">            caTokenProperties.remove(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING_NEXT);</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">            swichedSigningKey = !StringUtils.equals(nextCertSignKeyLabel, currentCertSignKeyLabel);</span>
        }
        // Replace key sequence (if present)
<span class="fc" id="L471">        final String nextKeySequence = caTokenProperties.getProperty(CATokenConstants.NEXT_SEQUENCE_PROPERTY);</span>
<span class="fc" id="L472">        final String currentKeySequence = getKeySequence();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (nextKeySequence != null) {</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L475">                log.debug(&quot;Current KeySequence: &quot; + getKeySequence());</span>
            }
<span class="fc" id="L477">            log.info(&quot;Set key sequence from nextSequence: &quot; + nextKeySequence);</span>
<span class="fc" id="L478">            caTokenProperties.setProperty(CATokenConstants.PREVIOUS_SEQUENCE_PROPERTY, currentKeySequence);</span>
<span class="fc" id="L479">            setKeySequence(nextKeySequence);</span>
<span class="fc" id="L480">            caTokenProperties.remove(CATokenConstants.NEXT_SEQUENCE_PROPERTY);</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">        } else if (swichedSigningKey) {</span>
            // If we did not have a next key sequence before this activation we generate one and push back the current.
<span class="fc" id="L483">            final String newKeySequence = StringTools.incrementKeySequence(getKeySequenceFormat(), currentKeySequence);</span>
<span class="fc" id="L484">            caTokenProperties.setProperty(CATokenConstants.PREVIOUS_SEQUENCE_PROPERTY, currentKeySequence);</span>
<span class="fc" id="L485">            setKeySequence(newKeySequence);</span>
<span class="fc" id="L486">        } else {</span>
            // So there is no key sequence and we didn't switch singing key..
            // ..let us just set the previous sequence to the current to at least match the singing key alias
<span class="nc" id="L489">            caTokenProperties.setProperty(CATokenConstants.PREVIOUS_SEQUENCE_PROPERTY, currentKeySequence);</span>
        }
        // Store changes in the CAToken's properties
<span class="fc" id="L492">        setCATokenPropertyData(storeProperties(caTokenProperties));</span>
<span class="fc" id="L493">    }</span>

    /** Set the next singing key alias 
     * @param nextSignKeyAlias Alias*/
    public void setNextCertSignKey(String nextSignKeyAlias) {
<span class="fc" id="L498">        final Properties caTokenProperties = getProperties();</span>
<span class="fc" id="L499">        caTokenProperties.setProperty(CATokenConstants.CAKEYPURPOSE_CERTSIGN_STRING_NEXT, nextSignKeyAlias);</span>
<span class="fc" id="L500">        setCATokenPropertyData(storeProperties(caTokenProperties));</span>
<span class="fc" id="L501">    }</span>

    /** Set the next key sequence 
     * @param newSequence sequence*/
    public void setNextKeySequence(String newSequence) {
<span class="fc" id="L506">        final Properties caTokenProperties = getProperties();</span>
<span class="fc" id="L507">        caTokenProperties.setProperty(CATokenConstants.NEXT_SEQUENCE_PROPERTY, newSequence);</span>
<span class="fc" id="L508">        setCATokenPropertyData(storeProperties(caTokenProperties));</span>
<span class="fc" id="L509">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>