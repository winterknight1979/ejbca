<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RequestMessageUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-common-entity-tests</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.certificate.request</a> &gt; <span class="el_source">RequestMessageUtils.java</span></div><h1>RequestMessageUtils.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/ 
package org.cesecore.certificates.certificate.request;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;

import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.crmf.CertReqMsg;
import org.bouncycastle.asn1.crmf.POPOSigningKey;
import org.bouncycastle.cert.crmf.CRMFException;
import org.bouncycastle.cert.crmf.PKMACBuilder;
import org.bouncycastle.cert.crmf.jcajce.JcaCertificateRequestMessage;
import org.bouncycastle.cert.crmf.jcajce.JcePKMACValuesCalculator;
import org.bouncycastle.jce.netscape.NetscapeCertRequest;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.util.encoders.DecoderException;
import org.cesecore.certificates.ca.SignRequestSignatureException;
import org.cesecore.certificates.certificate.CertificateConstants;
import org.cesecore.keys.util.KeyTools;
import org.cesecore.util.Base64;
import org.cesecore.util.CertTools;
import org.cesecore.util.FileTools;
import org.ejbca.cvc.CVCAuthenticatedRequest;
import org.ejbca.cvc.CVCObject;
import org.ejbca.cvc.CVCertificate;
import org.ejbca.cvc.CertificateParser;
import org.ejbca.cvc.exception.ConstructionException;
import org.ejbca.cvc.exception.ParseException;

/**
 * Utility class to gather a few functions
 *
 * @version $Id: RequestMessageUtils.java 27126 2017-11-13 09:28:54Z anatom $
 */
<span class="nc" id="L56">public abstract class RequestMessageUtils {</span>
	
<span class="fc" id="L58">	private static final Logger log = Logger.getLogger(RequestMessageUtils.class);</span>

	/** Tries to parse the byte array to create a request message of the correct type.
	 * Currently handles PKCS10 request messages and CVC request messages.
	 * @param request byte array
	 * 
	 * @return IRequestMessage
	 */
	public static RequestMessage parseRequestMessage(byte[] request) {
<span class="nc" id="L67">		RequestMessage ret = null;</span>
		try {
<span class="nc" id="L69">			ret = genPKCS10RequestMessage(request);			</span>
<span class="nc" id="L70">		} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L71">			log.debug(&quot;Can not parse PKCS10 request, trying CVC instead: &quot;+ e.getMessage());</span>
<span class="nc" id="L72">			ret = genCVCRequestMessage(request);</span>
<span class="nc" id="L73">		}</span>
<span class="nc" id="L74">		return ret;</span>
	}

	public static PKCS10RequestMessage genPKCS10RequestMessage(byte[] bytes) {
<span class="fc" id="L78">		byte[] buffer = getDecodedBytes(bytes);</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">		if (buffer == null) {</span>
<span class="nc" id="L80">			return null;</span>
		}		
<span class="fc" id="L82">		return new PKCS10RequestMessage(buffer);</span>
	} // genPKCS10RequestMessageFromPEM
	

	public static CVCRequestMessage genCVCRequestMessage(byte[] bytes) { 
<span class="nc" id="L87">		byte[] buffer = getDecodedBytes(bytes);</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">		if (buffer == null) {</span>
<span class="nc" id="L89">			return null;</span>
		}		
<span class="nc" id="L91">		return new CVCRequestMessage(buffer);</span>
	} // genCvcRequestMessageFromPEM
	
	/** Tries to get decoded, if needed, bytes from a certificate request or certificate
	 * 
	 * @param bytes pem (with headers), plain base64, or binary bytes with a CSR of certificate 
	 * @return binary bytes
	 */
	public static byte[] getDecodedBytes(byte[] bytes) {
<span class="fc" id="L100">		byte[] buffer = null;</span>
		try {
<span class="nc" id="L102">			 buffer = getRequestBytes(bytes); </span>
<span class="fc" id="L103">		} catch (IOException e) {</span>
<span class="fc" id="L104">			log.debug(&quot;Message not base64 encoded? Trying as binary: &quot;+e.getMessage());</span>
<span class="fc" id="L105">			buffer = bytes;</span>
<span class="nc" id="L106">		}</span>
<span class="fc" id="L107">		return buffer;</span>
	}

	/** Tries to get decoded bytes from a certificate request or certificate
	 * 
	 * @param b64Encoded pem (with headers) or plain base64 with a CSR of certificate 
	 * @return binary bytes
	 * @throws IOException on error
	 */
	public static byte[] getRequestBytes(byte[] b64Encoded) throws IOException {
<span class="fc" id="L117">		byte[] buffer = null;</span>
<span class="pc bpc" id="L118" title="2 of 4 branches missed.">		if (b64Encoded != null &amp;&amp; b64Encoded.length &gt; 0) {</span>
<span class="fc" id="L119">		    String str = new String(b64Encoded);</span>
            // A real PKCS10 PEM request
<span class="fc" id="L121">            String beginKey = CertTools.BEGIN_CERTIFICATE_REQUEST;</span>
<span class="fc" id="L122">            String endKey = CertTools.END_CERTIFICATE_REQUEST;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            if (!str.contains(beginKey)) {</span>
                // Keytool PKCS10 PEM request
<span class="fc" id="L125">                beginKey = CertTools.BEGIN_KEYTOOL_CERTIFICATE_REQUEST;</span>
<span class="fc" id="L126">                endKey = CertTools.END_KEYTOOL_CERTIFICATE_REQUEST;</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                if (!str.contains(beginKey)) {</span>
                    // CSR can be a PEM encoded certificate instead of &quot;certificate request&quot;
<span class="fc" id="L129">                    beginKey = CertTools.BEGIN_CERTIFICATE;</span>
<span class="fc" id="L130">                    endKey = CertTools.END_CERTIFICATE;</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">                    if (!str.contains(beginKey)) {</span>
                        // IE PKCS10 Base64 coded request
                        try {
<span class="nc" id="L134">                            buffer = Base64.decode(b64Encoded);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                            if (buffer == null) {</span>
<span class="nc" id="L136">                                throw new IOException(&quot;Base64 decode of buffer returns null&quot;);</span>
                            }
<span class="fc" id="L138">                        } catch (DecoderException de) {</span>
<span class="fc" id="L139">                            throw new IOException(&quot;Base64 decode fails, message not base64 encoded: &quot;+de.getMessage());</span>
<span class="nc" id="L140">                        }</span>
                    }
                }
            }
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (buffer == null) {</span>
<span class="nc" id="L145">                buffer = FileTools.getBytesFromPEM(b64Encoded, beginKey, endKey);                </span>
            }
<span class="nc" id="L147">		} else {</span>
<span class="nc" id="L148">            throw new IOException(&quot;Base64 decode fails, message is empty&quot;);		    </span>
		}
<span class="nc" id="L150">		return buffer;</span>
	}

    public static RequestMessage getRequestMessageFromType(final String username, final String password, final String req, final int reqType)
            throws SignRequestSignatureException, InvalidKeyException, NoSuchAlgorithmException, NoSuchProviderException, IOException,
            SignatureException, InvalidKeySpecException, ParseException, ConstructionException, NoSuchFieldException {
<span class="nc" id="L156">	    RequestMessage ret = null;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (reqType == CertificateConstants.CERT_REQ_TYPE_PKCS10) {</span>
<span class="nc" id="L158">            final PKCS10RequestMessage pkcs10RequestMessage = RequestMessageUtils.genPKCS10RequestMessage(req.getBytes());</span>
<span class="nc" id="L159">            pkcs10RequestMessage.setUsername(username);</span>
<span class="nc" id="L160">            pkcs10RequestMessage.setPassword(password);</span>
<span class="nc" id="L161">            ret = pkcs10RequestMessage;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        } else if (reqType == CertificateConstants.CERT_REQ_TYPE_SPKAC) {</span>
<span class="nc" id="L163">            byte[] reqBytes = req.getBytes();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">            if (reqBytes != null) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L166">                    log.debug(&quot;Received NS request: &quot;+new String(reqBytes));</span>
                }
<span class="nc" id="L168">                byte[] buffer = Base64.decode(reqBytes);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                if (buffer == null) {</span>
<span class="nc" id="L170">                    return null;</span>
                }
<span class="nc" id="L172">                ASN1InputStream in = new ASN1InputStream(new ByteArrayInputStream(buffer));</span>
<span class="nc" id="L173">                ASN1Sequence spkacSeq = (ASN1Sequence) in.readObject();</span>
<span class="nc" id="L174">                in.close();</span>
<span class="nc" id="L175">                NetscapeCertRequest nscr = new NetscapeCertRequest(spkacSeq);</span>
                // Verify POPO, we don't care about the challenge, it's not important.
<span class="nc" id="L177">                nscr.setChallenge(&quot;challenge&quot;);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                if (nscr.verify(&quot;challenge&quot;) == false) {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L180">                        log.debug(&quot;SPKAC POPO verification Failed&quot;);</span>
                    }
<span class="nc" id="L182">                    throw new SignRequestSignatureException(&quot;Invalid signature in NetscapeCertRequest, popo-verification failed.&quot;);</span>
                }
<span class="nc bnc" id="L184" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L185">                    log.debug(&quot;POPO verification successful&quot;);</span>
                }
<span class="nc" id="L187">                PublicKey pubKey = nscr.getPublicKey();</span>
<span class="nc" id="L188">                ret = new SimpleRequestMessage(pubKey, username, password);</span>
            }       
<span class="nc bnc" id="L190" title="All 2 branches missed.">        } else if (reqType == CertificateConstants.CERT_REQ_TYPE_CRMF) {</span>
<span class="nc" id="L191">            final byte[] certificateRequestMessages = Base64.decode(req.getBytes());</span>
<span class="nc" id="L192">            final CertReqMsg certReqMsg = CertReqMsg.getInstance(((ASN1Sequence)ASN1Sequence.fromByteArray(certificateRequestMessages)).getObjectAt(0));</span>
<span class="nc" id="L193">            final JcaCertificateRequestMessage jcrm = new JcaCertificateRequestMessage(certReqMsg);</span>
            try {
<span class="nc" id="L195">                final PublicKey publicKey = jcrm.getPublicKey();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if (jcrm.hasProofOfPossession()) {</span>
<span class="nc bnc" id="L197" title="All 5 branches missed.">                    switch (jcrm.getProofOfPossessionType()) {</span>
                    case JcaCertificateRequestMessage.popRaVerified: {
                        // The requestor claims that it is verified by an RA
<span class="nc" id="L200">                        break;</span>
                    }
                    case JcaCertificateRequestMessage.popSigningKey: {
                        // RFC 4211 Section 4.1
<span class="nc" id="L204">                        final POPOSigningKey popoSigningKey = POPOSigningKey.getInstance(jcrm.toASN1Structure().getPopo().getObject());</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                        if (log.isDebugEnabled()) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                            if (popoSigningKey!=null) {</span>
<span class="nc" id="L207">                                log.debug(&quot;CRMF POPOSigningKey poposkInput:                      &quot; + popoSigningKey.getPoposkInput());</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                                if (popoSigningKey.getPoposkInput()!=null) {</span>
<span class="nc" id="L209">                                    log.debug(&quot;CRMF POPOSigningKey poposkInput PublicKey:            &quot; + popoSigningKey.getPoposkInput().getPublicKey());</span>
<span class="nc" id="L210">                                    log.debug(&quot;CRMF POPOSigningKey poposkInput PublicKeyMAC:         &quot; + popoSigningKey.getPoposkInput().getPublicKeyMAC());</span>
                                }
<span class="nc" id="L212">                                log.debug(&quot;CRMF POPOSigningKey algorithmIdentifier.algorithm.id: &quot; + popoSigningKey.getAlgorithmIdentifier().getAlgorithm().getId());</span>
<span class="nc" id="L213">                                log.debug(&quot;CRMF POPOSigningKey signature:                        &quot; + popoSigningKey.getSignature());</span>
                            } else {
<span class="nc" id="L215">                                log.debug(&quot;CRMF POPOSigningKey is not defined even though POP type is popSigningKey. Validation will fail.&quot;);</span>
                            }
                        }
<span class="nc" id="L218">                        final ContentVerifierProvider cvp = CertTools.genContentVerifierProvider(publicKey);</span>
                        // Work around for bug in BC where jcrm.hasSigningKeyProofOfPossessionWithPKMAC() will throw NPE if PoposkInput is null
<span class="nc bnc" id="L220" title="All 4 branches missed.">                        if (popoSigningKey.getPoposkInput()!=null &amp;&amp; jcrm.hasSigningKeyProofOfPossessionWithPKMAC()) {</span>
<span class="nc" id="L221">                            final PKMACBuilder pkmacBuilder = new PKMACBuilder(new JcePKMACValuesCalculator().setProvider(BouncyCastleProvider.PROVIDER_NAME));</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                            if (!jcrm.isValidSigningKeyPOP(cvp, pkmacBuilder, password.toCharArray())) {</span>
<span class="nc" id="L223">                                throw new SignRequestSignatureException(&quot;CRMF POP with PKMAC failed signature or MAC validation.&quot;);</span>
                            } else {
<span class="nc bnc" id="L225" title="All 2 branches missed.">                                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L226">                                    log.debug(&quot;CRMF POP with PKMAC passed signature and PKMAC validation.&quot;);</span>
                                }
                            }
<span class="nc" id="L229">                        } else {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                            if (!jcrm.isValidSigningKeyPOP(cvp)) {</span>
<span class="nc" id="L231">                                throw new SignRequestSignatureException(&quot;CRMF POP failed signature validation.&quot;);</span>
                            } else {
<span class="nc bnc" id="L233" title="All 2 branches missed.">                                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L234">                                    log.debug(&quot;CRMF POP passed signature validation.&quot;);</span>
                                }
                            }
                        }
                        break;
                    }
                    case JcaCertificateRequestMessage.popKeyEncipherment: {
                        // RFC 4211 Section 4.2 (Not implemented)
<span class="nc" id="L242">                        log.info(&quot;CRMF RFC4211 Section 4.2 KeyEncipherment POP validation is not implemented. Will try to use the request's public key anyway.&quot;);</span>
<span class="nc" id="L243">                        break;</span>
                    }
                    case JcaCertificateRequestMessage.popKeyAgreement: {
                        // RFC 4211 Section 4.3 (Not implemented)
<span class="nc" id="L247">                        log.info(&quot;CRMF RFC4211 Section 4.3 KeyAgreement POP validation is not implemented. Will try to use the request's public key anyway.&quot;);</span>
<span class="nc" id="L248">                        break;</span>
                    }
                    default:
<span class="nc" id="L251">                        throw new SignRequestSignatureException(&quot;CRMF POP of type &quot;+jcrm.getProofOfPossessionType()+&quot; is unknown.&quot;);</span>
                    }
                }
<span class="nc" id="L254">                final SimpleRequestMessage simpleRequestMessage = new SimpleRequestMessage(publicKey, username, password);</span>
<span class="nc" id="L255">                simpleRequestMessage.setRequestExtensions(jcrm.getCertTemplate().getExtensions());</span>
<span class="nc" id="L256">                ret = simpleRequestMessage;</span>
<span class="nc" id="L257">            } catch (CRMFException e) {</span>
<span class="nc" id="L258">                throw new SignRequestSignatureException(&quot;CRMF POP verification failed.&quot;, e);</span>
<span class="nc" id="L259">            } catch (OperatorCreationException e) {</span>
<span class="nc" id="L260">                throw new SignRequestSignatureException(&quot;CRMF POP verification failed.&quot;, e);</span>
<span class="nc" id="L261">            }</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        } else if (reqType == CertificateConstants.CERT_REQ_TYPE_PUBLICKEY) {</span>
            byte[] request;
            // Request can be Base64 encoded or in PEM format
            try {
<span class="nc" id="L266">                request = FileTools.getBytesFromPEM(req.getBytes(), CertTools.BEGIN_PUBLIC_KEY, CertTools.END_PUBLIC_KEY);</span>
<span class="nc" id="L267">            } catch (IOException ex) {</span>
                try {
<span class="nc" id="L269">                    request = Base64.decode(req.getBytes());</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                    if (request == null) {</span>
<span class="nc" id="L271">                        throw new IOException(&quot;Base64 decode of buffer returns null&quot;);</span>
                    }
<span class="nc" id="L273">                } catch (DecoderException de) {</span>
<span class="nc" id="L274">                    throw new IOException(&quot;Base64 decode fails, message not base64 encoded: &quot; + de.getMessage());</span>
<span class="nc" id="L275">                }</span>
<span class="nc" id="L276">            }</span>
<span class="nc" id="L277">            final PublicKey pubKey = KeyTools.getPublicKeyFromBytes(request);</span>
<span class="nc" id="L278">            ret = new SimpleRequestMessage(pubKey, username, password);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        } else if (reqType == CertificateConstants.CERT_REQ_TYPE_CVC) {</span>
<span class="nc" id="L280">            CVCObject parsedObject = CertificateParser.parseCVCObject(Base64.decode(req.getBytes()));</span>
            // We will handle both the case if the request is an authenticated request, i.e. with an outer signature
            // and when the request is missing the (optional) outer signature.
<span class="nc" id="L283">            CVCertificate cvccert = null;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (parsedObject instanceof CVCAuthenticatedRequest) {</span>
<span class="nc" id="L285">                CVCAuthenticatedRequest cvcreq = (CVCAuthenticatedRequest)parsedObject;</span>
<span class="nc" id="L286">                cvccert = cvcreq.getRequest();</span>
<span class="nc" id="L287">            } else {</span>
<span class="nc" id="L288">                cvccert = (CVCertificate)parsedObject;</span>
            }
<span class="nc" id="L290">            CVCRequestMessage reqmsg = new CVCRequestMessage(cvccert.getDEREncoded());</span>
<span class="nc" id="L291">            reqmsg.setUsername(username);</span>
<span class="nc" id="L292">            reqmsg.setPassword(password);</span>
            // Popo is really actually verified by the CA (in SignSessionBean) as well
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (reqmsg.verify() == false) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L296">                    log.debug(&quot;CVC POPO verification Failed&quot;);</span>
                }
<span class="nc" id="L298">                throw new SignRequestSignatureException(&quot;Invalid inner signature in CVCRequest, popo-verification failed.&quot;);</span>
            } else {
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L301">                    log.debug(&quot;POPO verification successful&quot;);</span>
                }
            }
<span class="nc" id="L304">            ret = reqmsg;</span>
        }
<span class="nc" id="L306">        return ret;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>