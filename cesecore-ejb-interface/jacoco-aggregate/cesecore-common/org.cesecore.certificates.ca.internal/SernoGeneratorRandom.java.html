<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SernoGeneratorRandom.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-ejb-interface</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.ca.internal</a> &gt; <span class="el_source">SernoGeneratorRandom.java</span></div><h1>SernoGeneratorRandom.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.ca.internal;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.cesecore.config.CesecoreConfiguration;
import org.cesecore.internal.InternalResources;

/**
 * Implements a singleton serial number generator using SecureRandom. This generator generates random 8 octec (64 bits) serial numbers.
 * 
 * RFC3280 defines serialNumber be positive INTEGER, and X.690 defines INTEGER consist of one or more octets. X.690 also defines as follows:
 * 
 * If the contents octets of an integer value encoding consist of more than one octet, then the bits of the first octet and bit 8 of the second octet:
 * a) shall not all be ones; and b) shall not all be zero.
 * 
 * Therefore, minimum 8 octets value is 0080000000000000 and maximum value is 7FFFFFFFFFFFFFFF.&quot;
 * 
 * Therefore, minimum 4 octets value is 00800000 and maximum value is 7FFFFFFF.&quot;
 * 
 * X.690:
 * 
 * 8.3 Encoding of an integer value 8.3.1 The encoding of an integer value shall be primitive. The contents octets shall consist of one or more
 * octets. 8.3.2 If the contents octets of an integer value encoding consist of more than one octet, then the bits of the first octet and bit 8 of the
 * second octet: a) shall not all be ones; and b) shall not all be zero. NOTE – These rules ensure that an integer value is always encoded in the
 * smallest possible number of octets. 8.3.3 The contents octets shall be a two's complement binary number equal to the integer value, and consisting
 * of bits 8 to 1 of the first octet, followed by bits 8 to 1 of the second octet, followed by bits 8 to 1 of each octet in turn up to and including
 * the last octet of the contents octets. NOTE – The value of a two's complement binary number is derived by numbering the bits in the contents
 * octets, starting with bit 1 of the last octet as bit zero and ending the numbering with bit 8 of the first octet. Each bit is assigned a numerical
 * value of 2N, where N is its position in the above numbering sequence. The value of the two's complement binary number is obtained by summing the
 * numerical values assigned to each bit for those bits which are set to one, excluding bit 8 of the first octet, and then reducing this value by the
 * numerical value assigned to bit 8 of the first octet if that bit is set to one.
 * 
 * @version $Id: SernoGeneratorRandom.java 31966 2019-03-25 10:19:57Z anatom $
 */
public class SernoGeneratorRandom implements SernoGenerator {
    /** Log4j instance */
<span class="fc" id="L58">    private static final Logger log = Logger.getLogger(SernoGeneratorRandom.class);</span>
    /** Internal localization of logs and errors */
<span class="fc" id="L60">    private static final InternalResources intres = InternalResources.getInstance();</span>

    /** RFC5280, section 4.1.2.2, specifies using max 20 octets for serial number */ 
    private static final int SERNO_MAX_LENGTH = 20;

    /** random generator algorithm, defaults to FIPS approve SHA1PRNG in constructor 
     * The algorithm is specified globally in CesecoreConfiguration.getCaSerialNumberAlgorithm() */
    private String algorithm;

    /** number of bytes to generate, fixed size serial numbers */
    private int noOctets;

    /** random generator */
    private SecureRandom random;

    /** A registry of Singleton instances, to handle multiple octet sizes simultaneously. */
<span class="fc" id="L76">    private static Map&lt;Integer, SernoGeneratorRandom&gt; instances = new HashMap&lt;&gt;();</span>
    /**
     * Creates (if needed) a serial number generator and returns the object.
     * @param noOctets size
     *
     * @return An instance of the serial number generator.
     */
    public static synchronized SernoGenerator instance(Integer noOctets) {
<span class="fc" id="L84">        SernoGeneratorRandom instance = instances.get(noOctets);</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (instance == null) {</span>
<span class="fc" id="L86">            instance = new SernoGeneratorRandom(noOctets);</span>
<span class="fc" id="L87">            instances.put(noOctets, instance);</span>
        }
<span class="fc" id="L89">        return instance;</span>
    }

    /** DO NOT USE: Protected only to do testing of this implementation
     * use {@link #instance(Integer)} instead
     * @param noOctets size
     */
<span class="fc" id="L96">    protected SernoGeneratorRandom(Integer noOctets) {</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L98">            log.trace(&quot;&gt;SernoGenerator()&quot;);</span>
        }
<span class="fc" id="L100">        this.algorithm = CesecoreConfiguration.getCaSerialNumberAlgorithm();</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (this.algorithm == null) {</span>
<span class="nc" id="L102">            this.algorithm = &quot;SHA1PRNG&quot;;</span>
        }
<span class="pc bpc" id="L104" title="2 of 4 branches missed.">        if ((noOctets &gt; SERNO_MAX_LENGTH || noOctets &lt; 0)) { // We allow 0 octets for testing</span>
<span class="nc" id="L105">            throw new IllegalArgumentException(&quot;ca.serialnumberoctetsize must be between 0 and &quot; + SERNO_MAX_LENGTH + &quot; bytes for this serial number generator.&quot;);</span>
        }
<span class="fc" id="L107">        this.noOctets = noOctets;        </span>
<span class="fc" id="L108">        init();</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L110">            log.trace(&quot;&lt;SernoGenerator()&quot;);</span>
        }
<span class="fc" id="L112">    }</span>

    private void init() {
        // Init random number generator for random serial numbers. 
        // SecureRandom provides a cryptographically strong random number generator (CSPRNG).
        try {
            // Use a specified algorithm if ca.rngalgorithm is provided and it's not set to default
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">            if (!StringUtils.isEmpty(algorithm) &amp;&amp; !StringUtils.containsIgnoreCase(algorithm, &quot;default&quot;)) {</span>
<span class="fc" id="L120">                random = SecureRandom.getInstance(algorithm);</span>
<span class="fc" id="L121">                log.info(&quot;Using &quot;+algorithm+&quot; serialNumber RNG algorithm.&quot;);</span>
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">            } else if (!StringUtils.isEmpty(algorithm) &amp;&amp; StringUtils.equalsIgnoreCase(algorithm, &quot;defaultstrong&quot;)) {</span>
                // If defaultstrong is specified and we use &gt;=JDK8 try the getInstanceStrong to get a guaranteed strong random number generator.
                // Note that this may give you a generator that takes &gt;30 seconds to create a single random number. 
                // On JDK8/Linux this gives you a NativePRNGBlocking, while SecureRandom.getInstance() gives a NativePRNG.
                try {
<span class="fc" id="L127">                    final Method methodGetInstanceStrong = SecureRandom.class.getDeclaredMethod(&quot;getInstanceStrong&quot;);</span>
<span class="fc" id="L128">                    random = (SecureRandom) methodGetInstanceStrong.invoke(null);</span>
<span class="fc" id="L129">                    log.info(&quot;Using SecureRandom.getInstanceStrong() with &quot; + random.getAlgorithm() + &quot; for serialNumber RNG algorithm.&quot;);</span>
<span class="nc" id="L130">                } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {</span>
<span class="nc" id="L131">                    throw new IllegalStateException(&quot;SecureRandom.getInstanceStrong() is not available or failed invocation. (This method was added in Java 8.)&quot;);</span>
<span class="fc" id="L132">                }</span>
<span class="pc bpc" id="L133" title="2 of 4 branches missed.">            } else if (!StringUtils.isEmpty(algorithm) &amp;&amp; StringUtils.equalsIgnoreCase(algorithm, &quot;default&quot;)) {</span>
                // We entered &quot;default&quot; so let's use a good default SecureRandom this should be good enough for just about everyone (on Linux at least)
                // On Linux the default Java implementation uses the (secure) /dev/(u)random, but on windows something else
                // On JDK8/Linux this gives you a NativePRNG, while SecureRandom.getInstanceStrong() gives a NativePRNGBlocking.
<span class="fc" id="L137">                random = new SecureRandom();</span>
<span class="fc" id="L138">                log.info(&quot;Using default &quot; + random.getAlgorithm() + &quot; serialNumber RNG algorithm.&quot;);</span>
            }
<span class="nc" id="L140">        } catch (NoSuchAlgorithmException e) {</span>
            //This state is unrecoverable, and since algorithm is set in configuration requires a redeploy to handle
<span class="nc" id="L142">            throw new IllegalStateException(&quot;Algorithm &quot; + algorithm + &quot; was not a valid algorithm.&quot;, e);</span>
<span class="fc" id="L143">        }</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (random == null) {</span>
            //This state is unrecoverable, and since algorithm is set in configuration requires a redeploy to handle
<span class="nc" id="L146">            throw new IllegalStateException(&quot;Algorithm &quot; + algorithm + &quot; was not a valid algorithm.&quot;);</span>
        }
        // Call nextBytes directly after in order to force seeding if not already done. SecureRandom typically seeds on first call.
<span class="fc" id="L149">        random.nextBytes(new byte[0]);</span>
<span class="fc" id="L150">    }</span>

    @Override
    public BigInteger getSerno() {
        // This is only for testing, if size is set to 0 we will generate random number
        // between 1 and 5, this will give collisions often...
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (noOctets == 0) {</span>
<span class="nc" id="L157">            final Random rand = new Random();</span>
<span class="nc" id="L158">            return BigInteger.valueOf(rand.nextInt(4)+1); // value 1-5</span>
        }
        while (true) {
             /*
                Note that initBitsOfEntropy are not left intact by the following subsequent filtering operations:
                - Values discarded to avoid encoding in less than noOctets (including zero value).
                - Serial numbers previously assigned to other certificates (filtered later, not here).
                So the real entropy provided for generated serial numbers is always less than initBitsOfEntropy.
                 */
            // initBitsOfEntropy is 1 less than octet size, because we always use positive integers, which in 
            // two complements representation always has the most significant bit 0, making 63 bits random
<span class="fc" id="L169">            int initBitsOfEntropy = noOctets * 8 - 1;</span>
            // SecureRanom is thread safe. This will generate from (0 to 2^initBitsOfEntropy -1)
<span class="fc" id="L171">            final BigInteger serno = new BigInteger(initBitsOfEntropy, random);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (checkSernoValidity(serno)) {</span>
<span class="fc" id="L173">                return serno;</span>
            } else {
<span class="fc" id="L175">                String msg = intres.getLocalizedMessage(&quot;sernogenerator.discarding&quot;);</span>
<span class="fc" id="L176">                log.info(msg);</span>
            }
<span class="fc" id="L178">        }</span>
    }

    /**
     * This validates that the argument is a non-zero number to be encoded (according to X.690, &quot;8.3 Encoding of an
     * integer value&quot;) exactly in 'noOctets' bytes. For example, for an 8 bytes serial number it will validate that it
     * falls within the range 0080000000000000 - 7FFFFFFFFFFFFFFF (both inclusive).
     * @param serno serial
     * @return bool
     */
    protected boolean checkSernoValidity(final BigInteger serno) {
<span class="pc bpc" id="L189" title="1 of 4 branches missed.">        return serno.compareTo(BigInteger.ZERO) != 0 &amp;&amp; serno.bitLength() / 8 + 1 == noOctets;</span>
    }

    @Override
    public int getNoSernoBytes() {
<span class="nc" id="L194">        return noOctets;</span>
    }

    @Override
    public void setSeed(final long seed) {
<span class="nc" id="L199">        random.setSeed(seed);</span>
<span class="nc" id="L200">    }</span>

    @Override
    public void setAlgorithm(final String algo) throws NoSuchAlgorithmException {
        // Since re-initialization is expensive, we only do it if we changed the algo
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">        if (this.algorithm == null || !this.algorithm.equals(algo)) {</span>
<span class="fc" id="L206">            this.algorithm = algo;</span>
            // We must force re-init after choosing a new algorithm
<span class="fc" id="L208">            this.random = null;</span>
<span class="fc" id="L209">            init();</span>
        }
<span class="fc" id="L211">    }</span>

    /** Available for testing so we can compare that we actually use what we think
     * @return the random generator algorithm as reported by the underlying Java random number generator.
     */
    protected String getAlgorithm() {
<span class="fc" id="L217">        return random.getAlgorithm();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>