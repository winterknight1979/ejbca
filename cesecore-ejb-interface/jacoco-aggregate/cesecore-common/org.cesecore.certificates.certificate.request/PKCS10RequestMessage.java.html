<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PKCS10RequestMessage.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">cesecore-ejb-interface</a> &gt; <a href="../index.html" class="el_bundle">cesecore-common</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.certificates.certificate.request</a> &gt; <span class="el_source">PKCS10RequestMessage.java</span></div><h1>PKCS10RequestMessage.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.certificates.certificate.request;

import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.log4j.Logger;
import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Set;
import org.bouncycastle.asn1.ASN1String;
import org.bouncycastle.asn1.DERIA5String;
import org.bouncycastle.asn1.pkcs.Attribute;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.asn1.x500.AttributeTypeAndValue;
import org.bouncycastle.asn1.x500.DirectoryString;
import org.bouncycastle.asn1.x500.RDN;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Extensions;
import org.bouncycastle.cms.CMSSignedGenerator;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.pkcs.PKCS10CertificationRequest;
import org.bouncycastle.pkcs.PKCSException;
import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequest;
import org.cesecore.util.CeSecoreNameStyle;
import org.cesecore.util.CertTools;

/**
 * Class to handle PKCS10 request messages sent to the CA.
 *
 * @version $Id: PKCS10RequestMessage.java 28214 2018-02-08 10:16:53Z anatom $
 */
public class PKCS10RequestMessage implements RequestMessage {  
    /**
     * Determines if a de-serialized file is compatible with this class.
     *
     * Maintainers must change this value if and only if the new version
     * of this class is not compatible with old versions. See Sun docs
     * for &lt;a href=http://java.sun.com/products/jdk/1.1/docs/guide
     * /serialization/spec/version.doc.html&gt; details. &lt;/a&gt;
     *
     */
    static final long serialVersionUID = 3597275157018205137L;

<span class="fc" id="L65">    private static final Logger log = Logger.getLogger(PKCS10RequestMessage.class);</span>

    /** Raw form of the PKCS10 message */
    protected byte[] p10msg;

    /** manually set password */
<span class="pc" id="L71">    protected String password = null;</span>

    /** manually set username */
<span class="pc" id="L74">    protected String username = null;</span>

<span class="pc" id="L76">    protected Date notAfter = null;</span>
<span class="pc" id="L77">    protected Date notBefore = null;</span>

    /** If the CA certificate should be included in the response or not, default to true = yes */
<span class="pc" id="L80">    protected boolean includeCACert = true;</span>

    /** preferred digest algorithm to use in replies, if applicable */
<span class="pc" id="L83">    private transient String preferredDigestAlg = CMSSignedGenerator.DIGEST_SHA1;</span>

    /** The pkcs10 request message, not serialized. */
<span class="pc" id="L86">    protected transient JcaPKCS10CertificationRequest pkcs10 = null;</span>

    /** Type of error */
<span class="pc" id="L89">    private int error = 0;</span>

    /** Error text */
<span class="pc" id="L92">    private String errorText = null;</span>

<span class="pc" id="L94">    private List&lt;Certificate&gt; additionalCaCertificates = new ArrayList&lt;Certificate&gt;();</span>
    
<span class="pc" id="L96">    private List&lt;Certificate&gt; additionalExtraCertsCertificates = new ArrayList&lt;Certificate&gt;();</span>
    
    /**
     * Constructs a new empty PKCS#10 message handler object.
     */
<span class="fc" id="L101">    public PKCS10RequestMessage() {</span>
    	// No constructor
<span class="fc" id="L103">    }</span>

    /**
     * Constructs a new PKCS#10 message handler object.
     *
     * @param msg The DER encoded PKCS#10 request.
     */
<span class="fc" id="L110">    public PKCS10RequestMessage(byte[] msg) {</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">    	if (log.isTraceEnabled()) {</span>
<span class="nc" id="L112">    		log.trace(&quot;&gt;PKCS10RequestMessage(byte[])&quot;);</span>
    	}
<span class="fc" id="L114">        this.p10msg = msg;</span>
<span class="fc" id="L115">        init();</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">    	if (log.isTraceEnabled()) {</span>
<span class="nc" id="L117">    		log.trace(&quot;&lt;PKCS10RequestMessage(byte[])&quot;);</span>
    	}
<span class="fc" id="L119">    }</span>

    /**
     * Constructs a new PKCS#10 message handler object.
     *
     * @param p10 the PKCS#10 request
     * @throws IOException on fail
     */
<span class="nc" id="L127">    public PKCS10RequestMessage(JcaPKCS10CertificationRequest p10) throws IOException {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    	if (log.isTraceEnabled()) {</span>
<span class="nc" id="L129">    		log.trace(&quot;&gt;PKCS10RequestMessage(ExtendedPKCS10CertificationRequest)&quot;);</span>
    	}
<span class="nc" id="L131">        p10msg = p10.getEncoded();</span>
<span class="nc" id="L132">        pkcs10 = p10;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    	if (log.isTraceEnabled()) {</span>
<span class="nc" id="L134">    		log.trace(&quot;&lt;PKCS10RequestMessage(ExtendedPKCS10CertificationRequest)&quot;);</span>
    	}
<span class="nc" id="L136">    }</span>

    private void init() {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if(p10msg == null) {</span>
<span class="nc" id="L140">            throw new NullPointerException(&quot;Cannot initiate with p10msg == null&quot;);</span>
        }
        try {
<span class="fc" id="L143">            pkcs10 = new JcaPKCS10CertificationRequest(p10msg);</span>
<span class="nc" id="L144">        } catch (IOException e) {</span>
<span class="nc" id="L145">            log.warn(&quot;PKCS10 not initiated! &quot;+e.getMessage());</span>
<span class="fc" id="L146">        }</span>
<span class="fc" id="L147">    }</span>

    @Override
    public PublicKey getRequestPublicKey() throws InvalidKeyException, NoSuchAlgorithmException {
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (pkcs10 == null) {</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (p10msg != null) {</span>
<span class="nc" id="L153">                init();</span>
            } else {
<span class="fc" id="L155">                return null;</span>
            }
        }
<span class="fc" id="L158">        return pkcs10.getPublicKey();</span>
    }

    /**
     * force a password, i.e. ignore the challenge password in the request
     * @param pwd password
     */
    public void setPassword(String pwd) {
<span class="nc" id="L166">        this.password = pwd;</span>
<span class="nc" id="L167">    }</span>

    @Override
    public String getPassword() {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (password != null) {</span>
<span class="nc" id="L172">            return password;</span>
        }
        try {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (pkcs10 == null) {</span>
<span class="nc" id="L176">                init();</span>
            }
<span class="nc" id="L178">        } catch (NullPointerException e) {</span>
<span class="nc" id="L179">            log.error(&quot;PKCS10 not initated! &quot;+e.getMessage());</span>
<span class="nc" id="L180">            return null;</span>
<span class="fc" id="L181">        }</span>

<span class="fc" id="L183">        String ret = null;</span>
<span class="fc" id="L184">        Attribute[] attributes = pkcs10.getAttributes(PKCSObjectIdentifiers.pkcs_9_at_challengePassword);</span>
<span class="fc" id="L185">        ASN1Encodable obj = null;</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (attributes.length == 0) {</span>
            // See if we have it embedded in an extension request instead
<span class="fc" id="L188">            attributes = pkcs10.getAttributes(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest);</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (attributes.length == 0) {</span>
<span class="fc" id="L190">                return null;</span>
            }
<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L193">            	log.debug(&quot;got extension request&quot;);</span>
            }
<span class="nc" id="L195">            ASN1Set values = attributes[0].getAttrValues();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (values.size() == 0) {</span>
<span class="nc" id="L197">                return null;</span>
            }
<span class="nc" id="L199">            Extensions exts = Extensions.getInstance(values.getObjectAt(0));</span>
<span class="nc" id="L200">            Extension ext = exts.getExtension(PKCSObjectIdentifiers.pkcs_9_at_challengePassword);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (ext == null) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L203">                	log.debug(&quot;no challenge password extension&quot;);</span>
                }
<span class="nc" id="L205">                return null;</span>
            }
<span class="nc" id="L207">            obj = ext.getExtnValue();</span>
<span class="nc" id="L208">        } else {</span>
            // If it is a challengePassword directly, it's just to grab the value
<span class="fc" id="L210">            ASN1Set values = attributes[0].getAttrValues();</span>
<span class="fc" id="L211">            obj = values.getObjectAt(0);</span>
        }

<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (obj != null) {</span>
<span class="fc" id="L215">            ASN1String str = null;</span>
            try {
            	// Should be any DirectoryString according to RFC2985, preferably a PrintableString or UTF8String
<span class="fc" id="L218">                str = DirectoryString.getInstance((obj));</span>
<span class="fc" id="L219">            } catch (IllegalArgumentException ie) {</span>
                // This was not a DirectoryString type, it could then be IA5string, breaking pkcs#9 v2.0
                // but some version of openssl have been known to produce IA5strings
<span class="fc" id="L222">                str = DERIA5String.getInstance((obj));</span>
<span class="fc" id="L223">            }</span>

<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            if (str != null) {</span>
<span class="fc" id="L226">                ret = str.getString();</span>
            }
        }

<span class="fc" id="L230">        return ret;</span>
    }

    /**
     * force a username, i.e. ignore the DN/username in the request
     * @param username username
     */
    public void setUsername(String username) {
<span class="nc" id="L238">        this.username = username;</span>
<span class="nc" id="L239">    }</span>

    /**
     * Set the date after which the private key no longer will be valid, or null to
     * use the default validity specified in the certificate profile. The value
     * specified here will only be considered if user-defined validity dates are
     * allowed by the certificate profile, e.g. if Validity override&quot; is enabled.
     * @param notAfter expiry
     */
    public void setNotAfter(final Date notAfter) {
<span class="nc" id="L249">        this.notAfter = notAfter;</span>
<span class="nc" id="L250">    }</span>

    @Override
    public String getUsername() {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (username != null) {</span>
<span class="nc" id="L255">            return username;</span>
        }
        // Special if the DN contains unstructuredAddress where it becomes:
        // CN=pix.primekey.com + unstructuredAddress=pix.primekey.com
        // We only want the CN and not the oid-part.
        // Luckily for us this is handles automatically by BC X500Name class
<span class="fc" id="L261">        X500Name xname = getRequestX500Name();</span>
<span class="fc" id="L262">        String ret = null;</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (xname == null) {</span>
<span class="nc" id="L264">        	log.info(&quot;No requestDN in request, probably we could not read/parse/decrypt request.&quot;);</span>
        } else {
<span class="fc" id="L266">            RDN[] cnValues = xname.getRDNs(CeSecoreNameStyle.CN);</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">            if (cnValues.length == 0) {</span>
<span class="nc" id="L268">            	log.info(&quot;No CN in DN: &quot;+xname.toString());</span>
            } else {
<span class="fc" id="L270">                AttributeTypeAndValue[] tavs = cnValues[0].getTypesAndValues();</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">                for(AttributeTypeAndValue tav : tavs) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                    if(tav.getType().equals(CeSecoreNameStyle.CN)) {</span>
<span class="fc" id="L273">                        ret = tav.getValue().toString();</span>
<span class="fc" id="L274">                        break;</span>
                    }
                }
                // If we have a CN with a normal name like &quot;Test Testsson&quot; we only want to
                // use the first part as the username
<span class="fc" id="L279">            	int index = ret.indexOf(' ');</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            	if (index &gt; 0) {</span>
<span class="fc" id="L281">            		ret = ret.substring(0, index);</span>
            	}
            }
        }
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L286">        	log.debug(&quot;UserName='&quot; + ret + &quot;'&quot;);</span>
        }
<span class="fc" id="L288">        return ret;</span>
    }

    @Override
    public String getIssuerDN() {
<span class="nc" id="L293">        return null;</span>
    }

    @Override
    public BigInteger getSerialNo() {
<span class="nc" id="L298">    	return null;</span>
    }

    @Override
    public String getCRLIssuerDN() {
<span class="nc" id="L303">        return null;</span>
    }

    @Override
    public BigInteger getCRLSerialNo() {
<span class="nc" id="L308">        return null;</span>
    }

    @Override
    public String getRequestDN() {
<span class="fc" id="L313">    	String ret = null;</span>
<span class="fc" id="L314">    	X500Name name = getRequestX500Name();</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">    	if (name != null) {</span>
<span class="fc" id="L316">    		String dn = name.toString();</span>
    		// We have to make special handling again for Cisco devices.
    		// they will submit requests like: SN=FFFFFF+unstructuredName=Router
    		// EJBCA does not handle this very well so we will change it to: SN=FFFFFF,unstructuredName=Router
<span class="fc" id="L320">    		dn = dn.replace(&quot;+unstructuredName=&quot;, &quot;,unstructuredName=&quot;);</span>
<span class="fc" id="L321">    		dn = dn.replace(&quot; + unstructuredName=&quot;, &quot;,unstructuredName=&quot;);</span>
<span class="fc" id="L322">    		dn = dn.replace(&quot;+unstructuredAddress=&quot;, &quot;,unstructuredAddress=&quot;);</span>
<span class="fc" id="L323">    		dn = dn.replace(&quot; + unstructuredAddress=&quot;, &quot;,unstructuredAddress=&quot;);</span>
<span class="fc" id="L324">    		ret = dn;</span>
    	}
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L327">        	log.debug(&quot;getRequestDN: &quot;+ret);</span>
        }
<span class="fc" id="L329">        return ret;</span>
    }

    @Override
    public X500Name getRequestX500Name() {
        try {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (pkcs10 == null) {</span>
<span class="nc" id="L336">                init();</span>
            }
<span class="nc" id="L338">        } catch (NullPointerException e) {</span>
<span class="nc" id="L339">            log.error(&quot;PKCS10 not inited: &quot;+e.getMessage());</span>
<span class="nc" id="L340">            return null;</span>
<span class="fc" id="L341">        }</span>
<span class="fc" id="L342">        return X500Name.getInstance(new CeSecoreNameStyle(), pkcs10.getSubject());</span>
    }

    @Override
    public String getRequestAltNames() {
<span class="fc" id="L347">        String ret = null;</span>
        try {
<span class="fc" id="L349">        	Extensions exts = getRequestExtensions();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        	if (exts != null) {</span>
<span class="fc" id="L351">        		Extension ext = exts.getExtension(Extension.subjectAlternativeName);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">                if (ext != null) {</span>
                    // Finally read the value
<span class="fc" id="L354">            		ret = CertTools.getAltNameStringFromExtension(ext);</span>
                } else {
<span class="nc bnc" id="L356" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L357">                    	log.debug(&quot;no subject altName extension&quot;);</span>
                    }
                }
        	}
<span class="nc" id="L361">        } catch (IllegalArgumentException e) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L363">            	log.debug(&quot;pkcs_9_extensionRequest does not contain Extensions that it should, ignoring invalid encoded extension request.&quot;);</span>
            }
<span class="fc" id="L365">        }</span>
<span class="fc" id="L366">        return ret;</span>
    }

    @Override
	public Date getRequestValidityNotBefore() {
<span class="nc" id="L371">        return notBefore;</span>
	}

    @Override
	public Date getRequestValidityNotAfter() {
<span class="nc" id="L376">        return notAfter;</span>
	}

    @Override
	public Extensions getRequestExtensions() {
        try {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">            if (pkcs10 == null) {</span>
<span class="nc" id="L383">                init();</span>
            }
<span class="nc" id="L385">        } catch (NullPointerException e) {</span>
<span class="nc" id="L386">            log.error(&quot;PKCS10 not inited! &quot;+e.getMessage());</span>
<span class="nc" id="L387">            return null;</span>
<span class="fc" id="L388">        }</span>
<span class="fc" id="L389">        Extensions ret = null;</span>

        // Get attributes
        // The X509 extension is in a a pkcs_9_at_extensionRequest

        // See if we have it embedded in an extension request instead
<span class="fc" id="L395">        Attribute[] attr = pkcs10.getAttributes(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (attr.length != 0) {</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="nc" id="L398">                log.debug(&quot;got request extension&quot;);</span>
            }
<span class="fc" id="L400">            ASN1Set values = attr[0].getAttrValues();</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if (values.size() &gt; 0) {</span>
                try {
<span class="fc" id="L403">                    ret = Extensions.getInstance(values.getObjectAt(0));</span>
<span class="nc" id="L404">                } catch (IllegalArgumentException e) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                    if (log.isDebugEnabled()) {</span>
<span class="nc" id="L406">                        log.debug(&quot;pkcs_9_extensionRequest does not contain Extensions that it should, ignoring invalid encoded extension request.&quot;);</span>
                    }
<span class="fc" id="L408">                }</span>
            }
        }

<span class="fc" id="L412">        return ret;</span>
	}

    /**
     * Gets the underlying BC &lt;code&gt;PKCS10CertificationRequest&lt;/code&gt; object.
     *
     * @return the request object
     */
    public PKCS10CertificationRequest getCertificationRequest() {
        try {
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (pkcs10 == null) {</span>
<span class="nc" id="L423">                init();</span>
            }
<span class="nc" id="L425">        } catch (NullPointerException e) {</span>
<span class="nc" id="L426">            log.error(&quot;PKCS10 not inited! &quot;+e.getMessage());</span>
<span class="nc" id="L427">            return null;</span>
<span class="nc" id="L428">        }</span>

<span class="nc" id="L430">        return pkcs10;</span>
    }

    @Override
    public boolean verify() throws InvalidKeyException, NoSuchAlgorithmException {
<span class="fc" id="L435">        return verify(null);</span>
    }

    public boolean verify(PublicKey pubKey) throws InvalidKeyException, NoSuchAlgorithmException {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">    	if (log.isTraceEnabled()) {</span>
<span class="nc" id="L440">    		log.trace(&quot;&gt;verify()&quot;);</span>
    	}
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">    	 if (pkcs10 == null) {</span>
<span class="nc" id="L443">             init();</span>
         }

        ContentVerifierProvider verifierProvider;
        try {
<span class="fc bfc" id="L448" title="All 2 branches covered.">            if (pubKey == null) {</span>
<span class="fc" id="L449">                verifierProvider = CertTools.genContentVerifierProvider(pkcs10.getPublicKey());</span>
            } else {
<span class="fc" id="L451">                verifierProvider = CertTools.genContentVerifierProvider(pubKey);</span>
            }
            try {
<span class="fc" id="L454">                return pkcs10.isSignatureValid(verifierProvider);</span>
<span class="nc" id="L455">            } catch (PKCSException e) {</span>
<span class="nc" id="L456">                log.error(&quot;Signature could not be processed.&quot;, e);</span>
            }
<span class="nc" id="L458">        } catch (OperatorCreationException e) {</span>
<span class="nc" id="L459">            log.error(&quot;Content verifier provider could not be created.&quot;, e);</span>
        } finally {
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L462">                log.trace(&quot;&lt;verify()&quot;);</span>
            }
        }
<span class="nc" id="L465">        return false;</span>
    }

    @Override
    public boolean requireKeyInfo() {
<span class="nc" id="L470">        return false;</span>
    }

    @Override
    public void setKeyInfo(Certificate cert, PrivateKey key, String Provider) {
<span class="nc" id="L475">    }</span>

    @Override
    public int getErrorNo() {
<span class="nc" id="L479">        return error;</span>
    }

    @Override
    public String getErrorText() {
<span class="nc" id="L484">        return errorText;</span>
    }

    @Override
    public String getSenderNonce() {
<span class="nc" id="L489">        return null;</span>
    }

    @Override
    public String getTransactionId() {
<span class="nc" id="L494">        return null;</span>
    }

    @Override
    public byte[] getRequestKeyInfo() {
<span class="nc" id="L499">        return null;</span>
    }

    @Override
    public String getPreferredDigestAlg() {
<span class="nc" id="L504">    	return preferredDigestAlg;</span>
    }

    @Override
    public boolean includeCACert() {
<span class="nc" id="L509">    	return includeCACert;</span>
    }

    @Override
    public int getRequestType() {
<span class="nc" id="L514">    	return 0;</span>
    }

    @Override
    public int getRequestId() {
<span class="nc" id="L519">    	return 0;</span>
    }

    @Override
    public void setResponseKeyInfo(PrivateKey key, String provider) {
        // NOOP
<span class="nc" id="L525">    }</span>

    @Override
    public List&lt;Certificate&gt; getAdditionalCaCertificates() {
<span class="nc" id="L529">        return additionalCaCertificates;</span>
    }

    @Override
    public void setAdditionalCaCertificates(final List&lt;Certificate&gt; certificates) {
<span class="nc" id="L534">        this.additionalCaCertificates = certificates;</span>
<span class="nc" id="L535">    }</span>
    
    @Override
    public List&lt;Certificate&gt; getAdditionalExtraCertsCertificates() {
<span class="nc" id="L539">        return additionalExtraCertsCertificates;</span>
    }

    @Override
    public void setAdditionalExtraCertsCertificates(List&lt;Certificate&gt; additionalExtraCertsCertificates) {
<span class="nc" id="L544">        this.additionalExtraCertsCertificates = additionalExtraCertsCertificates;</span>
<span class="nc" id="L545">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>