<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuditDevicesConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cesecore-ejb-interface</a> &gt; <a href="index.source.html" class="el_package">org.cesecore.audit</a> &gt; <span class="el_source">AuditDevicesConfig.java</span></div><h1>AuditDevicesConfig.java</h1><pre class="source lang-java linenums">/*************************************************************************
 *                                                                       *
 *  CESeCore: CE Security Core                                           *
 *                                                                       *
 *  This software is free software; you can redistribute it and/or       *
 *  modify it under the terms of the GNU Lesser General Public           *
 *  License as published by the Free Software Foundation; either         *
 *  version 2.1 of the License, or any later version.                    *
 *                                                                       *
 *  See terms of license at gnu.org.                                     *
 *                                                                       *
 *************************************************************************/
package org.cesecore.audit;

import java.io.File;
import java.io.IOException;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.lang.time.FastDateFormat;
import org.apache.log4j.Logger;
import org.cesecore.audit.audit.AuditExporter;
import org.cesecore.audit.impl.AuditExporterDummy;
import org.cesecore.config.ConfigurationHolder;
import org.cesecore.util.ValidityDate;

/**
 * Parses configuration related to the log devices.
 * 
 * Custom properties for each device is reformatted. E.g. &quot;securityeventsaudit.deviceproperty.1.key1.key2=value&quot; is available to the log device
 * implementation 1 as &quot;key1.key2=value&quot;
 * 
 * @version $Id: AuditDevicesConfig.java 17625 2013-09-20 07:12:06Z netmackan $
 */
<span class="nc" id="L44">public class AuditDevicesConfig {</span>

<span class="nc" id="L46">    private static final Logger log = Logger.getLogger(AuditDevicesConfig.class);</span>
<span class="nc" id="L47">    private static final ReentrantLock lock = new ReentrantLock(false);</span>
<span class="nc" id="L48">    private static Map&lt;String, AuditLogDevice&gt; loggers = null;</span>
<span class="nc" id="L49">    private static final Map&lt;String, Class&lt;? extends AuditExporter&gt;&gt; exporters = new HashMap&lt;String, Class&lt;? extends AuditExporter&gt;&gt;();</span>
<span class="nc" id="L50">    private static final Map&lt;String, Properties&gt; deviceProperties = new HashMap&lt;String, Properties&gt;();</span>

    private static Map&lt;String, AuditLogDevice&gt; getLoggers() {
<span class="nc" id="L53">        setup();</span>
<span class="nc" id="L54">        return loggers;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static void setup() {
        try {
<span class="nc" id="L60">            lock.lock();</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">            if (loggers == null) {</span>
<span class="nc" id="L62">                loggers = new HashMap&lt;String, AuditLogDevice&gt;();</span>
<span class="nc" id="L63">                final Configuration conf = ConfigurationHolder.instance();</span>
<span class="nc" id="L64">                final String DEVICE_CLASS = &quot;securityeventsaudit.implementation.&quot;;</span>
<span class="nc" id="L65">                final String EXPORTER_CLASS = &quot;securityeventsaudit.exporter.&quot;;</span>
                // Extract custom properties configured for any device, to avoid lookup for each device later on..
                // Default devices should not require configuring of 'deviceproperty' in defaultvalues.properties, 
                // since the below Iterator does not read from default values. 
<span class="nc" id="L69">                final String DEVICE_PROPERTY = &quot;securityeventsaudit\\.deviceproperty\\.(\\d+)\\.(.+)&quot;;</span>
<span class="nc" id="L70">                final Map&lt;Integer, Properties&gt; allDeviceProperties = new HashMap&lt;Integer, Properties&gt;();</span>
<span class="nc" id="L71">                final Iterator&lt;String&gt; iterator = conf.getKeys();</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">                while (iterator.hasNext()) {</span>
<span class="nc" id="L73">                    final String currentKey = iterator.next();</span>
<span class="nc" id="L74">                    Pattern pattern = Pattern.compile(DEVICE_PROPERTY);</span>
<span class="nc" id="L75">                    Matcher matcher = pattern.matcher(currentKey);</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L77">                        final Integer deviceConfId = Integer.parseInt(matcher.group(1));</span>
<span class="nc" id="L78">                        Properties deviceProperties = allDeviceProperties.get(deviceConfId);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                        if (deviceProperties == null) {</span>
<span class="nc" id="L80">                            deviceProperties = new Properties();</span>
                        }
<span class="nc" id="L82">                        final String devicePropertyName = matcher.group(2);</span>
<span class="nc" id="L83">                        final String devicePropertyValue = conf.getString(currentKey);</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">                        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L85">                            log.debug(&quot;deviceConfId=&quot; + deviceConfId.toString() + &quot; &quot; + devicePropertyName + &quot;=&quot; + devicePropertyValue);</span>
                        }
<span class="nc" id="L87">                        deviceProperties.put(devicePropertyName, devicePropertyValue);</span>
<span class="nc" id="L88">                        allDeviceProperties.put(deviceConfId, deviceProperties);</span>
                    }
<span class="nc" id="L90">                }</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">                for (int i = 0; i &lt; 255; i++) {</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                    if (!checkNoDuplicateProperties(DEVICE_CLASS + i)) {</span>
<span class="nc" id="L93">                        continue;</span>
                    }
<span class="nc" id="L95">                    final String deviceClass = ConfigurationHolder.getString(DEVICE_CLASS + i);</span>
<span class="nc bnc" id="L96" title="All 4 branches missed.">                    if ((deviceClass != null) &amp;&amp; (!&quot;null&quot;.equalsIgnoreCase(deviceClass))) {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L98">                            log.debug(&quot;Trying to register audit device using implementation: &quot; + deviceClass);</span>
                        }
                        try {
                            // Instantiate device
<span class="nc" id="L102">                            final Class&lt;AuditLogDevice&gt; implClass = (Class&lt;AuditLogDevice&gt;) Class.forName(deviceClass);</span>
<span class="nc" id="L103">                            final AuditLogDevice auditLogDevice = implClass.getConstructor().newInstance();</span>
<span class="nc" id="L104">                            final String name = implClass.getSimpleName();</span>
<span class="nc" id="L105">                            loggers.put(name, auditLogDevice);</span>
<span class="nc" id="L106">                            log.info(&quot;Registered audit device using implementation: &quot; + deviceClass);</span>
                            // Store custom properties for this device, so they are searchable by name
<span class="nc bnc" id="L108" title="All 2 branches missed.">                            if (!allDeviceProperties.containsKey(Integer.valueOf(i))) {</span>
<span class="nc" id="L109">                                allDeviceProperties.put(Integer.valueOf(i), new Properties());</span>
                            }
<span class="nc" id="L111">                            deviceProperties.put(name, allDeviceProperties.get(Integer.valueOf(i)));</span>
                            // Setup an exporter for this device
<span class="nc" id="L113">                            final String exporterClassName = ConfigurationHolder.getString(EXPORTER_CLASS + i);</span>
<span class="nc" id="L114">                            Class&lt;? extends AuditExporter&gt; exporterClass = AuditExporterDummy.class;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">                            if (exporterClassName != null) {</span>
                                try {
<span class="nc" id="L117">                                    exporterClass = (Class&lt;? extends AuditExporter&gt;) Class.forName(exporterClassName);</span>
<span class="nc" id="L118">                                } catch (Exception e) {</span>
                                    // ClassCastException, ClassNotFoundException
<span class="nc" id="L120">                                    log.error(&quot;Could not configure exporter for audit device &quot; + name + &quot; using implementation: &quot; + exporterClass, e);</span>
<span class="nc" id="L121">                                }</span>
                            }
<span class="nc" id="L123">                            log.info(&quot;Configured exporter &quot; + exporterClass.getSimpleName() + &quot; for device &quot; + name);</span>
<span class="nc" id="L124">                            exporters.put(name, exporterClass);</span>
<span class="nc" id="L125">                        } catch (Exception e) {</span>
                            // ClassCastException, ClassNotFoundException, InstantiationException, IllegalAccessException
<span class="nc" id="L127">                            log.error(&quot;Could not creating audit device using implementation: &quot; + deviceClass, e);</span>
<span class="nc" id="L128">                        }</span>
                    }
                }
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (loggers.isEmpty()) {</span>
<span class="nc" id="L132">                    log.warn(&quot;No security event audit devices has been configured.&quot;);</span>
                }
            }
        } finally {
<span class="nc" id="L136">            lock.unlock();</span>
        }
<span class="nc" id="L138">    }</span>

    /** Checks that there are no duplicate properties in the configuration. 
     * @param name Propertiy name
     * @return boolean */
    private static boolean checkNoDuplicateProperties(String name) {
<span class="nc" id="L144">        final String[] arr = ConfigurationHolder.instance().getStringArray(name);</span>
<span class="nc bnc" id="L145" title="All 4 branches missed.">        if (arr != null &amp;&amp; arr.length &gt; 1) {</span>
<span class="nc" id="L146">            log.error(&quot;Duplicate property definitions of \&quot;&quot;+name+&quot;\&quot;. All defintions (&quot;+arr.length+&quot; occurrences) of this property will be ignored.&quot;);</span>
<span class="nc" id="L147">            return false;</span>
        }
<span class="nc" id="L149">        return true;</span>
    }

    /** @return the ids of all devices that support querying as a serilizable (Hash)Set. */
    public static Set&lt;String&gt; getQuerySupportingDeviceIds() {
<span class="nc" id="L154">        final Set&lt;String&gt; set = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        for (final String id : getLoggers().keySet()) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (loggers.get(id).isSupportingQueries()) {</span>
<span class="nc" id="L157">                set.add(id);</span>
            }
<span class="nc" id="L159">        }</span>
<span class="nc" id="L160">        return set;</span>
    }

    /** @return the ids of all devices as a serilizable (Hash)Set. */
    public static Set&lt;String&gt; getAllDeviceIds() {
<span class="nc" id="L165">        return new HashSet&lt;String&gt;(getLoggers().keySet());</span>
    }

    public static AuditLogDevice getDevice(final Map&lt;Class&lt;?&gt;, ?&gt; ejbs, final String id) {
<span class="nc" id="L169">        final AuditLogDevice auditLogDevice = getLoggers().get(id);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (auditLogDevice != null) {</span>
<span class="nc" id="L171">            auditLogDevice.setEjbs(ejbs);</span>
        }
<span class="nc" id="L173">        return auditLogDevice;</span>
    }

    public static Class&lt;? extends AuditExporter&gt; getExporter(final String id) {
<span class="nc" id="L177">        setup();</span>
<span class="nc" id="L178">        return exporters.get(id);</span>
    }

    public static Properties getProperties(final String id) {
<span class="nc" id="L182">        setup();</span>
<span class="nc" id="L183">        return deviceProperties.get(id);</span>
    }

	private static final String EXPORTFILE_DATE_FORMAT = &quot;yyyy-MM-dd-HHmmss&quot;;
	
	/** @param properties Properties
	 * @param exportDate Date exported
	 * @return the file name of the current export. 
	 * @throws IOException if IO fails*/
	public static File getExportFile(final Properties properties, final Date exportDate) throws IOException {
<span class="nc" id="L193">		final String p = properties.getProperty(&quot;export.dir&quot;, System.getProperty(&quot;java.io.tmpdir&quot;));</span>
<span class="nc" id="L194">		final File dir = new File(p);</span>
<span class="nc" id="L195">		final String file = &quot;cesecore-&quot; + FastDateFormat.getInstance(EXPORTFILE_DATE_FORMAT, ValidityDate.TIMEZONE_UTC).format(exportDate) + &quot;.log&quot;;</span>
<span class="nc" id="L196">        File ret = new File(dir, file);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="nc" id="L198">        	log.debug(&quot;Export file: &quot;+p+file);</span>
<span class="nc" id="L199">        	log.debug(&quot;Export file canonical: &quot;+ret.getCanonicalPath());</span>
        }
<span class="nc" id="L201">        return ret;</span>
	}

    /** Parameter to specify the number of logs to be fetched in each validation round trip. 
     * @param properties Properties
     * @return log size*/
    public static int getAuditLogValidationFetchSize(final Properties properties) {
<span class="nc" id="L208">        return getInt(properties, &quot;validate.fetchsize&quot;, 1000);</span>
    }

    /** Parameter to specify the number of logs to be fetched in each export round trip. 
     * @param properties properties
     * @return log size */
    public static int getAuditLogExportFetchSize(final Properties properties) {
<span class="nc" id="L215">        return getInt(properties, &quot;export.fetchsize&quot;, 1000);</span>
    }

    private static int getInt(final Properties properties, final String key, final int defaultValue) {
<span class="nc" id="L219">        int ret = defaultValue;</span>
        try {
<span class="nc" id="L221">            ret = Integer.valueOf(properties.getProperty(key, String.valueOf(ret)));</span>
<span class="nc" id="L222">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L223">            log.error(&quot;Invalid value in &quot; + key + &quot;, must be decimal number. Using default &quot; + defaultValue + &quot;. Message: &quot; + e.getMessage());</span>
<span class="nc" id="L224">        }</span>
<span class="nc" id="L225">        return ret;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>